(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
;__browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
/*
 CryptoJS v3.1.2
 core.js
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
/**
 * CryptoJS core components.
 */
var CryptoJS = CryptoJS || (function (Math, undefined) {
  /**
   * CryptoJS namespace.
   */
  var C = {};

  /**
   * Library namespace.
   */
  var C_lib = C.lib = {};

  /**
   * Base object for prototypal inheritance.
   */
  var Base = C_lib.Base = (function () {
    function F() {}

    return {
      /**
       * Creates a new object that inherits from this object.
       *
       * @param {Object} overrides Properties to copy into the new object.
       *
       * @return {Object} The new object.
       *
       * @static
       *
       * @example
       *
       *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
       */
      extend: function (overrides) {
        // Spawn
        F.prototype = this;
        var subtype = new F();

        // Augment
        if (overrides) {
          subtype.mixIn(overrides);
        }

        // Create default initializer
        if (!subtype.hasOwnProperty('init')) {
          subtype.init = function () {
            subtype.$super.init.apply(this, arguments);
          };
        }

        // Initializer's prototype is the subtype object
        subtype.init.prototype = subtype;

        // Reference supertype
        subtype.$super = this;

        return subtype;
      },

      /**
       * Extends this object and runs the init method.
       * Arguments to create() will be passed to init().
       *
       * @return {Object} The new object.
       *
       * @static
       *
       * @example
       *
       *     var instance = MyType.create();
       */
      create: function () {
        var instance = this.extend();
        instance.init.apply(instance, arguments);

        return instance;
      },

      /**
       * Initializes a newly created object.
       * Override this method to add some logic when your objects are created.
       *
       * @example
       *
       *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
       */
      init: function () {
      },

      /**
       * Copies properties into this object.
       *
       * @param {Object} properties The properties to mix in.
       *
       * @example
       *
       *     MyType.mixIn({
             *         field: 'value'
             *     });
       */
      mixIn: function (properties) {
        for (var propertyName in properties) {
          if (properties.hasOwnProperty(propertyName)) {
            this[propertyName] = properties[propertyName];
          }
        }

        // IE won't copy toString using the loop above
        if (properties.hasOwnProperty('toString')) {
          this.toString = properties.toString;
        }
      },

      /**
       * Creates a copy of this object.
       *
       * @return {Object} The clone.
       *
       * @example
       *
       *     var clone = instance.clone();
       */
      clone: function () {
        return this.init.prototype.extend(this);
      }
    };
  }());

  /**
   * An array of 32-bit words.
   *
   * @property {Array} words The array of 32-bit words.
   * @property {number} sigBytes The number of significant bytes in this word array.
   */
  var WordArray = C_lib.WordArray = Base.extend({
    /**
     * Initializes a newly created word array.
     *
     * @param {Array} words (Optional) An array of 32-bit words.
     * @param {number} sigBytes (Optional) The number of significant bytes in the words.
     *
     * @example
     *
     *     var wordArray = CryptoJS.lib.WordArray.create();
     *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
     *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
     */
    init: function (words, sigBytes) {
      words = this.words = words || [];

      if (sigBytes != undefined) {
        this.sigBytes = sigBytes;
      } else {
        this.sigBytes = words.length * 4;
      }
    },

    /**
     * Converts this word array to a string.
     *
     * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
     *
     * @return {string} The stringified word array.
     *
     * @example
     *
     *     var string = wordArray + '';
     *     var string = wordArray.toString();
     *     var string = wordArray.toString(CryptoJS.enc.Utf8);
     */
    toString: function (encoder) {
      return (encoder || Hex).stringify(this);
    },

    /**
     * Concatenates a word array to this word array.
     *
     * @param {WordArray} wordArray The word array to append.
     *
     * @return {WordArray} This word array.
     *
     * @example
     *
     *     wordArray1.concat(wordArray2);
     */
    concat: function (wordArray) {
      // Shortcuts
      var thisWords = this.words;
      var thatWords = wordArray.words;
      var thisSigBytes = this.sigBytes;
      var thatSigBytes = wordArray.sigBytes;

      // Clamp excess bits
      this.clamp();

      // Concat
      if (thisSigBytes % 4) {
        // Copy one byte at a time
        for (var i = 0; i < thatSigBytes; i++) {
          var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
          thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
        }
      } else if (thatWords.length > 0xffff) {
        // Copy one word at a time
        for (var i = 0; i < thatSigBytes; i += 4) {
          thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
        }
      } else {
        // Copy all words at once
        thisWords.push.apply(thisWords, thatWords);
      }
      this.sigBytes += thatSigBytes;

      // Chainable
      return this;
    },

    /**
     * Removes insignificant bits.
     *
     * @example
     *
     *     wordArray.clamp();
     */
    clamp: function () {
      // Shortcuts
      var words = this.words;
      var sigBytes = this.sigBytes;

      // Clamp
      words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
      words.length = Math.ceil(sigBytes / 4);
    },

    /**
     * Creates a copy of this word array.
     *
     * @return {WordArray} The clone.
     *
     * @example
     *
     *     var clone = wordArray.clone();
     */
    clone: function () {
      var clone = Base.clone.call(this);
      clone.words = this.words.slice(0);

      return clone;
    },

    /**
     * Creates a word array filled with random bytes.
     *
     * @param {number} nBytes The number of random bytes to generate.
     *
     * @return {WordArray} The random word array.
     *
     * @static
     *
     * @example
     *
     *     var wordArray = CryptoJS.lib.WordArray.random(16);
     */
    random: function (nBytes) {
      var words = [];
      for (var i = 0; i < nBytes; i += 4) {
        words.push((Math.random() * 0x100000000) | 0);
      }

      return new WordArray.init(words, nBytes);
    }
  });

  /**
   * Encoder namespace.
   */
  var C_enc = C.enc = {};

  /**
   * Hex encoding strategy.
   */
  var Hex = C_enc.Hex = {
    /**
     * Converts a word array to a hex string.
     *
     * @param {WordArray} wordArray The word array.
     *
     * @return {string} The hex string.
     *
     * @static
     *
     * @example
     *
     *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
     */
    stringify: function (wordArray) {
      // Shortcuts
      var words = wordArray.words;
      var sigBytes = wordArray.sigBytes;

      // Convert
      var hexChars = [];
      for (var i = 0; i < sigBytes; i++) {
        var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
        hexChars.push((bite >>> 4).toString(16));
        hexChars.push((bite & 0x0f).toString(16));
      }

      return hexChars.join('');
    },

    /**
     * Converts a hex string to a word array.
     *
     * @param {string} hexStr The hex string.
     *
     * @return {WordArray} The word array.
     *
     * @static
     *
     * @example
     *
     *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
     */
    parse: function (hexStr) {
      // Shortcut
      var hexStrLength = hexStr.length;

      // Convert
      var words = [];
      for (var i = 0; i < hexStrLength; i += 2) {
        words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
      }

      return new WordArray.init(words, hexStrLength / 2);
    }
  };

  /**
   * Latin1 encoding strategy.
   */
  var Latin1 = C_enc.Latin1 = {
    /**
     * Converts a word array to a Latin1 string.
     *
     * @param {WordArray} wordArray The word array.
     *
     * @return {string} The Latin1 string.
     *
     * @static
     *
     * @example
     *
     *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
     */
    stringify: function (wordArray) {
      // Shortcuts
      var words = wordArray.words;
      var sigBytes = wordArray.sigBytes;

      // Convert
      var latin1Chars = [];
      for (var i = 0; i < sigBytes; i++) {
        var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
        latin1Chars.push(String.fromCharCode(bite));
      }

      return latin1Chars.join('');
    },

    /**
     * Converts a Latin1 string to a word array.
     *
     * @param {string} latin1Str The Latin1 string.
     *
     * @return {WordArray} The word array.
     *
     * @static
     *
     * @example
     *
     *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
     */
    parse: function (latin1Str) {
      // Shortcut
      var latin1StrLength = latin1Str.length;

      // Convert
      var words = [];
      for (var i = 0; i < latin1StrLength; i++) {
        words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
      }

      return new WordArray.init(words, latin1StrLength);
    }
  };

  /**
   * UTF-8 encoding strategy.
   */
  var Utf8 = C_enc.Utf8 = {
    /**
     * Converts a word array to a UTF-8 string.
     *
     * @param {WordArray} wordArray The word array.
     *
     * @return {string} The UTF-8 string.
     *
     * @static
     *
     * @example
     *
     *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
     */
    stringify: function (wordArray) {
      try {
        return decodeURIComponent(escape(Latin1.stringify(wordArray)));
      } catch (e) {
        throw new Error('Malformed UTF-8 data');
      }
    },

    /**
     * Converts a UTF-8 string to a word array.
     *
     * @param {string} utf8Str The UTF-8 string.
     *
     * @return {WordArray} The word array.
     *
     * @static
     *
     * @example
     *
     *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
     */
    parse: function (utf8Str) {
      return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
    }
  };

  /**
   * Abstract buffered block algorithm template.
   *
   * The property blockSize must be implemented in a concrete subtype.
   *
   * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
   */
  var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
    /**
     * Resets this block algorithm's data buffer to its initial state.
     *
     * @example
     *
     *     bufferedBlockAlgorithm.reset();
     */
    reset: function () {
      // Initial values
      this._data = new WordArray.init();
      this._nDataBytes = 0;
    },

    /**
     * Adds new data to this block algorithm's buffer.
     *
     * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
     *
     * @example
     *
     *     bufferedBlockAlgorithm._append('data');
     *     bufferedBlockAlgorithm._append(wordArray);
     */
    _append: function (data) {
      // Convert string to WordArray, else assume WordArray already
      if (typeof data == 'string') {
        data = Utf8.parse(data);
      }

      // Append
      this._data.concat(data);
      this._nDataBytes += data.sigBytes;
    },

    /**
     * Processes available data blocks.
     *
     * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
     *
     * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
     *
     * @return {WordArray} The processed data.
     *
     * @example
     *
     *     var processedData = bufferedBlockAlgorithm._process();
     *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
     */
    _process: function (doFlush) {
      // Shortcuts
      var data = this._data;
      var dataWords = data.words;
      var dataSigBytes = data.sigBytes;
      var blockSize = this.blockSize;
      var blockSizeBytes = blockSize * 4;

      // Count blocks ready
      var nBlocksReady = dataSigBytes / blockSizeBytes;
      if (doFlush) {
        // Round up to include partial blocks
        nBlocksReady = Math.ceil(nBlocksReady);
      } else {
        // Round down to include only full blocks,
        // less the number of blocks that must remain in the buffer
        nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
      }

      // Count words ready
      var nWordsReady = nBlocksReady * blockSize;

      // Count bytes ready
      var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

      // Process blocks
      if (nWordsReady) {
        for (var offset = 0; offset < nWordsReady; offset += blockSize) {
          // Perform concrete-algorithm logic
          this._doProcessBlock(dataWords, offset);
        }

        // Remove processed words
        var processedWords = dataWords.splice(0, nWordsReady);
        data.sigBytes -= nBytesReady;
      }

      // Return processed words
      return new WordArray.init(processedWords, nBytesReady);
    },

    /**
     * Creates a copy of this object.
     *
     * @return {Object} The clone.
     *
     * @example
     *
     *     var clone = bufferedBlockAlgorithm.clone();
     */
    clone: function () {
      var clone = Base.clone.call(this);
      clone._data = this._data.clone();

      return clone;
    },

    _minBufferSize: 0
  });

  /**
   * Abstract hasher template.
   *
   * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
   */
  var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
    /**
     * Configuration options.
     */
    cfg: Base.extend(),

    /**
     * Initializes a newly created hasher.
     *
     * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
     *
     * @example
     *
     *     var hasher = CryptoJS.algo.SHA256.create();
     */
    init: function (cfg) {
      // Apply config defaults
      this.cfg = this.cfg.extend(cfg);

      // Set initial values
      this.reset();
    },

    /**
     * Resets this hasher to its initial state.
     *
     * @example
     *
     *     hasher.reset();
     */
    reset: function () {
      // Reset data buffer
      BufferedBlockAlgorithm.reset.call(this);

      // Perform concrete-hasher logic
      this._doReset();
    },

    /**
     * Updates this hasher with a message.
     *
     * @param {WordArray|string} messageUpdate The message to append.
     *
     * @return {Hasher} This hasher.
     *
     * @example
     *
     *     hasher.update('message');
     *     hasher.update(wordArray);
     */
    update: function (messageUpdate) {
      // Append
      this._append(messageUpdate);

      // Update the hash
      this._process();

      // Chainable
      return this;
    },

    /**
     * Finalizes the hash computation.
     * Note that the finalize operation is effectively a destructive, read-once operation.
     *
     * @param {WordArray|string} messageUpdate (Optional) A final message update.
     *
     * @return {WordArray} The hash.
     *
     * @example
     *
     *     var hash = hasher.finalize();
     *     var hash = hasher.finalize('message');
     *     var hash = hasher.finalize(wordArray);
     */
    finalize: function (messageUpdate) {
      // Final message update
      if (messageUpdate) {
        this._append(messageUpdate);
      }

      // Perform concrete-hasher logic
      var hash = this._doFinalize();

      return hash;
    },

    blockSize: 512/32,

    /**
     * Creates a shortcut function to a hasher's object interface.
     *
     * @param {Hasher} hasher The hasher to create a helper for.
     *
     * @return {Function} The shortcut function.
     *
     * @static
     *
     * @example
     *
     *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
     */
    _createHelper: function (hasher) {
      return function (message, cfg) {
        return new hasher.init(cfg).finalize(message);
      };
    },

    /**
     * Creates a shortcut function to the HMAC's object interface.
     *
     * @param {Hasher} hasher The hasher to use in this HMAC helper.
     *
     * @return {Function} The shortcut function.
     *
     * @static
     *
     * @example
     *
     *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
     */
    _createHmacHelper: function (hasher) {
      return function (message, key) {
        return new C_algo.HMAC.init(hasher, key).finalize(message);
      };
    }
  });

  /**
   * Algorithm namespace.
   */
  var C_algo = C.algo = {};

  return C;
}(Math));
/*
 CryptoJS v3.1.2
 enc-base64.js
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
(function () {
  // Shortcuts
  var C = CryptoJS;
  var C_lib = C.lib;
  var WordArray = C_lib.WordArray;
  var C_enc = C.enc;

  /**
   * Base64 encoding strategy.
   */
  var Base64 = C_enc.Base64 = {
    /**
     * Converts a word array to a Base64 string.
     *
     * @param {WordArray} wordArray The word array.
     *
     * @return {string} The Base64 string.
     *
     * @static
     *
     * @example
     *
     *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
     */
    stringify: function (wordArray) {
      // Shortcuts
      var words = wordArray.words;
      var sigBytes = wordArray.sigBytes;
      var map = this._map;

      // Clamp excess bits
      wordArray.clamp();

      // Convert
      var base64Chars = [];
      for (var i = 0; i < sigBytes; i += 3) {
        var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
        var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
        var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

        var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

        for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
          base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
        }
      }

      // Add padding
      var paddingChar = map.charAt(64);
      if (paddingChar) {
        while (base64Chars.length % 4) {
          base64Chars.push(paddingChar);
        }
      }

      return base64Chars.join('');
    },

    /**
     * Converts a Base64 string to a word array.
     *
     * @param {string} base64Str The Base64 string.
     *
     * @return {WordArray} The word array.
     *
     * @static
     *
     * @example
     *
     *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
     */
    parse: function (base64Str) {
      // Shortcuts
      var base64StrLength = base64Str.length;
      var map = this._map;

      // Ignore padding
      var paddingChar = map.charAt(64);
      if (paddingChar) {
        var paddingIndex = base64Str.indexOf(paddingChar);
        if (paddingIndex != -1) {
          base64StrLength = paddingIndex;
        }
      }

      // Convert
      var words = [];
      var nBytes = 0;
      for (var i = 0; i < base64StrLength; i++) {
        if (i % 4) {
          var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
          var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
          words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
          nBytes++;
        }
      }

      return WordArray.create(words, nBytes);
    },

    _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
  };
}());
/*
 CryptoJS v3.1.2
 cipher-core
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
/**
 * Cipher core components.
 */
CryptoJS.lib.Cipher || (function (undefined) {
  // Shortcuts
  var C = CryptoJS;
  var C_lib = C.lib;
  var Base = C_lib.Base;
  var WordArray = C_lib.WordArray;
  var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
  var C_enc = C.enc;
  var Utf8 = C_enc.Utf8;
  var Base64 = C_enc.Base64;
  var C_algo = C.algo;
  var EvpKDF = C_algo.EvpKDF;

  /**
   * Abstract base cipher template.
   *
   * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
   * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
   * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
   * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
   */
  var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
    /**
     * Configuration options.
     *
     * @property {WordArray} iv The IV to use for this operation.
     */
    cfg: Base.extend(),

    /**
     * Creates this cipher in encryption mode.
     *
     * @param {WordArray} key The key.
     * @param {Object} cfg (Optional) The configuration options to use for this operation.
     *
     * @return {Cipher} A cipher instance.
     *
     * @static
     *
     * @example
     *
     *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
     */
    createEncryptor: function (key, cfg) {
      return this.create(this._ENC_XFORM_MODE, key, cfg);
    },

    /**
     * Creates this cipher in decryption mode.
     *
     * @param {WordArray} key The key.
     * @param {Object} cfg (Optional) The configuration options to use for this operation.
     *
     * @return {Cipher} A cipher instance.
     *
     * @static
     *
     * @example
     *
     *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
     */
    createDecryptor: function (key, cfg) {
      return this.create(this._DEC_XFORM_MODE, key, cfg);
    },

    /**
     * Initializes a newly created cipher.
     *
     * @param {number} xformMode Either the encryption or decryption transormation mode constant.
     * @param {WordArray} key The key.
     * @param {Object} cfg (Optional) The configuration options to use for this operation.
     *
     * @example
     *
     *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
     */
    init: function (xformMode, key, cfg) {
      // Apply config defaults
      this.cfg = this.cfg.extend(cfg);

      // Store transform mode and key
      this._xformMode = xformMode;
      this._key = key;

      // Set initial values
      this.reset();
    },

    /**
     * Resets this cipher to its initial state.
     *
     * @example
     *
     *     cipher.reset();
     */
    reset: function () {
      // Reset data buffer
      BufferedBlockAlgorithm.reset.call(this);

      // Perform concrete-cipher logic
      this._doReset();
    },

    /**
     * Adds data to be encrypted or decrypted.
     *
     * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
     *
     * @return {WordArray} The data after processing.
     *
     * @example
     *
     *     var encrypted = cipher.process('data');
     *     var encrypted = cipher.process(wordArray);
     */
    process: function (dataUpdate) {
      // Append
      this._append(dataUpdate);

      // Process available blocks
      return this._process();
    },

    /**
     * Finalizes the encryption or decryption process.
     * Note that the finalize operation is effectively a destructive, read-once operation.
     *
     * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
     *
     * @return {WordArray} The data after final processing.
     *
     * @example
     *
     *     var encrypted = cipher.finalize();
     *     var encrypted = cipher.finalize('data');
     *     var encrypted = cipher.finalize(wordArray);
     */
    finalize: function (dataUpdate) {
      // Final data update
      if (dataUpdate) {
        this._append(dataUpdate);
      }

      // Perform concrete-cipher logic
      var finalProcessedData = this._doFinalize();

      return finalProcessedData;
    },

    keySize: 128/32,

    ivSize: 128/32,

    _ENC_XFORM_MODE: 1,

    _DEC_XFORM_MODE: 2,

    /**
     * Creates shortcut functions to a cipher's object interface.
     *
     * @param {Cipher} cipher The cipher to create a helper for.
     *
     * @return {Object} An object with encrypt and decrypt shortcut functions.
     *
     * @static
     *
     * @example
     *
     *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
     */
    _createHelper: (function () {
      function selectCipherStrategy(key) {
        if (typeof key == 'string') {
          return PasswordBasedCipher;
        } else {
          return SerializableCipher;
        }
      }

      return function (cipher) {
        return {
          encrypt: function (message, key, cfg) {
            return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
          },

          decrypt: function (ciphertext, key, cfg) {
            return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
          }
        };
      };
    }())
  });

  /**
   * Abstract base stream cipher template.
   *
   * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
   */
  var StreamCipher = C_lib.StreamCipher = Cipher.extend({
    _doFinalize: function () {
      // Process partial blocks
      var finalProcessedBlocks = this._process(!!'flush');

      return finalProcessedBlocks;
    },

    blockSize: 1
  });

  /**
   * Mode namespace.
   */
  var C_mode = C.mode = {};

  /**
   * Abstract base block cipher mode template.
   */
  var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
    /**
     * Creates this mode for encryption.
     *
     * @param {Cipher} cipher A block cipher instance.
     * @param {Array} iv The IV words.
     *
     * @static
     *
     * @example
     *
     *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
     */
    createEncryptor: function (cipher, iv) {
      return this.Encryptor.create(cipher, iv);
    },

    /**
     * Creates this mode for decryption.
     *
     * @param {Cipher} cipher A block cipher instance.
     * @param {Array} iv The IV words.
     *
     * @static
     *
     * @example
     *
     *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
     */
    createDecryptor: function (cipher, iv) {
      return this.Decryptor.create(cipher, iv);
    },

    /**
     * Initializes a newly created mode.
     *
     * @param {Cipher} cipher A block cipher instance.
     * @param {Array} iv The IV words.
     *
     * @example
     *
     *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
     */
    init: function (cipher, iv) {
      this._cipher = cipher;
      this._iv = iv;
    }
  });

  /**
   * Cipher Block Chaining mode.
   */
  var CBC = C_mode.CBC = (function () {
    /**
     * Abstract base CBC mode.
     */
    var CBC = BlockCipherMode.extend();

    /**
     * CBC encryptor.
     */
    CBC.Encryptor = CBC.extend({
      /**
       * Processes the data block at offset.
       *
       * @param {Array} words The data words to operate on.
       * @param {number} offset The offset where the block starts.
       *
       * @example
       *
       *     mode.processBlock(data.words, offset);
       */
      processBlock: function (words, offset) {
        // Shortcuts
        var cipher = this._cipher;
        var blockSize = cipher.blockSize;

        // XOR and encrypt
        xorBlock.call(this, words, offset, blockSize);
        cipher.encryptBlock(words, offset);

        // Remember this block to use with next block
        this._prevBlock = words.slice(offset, offset + blockSize);
      }
    });

    /**
     * CBC decryptor.
     */
    CBC.Decryptor = CBC.extend({
      /**
       * Processes the data block at offset.
       *
       * @param {Array} words The data words to operate on.
       * @param {number} offset The offset where the block starts.
       *
       * @example
       *
       *     mode.processBlock(data.words, offset);
       */
      processBlock: function (words, offset) {
        // Shortcuts
        var cipher = this._cipher;
        var blockSize = cipher.blockSize;

        // Remember this block to use with next block
        var thisBlock = words.slice(offset, offset + blockSize);

        // Decrypt and XOR
        cipher.decryptBlock(words, offset);
        xorBlock.call(this, words, offset, blockSize);

        // This block becomes the previous block
        this._prevBlock = thisBlock;
      }
    });

    function xorBlock(words, offset, blockSize) {
      // Shortcut
      var iv = this._iv;

      // Choose mixing block
      if (iv) {
        var block = iv;

        // Remove IV for subsequent blocks
        this._iv = undefined;
      } else {
        var block = this._prevBlock;
      }

      // XOR blocks
      for (var i = 0; i < blockSize; i++) {
        words[offset + i] ^= block[i];
      }
    }

    return CBC;
  }());

  /**
   * Padding namespace.
   */
  var C_pad = C.pad = {};

  /**
   * PKCS #5/7 padding strategy.
   */
  var Pkcs7 = C_pad.Pkcs7 = {
    /**
     * Pads data using the algorithm defined in PKCS #5/7.
     *
     * @param {WordArray} data The data to pad.
     * @param {number} blockSize The multiple that the data should be padded to.
     *
     * @static
     *
     * @example
     *
     *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
     */
    pad: function (data, blockSize) {
      // Shortcut
      var blockSizeBytes = blockSize * 4;

      // Count padding bytes
      var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

      // Create padding word
      var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

      // Create padding
      var paddingWords = [];
      for (var i = 0; i < nPaddingBytes; i += 4) {
        paddingWords.push(paddingWord);
      }
      var padding = WordArray.create(paddingWords, nPaddingBytes);

      // Add padding
      data.concat(padding);
    },

    /**
     * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
     *
     * @param {WordArray} data The data to unpad.
     *
     * @static
     *
     * @example
     *
     *     CryptoJS.pad.Pkcs7.unpad(wordArray);
     */
    unpad: function (data) {
      // Get number of padding bytes from last byte
      var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

      // Remove padding
      data.sigBytes -= nPaddingBytes;
    }
  };

  /**
   * Abstract base block cipher template.
   *
   * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
   */
  var BlockCipher = C_lib.BlockCipher = Cipher.extend({
    /**
     * Configuration options.
     *
     * @property {Mode} mode The block mode to use. Default: CBC
     * @property {Padding} padding The padding strategy to use. Default: Pkcs7
     */
    cfg: Cipher.cfg.extend({
      mode: CBC,
      padding: Pkcs7
    }),

    reset: function () {
      // Reset cipher
      Cipher.reset.call(this);

      // Shortcuts
      var cfg = this.cfg;
      var iv = cfg.iv;
      var mode = cfg.mode;

      // Reset block mode
      if (this._xformMode == this._ENC_XFORM_MODE) {
        var modeCreator = mode.createEncryptor;
      } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
        var modeCreator = mode.createDecryptor;

        // Keep at least one block in the buffer for unpadding
        this._minBufferSize = 1;
      }
      this._mode = modeCreator.call(mode, this, iv && iv.words);
    },

    _doProcessBlock: function (words, offset) {
      this._mode.processBlock(words, offset);
    },

    _doFinalize: function () {
      // Shortcut
      var padding = this.cfg.padding;

      // Finalize
      if (this._xformMode == this._ENC_XFORM_MODE) {
        // Pad data
        padding.pad(this._data, this.blockSize);

        // Process final blocks
        var finalProcessedBlocks = this._process(!!'flush');
      } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
        // Process final blocks
        var finalProcessedBlocks = this._process(!!'flush');

        // Unpad data
        padding.unpad(finalProcessedBlocks);
      }

      return finalProcessedBlocks;
    },

    blockSize: 128/32
  });

  /**
   * A collection of cipher parameters.
   *
   * @property {WordArray} ciphertext The raw ciphertext.
   * @property {WordArray} key The key to this ciphertext.
   * @property {WordArray} iv The IV used in the ciphering operation.
   * @property {WordArray} salt The salt used with a key derivation function.
   * @property {Cipher} algorithm The cipher algorithm.
   * @property {Mode} mode The block mode used in the ciphering operation.
   * @property {Padding} padding The padding scheme used in the ciphering operation.
   * @property {number} blockSize The block size of the cipher.
   * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
   */
  var CipherParams = C_lib.CipherParams = Base.extend({
    /**
     * Initializes a newly created cipher params object.
     *
     * @param {Object} cipherParams An object with any of the possible cipher parameters.
     *
     * @example
     *
     *     var cipherParams = CryptoJS.lib.CipherParams.create({
         *         ciphertext: ciphertextWordArray,
         *         key: keyWordArray,
         *         iv: ivWordArray,
         *         salt: saltWordArray,
         *         algorithm: CryptoJS.algo.AES,
         *         mode: CryptoJS.mode.CBC,
         *         padding: CryptoJS.pad.PKCS7,
         *         blockSize: 4,
         *         formatter: CryptoJS.format.OpenSSL
         *     });
     */
    init: function (cipherParams) {
      this.mixIn(cipherParams);
    },

    /**
     * Converts this cipher params object to a string.
     *
     * @param {Format} formatter (Optional) The formatting strategy to use.
     *
     * @return {string} The stringified cipher params.
     *
     * @throws Error If neither the formatter nor the default formatter is set.
     *
     * @example
     *
     *     var string = cipherParams + '';
     *     var string = cipherParams.toString();
     *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
     */
    toString: function (formatter) {
      return (formatter || this.formatter).stringify(this);
    }
  });

  /**
   * Format namespace.
   */
  var C_format = C.format = {};

  /**
   * OpenSSL formatting strategy.
   */
  var OpenSSLFormatter = C_format.OpenSSL = {
    /**
     * Converts a cipher params object to an OpenSSL-compatible string.
     *
     * @param {CipherParams} cipherParams The cipher params object.
     *
     * @return {string} The OpenSSL-compatible string.
     *
     * @static
     *
     * @example
     *
     *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
     */
    stringify: function (cipherParams) {
      // Shortcuts
      var ciphertext = cipherParams.ciphertext;
      var salt = cipherParams.salt;

      // Format
      if (salt) {
        var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
      } else {
        var wordArray = ciphertext;
      }

      return wordArray.toString(Base64);
    },

    /**
     * Converts an OpenSSL-compatible string to a cipher params object.
     *
     * @param {string} openSSLStr The OpenSSL-compatible string.
     *
     * @return {CipherParams} The cipher params object.
     *
     * @static
     *
     * @example
     *
     *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
     */
    parse: function (openSSLStr) {
      // Parse base64
      var ciphertext = Base64.parse(openSSLStr);

      // Shortcut
      var ciphertextWords = ciphertext.words;

      // Test for salt
      if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
        // Extract salt
        var salt = WordArray.create(ciphertextWords.slice(2, 4));

        // Remove salt from ciphertext
        ciphertextWords.splice(0, 4);
        ciphertext.sigBytes -= 16;
      }

      return CipherParams.create({ ciphertext: ciphertext, salt: salt });
    }
  };

  /**
   * A cipher wrapper that returns ciphertext as a serializable cipher params object.
   */
  var SerializableCipher = C_lib.SerializableCipher = Base.extend({
    /**
     * Configuration options.
     *
     * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
     */
    cfg: Base.extend({
      format: OpenSSLFormatter
    }),

    /**
     * Encrypts a message.
     *
     * @param {Cipher} cipher The cipher algorithm to use.
     * @param {WordArray|string} message The message to encrypt.
     * @param {WordArray} key The key.
     * @param {Object} cfg (Optional) The configuration options to use for this operation.
     *
     * @return {CipherParams} A cipher params object.
     *
     * @static
     *
     * @example
     *
     *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
     *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
     *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
     */
    encrypt: function (cipher, message, key, cfg) {
      // Apply config defaults
      cfg = this.cfg.extend(cfg);

      // Encrypt
      var encryptor = cipher.createEncryptor(key, cfg);
      var ciphertext = encryptor.finalize(message);

      // Shortcut
      var cipherCfg = encryptor.cfg;

      // Create and return serializable cipher params
      return CipherParams.create({
        ciphertext: ciphertext,
        key: key,
        iv: cipherCfg.iv,
        algorithm: cipher,
        mode: cipherCfg.mode,
        padding: cipherCfg.padding,
        blockSize: cipher.blockSize,
        formatter: cfg.format
      });
    },

    /**
     * Decrypts serialized ciphertext.
     *
     * @param {Cipher} cipher The cipher algorithm to use.
     * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
     * @param {WordArray} key The key.
     * @param {Object} cfg (Optional) The configuration options to use for this operation.
     *
     * @return {WordArray} The plaintext.
     *
     * @static
     *
     * @example
     *
     *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
     *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
     */
    decrypt: function (cipher, ciphertext, key, cfg) {
      // Apply config defaults
      cfg = this.cfg.extend(cfg);

      // Convert string to CipherParams
      ciphertext = this._parse(ciphertext, cfg.format);

      // Decrypt
      var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

      return plaintext;
    },

    /**
     * Converts serialized ciphertext to CipherParams,
     * else assumed CipherParams already and returns ciphertext unchanged.
     *
     * @param {CipherParams|string} ciphertext The ciphertext.
     * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
     *
     * @return {CipherParams} The unserialized ciphertext.
     *
     * @static
     *
     * @example
     *
     *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
     */
    _parse: function (ciphertext, format) {
      if (typeof ciphertext == 'string') {
        return format.parse(ciphertext, this);
      } else {
        return ciphertext;
      }
    }
  });

  /**
   * Key derivation function namespace.
   */
  var C_kdf = C.kdf = {};

  /**
   * OpenSSL key derivation function.
   */
  var OpenSSLKdf = C_kdf.OpenSSL = {
    /**
     * Derives a key and IV from a password.
     *
     * @param {string} password The password to derive from.
     * @param {number} keySize The size in words of the key to generate.
     * @param {number} ivSize The size in words of the IV to generate.
     * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
     *
     * @return {CipherParams} A cipher params object with the key, IV, and salt.
     *
     * @static
     *
     * @example
     *
     *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
     *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
     */
    execute: function (password, keySize, ivSize, salt) {
      // Generate random salt
      if (!salt) {
        salt = WordArray.random(64/8);
      }

      // Derive key and IV
      var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

      // Separate key and IV
      var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
      key.sigBytes = keySize * 4;

      // Return params
      return CipherParams.create({ key: key, iv: iv, salt: salt });
    }
  };

  /**
   * A serializable cipher wrapper that derives the key from a password,
   * and returns ciphertext as a serializable cipher params object.
   */
  var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
    /**
     * Configuration options.
     *
     * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
     */
    cfg: SerializableCipher.cfg.extend({
      kdf: OpenSSLKdf
    }),

    /**
     * Encrypts a message using a password.
     *
     * @param {Cipher} cipher The cipher algorithm to use.
     * @param {WordArray|string} message The message to encrypt.
     * @param {string} password The password.
     * @param {Object} cfg (Optional) The configuration options to use for this operation.
     *
     * @return {CipherParams} A cipher params object.
     *
     * @static
     *
     * @example
     *
     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
     */
    encrypt: function (cipher, message, password, cfg) {
      // Apply config defaults
      cfg = this.cfg.extend(cfg);

      // Derive key and other params
      var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

      // Add IV to config
      cfg.iv = derivedParams.iv;

      // Encrypt
      var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

      // Mix in derived params
      ciphertext.mixIn(derivedParams);

      return ciphertext;
    },

    /**
     * Decrypts serialized ciphertext using a password.
     *
     * @param {Cipher} cipher The cipher algorithm to use.
     * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
     * @param {string} password The password.
     * @param {Object} cfg (Optional) The configuration options to use for this operation.
     *
     * @return {WordArray} The plaintext.
     *
     * @static
     *
     * @example
     *
     *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
     *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
     */
    decrypt: function (cipher, ciphertext, password, cfg) {
      // Apply config defaults
      cfg = this.cfg.extend(cfg);

      // Convert string to CipherParams
      ciphertext = this._parse(ciphertext, cfg.format);

      // Derive key and other params
      var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

      // Add IV to config
      cfg.iv = derivedParams.iv;

      // Decrypt
      var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

      return plaintext;
    }
  });
}());
/*
 CryptoJS v3.1.2
 aes.js
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
(function () {
  // Shortcuts
  var C = CryptoJS;
  var C_lib = C.lib;
  var BlockCipher = C_lib.BlockCipher;
  var C_algo = C.algo;

  // Lookup tables
  var SBOX = [];
  var INV_SBOX = [];
  var SUB_MIX_0 = [];
  var SUB_MIX_1 = [];
  var SUB_MIX_2 = [];
  var SUB_MIX_3 = [];
  var INV_SUB_MIX_0 = [];
  var INV_SUB_MIX_1 = [];
  var INV_SUB_MIX_2 = [];
  var INV_SUB_MIX_3 = [];

  // Compute lookup tables
  (function () {
    // Compute double table
    var d = [];
    for (var i = 0; i < 256; i++) {
      if (i < 128) {
        d[i] = i << 1;
      } else {
        d[i] = (i << 1) ^ 0x11b;
      }
    }

    // Walk GF(2^8)
    var x = 0;
    var xi = 0;
    for (var i = 0; i < 256; i++) {
      // Compute sbox
      var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
      sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
      SBOX[x] = sx;
      INV_SBOX[sx] = x;

      // Compute multiplication
      var x2 = d[x];
      var x4 = d[x2];
      var x8 = d[x4];

      // Compute sub bytes, mix columns tables
      var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
      SUB_MIX_0[x] = (t << 24) | (t >>> 8);
      SUB_MIX_1[x] = (t << 16) | (t >>> 16);
      SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
      SUB_MIX_3[x] = t;

      // Compute inv sub bytes, inv mix columns tables
      var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
      INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
      INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
      INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
      INV_SUB_MIX_3[sx] = t;

      // Compute next counter
      if (!x) {
        x = xi = 1;
      } else {
        x = x2 ^ d[d[d[x8 ^ x2]]];
        xi ^= d[d[xi]];
      }
    }
  }());

  // Precomputed Rcon lookup
  var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

  /**
   * AES block cipher algorithm.
   */
  var AES = C_algo.AES = BlockCipher.extend({
    _doReset: function () {
      // Shortcuts
      var key = this._key;
      var keyWords = key.words;
      var keySize = key.sigBytes / 4;

      // Compute number of rounds
      var nRounds = this._nRounds = keySize + 6

      // Compute number of key schedule rows
      var ksRows = (nRounds + 1) * 4;

      // Compute key schedule
      var keySchedule = this._keySchedule = [];
      for (var ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          keySchedule[ksRow] = keyWords[ksRow];
        } else {
          var t = keySchedule[ksRow - 1];

          if (!(ksRow % keySize)) {
            // Rot word
            t = (t << 8) | (t >>> 24);

            // Sub word
            t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

            // Mix Rcon
            t ^= RCON[(ksRow / keySize) | 0] << 24;
          } else if (keySize > 6 && ksRow % keySize == 4) {
            // Sub word
            t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
          }

          keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
        }
      }

      // Compute inv key schedule
      var invKeySchedule = this._invKeySchedule = [];
      for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        var ksRow = ksRows - invKsRow;

        if (invKsRow % 4) {
          var t = keySchedule[ksRow];
        } else {
          var t = keySchedule[ksRow - 4];
        }

        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
              INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
        }
      }
    },

    encryptBlock: function (M, offset) {
      this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
    },

    decryptBlock: function (M, offset) {
      // Swap 2nd and 4th rows
      var t = M[offset + 1];
      M[offset + 1] = M[offset + 3];
      M[offset + 3] = t;

      this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

      // Inv swap 2nd and 4th rows
      var t = M[offset + 1];
      M[offset + 1] = M[offset + 3];
      M[offset + 3] = t;
    },

    _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
      // Shortcut
      var nRounds = this._nRounds;

      // Get input, add round key
      var s0 = M[offset]     ^ keySchedule[0];
      var s1 = M[offset + 1] ^ keySchedule[1];
      var s2 = M[offset + 2] ^ keySchedule[2];
      var s3 = M[offset + 3] ^ keySchedule[3];

      // Key schedule row counter
      var ksRow = 4;

      // Rounds
      for (var round = 1; round < nRounds; round++) {
        // Shift rows, sub bytes, mix columns, add round key
        var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
        var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
        var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
        var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

        // Update state
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
      }

      // Shift rows, sub bytes, add round key
      var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
      var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
      var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
      var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

      // Set output
      M[offset]     = t0;
      M[offset + 1] = t1;
      M[offset + 2] = t2;
      M[offset + 3] = t3;
    },

    keySize: 256/32
  });

  /**
   * Shortcut functions to the cipher's object interface.
   *
   * @example
   *
   *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
   *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
   */
  C.AES = BlockCipher._createHelper(AES);
}());
/*
 CryptoJS v3.1.2
 md5.js
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
(function (Math) {
  // Shortcuts
  var C = CryptoJS;
  var C_lib = C.lib;
  var WordArray = C_lib.WordArray;
  var Hasher = C_lib.Hasher;
  var C_algo = C.algo;

  // Constants table
  var T = [];

  // Compute constants
  (function () {
    for (var i = 0; i < 64; i++) {
      T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
    }
  }());

  /**
   * MD5 hash algorithm.
   */
  var MD5 = C_algo.MD5 = Hasher.extend({
    _doReset: function () {
      this._hash = new WordArray.init([
        0x67452301, 0xefcdab89,
        0x98badcfe, 0x10325476
      ]);
    },

    _doProcessBlock: function (M, offset) {
      // Swap endian
      for (var i = 0; i < 16; i++) {
        // Shortcuts
        var offset_i = offset + i;
        var M_offset_i = M[offset_i];

        M[offset_i] = (
            (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
                (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
            );
      }

      // Shortcuts
      var H = this._hash.words;

      var M_offset_0  = M[offset + 0];
      var M_offset_1  = M[offset + 1];
      var M_offset_2  = M[offset + 2];
      var M_offset_3  = M[offset + 3];
      var M_offset_4  = M[offset + 4];
      var M_offset_5  = M[offset + 5];
      var M_offset_6  = M[offset + 6];
      var M_offset_7  = M[offset + 7];
      var M_offset_8  = M[offset + 8];
      var M_offset_9  = M[offset + 9];
      var M_offset_10 = M[offset + 10];
      var M_offset_11 = M[offset + 11];
      var M_offset_12 = M[offset + 12];
      var M_offset_13 = M[offset + 13];
      var M_offset_14 = M[offset + 14];
      var M_offset_15 = M[offset + 15];

      // Working varialbes
      var a = H[0];
      var b = H[1];
      var c = H[2];
      var d = H[3];

      // Computation
      a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
      d = FF(d, a, b, c, M_offset_1,  12, T[1]);
      c = FF(c, d, a, b, M_offset_2,  17, T[2]);
      b = FF(b, c, d, a, M_offset_3,  22, T[3]);
      a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
      d = FF(d, a, b, c, M_offset_5,  12, T[5]);
      c = FF(c, d, a, b, M_offset_6,  17, T[6]);
      b = FF(b, c, d, a, M_offset_7,  22, T[7]);
      a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
      d = FF(d, a, b, c, M_offset_9,  12, T[9]);
      c = FF(c, d, a, b, M_offset_10, 17, T[10]);
      b = FF(b, c, d, a, M_offset_11, 22, T[11]);
      a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
      d = FF(d, a, b, c, M_offset_13, 12, T[13]);
      c = FF(c, d, a, b, M_offset_14, 17, T[14]);
      b = FF(b, c, d, a, M_offset_15, 22, T[15]);

      a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
      d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
      c = GG(c, d, a, b, M_offset_11, 14, T[18]);
      b = GG(b, c, d, a, M_offset_0,  20, T[19]);
      a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
      d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
      c = GG(c, d, a, b, M_offset_15, 14, T[22]);
      b = GG(b, c, d, a, M_offset_4,  20, T[23]);
      a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
      d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
      c = GG(c, d, a, b, M_offset_3,  14, T[26]);
      b = GG(b, c, d, a, M_offset_8,  20, T[27]);
      a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
      d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
      c = GG(c, d, a, b, M_offset_7,  14, T[30]);
      b = GG(b, c, d, a, M_offset_12, 20, T[31]);

      a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
      d = HH(d, a, b, c, M_offset_8,  11, T[33]);
      c = HH(c, d, a, b, M_offset_11, 16, T[34]);
      b = HH(b, c, d, a, M_offset_14, 23, T[35]);
      a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
      d = HH(d, a, b, c, M_offset_4,  11, T[37]);
      c = HH(c, d, a, b, M_offset_7,  16, T[38]);
      b = HH(b, c, d, a, M_offset_10, 23, T[39]);
      a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
      d = HH(d, a, b, c, M_offset_0,  11, T[41]);
      c = HH(c, d, a, b, M_offset_3,  16, T[42]);
      b = HH(b, c, d, a, M_offset_6,  23, T[43]);
      a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
      d = HH(d, a, b, c, M_offset_12, 11, T[45]);
      c = HH(c, d, a, b, M_offset_15, 16, T[46]);
      b = HH(b, c, d, a, M_offset_2,  23, T[47]);

      a = II(a, b, c, d, M_offset_0,  6,  T[48]);
      d = II(d, a, b, c, M_offset_7,  10, T[49]);
      c = II(c, d, a, b, M_offset_14, 15, T[50]);
      b = II(b, c, d, a, M_offset_5,  21, T[51]);
      a = II(a, b, c, d, M_offset_12, 6,  T[52]);
      d = II(d, a, b, c, M_offset_3,  10, T[53]);
      c = II(c, d, a, b, M_offset_10, 15, T[54]);
      b = II(b, c, d, a, M_offset_1,  21, T[55]);
      a = II(a, b, c, d, M_offset_8,  6,  T[56]);
      d = II(d, a, b, c, M_offset_15, 10, T[57]);
      c = II(c, d, a, b, M_offset_6,  15, T[58]);
      b = II(b, c, d, a, M_offset_13, 21, T[59]);
      a = II(a, b, c, d, M_offset_4,  6,  T[60]);
      d = II(d, a, b, c, M_offset_11, 10, T[61]);
      c = II(c, d, a, b, M_offset_2,  15, T[62]);
      b = II(b, c, d, a, M_offset_9,  21, T[63]);

      // Intermediate hash value
      H[0] = (H[0] + a) | 0;
      H[1] = (H[1] + b) | 0;
      H[2] = (H[2] + c) | 0;
      H[3] = (H[3] + d) | 0;
    },

    _doFinalize: function () {
      // Shortcuts
      var data = this._data;
      var dataWords = data.words;

      var nBitsTotal = this._nDataBytes * 8;
      var nBitsLeft = data.sigBytes * 8;

      // Add padding
      dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

      var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
      var nBitsTotalL = nBitsTotal;
      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
          (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
              (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
          );
      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
          (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
              (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
          );

      data.sigBytes = (dataWords.length + 1) * 4;

      // Hash final blocks
      this._process();

      // Shortcuts
      var hash = this._hash;
      var H = hash.words;

      // Swap endian
      for (var i = 0; i < 4; i++) {
        // Shortcut
        var H_i = H[i];

        H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
            (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
      }

      // Return final computed hash
      return hash;
    },

    clone: function () {
      var clone = Hasher.clone.call(this);
      clone._hash = this._hash.clone();

      return clone;
    }
  });

  function FF(a, b, c, d, x, s, t) {
    var n = a + ((b & c) | (~b & d)) + x + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  }

  function GG(a, b, c, d, x, s, t) {
    var n = a + ((b & d) | (c & ~d)) + x + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  }

  function HH(a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + x + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  }

  function II(a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + x + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  }

  /**
   * Shortcut function to the hasher's object interface.
   *
   * @param {WordArray|string} message The message to hash.
   *
   * @return {WordArray} The hash.
   *
   * @static
   *
   * @example
   *
   *     var hash = CryptoJS.MD5('message');
   *     var hash = CryptoJS.MD5(wordArray);
   */
  C.MD5 = Hasher._createHelper(MD5);

  /**
   * Shortcut function to the HMAC's object interface.
   *
   * @param {WordArray|string} message The message to hash.
   * @param {WordArray|string} key The secret key.
   *
   * @return {WordArray} The HMAC.
   *
   * @static
   *
   * @example
   *
   *     var hmac = CryptoJS.HmacMD5(message, key);
   */
  C.HmacMD5 = Hasher._createHmacHelper(MD5);
}(Math));
/*
 CryptoJS v3.1.2
 sha1.js
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
(function () {
  // Shortcuts
  var C = CryptoJS;
  var C_lib = C.lib;
  var WordArray = C_lib.WordArray;
  var Hasher = C_lib.Hasher;
  var C_algo = C.algo;

  // Reusable object
  var W = [];

  /**
   * SHA-1 hash algorithm.
   */
  var SHA1 = C_algo.SHA1 = Hasher.extend({
    _doReset: function () {
      this._hash = new WordArray.init([
        0x67452301, 0xefcdab89,
        0x98badcfe, 0x10325476,
        0xc3d2e1f0
      ]);
    },

    _doProcessBlock: function (M, offset) {
      // Shortcut
      var H = this._hash.words;

      // Working variables
      var a = H[0];
      var b = H[1];
      var c = H[2];
      var d = H[3];
      var e = H[4];

      // Computation
      for (var i = 0; i < 80; i++) {
        if (i < 16) {
          W[i] = M[offset + i] | 0;
        } else {
          var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
          W[i] = (n << 1) | (n >>> 31);
        }

        var t = ((a << 5) | (a >>> 27)) + e + W[i];
        if (i < 20) {
          t += ((b & c) | (~b & d)) + 0x5a827999;
        } else if (i < 40) {
          t += (b ^ c ^ d) + 0x6ed9eba1;
        } else if (i < 60) {
          t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
        } else /* if (i < 80) */ {
          t += (b ^ c ^ d) - 0x359d3e2a;
        }

        e = d;
        d = c;
        c = (b << 30) | (b >>> 2);
        b = a;
        a = t;
      }

      // Intermediate hash value
      H[0] = (H[0] + a) | 0;
      H[1] = (H[1] + b) | 0;
      H[2] = (H[2] + c) | 0;
      H[3] = (H[3] + d) | 0;
      H[4] = (H[4] + e) | 0;
    },

    _doFinalize: function () {
      // Shortcuts
      var data = this._data;
      var dataWords = data.words;

      var nBitsTotal = this._nDataBytes * 8;
      var nBitsLeft = data.sigBytes * 8;

      // Add padding
      dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
      data.sigBytes = dataWords.length * 4;

      // Hash final blocks
      this._process();

      // Return final computed hash
      return this._hash;
    },

    clone: function () {
      var clone = Hasher.clone.call(this);
      clone._hash = this._hash.clone();

      return clone;
    }
  });

  /**
   * Shortcut function to the hasher's object interface.
   *
   * @param {WordArray|string} message The message to hash.
   *
   * @return {WordArray} The hash.
   *
   * @static
   *
   * @example
   *
   *     var hash = CryptoJS.SHA1('message');
   *     var hash = CryptoJS.SHA1(wordArray);
   */
  C.SHA1 = Hasher._createHelper(SHA1);

  /**
   * Shortcut function to the HMAC's object interface.
   *
   * @param {WordArray|string} message The message to hash.
   * @param {WordArray|string} key The secret key.
   *
   * @return {WordArray} The HMAC.
   *
   * @static
   *
   * @example
   *
   *     var hmac = CryptoJS.HmacSHA1(message, key);
   */
  C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
}());
/*
 CryptoJS v3.1.2
 x64-core.js
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
(function (undefined) {
  // Shortcuts
  var C = CryptoJS;
  var C_lib = C.lib;
  var Base = C_lib.Base;
  var X32WordArray = C_lib.WordArray;

  /**
   * x64 namespace.
   */
  var C_x64 = C.x64 = {};

  /**
   * A 64-bit word.
   */
  var X64Word = C_x64.Word = Base.extend({
    /**
     * Initializes a newly created 64-bit word.
     *
     * @param {number} high The high 32 bits.
     * @param {number} low The low 32 bits.
     *
     * @example
     *
     *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
     */
    init: function (high, low) {
      this.high = high;
      this.low = low;
    }

    /**
     * Bitwise NOTs this word.
     *
     * @return {X64Word} A new x64-Word object after negating.
     *
     * @example
     *
     *     var negated = x64Word.not();
     */
    // not: function () {
    // var high = ~this.high;
    // var low = ~this.low;

    // return X64Word.create(high, low);
    // },

    /**
     * Bitwise ANDs this word with the passed word.
     *
     * @param {X64Word} word The x64-Word to AND with this word.
     *
     * @return {X64Word} A new x64-Word object after ANDing.
     *
     * @example
     *
     *     var anded = x64Word.and(anotherX64Word);
     */
    // and: function (word) {
    // var high = this.high & word.high;
    // var low = this.low & word.low;

    // return X64Word.create(high, low);
    // },

    /**
     * Bitwise ORs this word with the passed word.
     *
     * @param {X64Word} word The x64-Word to OR with this word.
     *
     * @return {X64Word} A new x64-Word object after ORing.
     *
     * @example
     *
     *     var ored = x64Word.or(anotherX64Word);
     */
    // or: function (word) {
    // var high = this.high | word.high;
    // var low = this.low | word.low;

    // return X64Word.create(high, low);
    // },

    /**
     * Bitwise XORs this word with the passed word.
     *
     * @param {X64Word} word The x64-Word to XOR with this word.
     *
     * @return {X64Word} A new x64-Word object after XORing.
     *
     * @example
     *
     *     var xored = x64Word.xor(anotherX64Word);
     */
    // xor: function (word) {
    // var high = this.high ^ word.high;
    // var low = this.low ^ word.low;

    // return X64Word.create(high, low);
    // },

    /**
     * Shifts this word n bits to the left.
     *
     * @param {number} n The number of bits to shift.
     *
     * @return {X64Word} A new x64-Word object after shifting.
     *
     * @example
     *
     *     var shifted = x64Word.shiftL(25);
     */
    // shiftL: function (n) {
    // if (n < 32) {
    // var high = (this.high << n) | (this.low >>> (32 - n));
    // var low = this.low << n;
    // } else {
    // var high = this.low << (n - 32);
    // var low = 0;
    // }

    // return X64Word.create(high, low);
    // },

    /**
     * Shifts this word n bits to the right.
     *
     * @param {number} n The number of bits to shift.
     *
     * @return {X64Word} A new x64-Word object after shifting.
     *
     * @example
     *
     *     var shifted = x64Word.shiftR(7);
     */
    // shiftR: function (n) {
    // if (n < 32) {
    // var low = (this.low >>> n) | (this.high << (32 - n));
    // var high = this.high >>> n;
    // } else {
    // var low = this.high >>> (n - 32);
    // var high = 0;
    // }

    // return X64Word.create(high, low);
    // },

    /**
     * Rotates this word n bits to the left.
     *
     * @param {number} n The number of bits to rotate.
     *
     * @return {X64Word} A new x64-Word object after rotating.
     *
     * @example
     *
     *     var rotated = x64Word.rotL(25);
     */
    // rotL: function (n) {
    // return this.shiftL(n).or(this.shiftR(64 - n));
    // },

    /**
     * Rotates this word n bits to the right.
     *
     * @param {number} n The number of bits to rotate.
     *
     * @return {X64Word} A new x64-Word object after rotating.
     *
     * @example
     *
     *     var rotated = x64Word.rotR(7);
     */
    // rotR: function (n) {
    // return this.shiftR(n).or(this.shiftL(64 - n));
    // },

    /**
     * Adds this word with the passed word.
     *
     * @param {X64Word} word The x64-Word to add with this word.
     *
     * @return {X64Word} A new x64-Word object after adding.
     *
     * @example
     *
     *     var added = x64Word.add(anotherX64Word);
     */
    // add: function (word) {
    // var low = (this.low + word.low) | 0;
    // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
    // var high = (this.high + word.high + carry) | 0;

    // return X64Word.create(high, low);
    // }
  });

  /**
   * An array of 64-bit words.
   *
   * @property {Array} words The array of CryptoJS.x64.Word objects.
   * @property {number} sigBytes The number of significant bytes in this word array.
   */
  var X64WordArray = C_x64.WordArray = Base.extend({
    /**
     * Initializes a newly created word array.
     *
     * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
     * @param {number} sigBytes (Optional) The number of significant bytes in the words.
     *
     * @example
     *
     *     var wordArray = CryptoJS.x64.WordArray.create();
     *
     *     var wordArray = CryptoJS.x64.WordArray.create([
     *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
     *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
     *     ]);
     *
     *     var wordArray = CryptoJS.x64.WordArray.create([
     *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
     *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
     *     ], 10);
     */
    init: function (words, sigBytes) {
      words = this.words = words || [];

      if (sigBytes != undefined) {
        this.sigBytes = sigBytes;
      } else {
        this.sigBytes = words.length * 8;
      }
    },

    /**
     * Converts this 64-bit word array to a 32-bit word array.
     *
     * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
     *
     * @example
     *
     *     var x32WordArray = x64WordArray.toX32();
     */
    toX32: function () {
      // Shortcuts
      var x64Words = this.words;
      var x64WordsLength = x64Words.length;

      // Convert
      var x32Words = [];
      for (var i = 0; i < x64WordsLength; i++) {
        var x64Word = x64Words[i];
        x32Words.push(x64Word.high);
        x32Words.push(x64Word.low);
      }

      return X32WordArray.create(x32Words, this.sigBytes);
    },

    /**
     * Creates a copy of this word array.
     *
     * @return {X64WordArray} The clone.
     *
     * @example
     *
     *     var clone = x64WordArray.clone();
     */
    clone: function () {
      var clone = Base.clone.call(this);

      // Clone "words" array
      var words = clone.words = this.words.slice(0);

      // Clone each X64Word object
      var wordsLength = words.length;
      for (var i = 0; i < wordsLength; i++) {
        words[i] = words[i].clone();
      }

      return clone;
    }
  });
}());
/*
 CryptoJS v3.1.2
 sha256.js
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
(function (Math) {
  // Shortcuts
  var C = CryptoJS;
  var C_lib = C.lib;
  var WordArray = C_lib.WordArray;
  var Hasher = C_lib.Hasher;
  var C_algo = C.algo;

  // Initialization and round constants tables
  var H = [];
  var K = [];

  // Compute constants
  (function () {
    function isPrime(n) {
      var sqrtN = Math.sqrt(n);
      for (var factor = 2; factor <= sqrtN; factor++) {
        if (!(n % factor)) {
          return false;
        }
      }

      return true;
    }

    function getFractionalBits(n) {
      return ((n - (n | 0)) * 0x100000000) | 0;
    }

    var n = 2;
    var nPrime = 0;
    while (nPrime < 64) {
      if (isPrime(n)) {
        if (nPrime < 8) {
          H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
        }
        K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

        nPrime++;
      }

      n++;
    }
  }());

  // Reusable object
  var W = [];

  /**
   * SHA-256 hash algorithm.
   */
  var SHA256 = C_algo.SHA256 = Hasher.extend({
    _doReset: function () {
      this._hash = new WordArray.init(H.slice(0));
    },

    _doProcessBlock: function (M, offset) {
      // Shortcut
      var H = this._hash.words;

      // Working variables
      var a = H[0];
      var b = H[1];
      var c = H[2];
      var d = H[3];
      var e = H[4];
      var f = H[5];
      var g = H[6];
      var h = H[7];

      // Computation
      for (var i = 0; i < 64; i++) {
        if (i < 16) {
          W[i] = M[offset + i] | 0;
        } else {
          var gamma0x = W[i - 15];
          var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
              ((gamma0x << 14) | (gamma0x >>> 18)) ^
              (gamma0x >>> 3);

          var gamma1x = W[i - 2];
          var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
              ((gamma1x << 13) | (gamma1x >>> 19)) ^
              (gamma1x >>> 10);

          W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
        }

        var ch  = (e & f) ^ (~e & g);
        var maj = (a & b) ^ (a & c) ^ (b & c);

        var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
        var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

        var t1 = h + sigma1 + ch + K[i] + W[i];
        var t2 = sigma0 + maj;

        h = g;
        g = f;
        f = e;
        e = (d + t1) | 0;
        d = c;
        c = b;
        b = a;
        a = (t1 + t2) | 0;
      }

      // Intermediate hash value
      H[0] = (H[0] + a) | 0;
      H[1] = (H[1] + b) | 0;
      H[2] = (H[2] + c) | 0;
      H[3] = (H[3] + d) | 0;
      H[4] = (H[4] + e) | 0;
      H[5] = (H[5] + f) | 0;
      H[6] = (H[6] + g) | 0;
      H[7] = (H[7] + h) | 0;
    },

    _doFinalize: function () {
      // Shortcuts
      var data = this._data;
      var dataWords = data.words;

      var nBitsTotal = this._nDataBytes * 8;
      var nBitsLeft = data.sigBytes * 8;

      // Add padding
      dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
      data.sigBytes = dataWords.length * 4;

      // Hash final blocks
      this._process();

      // Return final computed hash
      return this._hash;
    },

    clone: function () {
      var clone = Hasher.clone.call(this);
      clone._hash = this._hash.clone();

      return clone;
    }
  });

  /**
   * Shortcut function to the hasher's object interface.
   *
   * @param {WordArray|string} message The message to hash.
   *
   * @return {WordArray} The hash.
   *
   * @static
   *
   * @example
   *
   *     var hash = CryptoJS.SHA256('message');
   *     var hash = CryptoJS.SHA256(wordArray);
   */
  C.SHA256 = Hasher._createHelper(SHA256);

  /**
   * Shortcut function to the HMAC's object interface.
   *
   * @param {WordArray|string} message The message to hash.
   * @param {WordArray|string} key The secret key.
   *
   * @return {WordArray} The HMAC.
   *
   * @static
   *
   * @example
   *
   *     var hmac = CryptoJS.HmacSHA256(message, key);
   */
  C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
}(Math));
/*
 CryptoJS v3.1.2
 sha512.js
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
(function () {
  // Shortcuts
  var C = CryptoJS;
  var C_lib = C.lib;
  var Hasher = C_lib.Hasher;
  var C_x64 = C.x64;
  var X64Word = C_x64.Word;
  var X64WordArray = C_x64.WordArray;
  var C_algo = C.algo;

  function X64Word_create() {
    return X64Word.create.apply(X64Word, arguments);
  }

  // Constants
  var K = [
    X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
    X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
    X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
    X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
    X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
    X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
    X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
    X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
    X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
    X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
    X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
    X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
    X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
    X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
    X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
    X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
    X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
    X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
    X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
    X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
    X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
    X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
    X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
    X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
    X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
    X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
    X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
    X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
    X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
    X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
    X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
    X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
    X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
    X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
    X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
    X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
    X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
    X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
    X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
    X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
  ];

  // Reusable objects
  var W = [];
  (function () {
    for (var i = 0; i < 80; i++) {
      W[i] = X64Word_create();
    }
  }());

  /**
   * SHA-512 hash algorithm.
   */
  var SHA512 = C_algo.SHA512 = Hasher.extend({
    _doReset: function () {
      this._hash = new X64WordArray.init([
        new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
        new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
        new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
        new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
      ]);
    },

    _doProcessBlock: function (M, offset) {
      // Shortcuts
      var H = this._hash.words;

      var H0 = H[0];
      var H1 = H[1];
      var H2 = H[2];
      var H3 = H[3];
      var H4 = H[4];
      var H5 = H[5];
      var H6 = H[6];
      var H7 = H[7];

      var H0h = H0.high;
      var H0l = H0.low;
      var H1h = H1.high;
      var H1l = H1.low;
      var H2h = H2.high;
      var H2l = H2.low;
      var H3h = H3.high;
      var H3l = H3.low;
      var H4h = H4.high;
      var H4l = H4.low;
      var H5h = H5.high;
      var H5l = H5.low;
      var H6h = H6.high;
      var H6l = H6.low;
      var H7h = H7.high;
      var H7l = H7.low;

      // Working variables
      var ah = H0h;
      var al = H0l;
      var bh = H1h;
      var bl = H1l;
      var ch = H2h;
      var cl = H2l;
      var dh = H3h;
      var dl = H3l;
      var eh = H4h;
      var el = H4l;
      var fh = H5h;
      var fl = H5l;
      var gh = H6h;
      var gl = H6l;
      var hh = H7h;
      var hl = H7l;

      // Rounds
      for (var i = 0; i < 80; i++) {
        // Shortcut
        var Wi = W[i];

        // Extend message
        if (i < 16) {
          var Wih = Wi.high = M[offset + i * 2]     | 0;
          var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
        } else {
          // Gamma0
          var gamma0x  = W[i - 15];
          var gamma0xh = gamma0x.high;
          var gamma0xl = gamma0x.low;
          var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
          var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

          // Gamma1
          var gamma1x  = W[i - 2];
          var gamma1xh = gamma1x.high;
          var gamma1xl = gamma1x.low;
          var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
          var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

          // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
          var Wi7  = W[i - 7];
          var Wi7h = Wi7.high;
          var Wi7l = Wi7.low;

          var Wi16  = W[i - 16];
          var Wi16h = Wi16.high;
          var Wi16l = Wi16.low;

          var Wil = gamma0l + Wi7l;
          var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
          var Wil = Wil + gamma1l;
          var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
          var Wil = Wil + Wi16l;
          var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

          Wi.high = Wih;
          Wi.low  = Wil;
        }

        var chh  = (eh & fh) ^ (~eh & gh);
        var chl  = (el & fl) ^ (~el & gl);
        var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
        var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

        var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
        var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
        var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
        var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

        // t1 = h + sigma1 + ch + K[i] + W[i]
        var Ki  = K[i];
        var Kih = Ki.high;
        var Kil = Ki.low;

        var t1l = hl + sigma1l;
        var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
        var t1l = t1l + chl;
        var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
        var t1l = t1l + Kil;
        var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
        var t1l = t1l + Wil;
        var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

        // t2 = sigma0 + maj
        var t2l = sigma0l + majl;
        var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

        // Update working variables
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = (dl + t1l) | 0;
        eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = (t1l + t2l) | 0;
        ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
      }

      // Intermediate hash value
      H0l = H0.low  = (H0l + al);
      H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
      H1l = H1.low  = (H1l + bl);
      H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
      H2l = H2.low  = (H2l + cl);
      H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
      H3l = H3.low  = (H3l + dl);
      H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
      H4l = H4.low  = (H4l + el);
      H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
      H5l = H5.low  = (H5l + fl);
      H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
      H6l = H6.low  = (H6l + gl);
      H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
      H7l = H7.low  = (H7l + hl);
      H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
    },

    _doFinalize: function () {
      // Shortcuts
      var data = this._data;
      var dataWords = data.words;

      var nBitsTotal = this._nDataBytes * 8;
      var nBitsLeft = data.sigBytes * 8;

      // Add padding
      dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
      dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
      dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
      data.sigBytes = dataWords.length * 4;

      // Hash final blocks
      this._process();

      // Convert hash to 32-bit word array before returning
      var hash = this._hash.toX32();

      // Return final computed hash
      return hash;
    },

    clone: function () {
      var clone = Hasher.clone.call(this);
      clone._hash = this._hash.clone();

      return clone;
    },

    blockSize: 1024/32
  });

  /**
   * Shortcut function to the hasher's object interface.
   *
   * @param {WordArray|string} message The message to hash.
   *
   * @return {WordArray} The hash.
   *
   * @static
   *
   * @example
   *
   *     var hash = CryptoJS.SHA512('message');
   *     var hash = CryptoJS.SHA512(wordArray);
   */
  C.SHA512 = Hasher._createHelper(SHA512);

  /**
   * Shortcut function to the HMAC's object interface.
   *
   * @param {WordArray|string} message The message to hash.
   * @param {WordArray|string} key The secret key.
   *
   * @return {WordArray} The HMAC.
   *
   * @static
   *
   * @example
   *
   *     var hmac = CryptoJS.HmacSHA512(message, key);
   */
  C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
}());
/*
 CryptoJS v3.1.2
 sha3.js
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
(function (Math) {
  // Shortcuts
  var C = CryptoJS;
  var C_lib = C.lib;
  var WordArray = C_lib.WordArray;
  var Hasher = C_lib.Hasher;
  var C_x64 = C.x64;
  var X64Word = C_x64.Word;
  var C_algo = C.algo;

  // Constants tables
  var RHO_OFFSETS = [];
  var PI_INDEXES  = [];
  var ROUND_CONSTANTS = [];

  // Compute Constants
  (function () {
    // Compute rho offset constants
    var x = 1, y = 0;
    for (var t = 0; t < 24; t++) {
      RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

      var newX = y % 5;
      var newY = (2 * x + 3 * y) % 5;
      x = newX;
      y = newY;
    }

    // Compute pi index constants
    for (var x = 0; x < 5; x++) {
      for (var y = 0; y < 5; y++) {
        PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
      }
    }

    // Compute round constants
    var LFSR = 0x01;
    for (var i = 0; i < 24; i++) {
      var roundConstantMsw = 0;
      var roundConstantLsw = 0;

      for (var j = 0; j < 7; j++) {
        if (LFSR & 0x01) {
          var bitPosition = (1 << j) - 1;
          if (bitPosition < 32) {
            roundConstantLsw ^= 1 << bitPosition;
          } else /* if (bitPosition >= 32) */ {
            roundConstantMsw ^= 1 << (bitPosition - 32);
          }
        }

        // Compute next LFSR
        if (LFSR & 0x80) {
          // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
          LFSR = (LFSR << 1) ^ 0x71;
        } else {
          LFSR <<= 1;
        }
      }

      ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
    }
  }());

  // Reusable objects for temporary values
  var T = [];
  (function () {
    for (var i = 0; i < 25; i++) {
      T[i] = X64Word.create();
    }
  }());

  /**
   * SHA-3 hash algorithm.
   */
  var SHA3 = C_algo.SHA3 = Hasher.extend({
    /**
     * Configuration options.
     *
     * @property {number} outputLength
     *   The desired number of bits in the output hash.
     *   Only values permitted are: 224, 256, 384, 512.
     *   Default: 512
     */
    cfg: Hasher.cfg.extend({
      outputLength: 512
    }),

    _doReset: function () {
      var state = this._state = []
      for (var i = 0; i < 25; i++) {
        state[i] = new X64Word.init();
      }

      this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
    },

    _doProcessBlock: function (M, offset) {
      // Shortcuts
      var state = this._state;
      var nBlockSizeLanes = this.blockSize / 2;

      // Absorb
      for (var i = 0; i < nBlockSizeLanes; i++) {
        // Shortcuts
        var M2i  = M[offset + 2 * i];
        var M2i1 = M[offset + 2 * i + 1];

        // Swap endian
        M2i = (
            (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
                (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
            );
        M2i1 = (
            (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
                (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
            );

        // Absorb message into state
        var lane = state[i];
        lane.high ^= M2i1;
        lane.low  ^= M2i;
      }

      // Rounds
      for (var round = 0; round < 24; round++) {
        // Theta
        for (var x = 0; x < 5; x++) {
          // Mix column lanes
          var tMsw = 0, tLsw = 0;
          for (var y = 0; y < 5; y++) {
            var lane = state[x + 5 * y];
            tMsw ^= lane.high;
            tLsw ^= lane.low;
          }

          // Temporary values
          var Tx = T[x];
          Tx.high = tMsw;
          Tx.low  = tLsw;
        }
        for (var x = 0; x < 5; x++) {
          // Shortcuts
          var Tx4 = T[(x + 4) % 5];
          var Tx1 = T[(x + 1) % 5];
          var Tx1Msw = Tx1.high;
          var Tx1Lsw = Tx1.low;

          // Mix surrounding columns
          var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
          var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
          for (var y = 0; y < 5; y++) {
            var lane = state[x + 5 * y];
            lane.high ^= tMsw;
            lane.low  ^= tLsw;
          }
        }

        // Rho Pi
        for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
          // Shortcuts
          var lane = state[laneIndex];
          var laneMsw = lane.high;
          var laneLsw = lane.low;
          var rhoOffset = RHO_OFFSETS[laneIndex];

          // Rotate lanes
          if (rhoOffset < 32) {
            var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
            var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
          } else /* if (rhoOffset >= 32) */ {
            var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
            var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
          }

          // Transpose lanes
          var TPiLane = T[PI_INDEXES[laneIndex]];
          TPiLane.high = tMsw;
          TPiLane.low  = tLsw;
        }

        // Rho pi at x = y = 0
        var T0 = T[0];
        var state0 = state[0];
        T0.high = state0.high;
        T0.low  = state0.low;

        // Chi
        for (var x = 0; x < 5; x++) {
          for (var y = 0; y < 5; y++) {
            // Shortcuts
            var laneIndex = x + 5 * y;
            var lane = state[laneIndex];
            var TLane = T[laneIndex];
            var Tx1Lane = T[((x + 1) % 5) + 5 * y];
            var Tx2Lane = T[((x + 2) % 5) + 5 * y];

            // Mix rows
            lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
            lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
          }
        }

        // Iota
        var lane = state[0];
        var roundConstant = ROUND_CONSTANTS[round];
        lane.high ^= roundConstant.high;
        lane.low  ^= roundConstant.low;;
      }
    },

    _doFinalize: function () {
      // Shortcuts
      var data = this._data;
      var dataWords = data.words;
      var nBitsTotal = this._nDataBytes * 8;
      var nBitsLeft = data.sigBytes * 8;
      var blockSizeBits = this.blockSize * 32;

      // Add padding
      dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
      dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
      data.sigBytes = dataWords.length * 4;

      // Hash final blocks
      this._process();

      // Shortcuts
      var state = this._state;
      var outputLengthBytes = this.cfg.outputLength / 8;
      var outputLengthLanes = outputLengthBytes / 8;

      // Squeeze
      var hashWords = [];
      for (var i = 0; i < outputLengthLanes; i++) {
        // Shortcuts
        var lane = state[i];
        var laneMsw = lane.high;
        var laneLsw = lane.low;

        // Swap endian
        laneMsw = (
            (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
                (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
            );
        laneLsw = (
            (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
                (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
            );

        // Squeeze state to retrieve hash
        hashWords.push(laneLsw);
        hashWords.push(laneMsw);
      }

      // Return final computed hash
      return new WordArray.init(hashWords, outputLengthBytes);
    },

    clone: function () {
      var clone = Hasher.clone.call(this);

      var state = clone._state = this._state.slice(0);
      for (var i = 0; i < 25; i++) {
        state[i] = state[i].clone();
      }

      return clone;
    }
  });

  /**
   * Shortcut function to the hasher's object interface.
   *
   * @param {WordArray|string} message The message to hash.
   *
   * @return {WordArray} The hash.
   *
   * @static
   *
   * @example
   *
   *     var hash = CryptoJS.SHA3('message');
   *     var hash = CryptoJS.SHA3(wordArray);
   */
  C.SHA3 = Hasher._createHelper(SHA3);

  /**
   * Shortcut function to the HMAC's object interface.
   *
   * @param {WordArray|string} message The message to hash.
   * @param {WordArray|string} key The secret key.
   *
   * @return {WordArray} The HMAC.
   *
   * @static
   *
   * @example
   *
   *     var hmac = CryptoJS.HmacSHA3(message, key);
   */
  C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
}(Math));

; browserify_shim__define__module__export__(typeof CryptoJS != "undefined" ? CryptoJS : window.CryptoJS);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(require,module,exports){
(function (global){
;__browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
/**
 * Lawnchair!
 * ---
 * clientside json store
 *
 */
var Lawnchair = function (options, callback) {
  // ensure Lawnchair was called as a constructor
  if (!(this instanceof Lawnchair)) return new Lawnchair(options, callback);

  // lawnchair requires json
  if (!JSON) throw 'JSON unavailable! Include http://www.json.org/json2.js to fix.'
  // options are optional; callback is not
  if (arguments.length <= 2 && arguments.length > 0) {
    callback = (typeof arguments[0] === 'function') ? arguments[0] : arguments[1];
    options  = (typeof arguments[0] === 'function') ? {} : arguments[0];
  } else {
    throw 'Incorrect # of ctor args!'
  }
  // TODO perhaps allow for pub/sub instead?
  if (typeof callback !== 'function') throw 'No callback was provided';

  // default configuration
  this.record = options.record || 'record'  // default for records
  this.name   = options.name   || 'records' // default name for underlying store

  // mixin first valid  adapter
  var adapter
  // if the adapter is passed in we try to load that only
  if (options.adapter) {

    // the argument passed should be an array of prefered adapters
    // if it is not, we convert it
    if(typeof(options.adapter) === 'string'){
      options.adapter = [options.adapter];
    }

    // iterates over the array of passed adapters
    for(var j = 0, k = options.adapter.length; j < k; j++){

      // itirates over the array of available adapters
      for (var i = Lawnchair.adapters.length-1; i >= 0; i--) {
        if (Lawnchair.adapters[i].adapter === options.adapter[j]) {
          adapter = Lawnchair.adapters[i].valid() ? Lawnchair.adapters[i] : undefined;
          if (adapter) break
        }
      }
      if (adapter) break
    }

    // otherwise find the first valid adapter for this env
  }
  else {
    for (var i = 0, l = Lawnchair.adapters.length; i < l; i++) {
      adapter = Lawnchair.adapters[i].valid() ? Lawnchair.adapters[i] : undefined
      if (adapter) break
    }
  }

  // we have failed
  if (!adapter) throw 'No valid adapter.'

  // yay! mixin the adapter
  for (var j in adapter)
    this[j] = adapter[j]

  // call init for each mixed in plugin
  for (var i = 0, l = Lawnchair.plugins.length; i < l; i++)
    Lawnchair.plugins[i].call(this)

  // init the adapter
  this.init(options, callback)
}

Lawnchair.adapters = []

/**
 * queues an adapter for mixin
 * ===
 * - ensures an adapter conforms to a specific interface
 *
 */
Lawnchair.adapter = function (id, obj) {
  // add the adapter id to the adapter obj
  // ugly here for a  cleaner dsl for implementing adapters
  obj['adapter'] = id
  // methods required to implement a lawnchair adapter
  var implementing = 'adapter valid init keys save batch get exists all remove nuke'.split(' ')
    ,   indexOf = this.prototype.indexOf
  // mix in the adapter
  for (var i in obj) {
    if (indexOf(implementing, i) === -1) throw 'Invalid adapter! Nonstandard method: ' + i
  }
  // if we made it this far the adapter interface is valid
  // insert the new adapter as the preferred adapter
  Lawnchair.adapters.splice(0,0,obj)
}

Lawnchair.plugins = []

/**
 * generic shallow extension for plugins
 * ===
 * - if an init method is found it registers it to be called when the lawnchair is inited
 * - yes we could use hasOwnProp but nobody here is an asshole
 */
Lawnchair.plugin = function (obj) {
  for (var i in obj)
    i === 'init' ? Lawnchair.plugins.push(obj[i]) : this.prototype[i] = obj[i]
}

/**
 * helpers
 *
 */
Lawnchair.prototype = {

  isArray: Array.isArray || function(o) { return Object.prototype.toString.call(o) === '[object Array]' },

  /**
   * this code exists for ie8... for more background see:
   * http://www.flickr.com/photos/westcoastlogic/5955365742/in/photostream
   */
  indexOf: function(ary, item, i, l) {
    if (ary.indexOf) return ary.indexOf(item)
    for (i = 0, l = ary.length; i < l; i++) if (ary[i] === item) return i
    return -1
  },

  // awesome shorthand callbacks as strings. this is shameless theft from dojo.
  lambda: function (callback) {
    return this.fn(this.record, callback)
  },

  // first stab at named parameters for terse callbacks; dojo: first != best // ;D
  fn: function (name, callback) {
    return typeof callback == 'string' ? new Function(name, callback) : callback
  },

  // returns a unique identifier (by way of Backbone.localStorage.js)
  // TODO investigate smaller UUIDs to cut on storage cost
  uuid: function () {
    var S4 = function () {
      return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
    }
    return (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4());
  },

  // a classic iterator
  each: function (callback) {
    var cb = this.lambda(callback)
    // iterate from chain
    if (this.__results) {
      for (var i = 0, l = this.__results.length; i < l; i++) cb.call(this, this.__results[i], i)
    }
    // otherwise iterate the entire collection
    else {
      this.all(function(r) {
        for (var i = 0, l = r.length; i < l; i++) cb.call(this, r[i], i)
      })
    }
    return this
  }
// --
};
// window.name code courtesy Remy Sharp: http://24ways.org/2009/breaking-out-the-edges-of-the-browser
Lawnchair.adapter('window-name', (function() {
  if (typeof window==='undefined') {
    window = { top: { } }; // node/optimizer compatibility
  }

  // edited from the original here by elsigh
  // Some sites store JSON data in window.top.name, but some folks (twitter on iPad)
  // put simple strings in there - we should make sure not to cause a SyntaxError.
  var data = {}
  try {
    data = JSON.parse(window.top.name)
  } catch (e) {}


  return {

    valid: function () {
      return typeof window.top.name != 'undefined'
    },

    init: function (options, callback) {
      data[this.name] = data[this.name] || {index:[],store:{}}
      this.index = data[this.name].index
      this.store = data[this.name].store
      this.fn(this.name, callback).call(this, this)
      return this
    },

    keys: function (callback) {
      this.fn('keys', callback).call(this, this.index)
      return this
    },

    save: function (obj, cb) {
      // data[key] = value + ''; // force to string
      // window.top.name = JSON.stringify(data);
      var key = obj.key || this.uuid()
      this.exists(key, function(exists) {
        if (!exists) {
          if (obj.key) delete obj.key
          this.index.push(key)
        }
        this.store[key] = obj

        try {
          window.top.name = JSON.stringify(data) // TODO wow, this is the only diff from the memory adapter
        } catch(e) {
          // restore index/store to previous value before JSON exception
          if (!exists) {
            this.index.pop();
            delete this.store[key];
          }
          throw e;
        }

        if (cb) {
          obj.key = key
          this.lambda(cb).call(this, obj)
        }
      })
      return this
    },

    batch: function (objs, cb) {
      var r = []
      for (var i = 0, l = objs.length; i < l; i++) {
        this.save(objs[i], function(record) {
          r.push(record)
        })
      }
      if (cb) this.lambda(cb).call(this, r)
      return this
    },

    get: function (keyOrArray, cb) {
      var r;
      if (this.isArray(keyOrArray)) {
        r = []
        for (var i = 0, l = keyOrArray.length; i < l; i++) {
          r.push(this.store[keyOrArray[i]])
        }
      } else {
        r = this.store[keyOrArray]
        if (r) r.key = keyOrArray
      }
      if (cb) this.lambda(cb).call(this, r)
      return this
    },

    exists: function (key, cb) {
      this.lambda(cb).call(this, !!(this.store[key]))
      return this
    },

    all: function (cb) {
      var r = []
      for (var i = 0, l = this.index.length; i < l; i++) {
        var obj = this.store[this.index[i]]
        obj.key = this.index[i]
        r.push(obj)
      }
      this.fn(this.name, cb).call(this, r)
      return this
    },

    remove: function (keyOrArray, cb) {
      var del = this.isArray(keyOrArray) ? keyOrArray : [keyOrArray]
      for (var i = 0, l = del.length; i < l; i++) {
        var key = del[i].key ? del[i].key : del[i]
        var where = this.indexOf(this.index, key)
        if (where < 0) continue /* key not present */
        delete this.store[key]
        this.index.splice(where, 1)
      }
      window.top.name = JSON.stringify(data)
      if (cb) this.lambda(cb).call(this)
      return this
    },

    nuke: function (cb) {
      this.store = data[this.name].store = {}
      this.index = data[this.name].index = []
      window.top.name = JSON.stringify(data)
      if (cb) this.lambda(cb).call(this)
      return this
    }
  }
/////
})())
/**
 * dom storage adapter
 * ===
 * - originally authored by Joseph Pecoraro
 *
 */
//
// TODO does it make sense to be chainable all over the place?
// chainable: nuke, remove, all, get, save, all    
// not chainable: valid, keys
//
Lawnchair.adapter('dom', (function() {
  var storage = window.localStorage
  // the indexer is an encapsulation of the helpers needed to keep an ordered index of the keys
  var indexer = function(name) {
    return {
      // the key
      key: name + '._index_',
      // returns the index
      all: function() {
        var a  = storage.getItem(this.key)
        if (a) {
          a = JSON.parse(a)
        }
        if (a === null) storage.setItem(this.key, JSON.stringify([])) // lazy init
        return JSON.parse(storage.getItem(this.key))
      },
      // adds a key to the index
      add: function (key) {
        var a = this.all()
        a.push(key)
        storage.setItem(this.key, JSON.stringify(a))
      },
      // deletes a key from the index
      del: function (key) {
        var a = this.all(), r = []
        // FIXME this is crazy inefficient but I'm in a strata meeting and half concentrating
        for (var i = 0, l = a.length; i < l; i++) {
          if (a[i] != key) r.push(a[i])
        }
        storage.setItem(this.key, JSON.stringify(r))
      },
      // returns index for a key
      find: function (key) {
        var a = this.all()
        for (var i = 0, l = a.length; i < l; i++) {
          if (key === a[i]) return i
        }
        return false
      }
    }
  }

  // adapter api
  return {

    // ensure we are in an env with localStorage
    valid: function () {
      return !!storage && function() {
        // in mobile safari if safe browsing is enabled, window.storage
        // is defined but setItem calls throw exceptions.
        var success = true
        var value = Math.random()
        try {
          storage.setItem(value, value)
        } catch (e) {
          success = false
        }
        storage.removeItem(value)
        return success
      }()
    },

    init: function (options, callback) {
      this.indexer = indexer(this.name)
      if (callback) this.fn(this.name, callback).call(this, this)
    },

    save: function (obj, callback) {
      var key = obj.key ? this.name + '.' + obj.key : this.name + '.' + this.uuid()
      // now we kil the key and use it in the store colleciton
      delete obj.key;
      storage.setItem(key, JSON.stringify(obj))
      // if the key is not in the index push it on
      if (this.indexer.find(key) === false) this.indexer.add(key)
      obj.key = key.slice(this.name.length + 1)
      if (callback) {
        this.lambda(callback).call(this, obj)
      }
      return this
    },

    batch: function (ary, callback) {
      var saved = []
      // not particularily efficient but this is more for sqlite situations
      for (var i = 0, l = ary.length; i < l; i++) {
        this.save(ary[i], function(r){
          saved.push(r)
        })
      }
      if (callback) this.lambda(callback).call(this, saved)
      return this
    },

    // accepts [options], callback
    keys: function(callback) {
      if (callback) {
        var name = this.name
        var indices = this.indexer.all();
        var keys = [];
        //Checking for the support of map.
        if(Array.prototype.map) {
          keys = indices.map(function(r){ return r.replace(name + '.', '') })
        } else {
          for (var key in indices) {
            keys.push(key.replace(name + '.', ''));
          }
        }
        this.fn('keys', callback).call(this, keys)
      }
      return this // TODO options for limit/offset, return promise
    },

    get: function (key, callback) {
      if (this.isArray(key)) {
        var r = []
        for (var i = 0, l = key.length; i < l; i++) {
          var k = this.name + '.' + key[i]
          var obj = storage.getItem(k)
          if (obj) {
            obj = JSON.parse(obj)
            obj.key = key[i]
          }
          r.push(obj)
        }
        if (callback) this.lambda(callback).call(this, r)
      } else {
        var k = this.name + '.' + key
        var  obj = storage.getItem(k)
        if (obj) {
          obj = JSON.parse(obj)
          obj.key = key
        }
        if (callback) this.lambda(callback).call(this, obj)
      }
      return this
    },

    exists: function (key, cb) {
      var exists = this.indexer.find(this.name+'.'+key) === false ? false : true ;
      this.lambda(cb).call(this, exists);
      return this;
    },
    // NOTE adapters cannot set this.__results but plugins do
    // this probably should be reviewed
    all: function (callback) {
      var idx = this.indexer.all()
        ,   r   = []
        ,   o
        ,   k
      for (var i = 0, l = idx.length; i < l; i++) {
        k     = idx[i] //v
        o     = JSON.parse(storage.getItem(k))
        o.key = k.replace(this.name + '.', '')
        r.push(o)
      }
      if (callback) this.fn(this.name, callback).call(this, r)
      return this
    },

    remove: function (keyOrArray, callback) {
      var self = this;
      if (this.isArray(keyOrArray)) {
        // batch remove
        var i, done = keyOrArray.length;
        var removeOne = function(i) {
          self.remove(keyOrArray[i], function() {
            if ((--done) > 0) { return; }
            if (callback) {
              self.lambda(callback).call(self);
            }
          });
        };
        for (i=0; i < keyOrArray.length; i++)
          removeOne(i);
        return this;
      }
      var key = this.name + '.' +
        ((keyOrArray.key) ? keyOrArray.key : keyOrArray)
      this.indexer.del(key)
      storage.removeItem(key)
      if (callback) this.lambda(callback).call(this)
      return this
    },

    nuke: function (callback) {
      this.all(function(r) {
        for (var i = 0, l = r.length; i < l; i++) {
          this.remove(r[i]);
        }
        if (callback) this.lambda(callback).call(this)
      })
      return this
    }
  }})());
Lawnchair.adapter('webkit-sqlite', (function() {
  // private methods
  var fail = function(e, i) {
    if (console) {
      console.log('error in sqlite adaptor!', e, i)
    }
  }, now = function() {
      return new Date()
    } // FIXME need to use better date fn
    // not entirely sure if this is needed...

  // public methods
  return {

    valid: function() {
      return !!(window.openDatabase)
    },

    init: function(options, callback) {
      var that = this,
        cb = that.fn(that.name, callback),
        create = "CREATE TABLE IF NOT EXISTS " + this.record + " (id NVARCHAR(32) UNIQUE PRIMARY KEY, value TEXT, timestamp REAL)",
        win = function() {
          return cb.call(that, that);
        }
        // open a connection and create the db if it doesn't exist
        //FEEDHENRY CHANGE TO ALLOW ERROR CALLBACK
      if (options && 'function' === typeof options.fail) fail = options.fail
        //END CHANGE
      this.db = openDatabase(this.name, '1.0.0', this.name, 65536)
      this.db.transaction(function(t) {
        t.executeSql(create, [], win, fail)
      })
    },

    keys: function(callback) {
      var cb = this.lambda(callback),
        that = this,
        keys = "SELECT id FROM " + this.record + " ORDER BY timestamp DESC"

      this.db.readTransaction(function(t) {
        var win = function(xxx, results) {
          if (results.rows.length == 0) {
            cb.call(that, [])
          } else {
            var r = [];
            for (var i = 0, l = results.rows.length; i < l; i++) {
              r.push(results.rows.item(i).id);
            }
            cb.call(that, r)
          }
        }
        t.executeSql(keys, [], win, fail)
      })
      return this
    },
    // you think thats air you're breathing now?
    save: function(obj, callback, error) {
      var that = this
      objs = (this.isArray(obj) ? obj : [obj]).map(function(o) {
        if (!o.key) {
          o.key = that.uuid()
        }
        return o
      }),
        ins = "INSERT OR REPLACE INTO " + this.record + " (value, timestamp, id) VALUES (?,?,?)",
        win = function() {
          if (callback) {
            that.lambda(callback).call(that, that.isArray(obj) ? objs : objs[0])
          }
        }, error = error || function() {}, insvals = [],
        ts = now()

        try {
          for (var i = 0, l = objs.length; i < l; i++) {
            insvals[i] = [JSON.stringify(objs[i]), ts, objs[i].key];
          }
        } catch (e) {
          fail(e)
          throw e;
        }

      that.db.transaction(function(t) {
        for (var i = 0, l = objs.length; i < l; i++)
          t.executeSql(ins, insvals[i])
      }, function(e, i) {
        fail(e, i)
      }, win)

      return this
    },


    batch: function(objs, callback) {
      return this.save(objs, callback)
    },

    get: function(keyOrArray, cb) {
      var that = this,
        sql = '',
        args = this.isArray(keyOrArray) ? keyOrArray : [keyOrArray];
      // batch selects support
      sql = 'SELECT id, value FROM ' + this.record + " WHERE id IN (" +
        args.map(function() {
        return '?'
      }).join(",") + ")"
      // FIXME
      // will always loop the results but cleans it up if not a batch return at the end..
      // in other words, this could be faster
      var win = function(xxx, results) {
        var o, r, lookup = {}
          // map from results to keys
        for (var i = 0, l = results.rows.length; i < l; i++) {
          o = JSON.parse(results.rows.item(i).value)
          o.key = results.rows.item(i).id
          lookup[o.key] = o;
        }
        r = args.map(function(key) {
          return lookup[key];
        });
        if (!that.isArray(keyOrArray)) r = r.length ? r[0] : null
        if (cb) that.lambda(cb).call(that, r)
      }
      this.db.readTransaction(function(t) {
        t.executeSql(sql, args, win, fail)
      })
      return this
    },

    exists: function(key, cb) {
      var is = "SELECT * FROM " + this.record + " WHERE id = ?",
        that = this,
        win = function(xxx, results) {
          if (cb) that.fn('exists', cb).call(that, (results.rows.length > 0))
        }
      this.db.readTransaction(function(t) {
        t.executeSql(is, [key], win, fail)
      })
      return this
    },

    all: function(callback) {
      var that = this,
        all = "SELECT * FROM " + this.record,
        r = [],
        cb = this.fn(this.name, callback) || undefined,
        win = function(xxx, results) {
          if (results.rows.length != 0) {
            for (var i = 0, l = results.rows.length; i < l; i++) {
              var obj = JSON.parse(results.rows.item(i).value)
              obj.key = results.rows.item(i).id
              r.push(obj)
            }
          }
          if (cb) cb.call(that, r)
        }

      this.db.readTransaction(function(t) {
        t.executeSql(all, [], win, fail)
      })
      return this
    },

    remove: function(keyOrArray, cb) {
      var that = this,
        args, sql = "DELETE FROM " + this.record + " WHERE id ",
        win = function() {
          if (cb) that.lambda(cb).call(that)
        }
      if (!this.isArray(keyOrArray)) {
        sql += '= ?';
        args = [keyOrArray];
      } else {
        args = keyOrArray;
        sql += "IN (" +
          args.map(function() {
          return '?'
        }).join(',') +
          ")";
      }
      args = args.map(function(obj) {
        return obj.key ? obj.key : obj;
      });

      this.db.transaction(function(t) {
        t.executeSql(sql, args, win, fail);
      });

      return this;
    },

    nuke: function(cb) {
      var nuke = "DELETE FROM " + this.record,
        that = this,
        win = cb ? function() {
        that.lambda(cb).call(that)
      } : function() {}
      this.db.transaction(function(t) {
        t.executeSql(nuke, [], win, fail)
      })
      return this
    }
  }
})());
Lawnchair.adapter('html5-filesystem', (function(global){

  var FileError = global.FileError;

  var fail = function( e ) {
    var msg;
    var show = true;
    switch (e.code) {
      case FileError.QUOTA_EXCEEDED_ERR:
        msg = 'QUOTA_EXCEEDED_ERR';
        break;
      case FileError.NOT_FOUND_ERR:
        msg = 'NOT_FOUND_ERR';
        show = false;
        break;
      case FileError.SECURITY_ERR:
        msg = 'SECURITY_ERR';
        break;
      case FileError.INVALID_MODIFICATION_ERR:
        msg = 'INVALID_MODIFICATION_ERR';
        break;
      case FileError.INVALID_STATE_ERR:
        msg = 'INVALID_STATE_ERR';
        break;
      default:
        msg = 'Unknown Error';
        break;
    };
    if ( console && show ) console.error( e, msg );
  };

  var ls = function( reader, callback, entries ) {
    var result = entries || [];
    reader.readEntries(function( results ) {
      if ( !results.length ) {
        if ( callback ) callback( result.map(function(entry) { return entry.name; }) );
      } else {
        ls( reader, callback, result.concat( Array.prototype.slice.call( results ) ) );
      }
    }, fail );
  };

  var filesystems = {};

  var root = function( store, callback ) {
    var directory = filesystems[store.name];
    if ( directory ) {
      callback( directory );
    } else {
      setTimeout(function() {
        root( store, callback );
      }, 10 );
    }
  };

  var isPhoneGap = function() {
    //http://stackoverflow.com/questions/10347539/detect-between-a-mobile-browser-or-a-phonegap-application
    //may break.
    var app = document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1;
    if (app) {
      return true;
    } else {
      return false;
    }
  }

  var createBlobOrString = function(contentstr) {
    var retVal;
    if (isPhoneGap()) {  // phonegap filewriter works with strings, later versions also work with binary arrays, and if passed a blob will just convert to binary array anyway
      retVal = contentstr;
    } else {
      var targetContentType = 'application/json';
      try {
        retVal = new Blob( [contentstr], { type: targetContentType });  // Blob doesn't exist on all androids
      }
      catch (e){
        // TypeError old chrome and FF
        var blobBuilder = window.BlobBuilder ||
          window.WebKitBlobBuilder ||
          window.MozBlobBuilder ||
          window.MSBlobBuilder;
        if (e.name == 'TypeError' && blobBuilder) {
          var bb = new blobBuilder();
          bb.append([contentstr.buffer]);
          retVal = bb.getBlob(targetContentType);
        } else {
          // We can't make a Blob, so just return the stringified content
          retVal = contentstr;
        }
      }
    }
    return retVal;
  }

  return {
    // boolean; true if the adapter is valid for the current environment
    valid: function() {
      var fs = global.requestFileSystem || global.webkitRequestFileSystem || global.moz_requestFileSystem;
      return !!fs;
    },

    // constructor call and callback. 'name' is the most common option
    init: function( options, callback ) {
      var me = this;
      var error = function(e) { fail(e); if ( callback ) me.fn( me.name, callback ).call( me, me ); };
      var size = options.size || 100*1024*1024;
      var name = this.name;

      function requestFileSystem(amount) {
//        console.log('in requestFileSystem');
        var fs = global.requestFileSystem || global.webkitRequestFileSystem || global.moz_requestFileSystem;
        var mode = window.PERSISTENT;
        if(typeof LocalFileSystem !== "undefined" && typeof LocalFileSystem.PERSISTENT !== "undefined"){
          mode = LocalFileSystem.PERSISTENT;
        }      
        fs(mode, amount, function(fs) {
//          console.log('got FS ', fs);
          fs.root.getDirectory( name, {create:true}, function( directory ) {
//            console.log('got DIR ', directory);
            filesystems[name] = directory;
            if ( callback ) me.fn( me.name, callback ).call( me, me );
          }, function( e ) {
//            console.log('error getting dir :: ', e);
            error(e);
          });
        }, function( e ) {
//          console.log('error getting FS :: ', e);
          error(e);
        });
      };

      // When in the browser we need to use the html5 file system rather than
      // the one cordova supplies, but it needs to request a quota first.
      if (typeof navigator.webkitPersistentStorage !== 'undefined') {
        navigator.webkitPersistentStorage.requestQuota(size, requestFileSystem, function() {
          logger.warn('User declined file storage');
          error('User declined file storage');
        });
      } else {
        // Amount is 0 because we pretty much have free reign over the
        // amount of storage we use on an android device.
        requestFileSystem(0);
      }
    },

    // returns all the keys in the store
    keys: function( callback ) {
      var me = this;
      root( this, function( store ) {
        ls( store.createReader(), function( entries ) {
          if ( callback ) me.fn( 'keys', callback ).call( me, entries );
        });
      });
      return this;
    },

    // save an object
    save: function( obj, callback ) {
      var me = this;
      var key = obj.key || this.uuid();
      obj.key = key;
      var error = function(e) { fail(e); if ( callback ) me.lambda( callback ).call( me ); };
      root( this, function( store ) {
        store.getFile( key, {create:true}, function( file ) {
          file.createWriter(function( writer ) {
            writer.onerror = error;
            writer.onwriteend = function() {
              // Clear the onWriteEnd handler so the truncate does not call it and cause an infinite loop
              this.onwriteend = null;
              // Truncate the file at the end of the written contents. This ensures that if we are updating 
              // a file which was previously longer, we will not be left with old contents beyond the end of 
              // the current buffer.
              this.truncate(this.position);
              if ( callback ) me.lambda( callback ).call( me, obj );
            };
            var contentStr = JSON.stringify(obj);

            var writerContent = createBlobOrString(contentStr);
            writer.write(writerContent);
          }, error );
        }, error );
      });
      return this;
    },

    // batch save array of objs
    batch: function( objs, callback ) {
      var me = this;
      var saved = [];
      for ( var i = 0, il = objs.length; i < il; i++ ) {
        me.save( objs[i], function( obj ) {
          saved.push( obj );
          if ( saved.length === il && callback ) {
            me.lambda( callback ).call( me, saved );
          }
        });
      }
      return this;
    },

    // retrieve obj (or array of objs) and apply callback to each
    get: function( key /* or array */, callback ) {
      var me = this;
      if ( this.isArray( key ) ) {
        var values = [];
        for ( var i = 0, il = key.length; i < il; i++ ) {
          me.get( key[i], function( result ) {
            if ( result ) values.push( result );
            if ( values.length === il && callback ) {
              me.lambda( callback ).call( me, values );
            }
          });
        }
      } else {
        var error = function(e) {
          fail( e );
          if ( callback ) {
            me.lambda( callback ).call( me );
          }
        };
        root( this, function( store ) {
          store.getFile( key, {create:false}, function( entry ) {
            entry.file(function( file ) {
              var reader = new FileReader();

              reader.onerror = error;

              reader.onload = function(e) {
                var res = {};
                try {
                  res = JSON.parse( e.target.result);
                  res.key = key;
                } catch (e) {
                  res = {key:key};
                }
                if ( callback ) me.lambda( callback ).call( me, res );
              };

              reader.readAsText( file );
            }, error );
          }, error );
        });
      }
      return this;
    },

    // check if an obj exists in the collection
    exists: function( key, callback ) {
      var me = this;
      root( this, function( store ) {
        store.getFile( key, {create:false}, function() {
          if ( callback ) me.lambda( callback ).call( me, true );
        }, function() {
          if ( callback ) me.lambda( callback ).call( me, false );
        });
      });
      return this;
    },

    // returns all the objs to the callback as an array
    all: function( callback ) {
      var me = this;
      if ( callback ) {
        this.keys(function( keys ) {
          if ( !keys.length ) {
            me.fn( me.name, callback ).call( me, [] );
          } else {
            me.get( keys, function( values ) {
              me.fn( me.name, callback ).call( me, values );
            });
          }
        });
      }
      return this;
    },

    // remove a doc or collection of em
    remove: function( key /* or object */, callback ) {
      var me = this;
      var error = function(e) { fail( e ); if ( callback ) me.lambda( callback ).call( me ); };
      root( this, function( store ) {
        store.getFile( (typeof key === 'string' ? key : key.key ), {create:false}, function( file ) {
          file.remove(function() {
            if ( callback ) me.lambda( callback ).call( me );
          }, error );
        }, error );
      });
      return this;
    },

    // destroy everything
    nuke: function( callback ) {
      var me = this;
      var count = 0;
      this.keys(function( keys ) {
        if ( !keys.length ) {
          if ( callback ) me.lambda( callback ).call( me );
        } else {
          for ( var i = 0, il = keys.length; i < il; i++ ) {
            me.remove( keys[i], function() {
              count++;
              if ( count === il && callback ) {
                me.lambda( callback ).call( me );
              }
            });
          }
        }
      });
      return this;
    }
  };
}(this)));
Lawnchair.adapter('memory', (function(){

    var data = {}

    return {
        valid: function() { return true },

        init: function (options, callback) {
            data[this.name] = data[this.name] || {index:[],store:{}}
            this.index = data[this.name].index
            this.store = data[this.name].store
            var cb = this.fn(this.name, callback)
            if (cb) cb.call(this, this)
            return this
        },

        keys: function (callback) {
            this.fn('keys', callback).call(this, this.index)
            return this
        },

        save: function(obj, cb) {
            var key = obj.key || this.uuid()
            
            this.exists(key, function(exists) {
                if (!exists) {
                    if (obj.key) delete obj.key
                    this.index.push(key)
                }

                this.store[key] = obj
                
                if (cb) {
                    obj.key = key
                    this.lambda(cb).call(this, obj)
                }
            })

            return this
        },

        batch: function (objs, cb) {
            var r = []
            for (var i = 0, l = objs.length; i < l; i++) {
                this.save(objs[i], function(record) {
                    r.push(record)
                })
            }
            if (cb) this.lambda(cb).call(this, r)
            return this
        },

        get: function (keyOrArray, cb) {
            var r;
            if (this.isArray(keyOrArray)) {
                r = []
                for (var i = 0, l = keyOrArray.length; i < l; i++) {
                    r.push(this.store[keyOrArray[i]])
                }
            } else {
                r = this.store[keyOrArray]
                if (r) r.key = keyOrArray
            }
            if (cb) this.lambda(cb).call(this, r)
            return this 
        },

        exists: function (key, cb) {
            this.lambda(cb).call(this, !!(this.store[key]))
            return this
        },

        all: function (cb) {
            var r = []
            for (var i = 0, l = this.index.length; i < l; i++) {
                var obj = this.store[this.index[i]]
                obj.key = this.index[i]
                r.push(obj)
            }
            this.fn(this.name, cb).call(this, r)
            return this
        },

        remove: function (keyOrArray, cb) {
            var del = this.isArray(keyOrArray) ? keyOrArray : [keyOrArray]
            for (var i = 0, l = del.length; i < l; i++) {
                var key = del[i].key ? del[i].key : del[i]
                var where = this.indexOf(this.index, key)
                if (where < 0) continue /* key not present */
                delete this.store[key]
                this.index.splice(where, 1)
            }
            if (cb) this.lambda(cb).call(this)
            return this
        },

        nuke: function (cb) {
            this.store = data[this.name].store = {}
            this.index = data[this.name].index = []
            if (cb) this.lambda(cb).call(this)
            return this
        }
    }
/////
})());
; browserify_shim__define__module__export__(typeof Lawnchair != "undefined" ? Lawnchair : window.Lawnchair);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
(function (global){
;__browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
/*
 json2.js
 2011-10-19

 Public Domain.

 NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

 See http://www.JSON.org/js.html


 This code should be minified before deployment.
 See http://javascript.crockford.com/jsmin.html

 USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
 NOT CONTROL.


 This file creates a global JSON object containing two methods: stringify
 and parse.

 JSON.stringify(value, replacer, space)
 value       any JavaScript value, usually an object or array.

 replacer    an optional parameter that determines how object
 values are stringified for objects. It can be a
 function or an array of strings.

 space       an optional parameter that specifies the indentation
 of nested structures. If it is omitted, the text will
 be packed without extra whitespace. If it is a number,
 it will specify the number of spaces to indent at each
 level. If it is a string (such as '\t' or '&nbsp;'),
 it contains the characters used to indent at each level.

 This method produces a JSON text from a JavaScript value.

 When an object value is found, if the object contains a toJSON
 method, its toJSON method will be called and the result will be
 stringified. A toJSON method does not serialize: it returns the
 value represented by the name/value pair that should be serialized,
 or undefined if nothing should be serialized. The toJSON method
 will be passed the key associated with the value, and this will be
 bound to the value

 For example, this would serialize Dates as ISO strings.

 Date.prototype.toJSON = function (key) {
 function f(n) {
 // Format integers to have at least two digits.
 return n < 10 ? '0' + n : n;
 }

 return this.getUTCFullYear()   + '-' +
 f(this.getUTCMonth() + 1) + '-' +
 f(this.getUTCDate())      + 'T' +
 f(this.getUTCHours())     + ':' +
 f(this.getUTCMinutes())   + ':' +
 f(this.getUTCSeconds())   + 'Z';
 };

 You can provide an optional replacer method. It will be passed the
 key and value of each member, with this bound to the containing
 object. The value that is returned from your method will be
 serialized. If your method returns undefined, then the member will
 be excluded from the serialization.

 If the replacer parameter is an array of strings, then it will be
 used to select the members to be serialized. It filters the results
 such that only members with keys listed in the replacer array are
 stringified.

 Values that do not have JSON representations, such as undefined or
 functions, will not be serialized. Such values in objects will be
 dropped; in arrays they will be replaced with null. You can use
 a replacer function to replace those with JSON values.
 JSON.stringify(undefined) returns undefined.

 The optional space parameter produces a stringification of the
 value that is filled with line breaks and indentation to make it
 easier to read.

 If the space parameter is a non-empty string, then that string will
 be used for indentation. If the space parameter is a number, then
 the indentation will be that many spaces.

 Example:

 text = JSON.stringify(['e', {pluribus: 'unum'}]);
 // text is '["e",{"pluribus":"unum"}]'


 text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
 // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

 text = JSON.stringify([new Date()], function (key, value) {
 return this[key] instanceof Date ?
 'Date(' + this[key] + ')' : value;
 });
 // text is '["Date(---current time---)"]'


 JSON.parse(text, reviver)
 This method parses a JSON text to produce an object or array.
 It can throw a SyntaxError exception.

 The optional reviver parameter is a function that can filter and
 transform the results. It receives each of the keys and values,
 and its return value is used instead of the original value.
 If it returns what it received, then the structure is not modified.
 If it returns undefined then the member is deleted.

 Example:

 // Parse the text. Values that look like ISO date strings will
 // be converted to Date objects.

 myData = JSON.parse(text, function (key, value) {
 var a;
 if (typeof value === 'string') {
 a =
 /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
 if (a) {
 return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
 +a[5], +a[6]));
 }
 }
 return value;
 });

 myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
 var d;
 if (typeof value === 'string' &&
 value.slice(0, 5) === 'Date(' &&
 value.slice(-1) === ')') {
 d = new Date(value.slice(5, -1));
 if (d) {
 return d;
 }
 }
 return value;
 });


 This is a reference implementation. You are free to copy, modify, or
 redistribute.
 */

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
 call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
 getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
 lastIndex, length, parse, prototype, push, replace, slice, stringify,
 test, toJSON, toString, valueOf
 */


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
  JSON = {};
}

(function () {
  'use strict';

  function f(n) {
    // Format integers to have at least two digits.
    return n < 10 ? '0' + n : n;
  }

  if (typeof Date.prototype.toJSON !== 'function') {

    Date.prototype.toJSON = function (key) {

      return isFinite(this.valueOf())
        ? this.getUTCFullYear()     + '-' +
        f(this.getUTCMonth() + 1) + '-' +
        f(this.getUTCDate())      + 'T' +
        f(this.getUTCHours())     + ':' +
        f(this.getUTCMinutes())   + ':' +
        f(this.getUTCSeconds())   + 'Z'
        : null;
    };

    String.prototype.toJSON      =
      Number.prototype.toJSON  =
        Boolean.prototype.toJSON = function (key) {
          return this.valueOf();
        };
  }

  var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
      '\b': '\\b',
      '\t': '\\t',
      '\n': '\\n',
      '\f': '\\f',
      '\r': '\\r',
      '"' : '\\"',
      '\\': '\\\\'
    },
    rep;


  function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
      var c = meta[a];
      return typeof c === 'string'
        ? c
        : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
  }


  function str(key, holder) {

// Produce a string from holder[key].

    var i,          // The loop counter.
      k,          // The member key.
      v,          // The member value.
      length,
      mind = gap,
      partial,
      value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

    if (value && typeof value === 'object' &&
      typeof value.toJSON === 'function') {
      value = value.toJSON(key);
    }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

    if (typeof rep === 'function') {
      value = rep.call(holder, key, value);
    }

// What happens next depends on the value's type.

    switch (typeof value) {
      case 'string':
        return quote(value);

      case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

        return isFinite(value) ? String(value) : 'null';

      case 'boolean':
      case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

        return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

      case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

        if (!value) {
          return 'null';
        }

// Make an array to hold the partial results of stringifying this object value.

        gap += indent;
        partial = [];

// Is the value an array?

        if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

          length = value.length;
          for (i = 0; i < length; i += 1) {
            partial[i] = str(i, value) || 'null';
          }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

          v = partial.length === 0
            ? '[]'
            : gap
            ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
            : '[' + partial.join(',') + ']';
          gap = mind;
          return v;
        }

// If the replacer is an array, use it to select the members to be stringified.

        if (rep && typeof rep === 'object') {
          length = rep.length;
          for (i = 0; i < length; i += 1) {
            if (typeof rep[i] === 'string') {
              k = rep[i];
              v = str(k, value);
              if (v) {
                partial.push(quote(k) + (gap ? ': ' : ':') + v);
              }
            }
          }
        } else {

// Otherwise, iterate through all of the keys in the object.

          for (k in value) {
            if (Object.prototype.hasOwnProperty.call(value, k)) {
              v = str(k, value);
              if (v) {
                partial.push(quote(k) + (gap ? ': ' : ':') + v);
              }
            }
          }
        }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

        v = partial.length === 0
          ? '{}'
          : gap
          ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
          : '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
  }

// If the JSON object does not yet have a stringify method, give it one.

  if (typeof JSON.stringify !== 'function') {
    JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

      var i;
      gap = '';
      indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

      if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
          indent += ' ';
        }

// If the space parameter is a string, it will be used as the indent string.

      } else if (typeof space === 'string') {
        indent = space;
      }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

      rep = replacer;
      if (replacer && typeof replacer !== 'function' &&
        (typeof replacer !== 'object' ||
          typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
      }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

      return str('', {'': value});
    };
  }


// If the JSON object does not yet have a parse method, give it one.

  if (typeof JSON.parse !== 'function') {
    JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

      var j;

      function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
          for (k in value) {
            if (Object.prototype.hasOwnProperty.call(value, k)) {
              v = walk(value, k);
              if (v !== undefined) {
                value[k] = v;
              } else {
                delete value[k];
              }
            }
          }
        }
        return reviver.call(holder, key, value);
      }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

      text = String(text);
      cx.lastIndex = 0;
      if (cx.test(text)) {
        text = text.replace(cx, function (a) {
          return '\\u' +
            ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        });
      }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

      if (/^[\],:{}\s]*$/
        .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

        j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

        return typeof reviver === 'function'
          ? walk({'': j}, '')
          : j;
      }

// If the text is not JSON parseable, then a SyntaxError is thrown.

      throw new SyntaxError('JSON.parse');
    };
  }
}());
; browserify_shim__define__module__export__(typeof JSON != "undefined" ? JSON : window.JSON);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],4:[function(require,module,exports){
// Copyright (c) 2005  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.

// Basic JavaScript BN library - subset useful for RSA encryption.

// Bits per digit
var dbits;

// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary&0xffffff)==0xefcafe);

// (public) Constructor
function BigInteger(a,b,c) {
  if(a != null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null && "string" != typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}

// return new, unset BigInteger
function nbi() { return new BigInteger(null); }

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i,x,w,j,c,n) {
  while(--n >= 0) {
    var v = x*this[i++]+w[j]+c;
    c = Math.floor(v/0x4000000);
    w[j++] = v&0x3ffffff;
  }
  return c;
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i,x,w,j,c,n) {
  var xl = x&0x7fff, xh = x>>15;
  while(--n >= 0) {
    var l = this[i]&0x7fff;
    var h = this[i++]>>15;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
    w[j++] = l&0x3fffffff;
  }
  return c;
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i,x,w,j,c,n) {
  var xl = x&0x3fff, xh = x>>14;
  while(--n >= 0) {
    var l = this[i]&0x3fff;
    var h = this[i++]>>14;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x3fff)<<14)+w[j]+c;
    c = (l>>28)+(m>>14)+xh*h;
    w[j++] = l&0xfffffff;
  }
  return c;
}
if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
  BigInteger.prototype.am = am2;
  dbits = 30;
}
else if(j_lm && (navigator.appName != "Netscape")) {
  BigInteger.prototype.am = am1;
  dbits = 26;
}
else { // Mozilla/Netscape seems to prefer am3
  BigInteger.prototype.am = am3;
  dbits = 28;
}

BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1<<dbits)-1);
BigInteger.prototype.DV = (1<<dbits);

var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2,BI_FP);
BigInteger.prototype.F1 = BI_FP-dbits;
BigInteger.prototype.F2 = 2*dbits-BI_FP;

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr,vv;
rr = "0".charCodeAt(0);
for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

function int2char(n) { return BI_RM.charAt(n); }
function intAt(s,i) {
  var c = BI_RC[s.charCodeAt(i)];
  return (c==null)?-1:c;
}

// (protected) copy this to r
function bnpCopyTo(r) {
  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
  r.t = this.t;
  r.s = this.s;
}

// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x) {
  this.t = 1;
  this.s = (x<0)?-1:0;
  if(x > 0) this[0] = x;
  else if(x < -1) this[0] = x+DV;
  else this.t = 0;
}

// return bigint initialized to value
function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

// (protected) set from string and radix
function bnpFromString(s,b) {
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 256) k = 8; // byte array
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else { this.fromRadix(s,b); return; }
  this.t = 0;
  this.s = 0;
  var i = s.length, mi = false, sh = 0;
  while(--i >= 0) {
    var x = (k==8)?s[i]&0xff:intAt(s,i);
    if(x < 0) {
      if(s.charAt(i) == "-") mi = true;
      continue;
    }
    mi = false;
    if(sh == 0)
      this[this.t++] = x;
    else if(sh+k > this.DB) {
      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
      this[this.t++] = (x>>(this.DB-sh));
    }
    else
      this[this.t-1] |= x<<sh;
    sh += k;
    if(sh >= this.DB) sh -= this.DB;
  }
  if(k == 8 && (s[0]&0x80) != 0) {
    this.s = -1;
    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
  }
  this.clamp();
  if(mi) BigInteger.ZERO.subTo(this,this);
}

// (protected) clamp off excess high words
function bnpClamp() {
  var c = this.s&this.DM;
  while(this.t > 0 && this[this.t-1] == c) --this.t;
}

// (public) return string representation in given radix
function bnToString(b) {
  if(this.s < 0) return "-"+this.negate().toString(b);
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else return this.toRadix(b);
  var km = (1<<k)-1, d, m = false, r = "", i = this.t;
  var p = this.DB-(i*this.DB)%k;
  if(i-- > 0) {
    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
    while(i >= 0) {
      if(p < k) {
        d = (this[i]&((1<<p)-1))<<(k-p);
        d |= this[--i]>>(p+=this.DB-k);
      }
      else {
        d = (this[i]>>(p-=k))&km;
        if(p <= 0) { p += this.DB; --i; }
      }
      if(d > 0) m = true;
      if(m) r += int2char(d);
    }
  }
  return m?r:"0";
}

// (public) -this
function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

// (public) |this|
function bnAbs() { return (this.s<0)?this.negate():this; }

// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a) {
  var r = this.s-a.s;
  if(r != 0) return r;
  var i = this.t;
  r = i-a.t;
  if(r != 0) return (this.s<0)?-r:r;
  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
  return 0;
}

// returns bit length of the integer x
function nbits(x) {
  var r = 1, t;
  if((t=x>>>16) != 0) { x = t; r += 16; }
  if((t=x>>8) != 0) { x = t; r += 8; }
  if((t=x>>4) != 0) { x = t; r += 4; }
  if((t=x>>2) != 0) { x = t; r += 2; }
  if((t=x>>1) != 0) { x = t; r += 1; }
  return r;
}

// (public) return the number of bits in "this"
function bnBitLength() {
  if(this.t <= 0) return 0;
  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
}

// (protected) r = this << n*DB
function bnpDLShiftTo(n,r) {
  var i;
  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
  for(i = n-1; i >= 0; --i) r[i] = 0;
  r.t = this.t+n;
  r.s = this.s;
}

// (protected) r = this >> n*DB
function bnpDRShiftTo(n,r) {
  for(var i = n; i < this.t; ++i) r[i-n] = this[i];
  r.t = Math.max(this.t-n,0);
  r.s = this.s;
}

// (protected) r = this << n
function bnpLShiftTo(n,r) {
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1<<cbs)-1;
  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
  for(i = this.t-1; i >= 0; --i) {
    r[i+ds+1] = (this[i]>>cbs)|c;
    c = (this[i]&bm)<<bs;
  }
  for(i = ds-1; i >= 0; --i) r[i] = 0;
  r[ds] = c;
  r.t = this.t+ds+1;
  r.s = this.s;
  r.clamp();
}

// (protected) r = this >> n
function bnpRShiftTo(n,r) {
  r.s = this.s;
  var ds = Math.floor(n/this.DB);
  if(ds >= this.t) { r.t = 0; return; }
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1<<bs)-1;
  r[0] = this[ds]>>bs;
  for(var i = ds+1; i < this.t; ++i) {
    r[i-ds-1] |= (this[i]&bm)<<cbs;
    r[i-ds] = this[i]>>bs;
  }
  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
  r.t = this.t-ds;
  r.clamp();
}

// (protected) r = this - a
function bnpSubTo(a,r) {
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i < m) {
    c += this[i]-a[i];
    r[i++] = c&this.DM;
    c >>= this.DB;
  }
  if(a.t < this.t) {
    c -= a.s;
    while(i < this.t) {
      c += this[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c += this.s;
  }
  else {
    c += this.s;
    while(i < a.t) {
      c -= a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c -= a.s;
  }
  r.s = (c<0)?-1:0;
  if(c < -1) r[i++] = this.DV+c;
  else if(c > 0) r[i++] = c;
  r.t = i;
  r.clamp();
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a,r) {
  var x = this.abs(), y = a.abs();
  var i = x.t;
  r.t = i+y.t;
  while(--i >= 0) r[i] = 0;
  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
  r.s = 0;
  r.clamp();
  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
  var x = this.abs();
  var i = r.t = 2*x.t;
  while(--i >= 0) r[i] = 0;
  for(i = 0; i < x.t-1; ++i) {
    var c = x.am(i,x[i],r,2*i,0,1);
    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
      r[i+x.t] -= x.DV;
      r[i+x.t+1] = 1;
    }
  }
  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
  r.s = 0;
  r.clamp();
}

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m,q,r) {
  var pm = m.abs();
  if(pm.t <= 0) return;
  var pt = this.abs();
  if(pt.t < pm.t) {
    if(q != null) q.fromInt(0);
    if(r != null) this.copyTo(r);
    return;
  }
  if(r == null) r = nbi();
  var y = nbi(), ts = this.s, ms = m.s;
  var nsh = this.DB-nbits(pm[pm.t-1]);  // normalize modulus
  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
  else { pm.copyTo(y); pt.copyTo(r); }
  var ys = y.t;
  var y0 = y[ys-1];
  if(y0 == 0) return;
  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
  var i = r.t, j = i-ys, t = (q==null)?nbi():q;
  y.dlShiftTo(j,t);
  if(r.compareTo(t) >= 0) {
    r[r.t++] = 1;
    r.subTo(t,r);
  }
  BigInteger.ONE.dlShiftTo(ys,t);
  t.subTo(y,y); // "negative" y so we can replace sub with am later
  while(y.t < ys) y[y.t++] = 0;
  while(--j >= 0) {
    // Estimate quotient digit
    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {  // Try it out
      y.dlShiftTo(j,t);
      r.subTo(t,r);
      while(r[i] < --qd) r.subTo(t,r);
    }
  }
  if(q != null) {
    r.drShiftTo(ys,q);
    if(ts != ms) BigInteger.ZERO.subTo(q,q);
  }
  r.t = ys;
  r.clamp();
  if(nsh > 0) r.rShiftTo(nsh,r);  // Denormalize remainder
  if(ts < 0) BigInteger.ZERO.subTo(r,r);
}

// (public) this mod a
function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a,null,r);
  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
  return r;
}

// Modular reduction using "classic" algorithm
function Classic(m) { this.m = m; }
function cConvert(x) {
  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
  else return x;
}
function cRevert(x) { return x; }
function cReduce(x) { x.divRemTo(this.m,null,x); }
function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit() {
  if(this.t < 1) return 0;
  var x = this[0];
  if((x&1) == 0) return 0;
  var y = x&3;    // y == 1/x mod 2^2
  y = (y*(2-(x&0xf)*y))&0xf;  // y == 1/x mod 2^4
  y = (y*(2-(x&0xff)*y))&0xff;  // y == 1/x mod 2^8
  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff; // y == 1/x mod 2^16
  // last step - calculate inverse mod DV directly;
  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
  y = (y*(2-x*y%this.DV))%this.DV;    // y == 1/x mod 2^dbits
  // we really want the negative inverse, and -DV < y < DV
  return (y>0)?this.DV-y:-y;
}

// Montgomery reduction
function Montgomery(m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp&0x7fff;
  this.mph = this.mp>>15;
  this.um = (1<<(m.DB-15))-1;
  this.mt2 = 2*m.t;
}

// xR mod m
function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t,r);
  r.divRemTo(this.m,null,r);
  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
  return r;
}

// x/R mod m
function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
}

// x = x/R mod m (HAC 14.32)
function montReduce(x) {
  while(x.t <= this.mt2)  // pad x so am has enough room later
    x[x.t++] = 0;
  for(var i = 0; i < this.m.t; ++i) {
    // faster way of calculating u0 = x[i]*mp mod DV
    var j = x[i]&0x7fff;
    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
    // use am to combine the multiply-shift-add into one call
    j = i+this.m.t;
    x[j] += this.m.am(0,u0,x,i,0,this.m.t);
    // propagate carry
    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
  }
  x.clamp();
  x.drShiftTo(this.m.t,x);
  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
}

// r = "x^2/R mod m"; x != r
function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

// r = "xy/R mod m"; x,y != r
function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;

// (protected) true iff this is even
function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e,z) {
  if(e > 0xffffffff || e < 1) return BigInteger.ONE;
  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
  g.copyTo(r);
  while(--i >= 0) {
    z.sqrTo(r,r2);
    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
    else { var t = r; r = r2; r2 = t; }
  }
  return z.revert(r);
}

// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e,m) {
  var z;
  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
  return this.exp(e,z);
}

// protected
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;

// public
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;

// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

// prng4.js - uses Arcfour as a PRNG

function Arcfour() {
  this.i = 0;
  this.j = 0;
  this.S = new Array();
}

// Initialize arcfour context from key, an array of ints, each from [0..255]
function ARC4init(key) {
  var i, j, t;
  for(i = 0; i < 256; ++i)
    this.S[i] = i;
  j = 0;
  for(i = 0; i < 256; ++i) {
    j = (j + this.S[i] + key[i % key.length]) & 255;
    t = this.S[i];
    this.S[i] = this.S[j];
    this.S[j] = t;
  }
  this.i = 0;
  this.j = 0;
}

function ARC4next() {
  var t;
  this.i = (this.i + 1) & 255;
  this.j = (this.j + this.S[this.i]) & 255;
  t = this.S[this.i];
  this.S[this.i] = this.S[this.j];
  this.S[this.j] = t;
  return this.S[(t + this.S[this.i]) & 255];
}

Arcfour.prototype.init = ARC4init;
Arcfour.prototype.next = ARC4next;

// Plug in your RNG constructor here
function prng_newstate() {
  return new Arcfour();
}

// Pool size must be a multiple of 4 and greater than 32.
// An array of bytes the size of the pool will be passed to init()
var rng_psize = 256;
// Random number generator - requires a PRNG backend, e.g. prng4.js

// For best results, put code like
// <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>
// in your main HTML document.

var rng_state;
var rng_pool;
var rng_pptr;

// Mix in a 32-bit integer into the pool
function rng_seed_int(x) {
  rng_pool[rng_pptr++] ^= x & 255;
  rng_pool[rng_pptr++] ^= (x >> 8) & 255;
  rng_pool[rng_pptr++] ^= (x >> 16) & 255;
  rng_pool[rng_pptr++] ^= (x >> 24) & 255;
  if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;
}

// Mix in the current time (w/milliseconds) into the pool
function rng_seed_time() {
  rng_seed_int(new Date().getTime());
}

// Initialize the pool with junk if needed.
if(rng_pool == null) {
  rng_pool = new Array();
  rng_pptr = 0;
  var t;
  if(navigator.appName == "Netscape" && navigator.appVersion < "5" && window.crypto) {
    // Extract entropy (256 bits) from NS4 RNG if available
    var z = window.crypto.random(32);
    for(t = 0; t < z.length; ++t)
      rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
  }
  while(rng_pptr < rng_psize) {  // extract some randomness from Math.random()
    t = Math.floor(65536 * Math.random());
    rng_pool[rng_pptr++] = t >>> 8;
    rng_pool[rng_pptr++] = t & 255;
  }
  rng_pptr = 0;
  rng_seed_time();
  //rng_seed_int(window.screenX);
  //rng_seed_int(window.screenY);
}

function rng_get_byte() {
  if(rng_state == null) {
    rng_seed_time();
    rng_state = prng_newstate();
    rng_state.init(rng_pool);
    for(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
      rng_pool[rng_pptr] = 0;
    rng_pptr = 0;
    //rng_pool = null;
  }
  // TODO: allow reseeding after first request
  return rng_state.next();
}

function rng_get_bytes(ba) {
  var i;
  for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
}

function SecureRandom() {}

SecureRandom.prototype.nextBytes = rng_get_bytes;

//Depends on jsbn.js and rng.js

//Version 1.1: support utf-8 encoding in pkcs1pad2

//convert a (hex) string to a bignum object
function parseBigInt(str,r) {
  return new BigInteger(str,r);
}

function linebrk(s,n) {
  var ret = "";
  var i = 0;
  while(i + n < s.length) {
    ret += s.substring(i,i+n) + "\n";
    i += n;
  }
  return ret + s.substring(i,s.length);
}

function byte2Hex(b) {
  if(b < 0x10)
    return "0" + b.toString(16);
  else
    return b.toString(16);
}

//PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
function pkcs1pad2(s,n) {
  if(n < s.length + 11) { // TODO: fix for utf-8
    alert("Message too long for RSA");
    return null;
  }
  var ba = new Array();
  var i = s.length - 1;
  while(i >= 0 && n > 0) {
    var c = s.charCodeAt(i--);
    if(c < 128) { // encode using utf-8
      ba[--n] = c;
    }
    else if((c > 127) && (c < 2048)) {
      ba[--n] = (c & 63) | 128;
      ba[--n] = (c >> 6) | 192;
    }
    else {
      ba[--n] = (c & 63) | 128;
      ba[--n] = ((c >> 6) & 63) | 128;
      ba[--n] = (c >> 12) | 224;
    }
  }
  ba[--n] = 0;
  var rng = new SecureRandom();
  var x = new Array();
  while(n > 2) { // random non-zero pad
    x[0] = 0;
    while(x[0] == 0) rng.nextBytes(x);
    ba[--n] = x[0];
  }
  ba[--n] = 2;
  ba[--n] = 0;
  return new BigInteger(ba);
}

//"empty" RSA key constructor
function RSAKey() {
  this.n = null;
  this.e = 0;
  this.d = null;
  this.p = null;
  this.q = null;
  this.dmp1 = null;
  this.dmq1 = null;
  this.coeff = null;
}

//Set the public key fields N and e from hex strings
function RSASetPublic(N,E) {
  if(N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
  }
  else
    alert("Invalid RSA public key");
}

//Perform raw public operation on "x": return x^e (mod n)
function RSADoPublic(x) {
  return x.modPowInt(this.e, this.n);
}

//Return the PKCS#1 RSA encryption of "text" as an even-length hex string
function RSAEncrypt(text) {
  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);
  if(m == null) return null;
  var c = this.doPublic(m);
  if(c == null) return null;
  var h = c.toString(16);
  if((h.length & 1) == 0) return h; else return "0" + h;
}

//Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
//function RSAEncryptB64(text) {
//var h = this.encrypt(text);
//if(h) return hex2b64(h); else return null;
//}

//protected
RSAKey.prototype.doPublic = RSADoPublic;

//public
RSAKey.prototype.setPublic = RSASetPublic;
RSAKey.prototype.encrypt = RSAEncrypt;
//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;

module.exports = {
  SecureRandom: SecureRandom,
  byte2Hex: byte2Hex,
  RSAKey: RSAKey
}
},{}],5:[function(require,module,exports){
module.exports = require('./lib/chai');

},{"./lib/chai":6}],6:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var used = []
  , exports = module.exports = {};

/*!
 * Chai version
 */

exports.version = '1.8.1';

/*!
 * Assertion Error
 */

exports.AssertionError = require('assertion-error');

/*!
 * Utils for plugins (not exported)
 */

var util = require('./chai/utils');

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(this, util);
    used.push(fn);
  }

  return this;
};

/*!
 * Primary `Assertion` prototype
 */

var assertion = require('./chai/assertion');
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = require('./chai/core/assertions');
exports.use(core);

/*!
 * Expect interface
 */

var expect = require('./chai/interface/expect');
exports.use(expect);

/*!
 * Should interface
 */

var should = require('./chai/interface/should');
exports.use(should);

/*!
 * Assert interface
 */

var assert = require('./chai/interface/assert');
exports.use(assert);

},{"./chai/assertion":7,"./chai/core/assertions":8,"./chai/interface/assert":9,"./chai/interface/expect":10,"./chai/interface/should":11,"./chai/utils":22,"assertion-error":31}],7:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

  function Assertion (obj, msg, stack) {
    flag(this, 'ssfi', stack || arguments.callee);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
  }

  /*!
    * ### Assertion.includeStack
    *
    * User configurable property, influences whether stack trace
    * is included in Assertion error message. Default of false
    * suppresses stack trace in the error message
    *
    *     Assertion.includeStack = true;  // enable stack on error
    *
    * @api public
    */

  Assertion.includeStack = false;

  /*!
   * ### Assertion.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @api public
   */

  Assertion.showDiff = true;

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /*!
   * ### .assert(expression, message, negateMessage, expected, actual)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String} message to display if fails
   * @param {String} negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (true !== showDiff) showDiff = false;
    if (true !== Assertion.showDiff) showDiff = false;

    if (!ok) {
      var msg = util.getMessage(this, arguments)
        , actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (Assertion.includeStack) ? this.assert : flag(this, 'ssfi'));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, '_obj',
    { get: function () {
        return flag(this, 'object');
      }
    , set: function (val) {
        flag(this, 'object', val);
      }
  });
};

},{}],8:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide an testing capability unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @api public
   */

  [ 'to', 'be', 'been'
  , 'is', 'and', 'has', 'have'
  , 'with', 'that', 'at'
  , 'of', 'same' ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * @name deep
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object')
      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

    this.assert(
        type === _.type(obj)
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    );
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contain` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, 'contains', true);
  }

  function include (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    if (_.type(val) === 'object') {
      if (!flag(this, 'negate')) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {}
      for (var k in val) subset[k] = obj[k]
      var expected = _.eql(subset, val);
    } else {
      var expected = obj && ~obj.indexOf(val)
    }
    this.assert(
        expected
      , 'expected #{this} to include ' + _.inspect(val)
      , 'expected #{this} to not include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everthing').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy');
  });

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(
        true === flag(this, 'object')
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(
        false === flag(this, 'object')
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).not.to.be.null;
   *
   * @name null
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(
        null === flag(this, 'object')
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @api public
   */

  Assertion.addProperty('exist', function () {
    this.assert(
        null != flag(this, 'object')
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var obj = flag(this, 'object')
      , expected = obj;

    if (Array.isArray(obj) || 'string' === typeof object) {
      expected = obj.length;
    } else if (typeof obj === 'object') {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, 'object')
      , type = Object.prototype.toString.call(obj);
    this.assert(
        '[object Arguments]' === type
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    );
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'deep')) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len > n
        , 'expected #{this} to have a length above #{exp} but got #{act}'
        , 'expected #{this} to not have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj > n
        , 'expected #{this} to be above ' + n
        , 'expected #{this} to be at most ' + n
      );
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= n
        , 'expected #{this} to have a length at least #{exp} but got #{act}'
        , 'expected #{this} to have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj >= n
        , 'expected #{this} to be at least ' + n
        , 'expected #{this} to be below ' + n
      );
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len < n
        , 'expected #{this} to have a length below #{exp} but got #{act}'
        , 'expected #{this} to not have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj < n
        , 'expected #{this} to be below ' + n
        , 'expected #{this} to be at least ' + n
      );
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len <= n
        , 'expected #{this} to have a length at most #{exp} but got #{act}'
        , 'expected #{this} to have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj <= n
        , 'expected #{this} to be at most ' + n
        , 'expected #{this} to be above ' + n
      );
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , range = start + '..' + finish;
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= start && len <= finish
        , 'expected #{this} to have a length within ' + range
        , 'expected #{this} to not have a length within ' + range
      );
    } else {
      this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, 'object') instanceof constructor
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    );
  };

  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };

   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @api public
   */

  Assertion.addMethod('property', function (name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var descriptor = flag(this, 'deep') ? 'deep property ' : 'property '
      , negate = flag(this, 'negate')
      , obj = flag(this, 'object')
      , value = flag(this, 'deep')
        ? _.getPathValue(name, obj)
        : obj[name];

    if (negate && undefined !== val) {
      if (undefined === value) {
        msg = (msg != null) ? msg + ': ' : '';
        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          undefined !== value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (undefined !== val) {
      this.assert(
          val === value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      );
    }

    flag(this, 'object', value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        obj.hasOwnProperty(name)
      , 'expected #{this} to have own property ' + _.inspect(name)
      , 'expected #{this} to not have own property ' + _.inspect(name)
    );
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

  /**
   * ### .length(value)
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.length(3);
   *     expect('foobar').to.have.length(6);
   *
   * Can also be used as a chain precursor to a value
   * comparison for the length property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name length
   * @alias lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @api public
   */

  function assertLengthChain () {
    flag(this, 'doLength', true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).to.have.property('length');
    var len = obj.length;

    this.assert(
        len == n
      , 'expected #{this} to have a length of #{exp} but got #{act}'
      , 'expected #{this} to not have a length of #{act}'
      , n
      , len
    );
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addMethod('lengthOf', assertLength, assertLengthChain);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('match', function (re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    );
  });

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('string');

    this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target has exactly the given keys, or
   * asserts the inclusion of some keys when using the
   * `include` or `contain` modifiers.
   *
   *     expect({ foo: 1, bar: 2 }).to.have.keys(['foo', 'bar']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');
   *
   * @name keys
   * @alias key
   * @param {String...|Array} keys
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, 'object')
      , str
      , ok = true;

    keys = keys instanceof Array
      ? keys
      : Array.prototype.slice.call(arguments);

    if (!keys.length) throw new Error('keys required');

    var actual = Object.keys(obj)
      , len = keys.length;

    // Inclusion
    ok = keys.every(function(key){
      return ~actual.indexOf(key);
    });

    // Strict
    if (!flag(this, 'negate') && !flag(this, 'contains')) {
      ok = ok && keys.length == actual.length;
    }

    // Key string
    if (len > 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      str = keys.join(', ') + ', and ' + last;
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

    // Assertion
    this.assert(
        ok
      , 'expected #{this} to ' + str
      , 'expected #{this} to not ' + str
    );
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *     expect(fn).to.not.throw(new RangeError('Out of range.'));
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('function');

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor && constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === 'function') {
      name = constructor.prototype.name || constructor.name;
      if (name === 'Error' && constructor !== Error) {
        name = (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp}'
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, 'object', err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, 'object', err);
          return this;
        }
      }

      // next, check message
      var message = 'object' === _.type(err) && "message" in err
        ? err.message
        : '' + err;

      if ((message != null) && errMsg && errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , 'expected #{this} to throw error matching #{exp} but got #{act}'
          , 'expected #{this} to throw error not matching #{exp}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , 'expected #{this} to throw error including #{exp} but got #{act}'
          , 'expected #{this} to throw error not including #{act}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = ''
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? '#{exp}' //_.inspect(desiredError)
          : 'an error';

    if (thrown) {
      actuallyGot = ' but #{act} was thrown'
    }

    this.assert(
        thrown === true
      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, 'object', thrownError);
  };

  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @param {String} method
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('respondTo', function (method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , itself = flag(this, 'itself')
      , context = ('function' === _.type(obj) && !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        'function' === typeof context
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    );
  });

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo('bar');
   *     expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num > 0; });
   *
   * @name satisfy
   * @param {Function} matcher
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('satisfy', function (matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        matcher(obj)
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , this.negate ? false : true
      , matcher(obj)
    );
  });

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('closeTo', function (expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    );
  });

  function isSubsetOf(subset, superset) {
    return subset.every(function(elem) {
      return superset.indexOf(elem) !== -1;
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same members.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj).to.be.an('array');
    new Assertion(subset).to.be.an('array');

    if (flag(this, 'contains')) {
      return this.assert(
          isSubsetOf(subset, obj)
        , 'expected #{this} to be a superset of #{act}'
        , 'expected #{this} to not be a superset of #{act}'
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset) && isSubsetOf(subset, obj)
        , 'expected #{this} to have the same members as #{act}'
        , 'expected #{this} to not have the same members as #{act}'
        , obj
        , subset
    );
  });
};

},{}],9:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


module.exports = function (chai, util) {

  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null);
    test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    );
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .ok(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.ok('everything', 'everything is ok');
   *     assert.ok(false, 'this will fail');
   *
   * @name ok
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.ok = function (val, msg) {
    new Assertion(val, msg).is.ok;
  };

  /**
   * ### .notOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.notOk('everything', 'this will fail');
   *     assert.notOk(false, 'this will pass');
   *
   * @name notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.notOk = function (val, msg) {
    new Assertion(val, msg).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg);

    test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg);

    test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.deepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.eql(exp);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg).is['true'];
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg).is['false'];
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg).to.not.equal(null);
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg).to.be.a('function');
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('function');
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object (as revealed by
   * `Object.prototype.toString`).
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg).to.be.a('object');
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object.
   *
   *     var selection = 'chai'
   *     assert.isObject(selection, 'tea selection is not an object');
   *     assert.isObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('object');
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg).to.be.an('array');
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg).to.not.be.an('array');
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg).to.be.a('string');
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('string');
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg).to.be.a('number');
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('number');
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg).to.be.a('boolean');
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('boolean');
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *i
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg).not.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.property(prop);
  };

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.deepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop);
  };

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notDeepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.property(prop, val);
  };

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 5, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg).to.have.length(len);
  };

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throw(fn, 'function throws a reference error');
   *     assert.throw(fn, /function throws a reference error/);
   *     assert.throw(fn, ReferenceError);
   *     assert.throw(fn, ReferenceError, 'function throws a reference error');
   *     assert.throw(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.Throw = function (fn, errt, errs, msg) {
    if ('string' === typeof errt || errt instanceof RegExp) {
      errs = errt;
      errt = null;
    }

    var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);
    return flag(assertErr, 'object');
  };

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.doesNotThrow = function (fn, type, msg) {
    if ('string' === typeof type) {
      msg = type;
      type = null;
    }

    new Assertion(fn, msg).to.not.Throw(type);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {
      throw new Error('Invalid operator "' + operator + '"');
    }
    var test = new Assertion(eval(val + operator + val2), msg);
    test.assert(
        true === flag(test, 'object')
      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.members(subset);
  }

  /*!
   * Undocumented / untested
   */

  assert.ifError = function (val, msg) {
    new Assertion(val, msg).to.not.be.ok;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  ('Throw', 'throw')
  ('Throw', 'throws');
};

},{}],10:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };
};


},{}],11:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, 'should',
      {
        set: function (value) {
          // See https://github.com/chaijs/chai/issues/86: this makes
          // `whatever.should = someValue` actually set `someValue`, which is
          // especially useful for `global.should = require('chai').should()`.
          //
          // Note that we have to use [[DefineProperty]] instead of [[Put]]
          // since otherwise we would trigger this very setter!
          Object.defineProperty(this, 'should', {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        }
      , get: function(){
          if (this instanceof String || this instanceof Number) {
            return new Assertion(this.constructor(this));
          } else if (this instanceof Boolean) {
            return new Assertion(this == true);
          }
          return new Assertion(this);
        }
      , configurable: true
    });

    var should = {};

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};

},{}],12:[function(require,module,exports){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var transferFlags = require('./transferFlags');

/*!
 * Module variables
 */

// Check whether `__proto__` is supported
var hasProtoSupport = '__proto__' in Object;

// Without `__proto__` support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
var excludeNames = /^(?:length|name|arguments|caller)$/;

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @name addChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function () {
        chainableBehavior.chainingBehavior.call(this);

        var assert = function () {
          var result = chainableBehavior.method.apply(this, arguments);
          return result === undefined ? this : result;
        };

        // Use `__proto__` if available
        if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = assert.__proto__ = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (!excludeNames.test(asserterName)) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(this, assert);
        return assert;
      }
    , configurable: true
  });
};

},{"./transferFlags":29}],13:[function(require,module,exports){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @name addMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  ctx[name] = function () {
    var result = method.apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{}],14:[function(require,module,exports){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @name addProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter.call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],15:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### flag(object ,key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object (constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @name flag
 * @api private
 */

module.exports = function (obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};

},{}],16:[function(require,module,exports){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  var actual = args[4];
  return 'undefined' !== typeof actual ? actual : obj._obj;
};

},{}],17:[function(require,module,exports){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getEnumerableProperties
 * @api public
 */

module.exports = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};

},{}],18:[function(require,module,exports){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag')
  , getActual = require('./getActual')
  , inspect = require('./inspect')
  , objDisplay = require('./objDisplay');

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @name getMessage
 * @api public
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , val = flag(obj, 'object')
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, 'message');

  msg = msg || '';
  msg = msg
    .replace(/#{this}/g, objDisplay(val))
    .replace(/#{act}/g, objDisplay(actual))
    .replace(/#{exp}/g, objDisplay(expected));

  return flagMsg ? flagMsg + ': ' + msg : msg;
};

},{"./flag":15,"./getActual":16,"./inspect":23,"./objDisplay":24}],19:[function(require,module,exports){
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 */

module.exports = function (func) {
  if (func.name) return func.name;

  var match = /^\s?function ([^(]*)\(/.exec(func);
  return match && match[1] ? match[1] : "";
};

},{}],20:[function(require,module,exports){
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @name getPathValue
 * @api public
 */

var getPathValue = module.exports = function (path, obj) {
  var parsed = parsePath(path);
  return _getPathValue(parsed, obj);
};

/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath (path) {
  var str = path.replace(/\[/g, '.[')
    , parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    var re = /\[(\d+)\]$/
      , mArr = re.exec(value)
    if (mArr) return { i: parseFloat(mArr[1]) };
    else return { p: value };
  });
};

/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

function _getPathValue (parsed, obj) {
  var tmp = obj
    , res;
  for (var i = 0, l = parsed.length; i < l; i++) {
    var part = parsed[i];
    if (tmp) {
      if ('undefined' !== typeof part.p)
        tmp = tmp[part.p];
      else if ('undefined' !== typeof part.i)
        tmp = tmp[part.i];
      if (i == (l - 1)) res = tmp;
    } else {
      res = undefined;
    }
  }
  return res;
};

},{}],21:[function(require,module,exports){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(subject);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(subject);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};

},{}],22:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Main exports
 */

var exports = module.exports = {};

/*!
 * test utility
 */

exports.test = require('./test');

/*!
 * type utility
 */

exports.type = require('./type');

/*!
 * message utility
 */

exports.getMessage = require('./getMessage');

/*!
 * actual utility
 */

exports.getActual = require('./getActual');

/*!
 * Inspect util
 */

exports.inspect = require('./inspect');

/*!
 * Object Display util
 */

exports.objDisplay = require('./objDisplay');

/*!
 * Flag utility
 */

exports.flag = require('./flag');

/*!
 * Flag transferring utility
 */

exports.transferFlags = require('./transferFlags');

/*!
 * Deep equal utility
 */

exports.eql = require('deep-eql');

/*!
 * Deep path value
 */

exports.getPathValue = require('./getPathValue');

/*!
 * Function name
 */

exports.getName = require('./getName');

/*!
 * add Property
 */

exports.addProperty = require('./addProperty');

/*!
 * add Method
 */

exports.addMethod = require('./addMethod');

/*!
 * overwrite Property
 */

exports.overwriteProperty = require('./overwriteProperty');

/*!
 * overwrite Method
 */

exports.overwriteMethod = require('./overwriteMethod');

/*!
 * Add a chainable method
 */

exports.addChainableMethod = require('./addChainableMethod');

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = require('./overwriteChainableMethod');


},{"./addChainableMethod":12,"./addMethod":13,"./addProperty":14,"./flag":15,"./getActual":16,"./getMessage":18,"./getName":19,"./getPathValue":20,"./inspect":23,"./objDisplay":24,"./overwriteChainableMethod":25,"./overwriteMethod":26,"./overwriteProperty":27,"./test":28,"./transferFlags":29,"./type":30,"deep-eql":32}],23:[function(require,module,exports){
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = require('./getName');
var getProperties = require('./getProperties');
var getEnumerableProperties = require('./getEnumerableProperties');

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
}

// https://gist.github.com/1044128/
var getOuterHTML = function(element) {
  if ('outerHTML' in element) return element.outerHTML;
  var ns = "http://www.w3.org/1999/xhtml";
  var container = document.createElementNS(ns, '_');
  var elemProto = (window.HTMLElement || window.Element).prototype;
  var xmlSerializer = new XMLSerializer();
  var html;
  if (document.xmlVersion) {
    return xmlSerializer.serializeToString(element);
  } else {
    container.appendChild(element.cloneNode(false));
    html = container.innerHTML.replace('><', '>' + element.innerHTML + '<');
    container.innerHTML = '';
    return html;
  }
};

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === 'object') {
    return object instanceof HTMLElement;
  } else {
    return object &&
      typeof object === 'object' &&
      object.nodeType === 1 &&
      typeof object.nodeName === 'string';
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value && typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If it's DOM elem, get outer HTML.
  if (isDOMElement(value)) {
    return getOuterHTML(value);
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) && (
      (keys.length === 1 && keys[0] === 'stack') ||
      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
     ))) {
    if (typeof value === 'function') {
      var name = getName(value);
      var nameSuffix = name ? ': ' + name : '';
      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (typeof value === 'function') {
    var name = getName(value);
    var nameSuffix = name ? ': ' + name : '';
    base = ' [Function' + nameSuffix + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case 'undefined':
      return ctx.stylize('undefined', 'undefined');

    case 'string':
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');

    case 'number':
      return ctx.stylize('' + value, 'number');

    case 'boolean':
      return ctx.stylize('' + value, 'boolean');
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  if (value.__lookupGetter__) {
    if (value.__lookupGetter__(key)) {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
  }
  if (visibleKeys.indexOf(key) < 0) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (typeof name === 'undefined') {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
}

function isRegExp(re) {
  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
}

function isDate(d) {
  return typeof d === 'object' && objectToString(d) === '[object Date]';
}

function isError(e) {
  return typeof e === 'object' && objectToString(e) === '[object Error]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"./getEnumerableProperties":17,"./getName":19,"./getProperties":21}],24:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var inspect = require('./inspect');

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @api public
 */

module.exports = function (obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (str.length >= 40) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj)
        , kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};

},{"./inspect":23}],25:[function(require,module,exports){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, fn)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function () {
    var result = chainingBehavior(_chainingBehavior).call(this);
    return result === undefined ? this : result;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function () {
    var result = method(_method).apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{}],26:[function(require,module,exports){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @name overwriteMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  var _method = ctx[name]
    , _super = function () { return this; };

  if (_method && 'function' === typeof _method)
    _super = _method;

  ctx[name] = function () {
    var result = method(_super).apply(this, arguments);
    return result === undefined ? this : result;
  }
};

},{}],27:[function(require,module,exports){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @name overwriteProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get && 'function' === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter(_super).call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],28:[function(require,module,exports){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag');

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , expr = args[0];
  return negate ? !expr : expr;
};

},{"./flag":15}],29:[function(require,module,exports){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags too; usually a new assertion
 * @param {Boolean} includeAll
 * @name getAllFlags
 * @api private
 */

module.exports = function (assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
      object.__flags[flag] = flags[flag];
    }
  }
};

},{}],30:[function(require,module,exports){
/*!
 * Chai - type utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Arguments]': 'arguments'
  , '[object Array]': 'array'
  , '[object Date]': 'date'
  , '[object Function]': 'function'
  , '[object Number]': 'number'
  , '[object RegExp]': 'regexp'
  , '[object String]': 'string'
};

/**
 * ### type(object)
 *
 * Better implementation of `typeof` detection that can
 * be used cross-browser. Handles the inconsistencies of
 * Array, `null`, and `undefined` detection.
 *
 *     utils.type({}) // 'object'
 *     utils.type(null) // `null'
 *     utils.type(undefined) // `undefined`
 *     utils.type([]) // `array`
 *
 * @param {Mixed} object to detect type of
 * @name type
 * @api private
 */

module.exports = function (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
};

},{}],31:[function(require,module,exports){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || arguments.callee;
  if (ssf && Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};

},{}],32:[function(require,module,exports){
module.exports = require('./lib/eql');

},{"./lib/eql":33}],33:[function(require,module,exports){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var type = require('type-detect');

/*!
 * Buffer.isBuffer browser shim
 */

var Buffer;
try { Buffer = require('buffer').Buffer; }
catch(ex) {
  Buffer = {};
  Buffer.isBuffer = function() { return false; }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

function deepEqual(a, b, m) {
  if (sameValue(a, b)) {
    return true;
  } else if ('date' === type(a)) {
    return dateEqual(a, b);
  } else if ('regexp' === type(a)) {
    return regexpEqual(a, b);
  } else if (Buffer.isBuffer(a)) {
    return bufferEqual(a, b);
  } else if ('arguments' === type(a)) {
    return argumentsEqual(a, b, m);
  } else if (!typeEqual(a, b)) {
    return false;
  } else if (('object' !== type(a) && 'object' !== type(b))
  && ('array' !== type(a) && 'array' !== type(b))) {
    return sameValue(a, b);
  } else {
    return objectEqual(a, b, m);
  }
}

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

function sameValue(a, b) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  return a !== a && b !== b;
}

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function typeEqual(a, b) {
  return type(a) === type(b);
}

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

function dateEqual(a, b) {
  if ('date' !== type(b)) return false;
  return sameValue(a.getTime(), b.getTime());
}

/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

function regexpEqual(a, b) {
  if ('regexp' !== type(b)) return false;
  return sameValue(a.toString(), b.toString());
}

/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

function argumentsEqual(a, b, m) {
  if ('arguments' !== type(b)) return false;
  a = [].slice.call(a);
  b = [].slice.call(b);
  return deepEqual(a, b, m);
}

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

function enumerable(a) {
  var res = [];
  for (var key in a) res.push(key);
  return res;
}

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

function iterableEqual(a, b) {
  if (a.length !==  b.length) return false;

  var i = 0;
  var match = true;

  for (; i < a.length; i++) {
    if (a[i] !== b[i]) {
      match = false;
      break;
    }
  }

  return match;
}

/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function bufferEqual(a, b) {
  if (!Buffer.isBuffer(b)) return false;
  return iterableEqual(a, b);
}

/*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

function isValue(a) {
  return a !== null && a !== undefined;
}

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function objectEqual(a, b, m) {
  if (!isValue(a) || !isValue(b)) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  var i;
  if (m) {
    for (i = 0; i < m.length; i++) {
      if ((m[i][0] === a && m[i][1] === b)
      ||  (m[i][0] === b && m[i][1] === a)) {
        return true;
      }
    }
  } else {
    m = [];
  }

  try {
    var ka = enumerable(a);
    var kb = enumerable(b);
  } catch (ex) {
    return false;
  }

  ka.sort();
  kb.sort();

  if (!iterableEqual(ka, kb)) {
    return false;
  }

  m.push([ a, b ]);

  var key;
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], m)) {
      return false;
    }
  }

  return true;
}

},{"buffer":39,"type-detect":34}],34:[function(require,module,exports){
module.exports = require('./lib/type');

},{"./lib/type":35}],35:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Array]': 'array'
  , '[object RegExp]': 'regexp'
  , '[object Function]': 'function'
  , '[object Arguments]': 'arguments'
  , '[object Date]': 'date'
};

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

function getType (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library () {
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function (type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function (obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}],36:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":38}],37:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],38:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require("/Users/weili/work/fh-sdks/fh-js-sdk/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":37,"/Users/weili/work/fh-sdks/fh-js-sdk/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":45,"inherits":44}],39:[function(require,module,exports){
/**
 * The buffer module from node.js, for the browser.
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install buffer`
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
   // Detect if browser supports Typed Arrays. Supported browsers are IE 10+,
   // Firefox 4+, Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+.
  if (typeof Uint8Array !== 'function' || typeof ArrayBuffer !== 'function')
    return false

  // Does the browser support adding properties to `Uint8Array` instances? If
  // not, then that's the same as no `Uint8Array` support. We need to be able to
  // add all the node Buffer API methods.
  // Bug in Firefox 4-29, now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var arr = new Uint8Array(0)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // Assume object is an array
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof Uint8Array === 'function' &&
      subject instanceof Uint8Array) {
    // Speed optimization -- use set if we're copying from a Uint8Array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  // copy!
  for (var i = 0; i < end - start; i++)
    target[i + target_start] = this[i + start]
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array === 'function') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment the Uint8Array *instance* (not the class!) with Buffer methods
 */
function augment (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":40,"ieee754":41}],40:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var ZERO   = '0'.charCodeAt(0)
	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	module.exports.toByteArray = b64ToByteArray
	module.exports.fromByteArray = uint8ToBase64
}())

},{}],41:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],42:[function(require,module,exports){
(function (global){
/*global window, global*/
var util = require("util")
var assert = require("assert")

var slice = Array.prototype.slice
var console
var times = {}

if (typeof global !== "undefined" && global.console) {
    console = global.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = {}
}

var functions = [
    [log, "log"]
    , [info, "info"]
    , [warn, "warn"]
    , [error, "error"]
    , [time, "time"]
    , [timeEnd, "timeEnd"]
    , [trace, "trace"]
    , [dir, "dir"]
    , [assert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = Date.now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    var duration = Date.now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function assert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"assert":36,"util":47}],43:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        throw TypeError('Uncaught, unspecified "error" event.');
      }
      return false;
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      console.trace();
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],44:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],45:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],46:[function(require,module,exports){
module.exports=require(37)
},{}],47:[function(require,module,exports){
module.exports=require(38)
},{"./support/isBuffer":46,"/Users/weili/work/fh-sdks/fh-js-sdk/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":45,"inherits":44}],48:[function(require,module,exports){
/*
 * loglevel - https://github.com/pimterry/loglevel
 *
 * Copyright (c) 2013 Tim Perry
 * Licensed under the MIT license.
 */

;(function (undefined) {
    var undefinedType = "undefined";

    (function (name, definition) {
        if (typeof module !== 'undefined') {
            module.exports = definition();
        } else if (typeof define === 'function' && typeof define.amd === 'object') {
            define(definition);
        } else {
            this[name] = definition();
        }
    }('log', function () {
        var self = {};
        var noop = function() {};

        function realMethod(methodName) {
            if (typeof console === undefinedType) {
                return noop;
            } else if (console[methodName] === undefined) {
                if (console.log !== undefined) {
                    return boundToConsole(console, 'log');
                } else {
                    return noop;
                }
            } else {
                return boundToConsole(console, methodName);
            }
        }

        function boundToConsole(console, methodName) {
            var method = console[methodName];
            if (method.bind === undefined) {
                if (Function.prototype.bind === undefined) {
                    return functionBindingWrapper(method, console);
                } else {
                    try {
                        return Function.prototype.bind.call(console[methodName], console);
                    } catch (e) {
                        // In IE8 + Modernizr, the bind shim will reject the above, so we fall back to wrapping
                        return functionBindingWrapper(method, console);
                    }
                }
            } else {
                return console[methodName].bind(console);
            }
        }

        function functionBindingWrapper(f, context) {
            return function() {
                Function.prototype.apply.apply(f, [context, arguments]);
            };
        }

        var logMethods = [
            "trace",
            "debug",
            "info",
            "warn",
            "error"
        ];

        function replaceLoggingMethods(methodFactory) {
            for (var ii = 0; ii < logMethods.length; ii++) {
                self[logMethods[ii]] = methodFactory(logMethods[ii]);
            }
        }

        function cookiesAvailable() {
            return (typeof window !== undefinedType &&
                    window.document !== undefined &&
                    window.document.cookie !== undefined);
        }

        function localStorageAvailable() {
            try {
                return (typeof window !== undefinedType &&
                        window.localStorage !== undefined);
            } catch (e) {
                return false;
            }
        }

        function persistLevelIfPossible(levelNum) {
            var localStorageFail = false,
                levelName;

            for (var key in self.levels) {
                if (self.levels.hasOwnProperty(key) && self.levels[key] === levelNum) {
                    levelName = key;
                    break;
                }
            }

            if (localStorageAvailable()) {
                /*
                 * Setting localStorage can create a DOM 22 Exception if running in Private mode
                 * in Safari, so even if it is available we need to catch any errors when trying
                 * to write to it
                 */
                try {
                    window.localStorage['loglevel'] = levelName;
                } catch (e) {
                    localStorageFail = true;
                }
            } else {
                localStorageFail = true;
            }

            if (localStorageFail && cookiesAvailable()) {
                window.document.cookie = "loglevel=" + levelName + ";";
            }
        }

        var cookieRegex = /loglevel=([^;]+)/;

        function loadPersistedLevel() {
            var storedLevel;

            if (localStorageAvailable()) {
                storedLevel = window.localStorage['loglevel'];
            }

            if (storedLevel === undefined && cookiesAvailable()) {
                var cookieMatch = cookieRegex.exec(window.document.cookie) || [];
                storedLevel = cookieMatch[1];
            }
            
            if (self.levels[storedLevel] === undefined) {
                storedLevel = "WARN";
            }

            self.setLevel(self.levels[storedLevel]);
        }

        /*
         *
         * Public API
         *
         */

        self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
            "ERROR": 4, "SILENT": 5};

        self.setLevel = function (level) {
            if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
                persistLevelIfPossible(level);

                if (level === self.levels.SILENT) {
                    replaceLoggingMethods(function () {
                        return noop;
                    });
                    return;
                } else if (typeof console === undefinedType) {
                    replaceLoggingMethods(function (methodName) {
                        return function () {
                            if (typeof console !== undefinedType) {
                                self.setLevel(level);
                                self[methodName].apply(self, arguments);
                            }
                        };
                    });
                    return "No console available for logging";
                } else {
                    replaceLoggingMethods(function (methodName) {
                        if (level <= self.levels[methodName.toUpperCase()]) {
                            return realMethod(methodName);
                        } else {
                            return noop;
                        }
                    });
                }
            } else if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
                self.setLevel(self.levels[level.toUpperCase()]);
            } else {
                throw "log.setLevel() called with invalid level: " + level;
            }
        };

        self.enableAll = function() {
            self.setLevel(self.levels.TRACE);
        };

        self.disableAll = function() {
            self.setLevel(self.levels.SILENT);
        };

        loadPersistedLevel();
        return self;
    }));
})();

},{}],49:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.once = noop;
process.off = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],50:[function(require,module,exports){
(function (sinonChai) {
    "use strict";

    // Module systems magic dance.

    if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
        // NodeJS
        module.exports = sinonChai;
    } else if (typeof define === "function" && define.amd) {
        // AMD
        define(function () {
            return sinonChai;
        });
    } else {
        // Other environment (usually <script> tag): plug in to global chai instance directly.
        chai.use(sinonChai);
    }
}(function sinonChai(chai, utils) {
    "use strict";

    var slice = Array.prototype.slice;

    function isSpy(putativeSpy) {
        return typeof putativeSpy === "function" &&
               typeof putativeSpy.getCall === "function" &&
               typeof putativeSpy.calledWithExactly === "function";
    }

    function timesInWords(count) {
        return count === 1 ? "once" :
               count === 2 ? "twice" :
               count === 3 ? "thrice" :
               (count || 0) + " times";
    }

    function isCall(putativeCall) {
        return putativeCall && isSpy(putativeCall.proxy);
    }

    function assertCanWorkWith(assertion) {
        if (!isSpy(assertion._obj) && !isCall(assertion._obj)) {
            throw new TypeError(utils.inspect(assertion._obj) + " is not a spy or a call to a spy!");
        }
    }

    function getMessages(spy, action, nonNegatedSuffix, always, args) {
        var verbPhrase = always ? "always have " : "have ";
        nonNegatedSuffix = nonNegatedSuffix || "";
        if (isSpy(spy.proxy)) {
            spy = spy.proxy;
        }

        function printfArray(array) {
            return spy.printf.apply(spy, array);
        }

        return {
            affirmative: printfArray(["expected %n to " + verbPhrase + action + nonNegatedSuffix].concat(args)),
            negative: printfArray(["expected %n to not " + verbPhrase + action].concat(args))
        };
    }

    function sinonProperty(name, action, nonNegatedSuffix) {
        utils.addProperty(chai.Assertion.prototype, name, function () {
            assertCanWorkWith(this);

            var messages = getMessages(this._obj, action, nonNegatedSuffix, false);
            this.assert(this._obj[name], messages.affirmative, messages.negative);
        });
    }

    function sinonPropertyAsBooleanMethod(name, action, nonNegatedSuffix) {
        utils.addMethod(chai.Assertion.prototype, name, function (arg) {
            assertCanWorkWith(this);

            var messages = getMessages(this._obj, action, nonNegatedSuffix, false, [timesInWords(arg)]);
            this.assert(this._obj[name] === arg, messages.affirmative, messages.negative);
        });
    }

    function createSinonMethodHandler(sinonName, action, nonNegatedSuffix) {
        return function () {
            assertCanWorkWith(this);

            var alwaysSinonMethod = "always" + sinonName[0].toUpperCase() + sinonName.substring(1);
            var shouldBeAlways = utils.flag(this, "always") && typeof this._obj[alwaysSinonMethod] === "function";
            var sinonMethod = shouldBeAlways ? alwaysSinonMethod : sinonName;

            var messages = getMessages(this._obj, action, nonNegatedSuffix, shouldBeAlways, slice.call(arguments));
            this.assert(this._obj[sinonMethod].apply(this._obj, arguments), messages.affirmative, messages.negative);
        };
    }

    function sinonMethodAsProperty(name, action, nonNegatedSuffix) {
        var handler = createSinonMethodHandler(name, action, nonNegatedSuffix);
        utils.addProperty(chai.Assertion.prototype, name, handler);
    }

    function exceptionalSinonMethod(chaiName, sinonName, action, nonNegatedSuffix) {
        var handler = createSinonMethodHandler(sinonName, action, nonNegatedSuffix);
        utils.addMethod(chai.Assertion.prototype, chaiName, handler);
    }

    function sinonMethod(name, action, nonNegatedSuffix) {
        exceptionalSinonMethod(name, name, action, nonNegatedSuffix);
    }

    utils.addProperty(chai.Assertion.prototype, "always", function () {
        utils.flag(this, "always", true);
    });

    sinonProperty("called", "been called", " at least once, but it was never called");
    sinonPropertyAsBooleanMethod("callCount", "been called exactly %1", ", but it was called %c%C");
    sinonProperty("calledOnce", "been called exactly once", ", but it was called %c%C");
    sinonProperty("calledTwice", "been called exactly twice", ", but it was called %c%C");
    sinonProperty("calledThrice", "been called exactly thrice", ", but it was called %c%C");
    sinonMethodAsProperty("calledWithNew", "been called with new");
    sinonMethod("calledBefore", "been called before %1");
    sinonMethod("calledAfter", "been called after %1");
    sinonMethod("calledOn", "been called with %1 as this", ", but it was called with %t instead");
    sinonMethod("calledWith", "been called with arguments %*", "%C");
    sinonMethod("calledWithExactly", "been called with exact arguments %*", "%C");
    sinonMethod("calledWithMatch", "been called with arguments matching %*", "%C");
    sinonMethod("returned", "returned %1");
    exceptionalSinonMethod("thrown", "threw", "thrown %1");
}));

},{}],51:[function(require,module,exports){
var toString = Object.prototype.toString

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Function]': return 'function'
    case '[object Date]': return 'date'
    case '[object RegExp]': return 'regexp'
    case '[object Arguments]': return 'arguments'
    case '[object Array]': return 'array'
    case '[object String]': return 'string'
  }

  if (typeof val == 'object' && val && typeof val.length == 'number') {
    try {
      if (typeof val.callee == 'function') return 'arguments';
    } catch (ex) {
      if (ex instanceof TypeError) {
        return 'arguments';
      }
    }
  }

  if (val === null) return 'null'
  if (val === undefined) return 'undefined'
  if (val && val.nodeType === 1) return 'element'
  if (val === Object(val)) return 'object'

  return typeof val
}

},{}],52:[function(require,module,exports){
//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.6.0';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return obj;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
    return obj;
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    any(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);
    each(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, function(value, index, list) {
      return !predicate.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);
    each(obj, function(value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);
    each(obj, function(value, index, list) {
      if (result || (result = predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    var result = -Infinity, lastComputed = -Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed > lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    var result = Infinity, lastComputed = Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed < lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return value;
    return _.property(value);
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Split an array into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(array, predicate) {
    var pass = [], fail = [];
    each(array, function(elem) {
      (predicate(elem) ? pass : fail).push(elem);
    });
    return [pass, fail];
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.contains(other, item);
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error('bindAll must be passed function names');
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;
      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function () {
      return value;
    };
  };

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    return function(obj) {
      if (obj === attrs) return true; //avoid comparing an object to itself.
      for (var key in attrs) {
        if (attrs[key] !== obj[key])
          return false;
      }
      return true;
    }
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() { return new Date().getTime(); };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}).call(this);

},{}],53:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/XDomainRequestWrapper.js']) {
  _$jscoverage['modules/XDomainRequestWrapper.js'] = [];
  _$jscoverage['modules/XDomainRequestWrapper.js'][1] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][2] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][3] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][4] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][5] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][6] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][7] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][8] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][9] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][10] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][11] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][12] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][13] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][14] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][15] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][16] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][19] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][20] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][21] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][23] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][24] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][25] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][26] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][27] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][30] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][31] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][32] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][33] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][34] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][35] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][40] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][41] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][44] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][45] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][48] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][49] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][52] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][59] = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][63] = 0;
}
_$jscoverage['modules/XDomainRequestWrapper.js'][1]++;
var XDomainRequestWrapper = (function (xdr) {
  _$jscoverage['modules/XDomainRequestWrapper.js'][2]++;
  this.xdr = xdr;
  _$jscoverage['modules/XDomainRequestWrapper.js'][3]++;
  this.isWrapper = true;
  _$jscoverage['modules/XDomainRequestWrapper.js'][4]++;
  this.readyState = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][5]++;
  this.onreadystatechange = null;
  _$jscoverage['modules/XDomainRequestWrapper.js'][6]++;
  this.status = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][7]++;
  this.statusText = "";
  _$jscoverage['modules/XDomainRequestWrapper.js'][8]++;
  this.responseText = "";
  _$jscoverage['modules/XDomainRequestWrapper.js'][9]++;
  var self = this;
  _$jscoverage['modules/XDomainRequestWrapper.js'][10]++;
  this.xdr.onload = (function () {
  _$jscoverage['modules/XDomainRequestWrapper.js'][11]++;
  self.readyState = 4;
  _$jscoverage['modules/XDomainRequestWrapper.js'][12]++;
  self.status = 200;
  _$jscoverage['modules/XDomainRequestWrapper.js'][13]++;
  self.statusText = "";
  _$jscoverage['modules/XDomainRequestWrapper.js'][14]++;
  self.responseText = self.xdr.responseText;
  _$jscoverage['modules/XDomainRequestWrapper.js'][15]++;
  if (self.onreadystatechange) {
    _$jscoverage['modules/XDomainRequestWrapper.js'][16]++;
    self.onreadystatechange();
  }
});
  _$jscoverage['modules/XDomainRequestWrapper.js'][19]++;
  this.xdr.onerror = (function () {
  _$jscoverage['modules/XDomainRequestWrapper.js'][20]++;
  if (self.onerror) {
    _$jscoverage['modules/XDomainRequestWrapper.js'][21]++;
    self.onerror();
  }
  _$jscoverage['modules/XDomainRequestWrapper.js'][23]++;
  self.readyState = 4;
  _$jscoverage['modules/XDomainRequestWrapper.js'][24]++;
  self.status = 0;
  _$jscoverage['modules/XDomainRequestWrapper.js'][25]++;
  self.statusText = "";
  _$jscoverage['modules/XDomainRequestWrapper.js'][26]++;
  if (self.onreadystatechange) {
    _$jscoverage['modules/XDomainRequestWrapper.js'][27]++;
    self.onreadystatechange();
  }
});
  _$jscoverage['modules/XDomainRequestWrapper.js'][30]++;
  this.xdr.ontimeout = (function () {
  _$jscoverage['modules/XDomainRequestWrapper.js'][31]++;
  self.readyState = 4;
  _$jscoverage['modules/XDomainRequestWrapper.js'][32]++;
  self.status = 408;
  _$jscoverage['modules/XDomainRequestWrapper.js'][33]++;
  self.statusText = "timeout";
  _$jscoverage['modules/XDomainRequestWrapper.js'][34]++;
  if (self.onreadystatechange) {
    _$jscoverage['modules/XDomainRequestWrapper.js'][35]++;
    self.onreadystatechange();
  }
});
});
_$jscoverage['modules/XDomainRequestWrapper.js'][40]++;
XDomainRequestWrapper.prototype.open = (function (method, url, asyn) {
  _$jscoverage['modules/XDomainRequestWrapper.js'][41]++;
  this.xdr.open(method, url);
});
_$jscoverage['modules/XDomainRequestWrapper.js'][44]++;
XDomainRequestWrapper.prototype.send = (function (data) {
  _$jscoverage['modules/XDomainRequestWrapper.js'][45]++;
  this.xdr.send(data);
});
_$jscoverage['modules/XDomainRequestWrapper.js'][48]++;
XDomainRequestWrapper.prototype.abort = (function () {
  _$jscoverage['modules/XDomainRequestWrapper.js'][49]++;
  this.xdr.abort();
});
_$jscoverage['modules/XDomainRequestWrapper.js'][52]++;
XDomainRequestWrapper.prototype.setRequestHeader = (function (n, v) {
});
_$jscoverage['modules/XDomainRequestWrapper.js'][59]++;
XDomainRequestWrapper.prototype.getResponseHeader = (function (n) {
});
_$jscoverage['modules/XDomainRequestWrapper.js'][63]++;
module.exports = XDomainRequestWrapper;
_$jscoverage['modules/XDomainRequestWrapper.js'].source = ["var XDomainRequestWrapper = function(xdr){","  this.xdr = xdr;","  this.isWrapper = true;","  this.readyState = 0;","  this.onreadystatechange = null;","  this.status = 0;","  this.statusText = \"\";","  this.responseText = \"\";","  var self = this;","  this.xdr.onload = function(){","      self.readyState = 4;","      self.status = 200;","      self.statusText = \"\";","      self.responseText = self.xdr.responseText;","      if(self.onreadystatechange){","          self.onreadystatechange();","      }","  };","  this.xdr.onerror = function(){","      if(self.onerror){","          self.onerror();","      }","      self.readyState = 4;","      self.status = 0;","      self.statusText = \"\";","      if(self.onreadystatechange){","          self.onreadystatechange();","      }","  };","  this.xdr.ontimeout = function(){","      self.readyState = 4;","      self.status = 408;","      self.statusText = \"timeout\";","      if(self.onreadystatechange){","          self.onreadystatechange();","      }","  };","};","","XDomainRequestWrapper.prototype.open = function(method, url, asyn){","  this.xdr.open(method, url);","};","","XDomainRequestWrapper.prototype.send = function(data){","  this.xdr.send(data);","};","","XDomainRequestWrapper.prototype.abort = function(){","  this.xdr.abort();","};","","XDomainRequestWrapper.prototype.setRequestHeader = function(n, v){","  //not supported by xdr","  //Good doc on limitations of XDomainRequest http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx","  //XDomainRequest doesn't allow setting custom request headers. But it is the only available option to do CORS requests in IE8 &amp; 9. In IE10, they finally start to use standard XMLHttpRequest.","  //To support FH auth tokens in IE8&amp;9, we have to find a different way of doing it.","};","","XDomainRequestWrapper.prototype.getResponseHeader = function(n){","  //not supported by xdr","};","","module.exports = XDomainRequestWrapper;"];

},{}],54:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/ajax.js']) {
  _$jscoverage['modules/ajax.js'] = [];
  _$jscoverage['modules/ajax.js'][11] = 0;
  _$jscoverage['modules/ajax.js'][12] = 0;
  _$jscoverage['modules/ajax.js'][13] = 0;
  _$jscoverage['modules/ajax.js'][14] = 0;
  _$jscoverage['modules/ajax.js'][16] = 0;
  _$jscoverage['modules/ajax.js'][17] = 0;
  _$jscoverage['modules/ajax.js'][18] = 0;
  _$jscoverage['modules/ajax.js'][21] = 0;
  _$jscoverage['modules/ajax.js'][22] = 0;
  _$jscoverage['modules/ajax.js'][25] = 0;
  _$jscoverage['modules/ajax.js'][36] = 0;
  _$jscoverage['modules/ajax.js'][37] = 0;
  _$jscoverage['modules/ajax.js'][38] = 0;
  _$jscoverage['modules/ajax.js'][39] = 0;
  _$jscoverage['modules/ajax.js'][41] = 0;
  _$jscoverage['modules/ajax.js'][43] = 0;
  _$jscoverage['modules/ajax.js'][46] = 0;
  _$jscoverage['modules/ajax.js'][48] = 0;
  _$jscoverage['modules/ajax.js'][49] = 0;
  _$jscoverage['modules/ajax.js'][50] = 0;
  _$jscoverage['modules/ajax.js'][52] = 0;
  _$jscoverage['modules/ajax.js'][55] = 0;
  _$jscoverage['modules/ajax.js'][56] = 0;
  _$jscoverage['modules/ajax.js'][58] = 0;
  _$jscoverage['modules/ajax.js'][64] = 0;
  _$jscoverage['modules/ajax.js'][65] = 0;
  _$jscoverage['modules/ajax.js'][66] = 0;
  _$jscoverage['modules/ajax.js'][67] = 0;
  _$jscoverage['modules/ajax.js'][68] = 0;
  _$jscoverage['modules/ajax.js'][70] = 0;
  _$jscoverage['modules/ajax.js'][71] = 0;
  _$jscoverage['modules/ajax.js'][72] = 0;
  _$jscoverage['modules/ajax.js'][74] = 0;
  _$jscoverage['modules/ajax.js'][75] = 0;
  _$jscoverage['modules/ajax.js'][76] = 0;
  _$jscoverage['modules/ajax.js'][77] = 0;
  _$jscoverage['modules/ajax.js'][78] = 0;
  _$jscoverage['modules/ajax.js'][80] = 0;
  _$jscoverage['modules/ajax.js'][81] = 0;
  _$jscoverage['modules/ajax.js'][82] = 0;
  _$jscoverage['modules/ajax.js'][83] = 0;
  _$jscoverage['modules/ajax.js'][84] = 0;
  _$jscoverage['modules/ajax.js'][85] = 0;
  _$jscoverage['modules/ajax.js'][88] = 0;
  _$jscoverage['modules/ajax.js'][89] = 0;
  _$jscoverage['modules/ajax.js'][90] = 0;
  _$jscoverage['modules/ajax.js'][91] = 0;
  _$jscoverage['modules/ajax.js'][93] = 0;
  _$jscoverage['modules/ajax.js'][94] = 0;
  _$jscoverage['modules/ajax.js'][95] = 0;
  _$jscoverage['modules/ajax.js'][96] = 0;
  _$jscoverage['modules/ajax.js'][98] = 0;
  _$jscoverage['modules/ajax.js'][101] = 0;
  _$jscoverage['modules/ajax.js'][102] = 0;
  _$jscoverage['modules/ajax.js'][103] = 0;
  _$jscoverage['modules/ajax.js'][105] = 0;
  _$jscoverage['modules/ajax.js'][107] = 0;
  _$jscoverage['modules/ajax.js'][112] = 0;
  _$jscoverage['modules/ajax.js'][113] = 0;
  _$jscoverage['modules/ajax.js'][114] = 0;
  _$jscoverage['modules/ajax.js'][116] = 0;
  _$jscoverage['modules/ajax.js'][118] = 0;
  _$jscoverage['modules/ajax.js'][119] = 0;
  _$jscoverage['modules/ajax.js'][120] = 0;
  _$jscoverage['modules/ajax.js'][121] = 0;
  _$jscoverage['modules/ajax.js'][124] = 0;
  _$jscoverage['modules/ajax.js'][125] = 0;
  _$jscoverage['modules/ajax.js'][126] = 0;
  _$jscoverage['modules/ajax.js'][127] = 0;
  _$jscoverage['modules/ajax.js'][128] = 0;
  _$jscoverage['modules/ajax.js'][129] = 0;
  _$jscoverage['modules/ajax.js'][133] = 0;
  _$jscoverage['modules/ajax.js'][134] = 0;
  _$jscoverage['modules/ajax.js'][139] = 0;
  _$jscoverage['modules/ajax.js'][140] = 0;
  _$jscoverage['modules/ajax.js'][141] = 0;
  _$jscoverage['modules/ajax.js'][145] = 0;
  _$jscoverage['modules/ajax.js'][146] = 0;
  _$jscoverage['modules/ajax.js'][150] = 0;
  _$jscoverage['modules/ajax.js'][152] = 0;
  _$jscoverage['modules/ajax.js'][153] = 0;
  _$jscoverage['modules/ajax.js'][156] = 0;
  _$jscoverage['modules/ajax.js'][157] = 0;
  _$jscoverage['modules/ajax.js'][161] = 0;
  _$jscoverage['modules/ajax.js'][162] = 0;
  _$jscoverage['modules/ajax.js'][163] = 0;
  _$jscoverage['modules/ajax.js'][164] = 0;
  _$jscoverage['modules/ajax.js'][166] = 0;
  _$jscoverage['modules/ajax.js'][169] = 0;
  _$jscoverage['modules/ajax.js'][170] = 0;
  _$jscoverage['modules/ajax.js'][172] = 0;
  _$jscoverage['modules/ajax.js'][173] = 0;
  _$jscoverage['modules/ajax.js'][174] = 0;
  _$jscoverage['modules/ajax.js'][177] = 0;
  _$jscoverage['modules/ajax.js'][178] = 0;
  _$jscoverage['modules/ajax.js'][179] = 0;
  _$jscoverage['modules/ajax.js'][180] = 0;
  _$jscoverage['modules/ajax.js'][181] = 0;
  _$jscoverage['modules/ajax.js'][184] = 0;
  _$jscoverage['modules/ajax.js'][185] = 0;
  _$jscoverage['modules/ajax.js'][186] = 0;
  _$jscoverage['modules/ajax.js'][187] = 0;
  _$jscoverage['modules/ajax.js'][188] = 0;
  _$jscoverage['modules/ajax.js'][192] = 0;
  _$jscoverage['modules/ajax.js'][194] = 0;
  _$jscoverage['modules/ajax.js'][195] = 0;
  _$jscoverage['modules/ajax.js'][197] = 0;
  _$jscoverage['modules/ajax.js'][202] = 0;
  _$jscoverage['modules/ajax.js'][203] = 0;
  _$jscoverage['modules/ajax.js'][210] = 0;
  _$jscoverage['modules/ajax.js'][211] = 0;
  _$jscoverage['modules/ajax.js'][212] = 0;
  _$jscoverage['modules/ajax.js'][215] = 0;
  _$jscoverage['modules/ajax.js'][216] = 0;
  _$jscoverage['modules/ajax.js'][219] = 0;
  _$jscoverage['modules/ajax.js'][220] = 0;
  _$jscoverage['modules/ajax.js'][223] = 0;
  _$jscoverage['modules/ajax.js'][224] = 0;
  _$jscoverage['modules/ajax.js'][228] = 0;
  _$jscoverage['modules/ajax.js'][230] = 0;
  _$jscoverage['modules/ajax.js'][231] = 0;
  _$jscoverage['modules/ajax.js'][232] = 0;
  _$jscoverage['modules/ajax.js'][235] = 0;
  _$jscoverage['modules/ajax.js'][238] = 0;
  _$jscoverage['modules/ajax.js'][239] = 0;
  _$jscoverage['modules/ajax.js'][240] = 0;
  _$jscoverage['modules/ajax.js'][241] = 0;
  _$jscoverage['modules/ajax.js'][243] = 0;
  _$jscoverage['modules/ajax.js'][246] = 0;
  _$jscoverage['modules/ajax.js'][247] = 0;
  _$jscoverage['modules/ajax.js'][249] = 0;
  _$jscoverage['modules/ajax.js'][250] = 0;
  _$jscoverage['modules/ajax.js'][253] = 0;
  _$jscoverage['modules/ajax.js'][254] = 0;
  _$jscoverage['modules/ajax.js'][256] = 0;
  _$jscoverage['modules/ajax.js'][259] = 0;
  _$jscoverage['modules/ajax.js'][290] = 0;
  _$jscoverage['modules/ajax.js'][291] = 0;
  _$jscoverage['modules/ajax.js'][297] = 0;
  _$jscoverage['modules/ajax.js'][298] = 0;
  _$jscoverage['modules/ajax.js'][302] = 0;
  _$jscoverage['modules/ajax.js'][303] = 0;
  _$jscoverage['modules/ajax.js'][304] = 0;
  _$jscoverage['modules/ajax.js'][306] = 0;
  _$jscoverage['modules/ajax.js'][308] = 0;
  _$jscoverage['modules/ajax.js'][311] = 0;
  _$jscoverage['modules/ajax.js'][312] = 0;
  _$jscoverage['modules/ajax.js'][315] = 0;
  _$jscoverage['modules/ajax.js'][316] = 0;
  _$jscoverage['modules/ajax.js'][322] = 0;
  _$jscoverage['modules/ajax.js'][323] = 0;
  _$jscoverage['modules/ajax.js'][324] = 0;
  _$jscoverage['modules/ajax.js'][333] = 0;
  _$jscoverage['modules/ajax.js'][334] = 0;
  _$jscoverage['modules/ajax.js'][341] = 0;
  _$jscoverage['modules/ajax.js'][343] = 0;
  _$jscoverage['modules/ajax.js'][344] = 0;
  _$jscoverage['modules/ajax.js'][345] = 0;
  _$jscoverage['modules/ajax.js'][346] = 0;
  _$jscoverage['modules/ajax.js'][348] = 0;
  _$jscoverage['modules/ajax.js'][350] = 0;
  _$jscoverage['modules/ajax.js'][352] = 0;
  _$jscoverage['modules/ajax.js'][353] = 0;
  _$jscoverage['modules/ajax.js'][354] = 0;
  _$jscoverage['modules/ajax.js'][358] = 0;
  _$jscoverage['modules/ajax.js'][359] = 0;
  _$jscoverage['modules/ajax.js'][360] = 0;
  _$jscoverage['modules/ajax.js'][361] = 0;
  _$jscoverage['modules/ajax.js'][363] = 0;
  _$jscoverage['modules/ajax.js'][364] = 0;
  _$jscoverage['modules/ajax.js'][367] = 0;
  _$jscoverage['modules/ajax.js'][368] = 0;
  _$jscoverage['modules/ajax.js'][369] = 0;
  _$jscoverage['modules/ajax.js'][370] = 0;
  _$jscoverage['modules/ajax.js'][371] = 0;
  _$jscoverage['modules/ajax.js'][372] = 0;
  _$jscoverage['modules/ajax.js'][374] = 0;
}
_$jscoverage['modules/ajax.js'][11]++;
var eventsHandler = require("./events");
_$jscoverage['modules/ajax.js'][12]++;
var XDomainRequestWrapper = require("./XDomainRequestWrapper");
_$jscoverage['modules/ajax.js'][13]++;
var consts = require("./constants");
_$jscoverage['modules/ajax.js'][14]++;
var logger = require("./logger");
_$jscoverage['modules/ajax.js'][16]++;
var type;
_$jscoverage['modules/ajax.js'][17]++;
try {
  _$jscoverage['modules/ajax.js'][18]++;
  type = require("type-of");
}
catch (ex) {
  _$jscoverage['modules/ajax.js'][21]++;
  var r = require;
  _$jscoverage['modules/ajax.js'][22]++;
  type = r("type");
}
_$jscoverage['modules/ajax.js'][25]++;
var jsonpID = 0, document = window.document, key, name, rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, scriptTypeRE = /^(?:text|application)\/javascript/i, xmlTypeRE = /^(?:text|application)\/xml/i, jsonType = "application/json", htmlType = "text/html", blankRE = /^\s*$/;
_$jscoverage['modules/ajax.js'][36]++;
var ajax = module.exports = (function (options) {
  _$jscoverage['modules/ajax.js'][37]++;
  var settings = extend({}, options || {});
  _$jscoverage['modules/ajax.js'][38]++;
  for (key in ajax.settings) {
    _$jscoverage['modules/ajax.js'][39]++;
    if (settings[key] === undefined) {
      _$jscoverage['modules/ajax.js'][39]++;
      settings[key] = ajax.settings[key];
    }
}
  _$jscoverage['modules/ajax.js'][41]++;
  ajaxStart(settings);
  _$jscoverage['modules/ajax.js'][43]++;
  if (! settings.crossDomain) {
    _$jscoverage['modules/ajax.js'][43]++;
    settings.crossDomain = /^([\w-]+:)?\/\/([^\/]+)/.test(settings.url) && RegExp.$2 != window.location.host;
  }
  _$jscoverage['modules/ajax.js'][46]++;
  var dataType = settings.dataType, hasPlaceholder = /=\?/.test(settings.url);
  _$jscoverage['modules/ajax.js'][48]++;
  if (dataType == "jsonp" || hasPlaceholder) {
    _$jscoverage['modules/ajax.js'][49]++;
    if (! hasPlaceholder) {
      _$jscoverage['modules/ajax.js'][50]++;
      settings.url = appendQuery(settings.url, (settings.jsonp? settings.jsonp: "_callback") + "=?");
    }
    _$jscoverage['modules/ajax.js'][52]++;
    return ajax.JSONP(settings);
  }
  _$jscoverage['modules/ajax.js'][55]++;
  if (! settings.url) {
    _$jscoverage['modules/ajax.js'][55]++;
    settings.url = window.location.toString();
  }
  _$jscoverage['modules/ajax.js'][56]++;
  serializeData(settings);
  _$jscoverage['modules/ajax.js'][58]++;
  var mime = settings.accepts[dataType], baseHeaders = {}, protocol = /^([\w-]+:)\/\//.test(settings.url)? RegExp.$1: window.location.protocol, xhr = settings.xhr(settings.crossDomain), abortTimeout;
  _$jscoverage['modules/ajax.js'][64]++;
  if (! settings.crossDomain) {
    _$jscoverage['modules/ajax.js'][64]++;
    baseHeaders["X-Requested-With"] = "XMLHttpRequest";
  }
  _$jscoverage['modules/ajax.js'][65]++;
  if (mime) {
    _$jscoverage['modules/ajax.js'][66]++;
    baseHeaders.Accept = mime;
    _$jscoverage['modules/ajax.js'][67]++;
    if (mime.indexOf(",") > -1) {
      _$jscoverage['modules/ajax.js'][67]++;
      mime = mime.split(",", 2)[0];
    }
    _$jscoverage['modules/ajax.js'][68]++;
    xhr.overrideMimeType && xhr.overrideMimeType(mime);
  }
  _$jscoverage['modules/ajax.js'][70]++;
  if (settings.contentType || (settings.data && ! settings.formdata && settings.type.toUpperCase() != "GET")) {
    _$jscoverage['modules/ajax.js'][71]++;
    baseHeaders["Content-Type"] = (settings.contentType || "application/x-www-form-urlencoded");
  }
  _$jscoverage['modules/ajax.js'][72]++;
  settings.headers = extend(baseHeaders, settings.headers || {});
  _$jscoverage['modules/ajax.js'][74]++;
  xhr.onreadystatechange = (function () {
  _$jscoverage['modules/ajax.js'][75]++;
  if (xhr.readyState == 4) {
    _$jscoverage['modules/ajax.js'][76]++;
    clearTimeout(abortTimeout);
    _$jscoverage['modules/ajax.js'][77]++;
    var result, error = false;
    _$jscoverage['modules/ajax.js'][78]++;
    if (settings.tryJSONP) {
      _$jscoverage['modules/ajax.js'][80]++;
      if (xhr.status === 0 && settings.crossDomain && ! xhr.isTimeout && protocol != "file:") {
        _$jscoverage['modules/ajax.js'][81]++;
        logger.debug("retry ajax call with jsonp");
        _$jscoverage['modules/ajax.js'][82]++;
        settings.type = "GET";
        _$jscoverage['modules/ajax.js'][83]++;
        settings.dataType = "jsonp";
        _$jscoverage['modules/ajax.js'][84]++;
        settings.data = "_jsonpdata=" + settings.data;
        _$jscoverage['modules/ajax.js'][85]++;
        return ajax(settings);
      }
    }
    _$jscoverage['modules/ajax.js'][88]++;
    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == "file:")) {
      _$jscoverage['modules/ajax.js'][89]++;
      dataType = dataType || mimeToDataType(xhr.getResponseHeader("content-type"));
      _$jscoverage['modules/ajax.js'][90]++;
      result = xhr.responseText;
      _$jscoverage['modules/ajax.js'][91]++;
      logger.debug("ajax response :: status = " + xhr.status + " :: body = " + result);
      _$jscoverage['modules/ajax.js'][93]++;
      try {
        _$jscoverage['modules/ajax.js'][94]++;
        if (dataType == "script") {
          _$jscoverage['modules/ajax.js'][94]++;
          (1, eval)(result);
        }
        else {
          _$jscoverage['modules/ajax.js'][95]++;
          if (dataType == "xml") {
            _$jscoverage['modules/ajax.js'][95]++;
            result = xhr.responseXML;
          }
          else {
            _$jscoverage['modules/ajax.js'][96]++;
            if (dataType == "json") {
              _$jscoverage['modules/ajax.js'][96]++;
              result = blankRE.test(result)? null: JSON.parse(result);
            }
          }
        }
      }
      catch (e) {
        _$jscoverage['modules/ajax.js'][98]++;
        error = e;
      }
      _$jscoverage['modules/ajax.js'][101]++;
      if (error) {
        _$jscoverage['modules/ajax.js'][102]++;
        logger.debug("ajax error", error);
        _$jscoverage['modules/ajax.js'][103]++;
        ajaxError(error, "parsererror", xhr, settings);
      }
      else {
        _$jscoverage['modules/ajax.js'][105]++;
        ajaxSuccess(result, xhr, settings);
      }
    }
    else {
      _$jscoverage['modules/ajax.js'][107]++;
      ajaxError(null, "error", xhr, settings);
    }
  }
});
  _$jscoverage['modules/ajax.js'][112]++;
  var async = "async" in settings? settings.async: true;
  _$jscoverage['modules/ajax.js'][113]++;
  logger.debug("ajax call settings", settings);
  _$jscoverage['modules/ajax.js'][114]++;
  xhr.open(settings.type, settings.url, async);
  _$jscoverage['modules/ajax.js'][116]++;
  for (name in settings.headers) {
    _$jscoverage['modules/ajax.js'][116]++;
    xhr.setRequestHeader(name, settings.headers[name]);
}
  _$jscoverage['modules/ajax.js'][118]++;
  if (ajaxBeforeSend(xhr, settings) === false) {
    _$jscoverage['modules/ajax.js'][119]++;
    logger.debug("ajax call is aborted due to ajaxBeforeSend");
    _$jscoverage['modules/ajax.js'][120]++;
    xhr.abort();
    _$jscoverage['modules/ajax.js'][121]++;
    return false;
  }
  _$jscoverage['modules/ajax.js'][124]++;
  if (settings.timeout > 0) {
    _$jscoverage['modules/ajax.js'][124]++;
    abortTimeout = setTimeout((function () {
  _$jscoverage['modules/ajax.js'][125]++;
  logger.debug("ajax call timed out");
  _$jscoverage['modules/ajax.js'][126]++;
  xhr.onreadystatechange = empty;
  _$jscoverage['modules/ajax.js'][127]++;
  xhr.abort();
  _$jscoverage['modules/ajax.js'][128]++;
  xhr.isTimeout = true;
  _$jscoverage['modules/ajax.js'][129]++;
  ajaxError(null, "timeout", xhr, settings);
}), settings.timeout);
  }
  _$jscoverage['modules/ajax.js'][133]++;
  xhr.send(settings.data? settings.data: null);
  _$jscoverage['modules/ajax.js'][134]++;
  return xhr;
});
_$jscoverage['modules/ajax.js'][139]++;
function triggerAndReturn(context, eventName, data) {
  _$jscoverage['modules/ajax.js'][140]++;
  eventsHandler.emit(eventName, data);
  _$jscoverage['modules/ajax.js'][141]++;
  return true;
}
_$jscoverage['modules/ajax.js'][145]++;
function triggerGlobal(settings, context, eventName, data) {
  _$jscoverage['modules/ajax.js'][146]++;
  if (settings.global) {
    _$jscoverage['modules/ajax.js'][146]++;
    return triggerAndReturn(context || document, eventName, data);
  }
}
_$jscoverage['modules/ajax.js'][150]++;
ajax.active = 0;
_$jscoverage['modules/ajax.js'][152]++;
function ajaxStart(settings) {
  _$jscoverage['modules/ajax.js'][153]++;
  if (settings.global && ajax.active++ === 0) {
    _$jscoverage['modules/ajax.js'][153]++;
    triggerGlobal(settings, null, "ajaxStart");
  }
}
_$jscoverage['modules/ajax.js'][156]++;
function ajaxStop(settings) {
  _$jscoverage['modules/ajax.js'][157]++;
  if (settings.global && ! (--ajax.active)) {
    _$jscoverage['modules/ajax.js'][157]++;
    triggerGlobal(settings, null, "ajaxStop");
  }
}
_$jscoverage['modules/ajax.js'][161]++;
function ajaxBeforeSend(xhr, settings) {
  _$jscoverage['modules/ajax.js'][162]++;
  var context = settings.context;
  _$jscoverage['modules/ajax.js'][163]++;
  if (settings.beforeSend.call(context, xhr, settings) === false) {
    _$jscoverage['modules/ajax.js'][164]++;
    return false;
  }
  _$jscoverage['modules/ajax.js'][166]++;
  triggerGlobal(settings, context, "ajaxSend", [xhr, settings]);
}
_$jscoverage['modules/ajax.js'][169]++;
function ajaxSuccess(data, xhr, settings) {
  _$jscoverage['modules/ajax.js'][170]++;
  var context = settings.context, status = "success";
  _$jscoverage['modules/ajax.js'][172]++;
  settings.success.call(context, data, status, xhr);
  _$jscoverage['modules/ajax.js'][173]++;
  triggerGlobal(settings, context, "ajaxSuccess", [xhr, settings, data]);
  _$jscoverage['modules/ajax.js'][174]++;
  ajaxComplete(status, xhr, settings);
}
_$jscoverage['modules/ajax.js'][177]++;
function ajaxError(error, type, xhr, settings) {
  _$jscoverage['modules/ajax.js'][178]++;
  var context = settings.context;
  _$jscoverage['modules/ajax.js'][179]++;
  settings.error.call(context, xhr, type, error);
  _$jscoverage['modules/ajax.js'][180]++;
  triggerGlobal(settings, context, "ajaxError", [xhr, settings, error]);
  _$jscoverage['modules/ajax.js'][181]++;
  ajaxComplete(type, xhr, settings);
}
_$jscoverage['modules/ajax.js'][184]++;
function ajaxComplete(status, xhr, settings) {
  _$jscoverage['modules/ajax.js'][185]++;
  var context = settings.context;
  _$jscoverage['modules/ajax.js'][186]++;
  settings.complete.call(context, xhr, status);
  _$jscoverage['modules/ajax.js'][187]++;
  triggerGlobal(settings, context, "ajaxComplete", [xhr, settings]);
  _$jscoverage['modules/ajax.js'][188]++;
  ajaxStop(settings);
}
_$jscoverage['modules/ajax.js'][192]++;
function empty() {
}
_$jscoverage['modules/ajax.js'][194]++;
ajax.JSONP = (function (options) {
  _$jscoverage['modules/ajax.js'][195]++;
  if (! ("type" in options)) {
    _$jscoverage['modules/ajax.js'][195]++;
    return ajax(options);
  }
  _$jscoverage['modules/ajax.js'][197]++;
  var callbackName = "jsonp" + (++jsonpID), script = document.createElement("script"), abort = (function () {
  _$jscoverage['modules/ajax.js'][202]++;
  if (callbackName in window) {
    _$jscoverage['modules/ajax.js'][202]++;
    window[callbackName] = empty;
  }
  _$jscoverage['modules/ajax.js'][203]++;
  ajaxComplete("abort", xhr, options);
}), xhr = {abort: abort}, abortTimeout, head = document.getElementsByTagName("head")[0] || document.documentElement;
  _$jscoverage['modules/ajax.js'][210]++;
  if (options.error) {
    _$jscoverage['modules/ajax.js'][210]++;
    script.onerror = (function () {
  _$jscoverage['modules/ajax.js'][211]++;
  xhr.abort();
  _$jscoverage['modules/ajax.js'][212]++;
  options.error();
});
  }
  _$jscoverage['modules/ajax.js'][215]++;
  window[callbackName] = (function (data) {
  _$jscoverage['modules/ajax.js'][216]++;
  clearTimeout(abortTimeout);
  _$jscoverage['modules/ajax.js'][219]++;
  delete window[callbackName];
  _$jscoverage['modules/ajax.js'][220]++;
  ajaxSuccess(data, xhr, options);
});
  _$jscoverage['modules/ajax.js'][223]++;
  serializeData(options);
  _$jscoverage['modules/ajax.js'][224]++;
  script.src = options.url.replace(/=\?/, "=" + callbackName);
  _$jscoverage['modules/ajax.js'][228]++;
  head.insertBefore(script, head.firstChild);
  _$jscoverage['modules/ajax.js'][230]++;
  if (options.timeout > 0) {
    _$jscoverage['modules/ajax.js'][230]++;
    abortTimeout = setTimeout((function () {
  _$jscoverage['modules/ajax.js'][231]++;
  xhr.abort();
  _$jscoverage['modules/ajax.js'][232]++;
  ajaxComplete("timeout", xhr, options);
}), options.timeout);
  }
  _$jscoverage['modules/ajax.js'][235]++;
  return xhr;
});
_$jscoverage['modules/ajax.js'][238]++;
function isIE() {
  _$jscoverage['modules/ajax.js'][239]++;
  var ie = false;
  _$jscoverage['modules/ajax.js'][240]++;
  if (navigator.userAgent && navigator.userAgent.indexOf("MSIE") >= 0) {
    _$jscoverage['modules/ajax.js'][241]++;
    ie = true;
  }
  _$jscoverage['modules/ajax.js'][243]++;
  return ie;
}
_$jscoverage['modules/ajax.js'][246]++;
function getXhr(crossDomain) {
  _$jscoverage['modules/ajax.js'][247]++;
  var xhr = null;
  _$jscoverage['modules/ajax.js'][249]++;
  if (window.XMLHttpRequest) {
    _$jscoverage['modules/ajax.js'][250]++;
    xhr = new XMLHttpRequest();
  }
  _$jscoverage['modules/ajax.js'][253]++;
  if (isIE() && (crossDomain === true) && typeof window.XDomainRequest !== "undefined") {
    _$jscoverage['modules/ajax.js'][254]++;
    xhr = new XDomainRequestWrapper(new XDomainRequest());
  }
  _$jscoverage['modules/ajax.js'][256]++;
  return xhr;
}
_$jscoverage['modules/ajax.js'][259]++;
ajax.settings = {type: "GET", beforeSend: empty, success: empty, error: empty, complete: empty, context: null, global: true, xhr: getXhr, accepts: {script: "text/javascript, application/javascript", json: jsonType, xml: "application/xml, text/xml", html: htmlType, text: "text/plain"}, crossDomain: false, timeout: consts.fh_timeout};
_$jscoverage['modules/ajax.js'][290]++;
function mimeToDataType(mime) {
  _$jscoverage['modules/ajax.js'][291]++;
  return mime && (mime == htmlType? "html": mime == jsonType? "json": scriptTypeRE.test(mime)? "script": xmlTypeRE.test(mime) && "xml") || "text";
}
_$jscoverage['modules/ajax.js'][297]++;
function appendQuery(url, query) {
  _$jscoverage['modules/ajax.js'][298]++;
  return (url + "&" + query).replace(/[&?]{1,2}/, "?");
}
_$jscoverage['modules/ajax.js'][302]++;
function serializeData(options) {
  _$jscoverage['modules/ajax.js'][303]++;
  if (type(options.data) === "object") {
    _$jscoverage['modules/ajax.js'][304]++;
    if (typeof options.data.append === "function") {
      _$jscoverage['modules/ajax.js'][306]++;
      options.formdata = true;
    }
    else {
      _$jscoverage['modules/ajax.js'][308]++;
      options.data = param(options.data);
    }
  }
  _$jscoverage['modules/ajax.js'][311]++;
  if (options.data && (! options.type || options.type.toUpperCase() == "GET")) {
    _$jscoverage['modules/ajax.js'][312]++;
    options.url = appendQuery(options.url, options.data);
  }
}
_$jscoverage['modules/ajax.js'][315]++;
ajax.get = (function (url, success) {
  _$jscoverage['modules/ajax.js'][316]++;
  return ajax({url: url, success: success});
});
_$jscoverage['modules/ajax.js'][322]++;
ajax.post = (function (url, data, success, dataType) {
  _$jscoverage['modules/ajax.js'][323]++;
  if (type(data) === "function") {
    _$jscoverage['modules/ajax.js'][323]++;
    dataType = dataType || success, success = data, data = null;
  }
  _$jscoverage['modules/ajax.js'][324]++;
  return ajax({type: "POST", url: url, data: data, success: success, dataType: dataType});
});
_$jscoverage['modules/ajax.js'][333]++;
ajax.getJSON = (function (url, success) {
  _$jscoverage['modules/ajax.js'][334]++;
  return ajax({url: url, success: success, dataType: "json"});
});
_$jscoverage['modules/ajax.js'][341]++;
var escape = encodeURIComponent;
_$jscoverage['modules/ajax.js'][343]++;
function serialize(params, obj, traditional, scope) {
  _$jscoverage['modules/ajax.js'][344]++;
  var array = type(obj) === "array";
  _$jscoverage['modules/ajax.js'][345]++;
  for (var key in obj) {
    _$jscoverage['modules/ajax.js'][346]++;
    var value = obj[key];
    _$jscoverage['modules/ajax.js'][348]++;
    if (scope) {
      _$jscoverage['modules/ajax.js'][348]++;
      key = traditional? scope: scope + "[" + (array? "": key) + "]";
    }
    _$jscoverage['modules/ajax.js'][350]++;
    if (! scope && array) {
      _$jscoverage['modules/ajax.js'][350]++;
      params.add(value.name, value.value);
    }
    else {
      _$jscoverage['modules/ajax.js'][352]++;
      if (traditional? (type(value) === "array"): (type(value) === "object")) {
        _$jscoverage['modules/ajax.js'][353]++;
        serialize(params, value, traditional, key);
      }
      else {
        _$jscoverage['modules/ajax.js'][354]++;
        params.add(key, value);
      }
    }
}
}
_$jscoverage['modules/ajax.js'][358]++;
function param(obj, traditional) {
  _$jscoverage['modules/ajax.js'][359]++;
  var params = [];
  _$jscoverage['modules/ajax.js'][360]++;
  params.add = (function (k, v) {
  _$jscoverage['modules/ajax.js'][361]++;
  this.push(escape(k) + "=" + escape(v));
});
  _$jscoverage['modules/ajax.js'][363]++;
  serialize(params, obj, traditional);
  _$jscoverage['modules/ajax.js'][364]++;
  return params.join("&").replace("%20", "+");
}
_$jscoverage['modules/ajax.js'][367]++;
function extend(target) {
  _$jscoverage['modules/ajax.js'][368]++;
  var slice = Array.prototype.slice;
  _$jscoverage['modules/ajax.js'][369]++;
  slice.call(arguments, 1).forEach((function (source) {
  _$jscoverage['modules/ajax.js'][370]++;
  for (key in source) {
    _$jscoverage['modules/ajax.js'][371]++;
    if (source[key] !== undefined) {
      _$jscoverage['modules/ajax.js'][372]++;
      target[key] = source[key];
    }
}
}));
  _$jscoverage['modules/ajax.js'][374]++;
  return target;
}
_$jscoverage['modules/ajax.js'].source = ["//a shameless copy from https://github.com/ForbesLindesay/ajax/blob/master/index.js. ","//it has the same methods and config options as jQuery/zeptojs but very light weight. see http://api.jquery.com/jQuery.ajax/","//a few small changes are made for supporting IE 8 and other features:","//1. use getXhr function to replace the default XMLHttpRequest implementation for supporting IE8","//2. Integrate with events emitter. So to subscribe ajax events, you can do $fh.on(\"ajaxStart\", handler). See http://api.jquery.com/Ajax_Events/ for full list of events","//3. allow passing xhr factory method through options: e.g. $fh.ajax({xhr: function(){/*own implementation of xhr*/}}); ","//4. Use fh_timeout value as the default timeout","//5. an extra option called \"tryJSONP\" to allow try the same call with JSONP if normal CORS failed - should only be used internally","//6. for jsonp, allow to specify the callback query param name using the \"jsonp\" option","","var eventsHandler = require(\"./events\");","var XDomainRequestWrapper = require(\"./XDomainRequestWrapper\");","var consts = require(\"./constants\");","var logger = require(\"./logger\");","","var type","try {","  type = require('type-of')","} catch (ex) {","  //hide from browserify","  var r = require","  type = r('type')","}","","var jsonpID = 0,","  document = window.document,","  key,","  name,","  rscript = /&lt;script\\b[^&lt;]*(?:(?!&lt;\\/script&gt;)&lt;[^&lt;]*)*&lt;\\/script&gt;/gi,","  scriptTypeRE = /^(?:text|application)\\/javascript/i,","  xmlTypeRE = /^(?:text|application)\\/xml/i,","  jsonType = 'application/json',","  htmlType = 'text/html',","  blankRE = /^\\s*$/;","","var ajax = module.exports = function (options) {","  var settings = extend({}, options || {})","  for (key in ajax.settings)","    if (settings[key] === undefined) settings[key] = ajax.settings[key]","","  ajaxStart(settings)","","  if (!settings.crossDomain) settings.crossDomain = /^([\\w-]+:)?\\/\\/([^\\/]+)/.test(settings.url) &amp;&amp;","    RegExp.$2 != window.location.host","","  var dataType = settings.dataType,","    hasPlaceholder = /=\\?/.test(settings.url)","    if (dataType == 'jsonp' || hasPlaceholder) {","      if (!hasPlaceholder) {","        settings.url = appendQuery(settings.url, (settings.jsonp? settings.jsonp: '_callback') + '=?');","      }","      return ajax.JSONP(settings)","    }","","  if (!settings.url) settings.url = window.location.toString()","  serializeData(settings)","","  var mime = settings.accepts[dataType],","    baseHeaders = {},","    protocol = /^([\\w-]+:)\\/\\//.test(settings.url) ? RegExp.$1 : window.location.protocol,","    xhr = settings.xhr(settings.crossDomain),","    abortTimeout","","  if (!settings.crossDomain) baseHeaders['X-Requested-With'] = 'XMLHttpRequest'","  if (mime) {","    baseHeaders['Accept'] = mime","    if (mime.indexOf(',') &gt; -1) mime = mime.split(',', 2)[0]","    xhr.overrideMimeType &amp;&amp; xhr.overrideMimeType(mime)","  }","  if (settings.contentType || (settings.data &amp;&amp; !settings.formdata &amp;&amp; settings.type.toUpperCase() != 'GET'))","    baseHeaders['Content-Type'] = (settings.contentType || 'application/x-www-form-urlencoded')","  settings.headers = extend(baseHeaders, settings.headers || {})","","  xhr.onreadystatechange = function () {","    if (xhr.readyState == 4) {","      clearTimeout(abortTimeout)","      var result, error = false","      if(settings.tryJSONP){","        //check if the request has fail. In some cases, we may want to try jsonp as well. Again, FH only...","        if(xhr.status === 0 &amp;&amp; settings.crossDomain &amp;&amp; !xhr.isTimeout &amp;&amp;  protocol != 'file:'){","          logger.debug(\"retry ajax call with jsonp\")","          settings.type = \"GET\";","          settings.dataType = \"jsonp\";","          settings.data = \"_jsonpdata=\" + settings.data;","          return ajax(settings);","        }","      }","      if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304 || (xhr.status == 0 &amp;&amp; protocol == 'file:')) {","        dataType = dataType || mimeToDataType(xhr.getResponseHeader('content-type'))","        result = xhr.responseText","        logger.debug(\"ajax response :: status = \" + xhr.status + \" :: body = \" + result)","","        try {","          if (dataType == 'script')(1, eval)(result)","          else if (dataType == 'xml') result = xhr.responseXML","          else if (dataType == 'json') result = blankRE.test(result) ? null : JSON.parse(result)","        } catch (e) {","          error = e","        }","","        if (error) {","          logger.debug(\"ajax error\", error);","          ajaxError(error, 'parsererror', xhr, settings)","        }","        else ajaxSuccess(result, xhr, settings)","      } else {","        ajaxError(null, 'error', xhr, settings)","      }","    }","  }","","  var async = 'async' in settings ? settings.async : true","  logger.debug(\"ajax call settings\", settings)","  xhr.open(settings.type, settings.url, async)","","  for (name in settings.headers) xhr.setRequestHeader(name, settings.headers[name])","","  if (ajaxBeforeSend(xhr, settings) === false) {","    logger.debug(\"ajax call is aborted due to ajaxBeforeSend\")","    xhr.abort()","    return false","  }","","  if (settings.timeout &gt; 0) abortTimeout = setTimeout(function () {","    logger.debug(\"ajax call timed out\")","    xhr.onreadystatechange = empty","    xhr.abort()","    xhr.isTimeout = true","    ajaxError(null, 'timeout', xhr, settings)","  }, settings.timeout)","","  // avoid sending empty string (#319)","  xhr.send(settings.data ? settings.data : null)","  return xhr","}","","","// trigger a custom event and return true","function triggerAndReturn(context, eventName, data) {","  eventsHandler.emit(eventName, data);","  return true;","}","","// trigger an Ajax \"global\" event","function triggerGlobal(settings, context, eventName, data) {","  if (settings.global) return triggerAndReturn(context || document, eventName, data)","}","","// Number of active Ajax requests","ajax.active = 0","","function ajaxStart(settings) {","  if (settings.global &amp;&amp; ajax.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')","}","","function ajaxStop(settings) {","  if (settings.global &amp;&amp; !(--ajax.active)) triggerGlobal(settings, null, 'ajaxStop')","}","","// triggers an extra global event \"ajaxBeforeSend\" that's like \"ajaxSend\" but cancelable","function ajaxBeforeSend(xhr, settings) {","  var context = settings.context","  if (settings.beforeSend.call(context, xhr, settings) === false)","    return false","","  triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])","}","","function ajaxSuccess(data, xhr, settings) {","  var context = settings.context,","    status = 'success'","  settings.success.call(context, data, status, xhr)","  triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])","  ajaxComplete(status, xhr, settings)","}","// type: \"timeout\", \"error\", \"abort\", \"parsererror\"","function ajaxError(error, type, xhr, settings) {","  var context = settings.context","  settings.error.call(context, xhr, type, error)","  triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error])","  ajaxComplete(type, xhr, settings)","}","// status: \"success\", \"notmodified\", \"error\", \"timeout\", \"abort\", \"parsererror\"","function ajaxComplete(status, xhr, settings) {","  var context = settings.context","  settings.complete.call(context, xhr, status)","  triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])","  ajaxStop(settings)","}","","// Empty function, used as default callback","function empty() {}","","ajax.JSONP = function (options) {","  if (!('type' in options)) return ajax(options)","","  var callbackName = 'jsonp' + (++jsonpID),","    script = document.createElement('script'),","    abort = function () {","      //todo: remove script","      //$(script).remove()","      if (callbackName in window) window[callbackName] = empty","      ajaxComplete('abort', xhr, options)","    },","    xhr = {","      abort: abort","    }, abortTimeout,","    head = document.getElementsByTagName(\"head\")[0] || document.documentElement","","  if (options.error) script.onerror = function () {","    xhr.abort()","    options.error()","  }","","  window[callbackName] = function (data) {","    clearTimeout(abortTimeout)","    //todo: remove script","    //$(script).remove()","    delete window[callbackName]","    ajaxSuccess(data, xhr, options)","  }","","  serializeData(options)","  script.src = options.url.replace(/=\\?/, '=' + callbackName)","","  // Use insertBefore instead of appendChild to circumvent an IE6 bug.","  // This arises when a base node is used (see jQuery bugs #2709 and #4378).","  head.insertBefore(script, head.firstChild);","","  if (options.timeout &gt; 0) abortTimeout = setTimeout(function () {","    xhr.abort()","    ajaxComplete('timeout', xhr, options)","  }, options.timeout)","","  return xhr","}","","function isIE(){","  var ie = false;","  if(navigator.userAgent &amp;&amp; navigator.userAgent.indexOf(\"MSIE\") &gt;=0 ){","    ie = true;","  }","  return ie;","}","","function getXhr(crossDomain){","  var xhr = null;","  //always use XMLHttpRequest if available","  if(window.XMLHttpRequest){","    xhr = new XMLHttpRequest();","  }","  //for IE8","  if(isIE() &amp;&amp; (crossDomain === true) &amp;&amp; typeof window.XDomainRequest !== \"undefined\"){","    xhr = new XDomainRequestWrapper(new XDomainRequest());","  }","  return xhr;","}","","ajax.settings = {","  // Default type of request","  type: 'GET',","  // Callback that is executed before request","  beforeSend: empty,","  // Callback that is executed if the request succeeds","  success: empty,","  // Callback that is executed the the server drops error","  error: empty,","  // Callback that is executed on request complete (both: error and success)","  complete: empty,","  // The context for the callbacks","  context: null,","  // Whether to trigger \"global\" Ajax events","  global: true,","  // Transport","  xhr: getXhr,","  // MIME types mapping","  accepts: {","    script: 'text/javascript, application/javascript',","    json: jsonType,","    xml: 'application/xml, text/xml',","    html: htmlType,","    text: 'text/plain'","  },","  // Whether the request is to another domain","  crossDomain: false,","  // Default timeout","  timeout: consts.fh_timeout","}","","function mimeToDataType(mime) {","  return mime &amp;&amp; (mime == htmlType ? 'html' :","    mime == jsonType ? 'json' :","    scriptTypeRE.test(mime) ? 'script' :","    xmlTypeRE.test(mime) &amp;&amp; 'xml') || 'text'","}","","function appendQuery(url, query) {","  return (url + '&amp;' + query).replace(/[&amp;?]{1,2}/, '?')","}","","// serialize payload and append it to the URL for GET requests","function serializeData(options) {","  if (type(options.data) === 'object') {","    if(typeof options.data.append === \"function\"){","      //we are dealing with FormData, do not serialize","      options.formdata = true;","    } else {","      options.data = param(options.data)","    }","  }","  if (options.data &amp;&amp; (!options.type || options.type.toUpperCase() == 'GET'))","    options.url = appendQuery(options.url, options.data)","}","","ajax.get = function (url, success) {","  return ajax({","    url: url,","    success: success","  })","}","","ajax.post = function (url, data, success, dataType) {","  if (type(data) === 'function') dataType = dataType || success, success = data, data = null","  return ajax({","    type: 'POST',","    url: url,","    data: data,","    success: success,","    dataType: dataType","  })","}","","ajax.getJSON = function (url, success) {","  return ajax({","    url: url,","    success: success,","    dataType: 'json'","  })","}","","var escape = encodeURIComponent;","","function serialize(params, obj, traditional, scope) {","  var array = type(obj) === 'array';","  for (var key in obj) {","    var value = obj[key];","","    if (scope) key = traditional ? scope : scope + '[' + (array ? '' : key) + ']'","    // handle data in serializeArray() format","    if (!scope &amp;&amp; array) params.add(value.name, value.value)","    // recurse into nested objects","    else if (traditional ? (type(value) === 'array') : (type(value) === 'object'))","      serialize(params, value, traditional, key)","    else params.add(key, value)","  }","}","","function param(obj, traditional) {","  var params = []","  params.add = function (k, v) {","    this.push(escape(k) + '=' + escape(v))","  }","  serialize(params, obj, traditional)","  return params.join('&amp;').replace('%20', '+')","}","","function extend(target) {","  var slice = Array.prototype.slice;","  slice.call(arguments, 1).forEach(function (source) {","    for (key in source)","      if (source[key] !== undefined)","        target[key] = source[key]","  })","  return target","}"];

},{"./XDomainRequestWrapper":53,"./constants":58,"./events":61,"./logger":68,"type-of":51}],55:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/api_act.js']) {
  _$jscoverage['modules/api_act.js'] = [];
  _$jscoverage['modules/api_act.js'][1] = 0;
  _$jscoverage['modules/api_act.js'][2] = 0;
  _$jscoverage['modules/api_act.js'][3] = 0;
  _$jscoverage['modules/api_act.js'][4] = 0;
  _$jscoverage['modules/api_act.js'][5] = 0;
  _$jscoverage['modules/api_act.js'][6] = 0;
  _$jscoverage['modules/api_act.js'][8] = 0;
  _$jscoverage['modules/api_act.js'][9] = 0;
  _$jscoverage['modules/api_act.js'][10] = 0;
  _$jscoverage['modules/api_act.js'][11] = 0;
  _$jscoverage['modules/api_act.js'][12] = 0;
  _$jscoverage['modules/api_act.js'][13] = 0;
  _$jscoverage['modules/api_act.js'][23] = 0;
  _$jscoverage['modules/api_act.js'][28] = 0;
  _$jscoverage['modules/api_act.js'][29] = 0;
  _$jscoverage['modules/api_act.js'][30] = 0;
  _$jscoverage['modules/api_act.js'][31] = 0;
  _$jscoverage['modules/api_act.js'][32] = 0;
  _$jscoverage['modules/api_act.js'][36] = 0;
  _$jscoverage['modules/api_act.js'][37] = 0;
  _$jscoverage['modules/api_act.js'][40] = 0;
  _$jscoverage['modules/api_act.js'][41] = 0;
  _$jscoverage['modules/api_act.js'][42] = 0;
  _$jscoverage['modules/api_act.js'][43] = 0;
  _$jscoverage['modules/api_act.js'][45] = 0;
}
_$jscoverage['modules/api_act.js'][1]++;
var logger = require("./logger");
_$jscoverage['modules/api_act.js'][2]++;
var cloud = require("./waitForCloud");
_$jscoverage['modules/api_act.js'][3]++;
var fhparams = require("./fhparams");
_$jscoverage['modules/api_act.js'][4]++;
var ajax = require("./ajax");
_$jscoverage['modules/api_act.js'][5]++;
var JSON = require("JSON");
_$jscoverage['modules/api_act.js'][6]++;
var handleError = require("./handleError");
_$jscoverage['modules/api_act.js'][8]++;
function doActCall(opts, success, fail) {
  _$jscoverage['modules/api_act.js'][9]++;
  var cloud_host = cloud.getCloudHost();
  _$jscoverage['modules/api_act.js'][10]++;
  var url = cloud_host.getActUrl(opts.act);
  _$jscoverage['modules/api_act.js'][11]++;
  var params = opts.req || {};
  _$jscoverage['modules/api_act.js'][12]++;
  params = fhparams.addFHParams(params);
  _$jscoverage['modules/api_act.js'][13]++;
  return ajax({"url": url, "tryJSONP": true, "type": "POST", "dataType": "json", "data": JSON.stringify(params), "contentType": "application/json", "timeout": opts.timeout, "success": success, "error": (function (req, statusText, error) {
  _$jscoverage['modules/api_act.js'][23]++;
  return handleError(fail, req, statusText, error);
})});
}
_$jscoverage['modules/api_act.js'][28]++;
module.exports = (function (opts, success, fail) {
  _$jscoverage['modules/api_act.js'][29]++;
  logger.debug("act is called");
  _$jscoverage['modules/api_act.js'][30]++;
  if (! fail) {
    _$jscoverage['modules/api_act.js'][31]++;
    fail = (function (msg, error) {
  _$jscoverage['modules/api_act.js'][32]++;
  logger.debug(msg + ":" + JSON.stringify(error));
});
  }
  _$jscoverage['modules/api_act.js'][36]++;
  if (! opts.act) {
    _$jscoverage['modules/api_act.js'][37]++;
    return fail("act_no_action", {});
  }
  _$jscoverage['modules/api_act.js'][40]++;
  cloud.ready((function (err, cloudHost) {
  _$jscoverage['modules/api_act.js'][41]++;
  logger.debug("Calling fhact now");
  _$jscoverage['modules/api_act.js'][42]++;
  if (err) {
    _$jscoverage['modules/api_act.js'][43]++;
    return fail(err.message, err);
  }
  else {
    _$jscoverage['modules/api_act.js'][45]++;
    doActCall(opts, success, fail);
  }
}));
});
_$jscoverage['modules/api_act.js'].source = ["var logger =require(\"./logger\");","var cloud = require(\"./waitForCloud\");","var fhparams = require(\"./fhparams\");","var ajax = require(\"./ajax\");","var JSON = require(\"JSON\");","var handleError = require(\"./handleError\");","","function doActCall(opts, success, fail){","  var cloud_host = cloud.getCloudHost();","  var url = cloud_host.getActUrl(opts.act);","  var params = opts.req || {};","  params = fhparams.addFHParams(params);","  return ajax({","    \"url\": url,","    \"tryJSONP\": true,","    \"type\": \"POST\",","    \"dataType\": \"json\",","    \"data\": JSON.stringify(params),","    \"contentType\": \"application/json\",","    \"timeout\": opts.timeout,","    \"success\": success,","    \"error\": function(req, statusText, error){","      return handleError(fail, req, statusText, error);","    }","  })","}","","module.exports = function(opts, success, fail){","  logger.debug(\"act is called\");","  if(!fail){","    fail = function(msg, error){","      logger.debug(msg + \":\" + JSON.stringify(error));","    };","  }","","  if(!opts.act){","    return fail('act_no_action', {});","  }","","  cloud.ready(function(err, cloudHost){","    logger.debug(\"Calling fhact now\");","    if(err){","      return fail(err.message, err);","    } else {","      doActCall(opts, success, fail);","    }","  })","}"];

},{"./ajax":54,"./fhparams":62,"./handleError":63,"./logger":68,"./waitForCloud":75,"JSON":3}],56:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/api_cloud.js']) {
  _$jscoverage['modules/api_cloud.js'] = [];
  _$jscoverage['modules/api_cloud.js'][1] = 0;
  _$jscoverage['modules/api_cloud.js'][2] = 0;
  _$jscoverage['modules/api_cloud.js'][3] = 0;
  _$jscoverage['modules/api_cloud.js'][4] = 0;
  _$jscoverage['modules/api_cloud.js'][5] = 0;
  _$jscoverage['modules/api_cloud.js'][6] = 0;
  _$jscoverage['modules/api_cloud.js'][8] = 0;
  _$jscoverage['modules/api_cloud.js'][9] = 0;
  _$jscoverage['modules/api_cloud.js'][10] = 0;
  _$jscoverage['modules/api_cloud.js'][11] = 0;
  _$jscoverage['modules/api_cloud.js'][12] = 0;
  _$jscoverage['modules/api_cloud.js'][13] = 0;
  _$jscoverage['modules/api_cloud.js'][22] = 0;
  _$jscoverage['modules/api_cloud.js'][27] = 0;
  _$jscoverage['modules/api_cloud.js'][28] = 0;
  _$jscoverage['modules/api_cloud.js'][29] = 0;
  _$jscoverage['modules/api_cloud.js'][30] = 0;
  _$jscoverage['modules/api_cloud.js'][31] = 0;
  _$jscoverage['modules/api_cloud.js'][35] = 0;
  _$jscoverage['modules/api_cloud.js'][36] = 0;
  _$jscoverage['modules/api_cloud.js'][37] = 0;
  _$jscoverage['modules/api_cloud.js'][38] = 0;
  _$jscoverage['modules/api_cloud.js'][40] = 0;
}
_$jscoverage['modules/api_cloud.js'][1]++;
var logger = require("./logger");
_$jscoverage['modules/api_cloud.js'][2]++;
var cloud = require("./waitForCloud");
_$jscoverage['modules/api_cloud.js'][3]++;
var fhparams = require("./fhparams");
_$jscoverage['modules/api_cloud.js'][4]++;
var ajax = require("./ajax");
_$jscoverage['modules/api_cloud.js'][5]++;
var JSON = require("JSON");
_$jscoverage['modules/api_cloud.js'][6]++;
var handleError = require("./handleError");
_$jscoverage['modules/api_cloud.js'][8]++;
function doCloudCall(opts, success, fail) {
  _$jscoverage['modules/api_cloud.js'][9]++;
  var cloud_host = cloud.getCloudHost();
  _$jscoverage['modules/api_cloud.js'][10]++;
  var url = cloud_host.getCloudUrl(opts.path);
  _$jscoverage['modules/api_cloud.js'][11]++;
  var params = opts.data || {};
  _$jscoverage['modules/api_cloud.js'][12]++;
  params = fhparams.addFHParams(params);
  _$jscoverage['modules/api_cloud.js'][13]++;
  return ajax({"url": url, "type": opts.method || "POST", "dataType": opts.dataType || "json", "data": JSON.stringify(params), "contentType": opts.contentType || "application/json", "timeout": opts.timeout, "success": success, "error": (function (req, statusText, error) {
  _$jscoverage['modules/api_cloud.js'][22]++;
  return handleError(fail, req, statusText, error);
})});
}
_$jscoverage['modules/api_cloud.js'][27]++;
module.exports = (function (opts, success, fail) {
  _$jscoverage['modules/api_cloud.js'][28]++;
  logger.debug("cloud is called");
  _$jscoverage['modules/api_cloud.js'][29]++;
  if (! fail) {
    _$jscoverage['modules/api_cloud.js'][30]++;
    fail = (function (msg, error) {
  _$jscoverage['modules/api_cloud.js'][31]++;
  logger.debug(msg + ":" + JSON.stringify(error));
});
  }
  _$jscoverage['modules/api_cloud.js'][35]++;
  cloud.ready((function (err, cloudHost) {
  _$jscoverage['modules/api_cloud.js'][36]++;
  logger.debug("Calling fhact now");
  _$jscoverage['modules/api_cloud.js'][37]++;
  if (err) {
    _$jscoverage['modules/api_cloud.js'][38]++;
    return fail(err.message, err);
  }
  else {
    _$jscoverage['modules/api_cloud.js'][40]++;
    doCloudCall(opts, success, fail);
  }
}));
});
_$jscoverage['modules/api_cloud.js'].source = ["var logger =require(\"./logger\");","var cloud = require(\"./waitForCloud\");","var fhparams = require(\"./fhparams\");","var ajax = require(\"./ajax\");","var JSON = require(\"JSON\");","var handleError = require(\"./handleError\");","","function doCloudCall(opts, success, fail){","  var cloud_host = cloud.getCloudHost();","  var url = cloud_host.getCloudUrl(opts.path);","  var params = opts.data || {};","  params = fhparams.addFHParams(params);","  return ajax({","    \"url\": url,","    \"type\": opts.method || \"POST\",","    \"dataType\": opts.dataType || \"json\",","    \"data\": JSON.stringify(params),","    \"contentType\": opts.contentType || \"application/json\",","    \"timeout\": opts.timeout,","    \"success\": success,","    \"error\": function(req, statusText, error){","      return handleError(fail, req, statusText, error);","    }","  })","}","","module.exports = function(opts, success, fail){","  logger.debug(\"cloud is called\");","  if(!fail){","    fail = function(msg, error){","      logger.debug(msg + \":\" + JSON.stringify(error));","    };","  }","","  cloud.ready(function(err, cloudHost){","    logger.debug(\"Calling fhact now\");","    if(err){","      return fail(err.message, err);","    } else {","      doCloudCall(opts, success, fail);","    }","  })","}"];

},{"./ajax":54,"./fhparams":62,"./handleError":63,"./logger":68,"./waitForCloud":75,"JSON":3}],57:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/appProps.js']) {
  _$jscoverage['modules/appProps.js'] = [];
  _$jscoverage['modules/appProps.js'][1] = 0;
  _$jscoverage['modules/appProps.js'][2] = 0;
  _$jscoverage['modules/appProps.js'][3] = 0;
  _$jscoverage['modules/appProps.js'][4] = 0;
  _$jscoverage['modules/appProps.js'][6] = 0;
  _$jscoverage['modules/appProps.js'][8] = 0;
  _$jscoverage['modules/appProps.js'][9] = 0;
  _$jscoverage['modules/appProps.js'][10] = 0;
  _$jscoverage['modules/appProps.js'][11] = 0;
  _$jscoverage['modules/appProps.js'][14] = 0;
  _$jscoverage['modules/appProps.js'][15] = 0;
  _$jscoverage['modules/appProps.js'][16] = 0;
  _$jscoverage['modules/appProps.js'][17] = 0;
  _$jscoverage['modules/appProps.js'][18] = 0;
  _$jscoverage['modules/appProps.js'][19] = 0;
  _$jscoverage['modules/appProps.js'][20] = 0;
  _$jscoverage['modules/appProps.js'][21] = 0;
  _$jscoverage['modules/appProps.js'][22] = 0;
  _$jscoverage['modules/appProps.js'][23] = 0;
  _$jscoverage['modules/appProps.js'][26] = 0;
  _$jscoverage['modules/appProps.js'][27] = 0;
  _$jscoverage['modules/appProps.js'][31] = 0;
  _$jscoverage['modules/appProps.js'][33] = 0;
  _$jscoverage['modules/appProps.js'][34] = 0;
  _$jscoverage['modules/appProps.js'][36] = 0;
  _$jscoverage['modules/appProps.js'][38] = 0;
  _$jscoverage['modules/appProps.js'][43] = 0;
  _$jscoverage['modules/appProps.js'][44] = 0;
  _$jscoverage['modules/appProps.js'][46] = 0;
  _$jscoverage['modules/appProps.js'][47] = 0;
  _$jscoverage['modules/appProps.js'][52] = 0;
  _$jscoverage['modules/appProps.js'][53] = 0;
  _$jscoverage['modules/appProps.js'][56] = 0;
  _$jscoverage['modules/appProps.js'][57] = 0;
  _$jscoverage['modules/appProps.js'][60] = 0;
}
_$jscoverage['modules/appProps.js'][1]++;
var consts = require("./constants");
_$jscoverage['modules/appProps.js'][2]++;
var ajax = require("./ajax");
_$jscoverage['modules/appProps.js'][3]++;
var logger = require("./logger");
_$jscoverage['modules/appProps.js'][4]++;
var qs = require("./queryMap");
_$jscoverage['modules/appProps.js'][6]++;
var app_props = null;
_$jscoverage['modules/appProps.js'][8]++;
var load = (function (cb) {
  _$jscoverage['modules/appProps.js'][9]++;
  var doc_url = document.location.href;
  _$jscoverage['modules/appProps.js'][10]++;
  var url_params = qs(doc_url);
  _$jscoverage['modules/appProps.js'][11]++;
  var local = (typeof url_params.url !== "undefined");
  _$jscoverage['modules/appProps.js'][14]++;
  if (local) {
    _$jscoverage['modules/appProps.js'][15]++;
    app_props = {};
    _$jscoverage['modules/appProps.js'][16]++;
    app_props.local = true;
    _$jscoverage['modules/appProps.js'][17]++;
    app_props.host = url_params.url;
    _$jscoverage['modules/appProps.js'][18]++;
    app_props.appid = "000000000000000000000000";
    _$jscoverage['modules/appProps.js'][19]++;
    app_props.appkey = "0000000000000000000000000000000000000000";
    _$jscoverage['modules/appProps.js'][20]++;
    app_props.projectid = "000000000000000000000000";
    _$jscoverage['modules/appProps.js'][21]++;
    app_props.connectiontag = "0.0.1";
    _$jscoverage['modules/appProps.js'][22]++;
    app_props.loglevel = url_params.loglevel;
    _$jscoverage['modules/appProps.js'][23]++;
    return cb(null, app_props);
  }
  _$jscoverage['modules/appProps.js'][26]++;
  var config_url = url_params.fhconfig || consts.config_js;
  _$jscoverage['modules/appProps.js'][27]++;
  ajax({url: config_url, dataType: "json", success: (function (data) {
  _$jscoverage['modules/appProps.js'][31]++;
  logger.debug("fhconfig = " + JSON.stringify(data));
  _$jscoverage['modules/appProps.js'][33]++;
  if (null === data) {
    _$jscoverage['modules/appProps.js'][34]++;
    return cb(new Error("app_config_missing"));
  }
  else {
    _$jscoverage['modules/appProps.js'][36]++;
    app_props = data;
    _$jscoverage['modules/appProps.js'][38]++;
    cb(null, app_props);
  }
}), error: (function (req, statusText, error) {
  _$jscoverage['modules/appProps.js'][43]++;
  if (window.fh_app_props) {
    _$jscoverage['modules/appProps.js'][44]++;
    return cb(null, window.fh_app_props);
  }
  _$jscoverage['modules/appProps.js'][46]++;
  logger.error(consts.config_js + " Not Found");
  _$jscoverage['modules/appProps.js'][47]++;
  cb(new Error("app_config_missing"));
})});
});
_$jscoverage['modules/appProps.js'][52]++;
var setAppProps = (function (props) {
  _$jscoverage['modules/appProps.js'][53]++;
  app_props = props;
});
_$jscoverage['modules/appProps.js'][56]++;
var getAppProps = (function () {
  _$jscoverage['modules/appProps.js'][57]++;
  return app_props;
});
_$jscoverage['modules/appProps.js'][60]++;
module.exports = {load: load, getAppProps: getAppProps, setAppProps: setAppProps};
_$jscoverage['modules/appProps.js'].source = ["var consts = require(\"./constants\");","var ajax = require(\"./ajax\");","var logger = require(\"./logger\");","var qs = require(\"./queryMap\");","","var app_props = null;","","var load = function(cb) {","  var doc_url = document.location.href;","  var url_params = qs(doc_url);","  var local = (typeof url_params.url !== 'undefined');","","  // For local environments, no init needed","  if (local) {","    app_props = {};","    app_props.local = true;","    app_props.host = url_params.url;","    app_props.appid = \"000000000000000000000000\";","    app_props.appkey = \"0000000000000000000000000000000000000000\";","    app_props.projectid = \"000000000000000000000000\";","    app_props.connectiontag = \"0.0.1\";","    app_props.loglevel = url_params.loglevel;","    return cb(null, app_props);","  }","","  var config_url = url_params.fhconfig || consts.config_js;","  ajax({","    url: config_url,","    dataType: \"json\",","    success: function(data) {","      logger.debug(\"fhconfig = \" + JSON.stringify(data));","      //when load the config file on device, because file:// protocol is used, it will never call fail call back. The success callback will be called but the data value will be null.","      if (null === data) {","        return cb(new Error(\"app_config_missing\"));","      } else {","        app_props = data;","","        cb(null, app_props);","      }","    },","    error: function(req, statusText, error) {","      //fh v2 only","      if(window.fh_app_props){","        return cb(null, window.fh_app_props);","      }","      logger.error(consts.config_js + \" Not Found\");","      cb(new Error(\"app_config_missing\"));","    }","  });","};","","var setAppProps = function(props) {","  app_props = props;","};","","var getAppProps = function() {","  return app_props;","};","","module.exports = {","  load: load,","  getAppProps: getAppProps,","  setAppProps: setAppProps","};"];

},{"./ajax":54,"./constants":58,"./logger":68,"./queryMap":70}],58:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/constants.js']) {
  _$jscoverage['modules/constants.js'] = [];
  _$jscoverage['modules/constants.js'][1] = 0;
}
_$jscoverage['modules/constants.js'][1]++;
module.exports = {"fh_timeout": 20000, "boxprefix": "/box/srv/1.1/", "sdk_version": "BUILD_VERSION", "config_js": "fhconfig.json", "INIT_EVENT": "fhinit"};
_$jscoverage['modules/constants.js'].source = ["module.exports = {","  \"fh_timeout\": 20000,","  \"boxprefix\": \"/box/srv/1.1/\",","  \"sdk_version\": \"BUILD_VERSION\",","  \"config_js\": \"fhconfig.json\",","  \"INIT_EVENT\": \"fhinit\"","};"];

},{}],59:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/cookies.js']) {
  _$jscoverage['modules/cookies.js'] = [];
  _$jscoverage['modules/cookies.js'][1] = 0;
  _$jscoverage['modules/cookies.js'][3] = 0;
  _$jscoverage['modules/cookies.js'][4] = 0;
  _$jscoverage['modules/cookies.js'][5] = 0;
  _$jscoverage['modules/cookies.js'][6] = 0;
  _$jscoverage['modules/cookies.js'][7] = 0;
  _$jscoverage['modules/cookies.js'][8] = 0;
  _$jscoverage['modules/cookies.js'][10] = 0;
  _$jscoverage['modules/cookies.js'][11] = 0;
  _$jscoverage['modules/cookies.js'][14] = 0;
  _$jscoverage['modules/cookies.js'][18] = 0;
  _$jscoverage['modules/cookies.js'][19] = 0;
  _$jscoverage['modules/cookies.js'][20] = 0;
  _$jscoverage['modules/cookies.js'][21] = 0;
}
_$jscoverage['modules/cookies.js'][1]++;
module.exports = {readCookieValue: (function (cookie_name) {
  _$jscoverage['modules/cookies.js'][3]++;
  var name_str = cookie_name + "=";
  _$jscoverage['modules/cookies.js'][4]++;
  var cookies = document.cookie.split(";");
  _$jscoverage['modules/cookies.js'][5]++;
  for (var i = 0; i < cookies.length; i++) {
    _$jscoverage['modules/cookies.js'][6]++;
    var c = cookies[i];
    _$jscoverage['modules/cookies.js'][7]++;
    while (c.charAt(0) === " ") {
      _$jscoverage['modules/cookies.js'][8]++;
      c = c.substring(1, c.length);
}
    _$jscoverage['modules/cookies.js'][10]++;
    if (c.indexOf(name_str) === 0) {
      _$jscoverage['modules/cookies.js'][11]++;
      return c.substring(name_str.length, c.length);
    }
}
  _$jscoverage['modules/cookies.js'][14]++;
  return null;
}), createCookie: (function (cookie_name, cookie_value) {
  _$jscoverage['modules/cookies.js'][18]++;
  var date = new Date();
  _$jscoverage['modules/cookies.js'][19]++;
  date.setTime(date.getTime() + 3153600000000);
  _$jscoverage['modules/cookies.js'][20]++;
  var expires = "; expires=" + date.toGMTString();
  _$jscoverage['modules/cookies.js'][21]++;
  document.cookie = cookie_name + "=" + cookie_value + expires + "; path = /";
})};
_$jscoverage['modules/cookies.js'].source = ["module.exports = {","  readCookieValue  : function (cookie_name) {","    var name_str = cookie_name + \"=\";","    var cookies = document.cookie.split(\";\");","    for (var i = 0; i &lt; cookies.length; i++) {","      var c = cookies[i];","      while (c.charAt(0) === ' ') {","        c = c.substring(1, c.length);","      }","      if (c.indexOf(name_str) === 0) {","        return c.substring(name_str.length, c.length);","      }","    }","    return null;","  },","","  createCookie : function (cookie_name, cookie_value) {","    var date = new Date();","    date.setTime(date.getTime() + 36500 * 24 * 60 * 60 * 1000); //100 years","    var expires = \"; expires=\" + date.toGMTString();","    document.cookie = cookie_name + \"=\" + cookie_value + expires + \"; path = /\";","  }","};"];

},{}],60:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/device.js']) {
  _$jscoverage['modules/device.js'] = [];
  _$jscoverage['modules/device.js'][1] = 0;
  _$jscoverage['modules/device.js'][2] = 0;
  _$jscoverage['modules/device.js'][3] = 0;
  _$jscoverage['modules/device.js'][5] = 0;
  _$jscoverage['modules/device.js'][9] = 0;
  _$jscoverage['modules/device.js'][10] = 0;
  _$jscoverage['modules/device.js'][11] = 0;
  _$jscoverage['modules/device.js'][12] = 0;
  _$jscoverage['modules/device.js'][13] = 0;
  _$jscoverage['modules/device.js'][14] = 0;
  _$jscoverage['modules/device.js'][16] = 0;
  _$jscoverage['modules/device.js'][17] = 0;
  _$jscoverage['modules/device.js'][18] = 0;
  _$jscoverage['modules/device.js'][19] = 0;
  _$jscoverage['modules/device.js'][20] = 0;
  _$jscoverage['modules/device.js'][22] = 0;
  _$jscoverage['modules/device.js'][28] = 0;
  _$jscoverage['modules/device.js'][29] = 0;
  _$jscoverage['modules/device.js'][30] = 0;
  _$jscoverage['modules/device.js'][31] = 0;
  _$jscoverage['modules/device.js'][32] = 0;
  _$jscoverage['modules/device.js'][33] = 0;
  _$jscoverage['modules/device.js'][36] = 0;
  _$jscoverage['modules/device.js'][40] = 0;
  _$jscoverage['modules/device.js'][41] = 0;
  _$jscoverage['modules/device.js'][44] = 0;
  _$jscoverage['modules/device.js'][46] = 0;
  _$jscoverage['modules/device.js'][47] = 0;
  _$jscoverage['modules/device.js'][48] = 0;
  _$jscoverage['modules/device.js'][49] = 0;
  _$jscoverage['modules/device.js'][50] = 0;
  _$jscoverage['modules/device.js'][52] = 0;
  _$jscoverage['modules/device.js'][53] = 0;
  _$jscoverage['modules/device.js'][54] = 0;
  _$jscoverage['modules/device.js'][55] = 0;
  _$jscoverage['modules/device.js'][61] = 0;
  _$jscoverage['modules/device.js'][62] = 0;
  _$jscoverage['modules/device.js'][65] = 0;
  _$jscoverage['modules/device.js'][67] = 0;
}
_$jscoverage['modules/device.js'][1]++;
var cookies = require("./cookies");
_$jscoverage['modules/device.js'][2]++;
var uuidModule = require("./uuid");
_$jscoverage['modules/device.js'][3]++;
var logger = require("./logger");
_$jscoverage['modules/device.js'][5]++;
module.exports = {"getDeviceId": (function () {
  _$jscoverage['modules/device.js'][9]++;
  if (typeof window.fhdevice !== "undefined" && typeof window.fhdevice.uuid !== "undefined") {
    _$jscoverage['modules/device.js'][10]++;
    return window.fhdevice.uuid;
  }
  else {
    _$jscoverage['modules/device.js'][11]++;
    if (typeof window.device !== "undefined" && typeof window.device.uuid !== "undefined") {
      _$jscoverage['modules/device.js'][12]++;
      return window.device.uuid;
    }
    else {
      _$jscoverage['modules/device.js'][13]++;
      if (typeof navigator.device !== "undefined" && typeof navigator.device.uuid !== "undefined") {
        _$jscoverage['modules/device.js'][14]++;
        return navigator.device.uuid;
      }
      else {
        _$jscoverage['modules/device.js'][16]++;
        var _mock_uuid_cookie_name = "mock_uuid";
        _$jscoverage['modules/device.js'][17]++;
        var uuid = cookies.readCookieValue(_mock_uuid_cookie_name);
        _$jscoverage['modules/device.js'][18]++;
        if (null == uuid) {
          _$jscoverage['modules/device.js'][19]++;
          uuid = uuidModule.createUUID();
          _$jscoverage['modules/device.js'][20]++;
          cookies.createCookie(_mock_uuid_cookie_name, uuid);
        }
        _$jscoverage['modules/device.js'][22]++;
        return uuid;
      }
    }
  }
}), "getCuidMap": (function () {
  _$jscoverage['modules/device.js'][28]++;
  if (typeof window.fhdevice !== "undefined" && typeof window.fhdevice.cuidMap !== "undefined") {
    _$jscoverage['modules/device.js'][29]++;
    return window.fhdevice.cuidMap;
  }
  else {
    _$jscoverage['modules/device.js'][30]++;
    if (typeof window.device !== "undefined" && typeof window.device.cuidMap !== "undefined") {
      _$jscoverage['modules/device.js'][31]++;
      return window.device.cuidMap;
    }
    else {
      _$jscoverage['modules/device.js'][32]++;
      if (typeof navigator.device !== "undefined" && typeof navigator.device.cuidMap !== "undefined") {
        _$jscoverage['modules/device.js'][33]++;
        return navigator.device.cuidMap;
      }
    }
  }
  _$jscoverage['modules/device.js'][36]++;
  return null;
}), "getDestination": (function () {
  _$jscoverage['modules/device.js'][40]++;
  var destination = null;
  _$jscoverage['modules/device.js'][41]++;
  var platformsToTest = require("./platformsMap");
  _$jscoverage['modules/device.js'][44]++;
  var userAgent = navigator.userAgent;
  _$jscoverage['modules/device.js'][46]++;
  var dest_override = document.location.search.split("fh_destination_code=");
  _$jscoverage['modules/device.js'][47]++;
  if (dest_override.length > 1) {
    _$jscoverage['modules/device.js'][48]++;
    destination = dest_override[1];
  }
  else {
    _$jscoverage['modules/device.js'][49]++;
    if (typeof window.fh_destination_code !== "undefined") {
      _$jscoverage['modules/device.js'][50]++;
      destination = window.fh_destination_code;
    }
    else {
      _$jscoverage['modules/device.js'][52]++;
      platformsToTest.forEach((function (testDestination) {
  _$jscoverage['modules/device.js'][53]++;
  testDestination.test.forEach((function (destinationTest) {
  _$jscoverage['modules/device.js'][54]++;
  if (userAgent.indexOf(destinationTest) > -1) {
    _$jscoverage['modules/device.js'][55]++;
    destination = testDestination.destination;
  }
}));
}));
    }
  }
  _$jscoverage['modules/device.js'][61]++;
  if (destination == null) {
    _$jscoverage['modules/device.js'][62]++;
    destination = "web";
  }
  _$jscoverage['modules/device.js'][65]++;
  logger.debug("destination = " + destination);
  _$jscoverage['modules/device.js'][67]++;
  return destination;
})};
_$jscoverage['modules/device.js'].source = ["var cookies = require(\"./cookies\");","var uuidModule = require(\"./uuid\");","var logger = require(\"./logger\");","","module.exports = {","  //try to get the unique device identifier","  \"getDeviceId\": function(){","    //check for cordova/phonegap first","    if(typeof window.fhdevice !== \"undefined\" &amp;&amp; typeof window.fhdevice.uuid !== \"undefined\"){","      return window.fhdevice.uuid;","    } else if(typeof window.device !== \"undefined\" &amp;&amp; typeof window.device.uuid !== \"undefined\"){","      return window.device.uuid;","    }  else if(typeof navigator.device !== \"undefined\" &amp;&amp; typeof navigator.device.uuid !== \"undefined\"){","      return navigator.device.uuid;","    } else {","      var _mock_uuid_cookie_name = \"mock_uuid\";","      var uuid = cookies.readCookieValue(_mock_uuid_cookie_name);","      if(null == uuid){","          uuid = uuidModule.createUUID();","          cookies.createCookie(_mock_uuid_cookie_name, uuid);","      }","      return uuid;","    }","  },","","  //this is for fixing analytics issues when upgrading from io6 to ios7. Probably can be deprecated now","  \"getCuidMap\": function(){","    if(typeof window.fhdevice !== \"undefined\" &amp;&amp; typeof window.fhdevice.cuidMap !== \"undefined\"){","      return window.fhdevice.cuidMap;","    } else if(typeof window.device !== \"undefined\" &amp;&amp; typeof window.device.cuidMap !== \"undefined\"){","      return window.device.cuidMap;","    }  else if(typeof navigator.device !== \"undefined\" &amp;&amp; typeof navigator.device.cuidMap !== \"undefined\"){","      return navigator.device.cuidMap;","    }","","    return null;","  },","","  \"getDestination\": function(){","    var destination = null;","    var platformsToTest = require(\"./platformsMap\");","","","    var userAgent = navigator.userAgent;","","    var dest_override = document.location.search.split(\"fh_destination_code=\");","    if (dest_override.length &gt; 1) {","     destination = dest_override[1];","    } else if (typeof window.fh_destination_code !== 'undefined') {","      destination = window.fh_destination_code;","    } else {","      platformsToTest.forEach(function(testDestination){","        testDestination.test.forEach(function(destinationTest){","          if(userAgent.indexOf(destinationTest) &gt; -1){","            destination = testDestination.destination;","          }","        });","      });","    }","","    if(destination == null){ //No user agents were found, set to default web","      destination = \"web\";","    }","","    logger.debug(\"destination = \" + destination);","","    return destination;","  }","}"];

},{"./cookies":59,"./logger":68,"./platformsMap":69,"./uuid":74}],61:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/events.js']) {
  _$jscoverage['modules/events.js'] = [];
  _$jscoverage['modules/events.js'][1] = 0;
  _$jscoverage['modules/events.js'][3] = 0;
  _$jscoverage['modules/events.js'][4] = 0;
  _$jscoverage['modules/events.js'][6] = 0;
}
_$jscoverage['modules/events.js'][1]++;
var EventEmitter = require("events").EventEmitter;
_$jscoverage['modules/events.js'][3]++;
var emitter = new EventEmitter();
_$jscoverage['modules/events.js'][4]++;
emitter.setMaxListeners(0);
_$jscoverage['modules/events.js'][6]++;
module.exports = emitter;
_$jscoverage['modules/events.js'].source = ["var EventEmitter = require('events').EventEmitter;","","var emitter = new EventEmitter();","emitter.setMaxListeners(0);","","module.exports = emitter;"];

},{"events":43}],62:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/fhparams.js']) {
  _$jscoverage['modules/fhparams.js'] = [];
  _$jscoverage['modules/fhparams.js'][1] = 0;
  _$jscoverage['modules/fhparams.js'][2] = 0;
  _$jscoverage['modules/fhparams.js'][3] = 0;
  _$jscoverage['modules/fhparams.js'][4] = 0;
  _$jscoverage['modules/fhparams.js'][6] = 0;
  _$jscoverage['modules/fhparams.js'][7] = 0;
  _$jscoverage['modules/fhparams.js'][9] = 0;
  _$jscoverage['modules/fhparams.js'][10] = 0;
  _$jscoverage['modules/fhparams.js'][11] = 0;
  _$jscoverage['modules/fhparams.js'][13] = 0;
  _$jscoverage['modules/fhparams.js'][14] = 0;
  _$jscoverage['modules/fhparams.js'][15] = 0;
  _$jscoverage['modules/fhparams.js'][16] = 0;
  _$jscoverage['modules/fhparams.js'][18] = 0;
  _$jscoverage['modules/fhparams.js'][19] = 0;
  _$jscoverage['modules/fhparams.js'][23] = 0;
  _$jscoverage['modules/fhparams.js'][24] = 0;
  _$jscoverage['modules/fhparams.js'][26] = 0;
  _$jscoverage['modules/fhparams.js'][27] = 0;
  _$jscoverage['modules/fhparams.js'][29] = 0;
  _$jscoverage['modules/fhparams.js'][30] = 0;
  _$jscoverage['modules/fhparams.js'][32] = 0;
  _$jscoverage['modules/fhparams.js'][33] = 0;
  _$jscoverage['modules/fhparams.js'][34] = 0;
  _$jscoverage['modules/fhparams.js'][37] = 0;
  _$jscoverage['modules/fhparams.js'][38] = 0;
  _$jscoverage['modules/fhparams.js'][39] = 0;
  _$jscoverage['modules/fhparams.js'][40] = 0;
  _$jscoverage['modules/fhparams.js'][41] = 0;
  _$jscoverage['modules/fhparams.js'][42] = 0;
  _$jscoverage['modules/fhparams.js'][43] = 0;
  _$jscoverage['modules/fhparams.js'][44] = 0;
  _$jscoverage['modules/fhparams.js'][45] = 0;
  _$jscoverage['modules/fhparams.js'][49] = 0;
  _$jscoverage['modules/fhparams.js'][50] = 0;
  _$jscoverage['modules/fhparams.js'][51] = 0;
  _$jscoverage['modules/fhparams.js'][54] = 0;
  _$jscoverage['modules/fhparams.js'][55] = 0;
  _$jscoverage['modules/fhparams.js'][56] = 0;
  _$jscoverage['modules/fhparams.js'][57] = 0;
  _$jscoverage['modules/fhparams.js'][60] = 0;
  _$jscoverage['modules/fhparams.js'][61] = 0;
  _$jscoverage['modules/fhparams.js'][64] = 0;
}
_$jscoverage['modules/fhparams.js'][1]++;
var device = require("./device");
_$jscoverage['modules/fhparams.js'][2]++;
var sdkversion = require("./sdkversion");
_$jscoverage['modules/fhparams.js'][3]++;
var appProps = require("./appProps");
_$jscoverage['modules/fhparams.js'][4]++;
var logger = require("./logger");
_$jscoverage['modules/fhparams.js'][6]++;
var defaultParams = null;
_$jscoverage['modules/fhparams.js'][7]++;
var authSessionToken = null;
_$jscoverage['modules/fhparams.js'][9]++;
var buildFHParams = (function () {
  _$jscoverage['modules/fhparams.js'][10]++;
  if (defaultParams) {
    _$jscoverage['modules/fhparams.js'][11]++;
    return defaultParams;
  }
  _$jscoverage['modules/fhparams.js'][13]++;
  var fhparams = {};
  _$jscoverage['modules/fhparams.js'][14]++;
  fhparams.cuid = device.getDeviceId();
  _$jscoverage['modules/fhparams.js'][15]++;
  fhparams.cuidMap = device.getCuidMap();
  _$jscoverage['modules/fhparams.js'][16]++;
  fhparams.destination = device.getDestination();
  _$jscoverage['modules/fhparams.js'][18]++;
  if (window.device || navigator.device) {
    _$jscoverage['modules/fhparams.js'][19]++;
    fhparams.device = window.device || navigator.device;
  }
  _$jscoverage['modules/fhparams.js'][23]++;
  if (typeof window.fh_app_version !== "undefined") {
    _$jscoverage['modules/fhparams.js'][24]++;
    fhparams.app_version = fh_app_version;
  }
  _$jscoverage['modules/fhparams.js'][26]++;
  if (typeof window.fh_project_version !== "undefined") {
    _$jscoverage['modules/fhparams.js'][27]++;
    fhparams.project_version = fh_project_version;
  }
  _$jscoverage['modules/fhparams.js'][29]++;
  if (typeof window.fh_project_app_version !== "undefined") {
    _$jscoverage['modules/fhparams.js'][30]++;
    fhparams.project_app_version = fh_project_app_version;
  }
  _$jscoverage['modules/fhparams.js'][32]++;
  fhparams.sdk_version = sdkversion();
  _$jscoverage['modules/fhparams.js'][33]++;
  if (authSessionToken) {
    _$jscoverage['modules/fhparams.js'][34]++;
    fhparams.sessionToken = authSessionToken;
  }
  _$jscoverage['modules/fhparams.js'][37]++;
  var app_props = appProps.getAppProps();
  _$jscoverage['modules/fhparams.js'][38]++;
  if (app_props) {
    _$jscoverage['modules/fhparams.js'][39]++;
    fhparams.appid = app_props.appid;
    _$jscoverage['modules/fhparams.js'][40]++;
    fhparams.appkey = app_props.appkey;
    _$jscoverage['modules/fhparams.js'][41]++;
    fhparams.projectid = app_props.projectid;
    _$jscoverage['modules/fhparams.js'][42]++;
    fhparams.analyticsTag = app_props.analyticsTag;
    _$jscoverage['modules/fhparams.js'][43]++;
    fhparams.connectiontag = app_props.connectiontag;
    _$jscoverage['modules/fhparams.js'][44]++;
    if (app_props.init) {
      _$jscoverage['modules/fhparams.js'][45]++;
      fhparams.init = typeof app_props.init === "string"? JSON.parse(app_props.init): app_props.init;
    }
  }
  _$jscoverage['modules/fhparams.js'][49]++;
  defaultParams = fhparams;
  _$jscoverage['modules/fhparams.js'][50]++;
  logger.debug("fhparams = ", defaultParams);
  _$jscoverage['modules/fhparams.js'][51]++;
  return fhparams;
});
_$jscoverage['modules/fhparams.js'][54]++;
var addFHParams = (function (params) {
  _$jscoverage['modules/fhparams.js'][55]++;
  var params = params || {};
  _$jscoverage['modules/fhparams.js'][56]++;
  params.__fh = buildFHParams();
  _$jscoverage['modules/fhparams.js'][57]++;
  return params;
});
_$jscoverage['modules/fhparams.js'][60]++;
var setAuthSessionToken = (function (sessionToken) {
  _$jscoverage['modules/fhparams.js'][61]++;
  authSessionToken = sessionToken;
});
_$jscoverage['modules/fhparams.js'][64]++;
module.exports = {"buildFHParams": buildFHParams, "addFHParams": addFHParams, "setAuthSessionToken": setAuthSessionToken};
_$jscoverage['modules/fhparams.js'].source = ["var device = require(\"./device\");","var sdkversion = require(\"./sdkversion\");","var appProps = require(\"./appProps\");","var logger = require(\"./logger\");","","var defaultParams = null;","var authSessionToken = null;","//TODO: review these options, we probably only needs all of them for init calls, but we shouldn't need all of them for act calls","var buildFHParams = function(){","  if(defaultParams){","    return defaultParams;","  }","  var fhparams = {};","  fhparams.cuid = device.getDeviceId();","  fhparams.cuidMap = device.getCuidMap();","  fhparams.destination = device.getDestination();","  ","  if(window.device || navigator.device){","    fhparams.device = window.device || navigator.device;","  }","","  //backward compatible","  if (typeof window.fh_app_version !== 'undefined'){","    fhparams.app_version = fh_app_version;","  }","  if (typeof window.fh_project_version !== 'undefined'){","    fhparams.project_version = fh_project_version;","  }","  if (typeof window.fh_project_app_version !== 'undefined'){","    fhparams.project_app_version = fh_project_app_version;","  }","  fhparams.sdk_version = sdkversion();","  if(authSessionToken){","    fhparams.sessionToken = authSessionToken;","  }","","  var app_props = appProps.getAppProps();","  if(app_props){","    fhparams.appid = app_props.appid;","    fhparams.appkey = app_props.appkey;","    fhparams.projectid = app_props.projectid;","    fhparams.analyticsTag =  app_props.analyticsTag;","    fhparams.connectiontag = app_props.connectiontag;","    if(app_props.init){","      fhparams.init = typeof(app_props.init) === \"string\" ? JSON.parse(app_props.init) : app_props.init;","    }","  }","  ","  defaultParams = fhparams;","  logger.debug(\"fhparams = \", defaultParams);","  return fhparams;","}","","var addFHParams = function(params){","  var params = params || {};","  params.__fh = buildFHParams();","  return params;","}","","var setAuthSessionToken = function(sessionToken){","  authSessionToken = sessionToken;","}","","module.exports = {","  \"buildFHParams\": buildFHParams,","  \"addFHParams\": addFHParams,","  \"setAuthSessionToken\":setAuthSessionToken","}"];

},{"./appProps":57,"./device":60,"./logger":68,"./sdkversion":71}],63:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/handleError.js']) {
  _$jscoverage['modules/handleError.js'] = [];
  _$jscoverage['modules/handleError.js'][1] = 0;
  _$jscoverage['modules/handleError.js'][3] = 0;
  _$jscoverage['modules/handleError.js'][4] = 0;
  _$jscoverage['modules/handleError.js'][5] = 0;
  _$jscoverage['modules/handleError.js'][6] = 0;
  _$jscoverage['modules/handleError.js'][7] = 0;
  _$jscoverage['modules/handleError.js'][8] = 0;
  _$jscoverage['modules/handleError.js'][9] = 0;
  _$jscoverage['modules/handleError.js'][10] = 0;
  _$jscoverage['modules/handleError.js'][11] = 0;
  _$jscoverage['modules/handleError.js'][12] = 0;
  _$jscoverage['modules/handleError.js'][15] = 0;
  _$jscoverage['modules/handleError.js'][18] = 0;
  _$jscoverage['modules/handleError.js'][19] = 0;
}
_$jscoverage['modules/handleError.js'][1]++;
var JSON = require("JSON");
_$jscoverage['modules/handleError.js'][3]++;
module.exports = (function (fail, req, resStatus, error) {
  _$jscoverage['modules/handleError.js'][4]++;
  var errraw;
  _$jscoverage['modules/handleError.js'][5]++;
  var statusCode = 0;
  _$jscoverage['modules/handleError.js'][6]++;
  if (req) {
    _$jscoverage['modules/handleError.js'][7]++;
    try {
      _$jscoverage['modules/handleError.js'][8]++;
      statusCode = req.status;
      _$jscoverage['modules/handleError.js'][9]++;
      var res = JSON.parse(req.responseText);
      _$jscoverage['modules/handleError.js'][10]++;
      errraw = res.error || res.msg;
      _$jscoverage['modules/handleError.js'][11]++;
      if (errraw instanceof Array) {
        _$jscoverage['modules/handleError.js'][12]++;
        errraw = errraw.join("\n");
      }
    }
    catch (e) {
      _$jscoverage['modules/handleError.js'][15]++;
      errraw = req.responseText;
    }
  }
  _$jscoverage['modules/handleError.js'][18]++;
  if (fail) {
    _$jscoverage['modules/handleError.js'][19]++;
    fail(errraw, {status: statusCode, message: resStatus, error: error});
  }
});
_$jscoverage['modules/handleError.js'].source = ["var JSON = require(\"JSON\");","","module.exports = function(fail, req, resStatus, error){","  var errraw;","  var statusCode = 0;","  if(req){","    try{","      statusCode = req.status;","      var res = JSON.parse(req.responseText);","      errraw = res.error || res.msg;","      if (errraw instanceof Array) {","        errraw = errraw.join('\\n');","      }","    } catch(e){","      errraw = req.responseText;","    }","  }","  if(fail){","    fail(errraw, {","      status: statusCode,","      message: resStatus,","      error: error","    });","  }","};"];

},{"JSON":3}],64:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/hosts.js']) {
  _$jscoverage['modules/hosts.js'] = [];
  _$jscoverage['modules/hosts.js'][1] = 0;
  _$jscoverage['modules/hosts.js'][2] = 0;
  _$jscoverage['modules/hosts.js'][4] = 0;
  _$jscoverage['modules/hosts.js'][5] = 0;
  _$jscoverage['modules/hosts.js'][6] = 0;
  _$jscoverage['modules/hosts.js'][7] = 0;
  _$jscoverage['modules/hosts.js'][9] = 0;
  _$jscoverage['modules/hosts.js'][12] = 0;
  _$jscoverage['modules/hosts.js'][13] = 0;
  _$jscoverage['modules/hosts.js'][14] = 0;
  _$jscoverage['modules/hosts.js'][15] = 0;
  _$jscoverage['modules/hosts.js'][17] = 0;
  _$jscoverage['modules/hosts.js'][20] = 0;
  _$jscoverage['modules/hosts.js'][21] = 0;
  _$jscoverage['modules/hosts.js'][22] = 0;
  _$jscoverage['modules/hosts.js'][23] = 0;
  _$jscoverage['modules/hosts.js'][26] = 0;
  _$jscoverage['modules/hosts.js'][27] = 0;
  _$jscoverage['modules/hosts.js'][28] = 0;
  _$jscoverage['modules/hosts.js'][30] = 0;
  _$jscoverage['modules/hosts.js'][31] = 0;
  _$jscoverage['modules/hosts.js'][32] = 0;
  _$jscoverage['modules/hosts.js'][33] = 0;
  _$jscoverage['modules/hosts.js'][35] = 0;
  _$jscoverage['modules/hosts.js'][40] = 0;
  _$jscoverage['modules/hosts.js'][41] = 0;
  _$jscoverage['modules/hosts.js'][43] = 0;
  _$jscoverage['modules/hosts.js'][44] = 0;
  _$jscoverage['modules/hosts.js'][45] = 0;
  _$jscoverage['modules/hosts.js'][47] = 0;
  _$jscoverage['modules/hosts.js'][50] = 0;
  _$jscoverage['modules/hosts.js'][51] = 0;
  _$jscoverage['modules/hosts.js'][52] = 0;
  _$jscoverage['modules/hosts.js'][53] = 0;
  _$jscoverage['modules/hosts.js'][55] = 0;
  _$jscoverage['modules/hosts.js'][59] = 0;
  _$jscoverage['modules/hosts.js'][60] = 0;
  _$jscoverage['modules/hosts.js'][61] = 0;
  _$jscoverage['modules/hosts.js'][62] = 0;
  _$jscoverage['modules/hosts.js'][64] = 0;
  _$jscoverage['modules/hosts.js'][65] = 0;
  _$jscoverage['modules/hosts.js'][67] = 0;
  _$jscoverage['modules/hosts.js'][71] = 0;
  _$jscoverage['modules/hosts.js'][72] = 0;
  _$jscoverage['modules/hosts.js'][73] = 0;
  _$jscoverage['modules/hosts.js'][74] = 0;
  _$jscoverage['modules/hosts.js'][76] = 0;
  _$jscoverage['modules/hosts.js'][79] = 0;
  _$jscoverage['modules/hosts.js'][80] = 0;
  _$jscoverage['modules/hosts.js'][81] = 0;
  _$jscoverage['modules/hosts.js'][82] = 0;
  _$jscoverage['modules/hosts.js'][84] = 0;
  _$jscoverage['modules/hosts.js'][89] = 0;
}
_$jscoverage['modules/hosts.js'][1]++;
var constants = require("./constants");
_$jscoverage['modules/hosts.js'][2]++;
var appProps = require("./appProps");
_$jscoverage['modules/hosts.js'][4]++;
function removeEndSlash(input) {
  _$jscoverage['modules/hosts.js'][5]++;
  var ret = input;
  _$jscoverage['modules/hosts.js'][6]++;
  if (ret.charAt(ret.length - 1) === "/") {
    _$jscoverage['modules/hosts.js'][7]++;
    ret = ret.substring(0, ret.length - 1);
  }
  _$jscoverage['modules/hosts.js'][9]++;
  return ret;
}
_$jscoverage['modules/hosts.js'][12]++;
function removeStartSlash(input) {
  _$jscoverage['modules/hosts.js'][13]++;
  var ret = input;
  _$jscoverage['modules/hosts.js'][14]++;
  if (ret.length > 1 && ret.charAt(0) === "/") {
    _$jscoverage['modules/hosts.js'][15]++;
    ret = ret.substring(1, ret.length);
  }
  _$jscoverage['modules/hosts.js'][17]++;
  return ret;
}
_$jscoverage['modules/hosts.js'][20]++;
function CloudHost(cloud_props) {
  _$jscoverage['modules/hosts.js'][21]++;
  this.cloud_props = cloud_props;
  _$jscoverage['modules/hosts.js'][22]++;
  this.cloud_host = undefined;
  _$jscoverage['modules/hosts.js'][23]++;
  this.isLegacy = false;
}
_$jscoverage['modules/hosts.js'][26]++;
CloudHost.prototype.getHost = (function (appType) {
  _$jscoverage['modules/hosts.js'][27]++;
  if (this.cloud_host) {
    _$jscoverage['modules/hosts.js'][28]++;
    return this.cloud_host;
  }
  else {
    _$jscoverage['modules/hosts.js'][30]++;
    var url;
    _$jscoverage['modules/hosts.js'][31]++;
    var app_type;
    _$jscoverage['modules/hosts.js'][32]++;
    if (this.cloud_props && this.cloud_props.hosts) {
      _$jscoverage['modules/hosts.js'][33]++;
      url = this.cloud_props.hosts.url;
      _$jscoverage['modules/hosts.js'][35]++;
      if (typeof url === "undefined") {
        _$jscoverage['modules/hosts.js'][40]++;
        var cloud_host = this.cloud_props.hosts.releaseCloudUrl;
        _$jscoverage['modules/hosts.js'][41]++;
        app_type = this.cloud_props.hosts.releaseCloudType;
        _$jscoverage['modules/hosts.js'][43]++;
        if (typeof appType !== "undefined" && appType.indexOf("dev") > -1) {
          _$jscoverage['modules/hosts.js'][44]++;
          cloud_host = this.cloud_props.hosts.debugCloudUrl;
          _$jscoverage['modules/hosts.js'][45]++;
          app_type = this.cloud_props.hosts.debugCloudType;
        }
        _$jscoverage['modules/hosts.js'][47]++;
        url = cloud_host;
      }
    }
    _$jscoverage['modules/hosts.js'][50]++;
    url = removeEndSlash(url);
    _$jscoverage['modules/hosts.js'][51]++;
    this.cloud_host = url;
    _$jscoverage['modules/hosts.js'][52]++;
    if (app_type === "fh") {
      _$jscoverage['modules/hosts.js'][53]++;
      this.isLegacy = true;
    }
    _$jscoverage['modules/hosts.js'][55]++;
    return url;
  }
});
_$jscoverage['modules/hosts.js'][59]++;
CloudHost.prototype.getActUrl = (function (act) {
  _$jscoverage['modules/hosts.js'][60]++;
  var app_props = appProps.getAppProps() || {};
  _$jscoverage['modules/hosts.js'][61]++;
  if (typeof this.cloud_host === "undefined") {
    _$jscoverage['modules/hosts.js'][62]++;
    this.getHost(app_props.mode);
  }
  _$jscoverage['modules/hosts.js'][64]++;
  if (this.isLegacy) {
    _$jscoverage['modules/hosts.js'][65]++;
    return this.cloud_host + constants.boxprefix + "act/" + this.cloud_props.domain + "/" + app_props.appid + "/" + act + "/" + app_props.appid;
  }
  else {
    _$jscoverage['modules/hosts.js'][67]++;
    return this.cloud_host + "/cloud/" + act;
  }
});
_$jscoverage['modules/hosts.js'][71]++;
CloudHost.prototype.getMBAASUrl = (function (service) {
  _$jscoverage['modules/hosts.js'][72]++;
  var app_props = appProps.getAppProps() || {};
  _$jscoverage['modules/hosts.js'][73]++;
  if (typeof this.cloud_host === "undefined") {
    _$jscoverage['modules/hosts.js'][74]++;
    this.getHost(app_props.mode);
  }
  _$jscoverage['modules/hosts.js'][76]++;
  return this.cloud_host + "/mbaas/" + service;
});
_$jscoverage['modules/hosts.js'][79]++;
CloudHost.prototype.getCloudUrl = (function (path) {
  _$jscoverage['modules/hosts.js'][80]++;
  var app_props = appProps.getAppProps() || {};
  _$jscoverage['modules/hosts.js'][81]++;
  if (typeof this.cloud_host === "undefined") {
    _$jscoverage['modules/hosts.js'][82]++;
    this.getHost(app_props.mode);
  }
  _$jscoverage['modules/hosts.js'][84]++;
  return this.cloud_host + "/" + removeStartSlash(path);
});
_$jscoverage['modules/hosts.js'][89]++;
module.exports = CloudHost;
_$jscoverage['modules/hosts.js'].source = ["var constants = require(\"./constants\");","var appProps = require(\"./appProps\");","","function removeEndSlash(input){","  var ret = input;","  if(ret.charAt(ret.length - 1) === \"/\"){","    ret = ret.substring(0, ret.length-1);","  }","  return ret;","}","","function removeStartSlash(input){","  var ret = input;","  if(ret.length &gt; 1 &amp;&amp; ret.charAt(0) === \"/\"){","    ret = ret.substring(1, ret.length);","  }","  return ret;","}","","function CloudHost(cloud_props){","  this.cloud_props = cloud_props;","  this.cloud_host = undefined;","  this.isLegacy = false;","}","","CloudHost.prototype.getHost = function(appType){","  if(this.cloud_host){","    return this.cloud_host;","  } else {","    var url;","    var app_type;","    if(this.cloud_props &amp;&amp; this.cloud_props.hosts){","      url = this.cloud_props.hosts.url;","","      if (typeof url === 'undefined') {","        // resolve url the old way i.e. depending on","        // -burnt in app mode","        // -returned dev or live url","        // -returned dev or live type (node or fh(rhino or proxying))","        var cloud_host = this.cloud_props.hosts.releaseCloudUrl;","        app_type = this.cloud_props.hosts.releaseCloudType;","","        if(typeof appType !== \"undefined\" &amp;&amp; appType.indexOf(\"dev\") &gt; -1){","          cloud_host = this.cloud_props.hosts.debugCloudUrl;","          app_type = this.cloud_props.hosts.debugCloudType;","        }","        url = cloud_host;","      }","    }","    url = removeEndSlash(url);","    this.cloud_host = url;","    if(app_type === \"fh\"){","      this.isLegacy = true;","    }","    return url;","  }","}","","CloudHost.prototype.getActUrl = function(act){","  var app_props = appProps.getAppProps() || {};","  if(typeof this.cloud_host === \"undefined\"){","    this.getHost(app_props.mode);","  }","  if(this.isLegacy){","    return this.cloud_host + constants.boxprefix + \"act/\" + this.cloud_props.domain + \"/\" + app_props.appid + \"/\" + act + \"/\" + app_props.appid;","  } else {","    return this.cloud_host + \"/cloud/\" + act;","  }","}","","CloudHost.prototype.getMBAASUrl = function(service){","  var app_props = appProps.getAppProps() || {};","  if(typeof this.cloud_host === \"undefined\"){","    this.getHost(app_props.mode);","  }","  return this.cloud_host + \"/mbaas/\" + service;","}","","CloudHost.prototype.getCloudUrl = function(path){","  var app_props = appProps.getAppProps() || {};","  if(typeof this.cloud_host === \"undefined\"){","    this.getHost(app_props.mode);","  }","  return this.cloud_host + \"/\" + removeStartSlash(path);","}","","","","module.exports = CloudHost;"];

},{"./appProps":57,"./constants":58}],65:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/initializer.js']) {
  _$jscoverage['modules/initializer.js'] = [];
  _$jscoverage['modules/initializer.js'][1] = 0;
  _$jscoverage['modules/initializer.js'][2] = 0;
  _$jscoverage['modules/initializer.js'][3] = 0;
  _$jscoverage['modules/initializer.js'][4] = 0;
  _$jscoverage['modules/initializer.js'][5] = 0;
  _$jscoverage['modules/initializer.js'][6] = 0;
  _$jscoverage['modules/initializer.js'][7] = 0;
  _$jscoverage['modules/initializer.js'][8] = 0;
  _$jscoverage['modules/initializer.js'][9] = 0;
  _$jscoverage['modules/initializer.js'][10] = 0;
  _$jscoverage['modules/initializer.js'][11] = 0;
  _$jscoverage['modules/initializer.js'][13] = 0;
  _$jscoverage['modules/initializer.js'][14] = 0;
  _$jscoverage['modules/initializer.js'][15] = 0;
  _$jscoverage['modules/initializer.js'][16] = 0;
  _$jscoverage['modules/initializer.js'][20] = 0;
  _$jscoverage['modules/initializer.js'][21] = 0;
  _$jscoverage['modules/initializer.js'][22] = 0;
  _$jscoverage['modules/initializer.js'][25] = 0;
  _$jscoverage['modules/initializer.js'][26] = 0;
  _$jscoverage['modules/initializer.js'][43] = 0;
  _$jscoverage['modules/initializer.js'][50] = 0;
  _$jscoverage['modules/initializer.js'][54] = 0;
  _$jscoverage['modules/initializer.js'][58] = 0;
  _$jscoverage['modules/initializer.js'][59] = 0;
  _$jscoverage['modules/initializer.js'][63] = 0;
  _$jscoverage['modules/initializer.js'][64] = 0;
  _$jscoverage['modules/initializer.js'][65] = 0;
  _$jscoverage['modules/initializer.js'][69] = 0;
  _$jscoverage['modules/initializer.js'][70] = 0;
  _$jscoverage['modules/initializer.js'][73] = 0;
  _$jscoverage['modules/initializer.js'][75] = 0;
  _$jscoverage['modules/initializer.js'][76] = 0;
  _$jscoverage['modules/initializer.js'][77] = 0;
  _$jscoverage['modules/initializer.js'][78] = 0;
  _$jscoverage['modules/initializer.js'][79] = 0;
  _$jscoverage['modules/initializer.js'][80] = 0;
  _$jscoverage['modules/initializer.js'][81] = 0;
  _$jscoverage['modules/initializer.js'][84] = 0;
  _$jscoverage['modules/initializer.js'][86] = 0;
  _$jscoverage['modules/initializer.js'][87] = 0;
  _$jscoverage['modules/initializer.js'][90] = 0;
  _$jscoverage['modules/initializer.js'][92] = 0;
  _$jscoverage['modules/initializer.js'][101] = 0;
  _$jscoverage['modules/initializer.js'][105] = 0;
  _$jscoverage['modules/initializer.js'][106] = 0;
  _$jscoverage['modules/initializer.js'][113] = 0;
  _$jscoverage['modules/initializer.js'][114] = 0;
  _$jscoverage['modules/initializer.js'][115] = 0;
  _$jscoverage['modules/initializer.js'][120] = 0;
  _$jscoverage['modules/initializer.js'][121] = 0;
  _$jscoverage['modules/initializer.js'][122] = 0;
  _$jscoverage['modules/initializer.js'][134] = 0;
}
_$jscoverage['modules/initializer.js'][1]++;
var loadScript = require("./loadScript");
_$jscoverage['modules/initializer.js'][2]++;
var Lawnchair = require("../../libs/generated/lawnchair");
_$jscoverage['modules/initializer.js'][3]++;
var lawnchairext = require("./lawnchair-ext");
_$jscoverage['modules/initializer.js'][4]++;
var consts = require("./constants");
_$jscoverage['modules/initializer.js'][5]++;
var fhparams = require("./fhparams");
_$jscoverage['modules/initializer.js'][6]++;
var ajax = require("./ajax");
_$jscoverage['modules/initializer.js'][7]++;
var handleError = require("./handleError");
_$jscoverage['modules/initializer.js'][8]++;
var logger = require("./logger");
_$jscoverage['modules/initializer.js'][9]++;
var JSON = require("JSON");
_$jscoverage['modules/initializer.js'][10]++;
var hashFunc = require("./security/hash");
_$jscoverage['modules/initializer.js'][11]++;
var appProps = require("./appProps");
_$jscoverage['modules/initializer.js'][13]++;
var init = (function (cb) {
  _$jscoverage['modules/initializer.js'][14]++;
  appProps.load((function (err, data) {
  _$jscoverage['modules/initializer.js'][15]++;
  if (err) {
    _$jscoverage['modules/initializer.js'][15]++;
    return cb(err);
  }
  _$jscoverage['modules/initializer.js'][16]++;
  return loadCloudProps(data, cb);
}));
});
_$jscoverage['modules/initializer.js'][20]++;
var loadCloudProps = (function (app_props, callback) {
  _$jscoverage['modules/initializer.js'][21]++;
  if (app_props.loglevel) {
    _$jscoverage['modules/initializer.js'][22]++;
    logger.setLevel(app_props.loglevel);
  }
  _$jscoverage['modules/initializer.js'][25]++;
  if (app_props.local) {
    _$jscoverage['modules/initializer.js'][26]++;
    var res = {"domain": "local", "firstTime": false, "hosts": {"debugCloudType": "node", "debugCloudUrl": app_props.host, "releaseCloudType": "node", "releaseCloudUrl": app_props.host, "type": "cloud_nodejs", "url": app_props.host}, "init": {"trackId": "000000000000000000000000"}, "status": "ok"};
    _$jscoverage['modules/initializer.js'][43]++;
    return callback(null, {cloud: res});
  }
  _$jscoverage['modules/initializer.js'][50]++;
  lawnchairext.addAdapter(app_props, hashFunc);
  _$jscoverage['modules/initializer.js'][54]++;
  var lcConf = {name: "fh_init_storage", adapter: ["dom", "webkit-sqlite", "localFileStorage", "window-name"], fail: (function (msg, err) {
  _$jscoverage['modules/initializer.js'][58]++;
  var error_message = "read/save from/to local storage failed  msg:" + msg + " err:" + err;
  _$jscoverage['modules/initializer.js'][59]++;
  return fail(error_message, {});
})};
  _$jscoverage['modules/initializer.js'][63]++;
  var storage = null;
  _$jscoverage['modules/initializer.js'][64]++;
  try {
    _$jscoverage['modules/initializer.js'][65]++;
    storage = new Lawnchair(lcConf, (function () {
}));
  }
  catch (e) {
    _$jscoverage['modules/initializer.js'][69]++;
    lcConf.adapter = undefined;
    _$jscoverage['modules/initializer.js'][70]++;
    storage = new Lawnchair(lcConf, (function () {
}));
  }
  _$jscoverage['modules/initializer.js'][73]++;
  var path = app_props.host + consts.boxprefix + "app/init";
  _$jscoverage['modules/initializer.js'][75]++;
  storage.get("fh_init", (function (storage_res) {
  _$jscoverage['modules/initializer.js'][76]++;
  var savedHost = null;
  _$jscoverage['modules/initializer.js'][77]++;
  if (storage_res && storage_res.value !== null && typeof storage_res.value !== "undefined" && storage_res !== "") {
    _$jscoverage['modules/initializer.js'][78]++;
    storage_res = typeof storage_res === "string"? JSON.parse(storage_res): storage_res;
    _$jscoverage['modules/initializer.js'][79]++;
    storage_res.value = typeof storage_res.value === "string"? JSON.parse(storage_res.value): storage_res.value;
    _$jscoverage['modules/initializer.js'][80]++;
    if (storage_res.value.init) {
      _$jscoverage['modules/initializer.js'][81]++;
      app_props.init = storage_res.value.init;
    }
    else {
      _$jscoverage['modules/initializer.js'][84]++;
      app_props.init = typeof storage_res.value === "string"? JSON.parse(storage_res.value): storage_res.value;
    }
    _$jscoverage['modules/initializer.js'][86]++;
    if (storage_res.value.hosts) {
      _$jscoverage['modules/initializer.js'][87]++;
      savedHost = storage_res.value;
    }
  }
  _$jscoverage['modules/initializer.js'][90]++;
  var data = fhparams.buildFHParams();
  _$jscoverage['modules/initializer.js'][92]++;
  ajax({"url": path, "type": "POST", "tryJSONP": true, "dataType": "json", "contentType": "application/json", "data": JSON.stringify(data), "timeout": app_props.timeout || consts.fh_timeout, "success": (function (initRes) {
  _$jscoverage['modules/initializer.js'][101]++;
  storage.save({key: "fh_init", value: initRes}, (function () {
}));
  _$jscoverage['modules/initializer.js'][105]++;
  if (callback) {
    _$jscoverage['modules/initializer.js'][106]++;
    callback(null, {cloud: initRes});
  }
}), "error": (function (req, statusText, error) {
  _$jscoverage['modules/initializer.js'][113]++;
  if (savedHost) {
    _$jscoverage['modules/initializer.js'][114]++;
    if (callback) {
      _$jscoverage['modules/initializer.js'][115]++;
      callback(null, {cloud: savedHost});
    }
  }
  else {
    _$jscoverage['modules/initializer.js'][120]++;
    handleError((function (msg, err) {
  _$jscoverage['modules/initializer.js'][121]++;
  if (callback) {
    _$jscoverage['modules/initializer.js'][122]++;
    callback({error: err, message: msg});
  }
}), req, statusText, error);
  }
})});
}));
});
_$jscoverage['modules/initializer.js'][134]++;
module.exports = {"init": init, "loadCloudProps": loadCloudProps};
_$jscoverage['modules/initializer.js'].source = ["var loadScript = require(\"./loadScript\");","var Lawnchair = require('../../libs/generated/lawnchair');","var lawnchairext = require('./lawnchair-ext');","var consts = require(\"./constants\");","var fhparams = require(\"./fhparams\");","var ajax = require(\"./ajax\");","var handleError = require(\"./handleError\");","var logger = require(\"./logger\");","var JSON = require(\"JSON\");","var hashFunc = require(\"./security/hash\");","var appProps = require(\"./appProps\");","","var init = function(cb) {","  appProps.load(function(err, data) {","    if (err) return cb(err);","    return loadCloudProps(data, cb);","  });","}","","var loadCloudProps = function(app_props, callback) {","  if(app_props.loglevel){","    logger.setLevel(app_props.loglevel);","  }","  // If local - shortcircuit the init - just return the host","  if (app_props.local) {","    var res = {","      \"domain\": \"local\",","      \"firstTime\": false,","      \"hosts\": {","        \"debugCloudType\": \"node\",","        \"debugCloudUrl\": app_props.host,","        \"releaseCloudType\": \"node\",","        \"releaseCloudUrl\": app_props.host,","        \"type\": \"cloud_nodejs\",","        \"url\": app_props.host","      },","      \"init\": {","        \"trackId\": \"000000000000000000000000\"","      },","      \"status\": \"ok\"","    };","","    return callback(null, {","      cloud: res","    });","  }","","","  //now we have app props, add the fileStorageAdapter","  lawnchairext.addAdapter(app_props, hashFunc);","  //dom adapter doens't work on windows phone, so don't specify the adapter if the dom one failed","  //we specify the order of lawnchair adapters to use, lawnchair will find the right one to use, to keep backward compatibility, keep the order","  //as dom, webkit-sqlite, localFileStorage, window-name","  var lcConf = {","    name: \"fh_init_storage\",","    adapter: [\"dom\", \"webkit-sqlite\", \"localFileStorage\", \"window-name\"],","    fail: function(msg, err) {","      var error_message = 'read/save from/to local storage failed  msg:' + msg + ' err:' + err;","      return fail(error_message, {});","    }","  };","","  var storage = null;","  try {","    storage = new Lawnchair(lcConf, function() {});","  } catch (e) {","    //when dom adapter failed, Lawnchair throws an error","    //shoudn't go in here anymore","    lcConf.adapter = undefined;","    storage = new Lawnchair(lcConf, function() {});","  }","","  var path = app_props.host + consts.boxprefix + \"app/init\";","","  storage.get('fh_init', function(storage_res) {","    var savedHost = null;","    if (storage_res &amp;&amp; storage_res.value !== null &amp;&amp; typeof(storage_res.value) !== \"undefined\" &amp;&amp; storage_res !== \"\") {","      storage_res = typeof(storage_res) === \"string\" ? JSON.parse(storage_res) : storage_res;","      storage_res.value = typeof(storage_res.value) === \"string\" ? JSON.parse(storage_res.value) : storage_res.value;","      if (storage_res.value.init) {","        app_props.init = storage_res.value.init;","      } else {","        //keep it backward compatible.","        app_props.init = typeof(storage_res.value) === \"string\" ? JSON.parse(storage_res.value) : storage_res.value;","      }","      if (storage_res.value.hosts) {","        savedHost = storage_res.value;","      }","    }","    var data = fhparams.buildFHParams();","","    ajax({","      \"url\": path,","      \"type\": \"POST\",","      \"tryJSONP\": true,","      \"dataType\": \"json\",","      \"contentType\": \"application/json\",","      \"data\": JSON.stringify(data),","      \"timeout\": app_props.timeout || consts.fh_timeout,","      \"success\": function(initRes) {","        storage.save({","          key: \"fh_init\",","          value: initRes","        }, function() {});","        if (callback) {","          callback(null, {","            cloud: initRes","          });","        }","      },","      \"error\": function(req, statusText, error) {","        //use the cached host if we have a copy","        if (savedHost) {","          if (callback) {","            callback(null, {","              cloud: savedHost","            });","          }","        } else {","          handleError(function(msg, err) {","            if (callback) {","              callback({","                error: err,","                message: msg","              });","            }","          }, req, statusText, error);","        }","      }","    });","  });","};","","module.exports = {","  \"init\": init,","  \"loadCloudProps\": loadCloudProps","}"];

},{"../../libs/generated/lawnchair":2,"./ajax":54,"./appProps":57,"./constants":58,"./fhparams":62,"./handleError":63,"./lawnchair-ext":66,"./loadScript":67,"./logger":68,"./security/hash":72,"JSON":3}],66:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/lawnchair-ext.js']) {
  _$jscoverage['modules/lawnchair-ext.js'] = [];
  _$jscoverage['modules/lawnchair-ext.js'][1] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][3] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][6] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][7] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][8] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][12] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][13] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][14] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][18] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][19] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][21] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][25] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][26] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][27] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][28] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][29] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][30] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][31] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][32] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][34] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][36] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][37] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][39] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][42] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][43] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][48] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][50] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][54] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][55] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][59] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][63] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][64] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][65] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][66] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][68] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][71] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][72] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][73] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][78] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][80] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][83] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][86] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][92] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][96] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][97] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][98] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][99] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][100] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][101] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][102] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][105] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][106] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][111] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][116] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][118] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][122] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][128] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][134] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][135] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][136] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][138] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][140] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][147] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][151] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][153] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][154] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][156] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][157] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][162] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][165] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][168] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][174] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][181] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][182] = 0;
  _$jscoverage['modules/lawnchair-ext.js'][185] = 0;
}
_$jscoverage['modules/lawnchair-ext.js'][1]++;
var Lawnchair = require("../../libs/generated/lawnchair");
_$jscoverage['modules/lawnchair-ext.js'][3]++;
var fileStorageAdapter = (function (app_props, hashFunc) {
  _$jscoverage['modules/lawnchair-ext.js'][6]++;
  function doLog(mess) {
    _$jscoverage['modules/lawnchair-ext.js'][7]++;
    if (console) {
      _$jscoverage['modules/lawnchair-ext.js'][8]++;
      console.log(mess);
    }
}
  _$jscoverage['modules/lawnchair-ext.js'][12]++;
  var fail = (function (e, i) {
  _$jscoverage['modules/lawnchair-ext.js'][13]++;
  if (console) {
    _$jscoverage['modules/lawnchair-ext.js'][13]++;
    console.log("error in file system adapter !", e, i);
  }
  else {
    _$jscoverage['modules/lawnchair-ext.js'][14]++;
    throw e;
  }
});
  _$jscoverage['modules/lawnchair-ext.js'][18]++;
  function filenameForKey(key, cb) {
    _$jscoverage['modules/lawnchair-ext.js'][19]++;
    key = app_props.appid + key;
    _$jscoverage['modules/lawnchair-ext.js'][21]++;
    hashFunc({algorithm: "MD5", text: key}, (function (result) {
  _$jscoverage['modules/lawnchair-ext.js'][25]++;
  var filename = result.hashvalue + ".txt";
  _$jscoverage['modules/lawnchair-ext.js'][26]++;
  if (typeof navigator.externalstorage !== "undefined") {
    _$jscoverage['modules/lawnchair-ext.js'][27]++;
    navigator.externalstorage.enable((function handleSuccess(res) {
  _$jscoverage['modules/lawnchair-ext.js'][28]++;
  var path = filename;
  _$jscoverage['modules/lawnchair-ext.js'][29]++;
  if (res.path) {
    _$jscoverage['modules/lawnchair-ext.js'][30]++;
    path = res.path;
    _$jscoverage['modules/lawnchair-ext.js'][31]++;
    if (! path.match(/\/$/)) {
      _$jscoverage['modules/lawnchair-ext.js'][32]++;
      path += "/";
    }
    _$jscoverage['modules/lawnchair-ext.js'][34]++;
    path += filename;
  }
  _$jscoverage['modules/lawnchair-ext.js'][36]++;
  filename = path;
  _$jscoverage['modules/lawnchair-ext.js'][37]++;
  return cb(filename);
}), (function handleError(err) {
  _$jscoverage['modules/lawnchair-ext.js'][39]++;
  return cb(filename);
}));
  }
  else {
    _$jscoverage['modules/lawnchair-ext.js'][42]++;
    doLog("filenameForKey key=" + key + " , Filename: " + filename);
    _$jscoverage['modules/lawnchair-ext.js'][43]++;
    return cb(filename);
  }
}));
}
  _$jscoverage['modules/lawnchair-ext.js'][48]++;
  return ({valid: (function () {
  _$jscoverage['modules/lawnchair-ext.js'][50]++;
  return ! ! window.requestFileSystem;
}), init: (function (options, callback) {
  _$jscoverage['modules/lawnchair-ext.js'][54]++;
  if (options && "function" === typeof options.fail) {
    _$jscoverage['modules/lawnchair-ext.js'][54]++;
    fail = options.fail;
  }
  _$jscoverage['modules/lawnchair-ext.js'][55]++;
  if (callback) {
    _$jscoverage['modules/lawnchair-ext.js'][55]++;
    this.fn(this.name, callback).call(this, this);
  }
}), keys: (function (callback) {
  _$jscoverage['modules/lawnchair-ext.js'][59]++;
  throw "Currently not supported";
}), save: (function (obj, callback) {
  _$jscoverage['modules/lawnchair-ext.js'][63]++;
  var key = obj.key;
  _$jscoverage['modules/lawnchair-ext.js'][64]++;
  var value = obj.val || obj.value;
  _$jscoverage['modules/lawnchair-ext.js'][65]++;
  filenameForKey(key, (function (hash) {
  _$jscoverage['modules/lawnchair-ext.js'][66]++;
  window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, (function gotFS(fileSystem) {
  _$jscoverage['modules/lawnchair-ext.js'][68]++;
  fileSystem.root.getFile(hash, {create: true}, (function gotFileEntry(fileEntry) {
  _$jscoverage['modules/lawnchair-ext.js'][71]++;
  fileEntry.createWriter((function gotFileWriter(writer) {
  _$jscoverage['modules/lawnchair-ext.js'][72]++;
  writer.onwrite = (function () {
  _$jscoverage['modules/lawnchair-ext.js'][73]++;
  return callback({key: key, val: value});
});
  _$jscoverage['modules/lawnchair-ext.js'][78]++;
  writer.write(value);
}), (function () {
  _$jscoverage['modules/lawnchair-ext.js'][80]++;
  fail("[save] Failed to create file writer");
}));
}), (function () {
  _$jscoverage['modules/lawnchair-ext.js'][83]++;
  fail("[save] Failed to getFile");
}));
}), (function () {
  _$jscoverage['modules/lawnchair-ext.js'][86]++;
  fail("[save] Failed to requestFileSystem");
}));
}));
}), batch: (function (records, callback) {
  _$jscoverage['modules/lawnchair-ext.js'][92]++;
  throw "Currently not supported";
}), get: (function (key, callback) {
  _$jscoverage['modules/lawnchair-ext.js'][96]++;
  filenameForKey(key, (function (hash) {
  _$jscoverage['modules/lawnchair-ext.js'][97]++;
  window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, (function gotFS(fileSystem) {
  _$jscoverage['modules/lawnchair-ext.js'][98]++;
  fileSystem.root.getFile(hash, {}, (function gotFileEntry(fileEntry) {
  _$jscoverage['modules/lawnchair-ext.js'][99]++;
  fileEntry.file((function gotFile(file) {
  _$jscoverage['modules/lawnchair-ext.js'][100]++;
  var reader = new FileReader();
  _$jscoverage['modules/lawnchair-ext.js'][101]++;
  reader.onloadend = (function (evt) {
  _$jscoverage['modules/lawnchair-ext.js'][102]++;
  var text = evt.target.result;
  _$jscoverage['modules/lawnchair-ext.js'][105]++;
  try {
    _$jscoverage['modules/lawnchair-ext.js'][106]++;
    text = decodeURIComponent(text);
  }
  catch (e) {
  }
  _$jscoverage['modules/lawnchair-ext.js'][111]++;
  return callback({key: key, val: text});
});
  _$jscoverage['modules/lawnchair-ext.js'][116]++;
  reader.readAsText(file);
}), (function () {
  _$jscoverage['modules/lawnchair-ext.js'][118]++;
  fail("[load] Failed to getFile");
}));
}), (function () {
  _$jscoverage['modules/lawnchair-ext.js'][122]++;
  callback({key: key, val: null});
}));
}), (function () {
  _$jscoverage['modules/lawnchair-ext.js'][128]++;
  fail("[load] Failed to get fileSystem");
}));
}));
}), exists: (function (key, callback) {
  _$jscoverage['modules/lawnchair-ext.js'][134]++;
  filenameForKey(key, (function (hash) {
  _$jscoverage['modules/lawnchair-ext.js'][135]++;
  window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, (function gotFS(fileSystem) {
  _$jscoverage['modules/lawnchair-ext.js'][136]++;
  fileSystem.root.getFile(hash, {}, (function gotFileEntry(fileEntry) {
  _$jscoverage['modules/lawnchair-ext.js'][138]++;
  return callback(true);
}), (function (err) {
  _$jscoverage['modules/lawnchair-ext.js'][140]++;
  return callback(false);
}));
}));
}));
}), all: (function (callback) {
  _$jscoverage['modules/lawnchair-ext.js'][147]++;
  throw "Currently not supported";
}), remove: (function (key, callback) {
  _$jscoverage['modules/lawnchair-ext.js'][151]++;
  filenameForKey(key, (function (hash) {
  _$jscoverage['modules/lawnchair-ext.js'][153]++;
  window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, (function gotFS(fileSystem) {
  _$jscoverage['modules/lawnchair-ext.js'][154]++;
  fileSystem.root.getFile(hash, {}, (function gotFileEntry(fileEntry) {
  _$jscoverage['modules/lawnchair-ext.js'][156]++;
  fileEntry.remove((function () {
  _$jscoverage['modules/lawnchair-ext.js'][157]++;
  return callback({key: key, val: null});
}), (function () {
  _$jscoverage['modules/lawnchair-ext.js'][162]++;
  fail("[remove] Failed to remove file");
}));
}), (function () {
  _$jscoverage['modules/lawnchair-ext.js'][165]++;
  fail("[remove] Failed to getFile");
}));
}), (function () {
  _$jscoverage['modules/lawnchair-ext.js'][168]++;
  fail("[remove] Failed to get fileSystem");
}));
}));
}), nuke: (function (callback) {
  _$jscoverage['modules/lawnchair-ext.js'][174]++;
  throw "Currently not supported";
})});
});
_$jscoverage['modules/lawnchair-ext.js'][181]++;
var addAdapter = (function (app_props, hashFunc) {
  _$jscoverage['modules/lawnchair-ext.js'][182]++;
  Lawnchair.adapter("localFileStorage", fileStorageAdapter(app_props, hashFunc));
});
_$jscoverage['modules/lawnchair-ext.js'][185]++;
module.exports = {addAdapter: addAdapter};
_$jscoverage['modules/lawnchair-ext.js'].source = ["var Lawnchair = require('../../libs/generated/lawnchair');","","var fileStorageAdapter = function (app_props, hashFunc) {","  // private methods","","  function doLog(mess){","    if(console){","      console.log(mess);","    }","  }","","  var fail = function (e, i) {","    if(console) console.log('error in file system adapter !', e, i);","    else throw e;","  };","","","  function filenameForKey(key, cb) {","    key = app_props.appid + key;","","    hashFunc({","      algorithm: \"MD5\",","      text: key","    }, function(result) {","      var filename = result.hashvalue + '.txt';","      if (typeof navigator.externalstorage !== \"undefined\") {","        navigator.externalstorage.enable(function handleSuccess(res){","          var path = filename;","          if(res.path ) {","            path = res.path;","            if(!path.match(/\\/$/)) {","              path += '/';","            }","            path += filename;","          }","          filename = path;","          return cb(filename);","        },function handleError(err){","          return cb(filename);","        })","      } else {","        doLog('filenameForKey key=' + key+ ' , Filename: ' + filename);","        return cb(filename);","      }","    });","  }","","  return {","","    valid: function () { return !!(window.requestFileSystem) },","","    init : function (options, callback){","      //calls the parent function fn and applies this scope","      if(options &amp;&amp; 'function' === typeof options.fail ) fail = options.fail;","      if (callback) this.fn(this.name, callback).call(this, this);","    },","","    keys: function (callback){","      throw \"Currently not supported\";","    },","","    save : function (obj, callback){","      var key = obj.key;","      var value = obj.val||obj.value;","      filenameForKey(key, function(hash) {","        window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, function gotFS(fileSystem) {","","          fileSystem.root.getFile(hash, {","            create: true","          }, function gotFileEntry(fileEntry) {","            fileEntry.createWriter(function gotFileWriter(writer) {","              writer.onwrite = function() {","                return callback({","                  key: key,","                  val: value","                });","              };","              writer.write(value);","            }, function() {","              fail('[save] Failed to create file writer');","            });","          }, function() {","            fail('[save] Failed to getFile');","          });","        }, function() {","          fail('[save] Failed to requestFileSystem');","        });","      });","    },","","    batch : function (records, callback){","      throw \"Currently not supported\";","    },","","    get : function (key, callback){","      filenameForKey(key, function(hash) {","        window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, function gotFS(fileSystem) {","          fileSystem.root.getFile(hash, {}, function gotFileEntry(fileEntry) {","            fileEntry.file(function gotFile(file) {","              var reader = new FileReader();","              reader.onloadend = function (evt) {","                var text = evt.target.result;","                // Check for URLencoded","                // PG 2.2 bug in readAsText()","                try {","                  text = decodeURIComponent(text);","                } catch (e) {","                  // Swallow exception if not URLencoded","                  // Just use the result","                }","                return callback({","                  key: key,","                  val: text","                });","              };","              reader.readAsText(file);","            }, function() {","              fail('[load] Failed to getFile');","            });","          }, function() {","            // Success callback on key load failure","            callback({","              key: key,","              val: null","            });","          });","        }, function() {","          fail('[load] Failed to get fileSystem');","        });","      });","    },","","    exists : function (key, callback){","      filenameForKey(key,function (hash){","        window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, function gotFS(fileSystem) {","          fileSystem.root.getFile(hash, {},","            function gotFileEntry(fileEntry) {","              return callback(true);","            }, function (err){","              return callback(false);","            });","        });","      });","    },","","    all : function (callback){","      throw \"Currently not supported\";","    },","","    remove : function (key, callback){","      filenameForKey(key, function(hash) {","","        window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, function gotFS(fileSystem) {","          fileSystem.root.getFile(hash, {}, function gotFileEntry(fileEntry) {","","            fileEntry.remove(function() {","              return callback({","                key: key,","                val: null","              });","            }, function() {","              fail('[remove] Failed to remove file');","            });","          }, function() {","            fail('[remove] Failed to getFile');","          });","        }, function() {","          fail('[remove] Failed to get fileSystem');","        });","      });","    },","","    nuke : function (callback){","      throw \"Currently not supported\";","    }","","","  };","}","","var addAdapter = function(app_props, hashFunc){","  Lawnchair.adapter('localFileStorage', fileStorageAdapter(app_props, hashFunc));","}","","module.exports = {","  addAdapter: addAdapter","}"];

},{"../../libs/generated/lawnchair":2}],67:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/loadScript.js']) {
  _$jscoverage['modules/loadScript.js'] = [];
  _$jscoverage['modules/loadScript.js'][1] = 0;
  _$jscoverage['modules/loadScript.js'][2] = 0;
  _$jscoverage['modules/loadScript.js'][3] = 0;
  _$jscoverage['modules/loadScript.js'][4] = 0;
  _$jscoverage['modules/loadScript.js'][5] = 0;
  _$jscoverage['modules/loadScript.js'][6] = 0;
  _$jscoverage['modules/loadScript.js'][7] = 0;
  _$jscoverage['modules/loadScript.js'][8] = 0;
  _$jscoverage['modules/loadScript.js'][9] = 0;
  _$jscoverage['modules/loadScript.js'][10] = 0;
  _$jscoverage['modules/loadScript.js'][11] = 0;
  _$jscoverage['modules/loadScript.js'][12] = 0;
  _$jscoverage['modules/loadScript.js'][14] = 0;
  _$jscoverage['modules/loadScript.js'][15] = 0;
  _$jscoverage['modules/loadScript.js'][16] = 0;
  _$jscoverage['modules/loadScript.js'][20] = 0;
}
_$jscoverage['modules/loadScript.js'][1]++;
module.exports = (function (url, callback) {
  _$jscoverage['modules/loadScript.js'][2]++;
  var script;
  _$jscoverage['modules/loadScript.js'][3]++;
  var head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;
  _$jscoverage['modules/loadScript.js'][4]++;
  script = document.createElement("script");
  _$jscoverage['modules/loadScript.js'][5]++;
  script.async = "async";
  _$jscoverage['modules/loadScript.js'][6]++;
  script.src = url;
  _$jscoverage['modules/loadScript.js'][7]++;
  script.type = "text/javascript";
  _$jscoverage['modules/loadScript.js'][8]++;
  script.onload = script.onreadystatechange = (function () {
  _$jscoverage['modules/loadScript.js'][9]++;
  if (! script.readyState || /loaded|complete/.test(script.readyState)) {
    _$jscoverage['modules/loadScript.js'][10]++;
    script.onload = script.onreadystatechange = null;
    _$jscoverage['modules/loadScript.js'][11]++;
    if (head && script.parentNode) {
      _$jscoverage['modules/loadScript.js'][12]++;
      head.removeChild(script);
    }
    _$jscoverage['modules/loadScript.js'][14]++;
    script = undefined;
    _$jscoverage['modules/loadScript.js'][15]++;
    if (callback && typeof callback === "function") {
      _$jscoverage['modules/loadScript.js'][16]++;
      callback();
    }
  }
});
  _$jscoverage['modules/loadScript.js'][20]++;
  head.insertBefore(script, head.firstChild);
});
_$jscoverage['modules/loadScript.js'].source = ["module.exports = function (url, callback) {","  var script;","  var head = document.head || document.getElementsByTagName(\"head\")[0] || document.documentElement;","  script = document.createElement(\"script\");","  script.async = \"async\";","  script.src = url;","  script.type = \"text/javascript\";","  script.onload = script.onreadystatechange = function () {","    if (!script.readyState || /loaded|complete/.test(script.readyState)) {","      script.onload = script.onreadystatechange = null;","      if (head &amp;&amp; script.parentNode) {","        head.removeChild(script);","      }","      script = undefined;","      if (callback &amp;&amp; typeof callback === \"function\") {","        callback();","      }","    }","  };","  head.insertBefore(script, head.firstChild);","};"];

},{}],68:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/logger.js']) {
  _$jscoverage['modules/logger.js'] = [];
  _$jscoverage['modules/logger.js'][1] = 0;
  _$jscoverage['modules/logger.js'][2] = 0;
  _$jscoverage['modules/logger.js'][4] = 0;
  _$jscoverage['modules/logger.js'][23] = 0;
}
_$jscoverage['modules/logger.js'][1]++;
var console = require("console");
_$jscoverage['modules/logger.js'][2]++;
var log = require("loglevel");
_$jscoverage['modules/logger.js'][4]++;
log.setLevel("info");
_$jscoverage['modules/logger.js'][23]++;
module.exports = log;
_$jscoverage['modules/logger.js'].source = ["var console = require('console');","var log = require('loglevel');","","log.setLevel('info');","","/**"," * APIs:"," * see https://github.com/pimterry/loglevel."," * In short, you can use:"," * log.setLevel(loglevel) - default to info"," * log.enableAll() - enable all log messages"," * log.disableAll() - disable all log messages"," *"," * log.trace(msg)"," * log.debug(msg)"," * log.info(msg)"," * log.warn(msg)"," * log.error(msg)"," *"," * Available levels: { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3, \"ERROR\": 4, \"SILENT\": 5}"," * Use either string or integer value"," */","module.exports = log;"];

},{"console":42,"loglevel":48}],69:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/platformsMap.js']) {
  _$jscoverage['modules/platformsMap.js'] = [];
  _$jscoverage['modules/platformsMap.js'][1] = 0;
}
_$jscoverage['modules/platformsMap.js'][1]++;
module.exports = [{"destination": "ipad", "test": ["iPad"]}, {"destination": "iphone", "test": ["iPhone"]}, {"destination": "android", "test": ["Android"]}, {"destination": "blackberry", "test": ["BlackBerry", "BB10", "RIM Tablet OS"]}, {"destination": "windowsphone", "test": ["Windows Phone 8"]}, {"destination": "windowsphone7", "test": ["Windows Phone OS 7"]}];
_$jscoverage['modules/platformsMap.js'].source = ["module.exports = [","  {","    \"destination\" :\"ipad\",","    \"test\": [\"iPad\"]","  },","  {","    \"destination\" :\"iphone\",","    \"test\": [\"iPhone\"]","  },","  {","    \"destination\" :\"android\",","    \"test\": [\"Android\"]","  },","  {","    \"destination\" :\"blackberry\",","    \"test\": [\"BlackBerry\", \"BB10\", \"RIM Tablet OS\"]//Blackberry 10 does not contain \"Blackberry\"","  },","  {","    \"destination\" :\"windowsphone\",","    \"test\": [\"Windows Phone 8\"]","  },","  {","    \"destination\" :\"windowsphone7\",","    \"test\": [\"Windows Phone OS 7\"]","  }","];"];

},{}],70:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/queryMap.js']) {
  _$jscoverage['modules/queryMap.js'] = [];
  _$jscoverage['modules/queryMap.js'][1] = 0;
  _$jscoverage['modules/queryMap.js'][2] = 0;
  _$jscoverage['modules/queryMap.js'][3] = 0;
  _$jscoverage['modules/queryMap.js'][4] = 0;
  _$jscoverage['modules/queryMap.js'][5] = 0;
  _$jscoverage['modules/queryMap.js'][6] = 0;
  _$jscoverage['modules/queryMap.js'][7] = 0;
  _$jscoverage['modules/queryMap.js'][8] = 0;
  _$jscoverage['modules/queryMap.js'][9] = 0;
  _$jscoverage['modules/queryMap.js'][10] = 0;
  _$jscoverage['modules/queryMap.js'][11] = 0;
  _$jscoverage['modules/queryMap.js'][14] = 0;
}
_$jscoverage['modules/queryMap.js'][1]++;
module.exports = (function (url) {
  _$jscoverage['modules/queryMap.js'][2]++;
  var qmap = {};
  _$jscoverage['modules/queryMap.js'][3]++;
  var i = url.split("?");
  _$jscoverage['modules/queryMap.js'][4]++;
  if (i.length === 2) {
    _$jscoverage['modules/queryMap.js'][5]++;
    var queryString = i[1];
    _$jscoverage['modules/queryMap.js'][6]++;
    var pairs = queryString.split("&");
    _$jscoverage['modules/queryMap.js'][7]++;
    qmap = {};
    _$jscoverage['modules/queryMap.js'][8]++;
    for (var p = 0; p < pairs.length; p++) {
      _$jscoverage['modules/queryMap.js'][9]++;
      var q = pairs[p];
      _$jscoverage['modules/queryMap.js'][10]++;
      var qp = q.split("=");
      _$jscoverage['modules/queryMap.js'][11]++;
      qmap[qp[0]] = qp[1];
}
  }
  _$jscoverage['modules/queryMap.js'][14]++;
  return qmap;
});
_$jscoverage['modules/queryMap.js'].source = ["module.exports = function(url) {","  var qmap = {};","  var i = url.split(\"?\");","  if (i.length === 2) {","    var queryString = i[1];","    var pairs = queryString.split(\"&amp;\");","    qmap = {};","    for (var p = 0; p &lt; pairs.length; p++) {","      var q = pairs[p];","      var qp = q.split(\"=\");","      qmap[qp[0]] = qp[1];","    }","  }","  return qmap;","};"];

},{}],71:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/sdkversion.js']) {
  _$jscoverage['modules/sdkversion.js'] = [];
  _$jscoverage['modules/sdkversion.js'][1] = 0;
  _$jscoverage['modules/sdkversion.js'][3] = 0;
  _$jscoverage['modules/sdkversion.js'][4] = 0;
  _$jscoverage['modules/sdkversion.js'][5] = 0;
  _$jscoverage['modules/sdkversion.js'][6] = 0;
  _$jscoverage['modules/sdkversion.js'][7] = 0;
  _$jscoverage['modules/sdkversion.js'][8] = 0;
  _$jscoverage['modules/sdkversion.js'][10] = 0;
}
_$jscoverage['modules/sdkversion.js'][1]++;
var constants = require("./constants");
_$jscoverage['modules/sdkversion.js'][3]++;
module.exports = (function () {
  _$jscoverage['modules/sdkversion.js'][4]++;
  var type = "FH_JS_SDK";
  _$jscoverage['modules/sdkversion.js'][5]++;
  if (typeof window.fh_destination_code !== "undefined") {
    _$jscoverage['modules/sdkversion.js'][6]++;
    type = "FH_HYBRID_SDK";
  }
  else {
    _$jscoverage['modules/sdkversion.js'][7]++;
    if (window.PhoneGap || window.cordova) {
      _$jscoverage['modules/sdkversion.js'][8]++;
      type = "FH_PHONEGAP_SDK";
    }
  }
  _$jscoverage['modules/sdkversion.js'][10]++;
  return type + "/" + constants.sdk_version;
});
_$jscoverage['modules/sdkversion.js'].source = ["var constants = require(\"./constants\");","","module.exports = function() {","  var type = \"FH_JS_SDK\";","  if (typeof window.fh_destination_code !== 'undefined') {","    type = \"FH_HYBRID_SDK\";","  } else if(window.PhoneGap || window.cordova) {","    type = \"FH_PHONEGAP_SDK\";","  }","  return type + \"/\" + constants.sdk_version;","};"];

},{"./constants":58}],72:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/security/hash.js']) {
  _$jscoverage['modules/security/hash.js'] = [];
  _$jscoverage['modules/security/hash.js'][1] = 0;
  _$jscoverage['modules/security/hash.js'][4] = 0;
  _$jscoverage['modules/security/hash.js'][5] = 0;
  _$jscoverage['modules/security/hash.js'][6] = 0;
  _$jscoverage['modules/security/hash.js'][7] = 0;
  _$jscoverage['modules/security/hash.js'][9] = 0;
  _$jscoverage['modules/security/hash.js'][10] = 0;
  _$jscoverage['modules/security/hash.js'][11] = 0;
  _$jscoverage['modules/security/hash.js'][12] = 0;
  _$jscoverage['modules/security/hash.js'][13] = 0;
  _$jscoverage['modules/security/hash.js'][14] = 0;
  _$jscoverage['modules/security/hash.js'][15] = 0;
  _$jscoverage['modules/security/hash.js'][16] = 0;
  _$jscoverage['modules/security/hash.js'][17] = 0;
  _$jscoverage['modules/security/hash.js'][19] = 0;
  _$jscoverage['modules/security/hash.js'][21] = 0;
  _$jscoverage['modules/security/hash.js'][24] = 0;
}
_$jscoverage['modules/security/hash.js'][1]++;
var CryptoJS = require("../../../libs/generated/crypto");
_$jscoverage['modules/security/hash.js'][4]++;
var hash = (function (p, s, f) {
  _$jscoverage['modules/security/hash.js'][5]++;
  if (! p.params.text) {
    _$jscoverage['modules/security/hash.js'][6]++;
    f("hash_no_text", {}, p);
    _$jscoverage['modules/security/hash.js'][7]++;
    return;
  }
  _$jscoverage['modules/security/hash.js'][9]++;
  var hashValue;
  _$jscoverage['modules/security/hash.js'][10]++;
  if (p.params.algorithm.toLowerCase() === "md5") {
    _$jscoverage['modules/security/hash.js'][11]++;
    hashValue = CryptoJS.MD5(p.params.text).toString(CryptoJS.enc.Hex);
  }
  else {
    _$jscoverage['modules/security/hash.js'][12]++;
    if (p.params.algorithm.toLowerCase() === "sha1") {
      _$jscoverage['modules/security/hash.js'][13]++;
      hashValue = CryptoJS.SHA1(p.params.text).toString(CryptoJS.enc.Hex);
    }
    else {
      _$jscoverage['modules/security/hash.js'][14]++;
      if (p.params.algorithm.toLowerCase() === "sha256") {
        _$jscoverage['modules/security/hash.js'][15]++;
        hashValue = CryptoJS.SHA256(p.params.text).toString(CryptoJS.enc.Hex);
      }
      else {
        _$jscoverage['modules/security/hash.js'][16]++;
        if (p.params.algorithm.toLowerCase() === "sha512") {
          _$jscoverage['modules/security/hash.js'][17]++;
          hashValue = CryptoJS.SHA512(p.params.text).toString(CryptoJS.enc.Hex);
        }
        else {
          _$jscoverage['modules/security/hash.js'][19]++;
          return f("hash_unsupported_algorithm: " + p.params.algorithm);
        }
      }
    }
  }
  _$jscoverage['modules/security/hash.js'][21]++;
  return s({"hashvalue": hashValue});
});
_$jscoverage['modules/security/hash.js'][24]++;
module.exports = hash;
_$jscoverage['modules/security/hash.js'].source = ["var CryptoJS = require(\"../../../libs/generated/crypto\");","","","var hash = function(p, s, f){","  if (!p.params.text) {","    f('hash_no_text', {}, p);","    return;","  }","  var hashValue;","  if (p.params.algorithm.toLowerCase() === \"md5\") {","    hashValue = CryptoJS.MD5(p.params.text).toString(CryptoJS.enc.Hex);","  } else if(p.params.algorithm.toLowerCase() === \"sha1\"){","    hashValue = CryptoJS.SHA1(p.params.text).toString(CryptoJS.enc.Hex);","  } else if(p.params.algorithm.toLowerCase() === \"sha256\"){","    hashValue = CryptoJS.SHA256(p.params.text).toString(CryptoJS.enc.Hex);","  } else if(p.params.algorithm.toLowerCase() === \"sha512\"){","    hashValue = CryptoJS.SHA512(p.params.text).toString(CryptoJS.enc.Hex);","  } else {","    return f(\"hash_unsupported_algorithm: \" + p.params.algorithm);","  }","  return s({\"hashvalue\": hashValue});","}","","module.exports = hash;"];

},{"../../../libs/generated/crypto":1}],73:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/sync-cli.js']) {
  _$jscoverage['modules/sync-cli.js'] = [];
  _$jscoverage['modules/sync-cli.js'][1] = 0;
  _$jscoverage['modules/sync-cli.js'][2] = 0;
  _$jscoverage['modules/sync-cli.js'][3] = 0;
  _$jscoverage['modules/sync-cli.js'][4] = 0;
  _$jscoverage['modules/sync-cli.js'][5] = 0;
  _$jscoverage['modules/sync-cli.js'][7] = 0;
  _$jscoverage['modules/sync-cli.js'][87] = 0;
  _$jscoverage['modules/sync-cli.js'][89] = 0;
  _$jscoverage['modules/sync-cli.js'][90] = 0;
  _$jscoverage['modules/sync-cli.js'][91] = 0;
  _$jscoverage['modules/sync-cli.js'][94] = 0;
  _$jscoverage['modules/sync-cli.js'][98] = 0;
  _$jscoverage['modules/sync-cli.js'][102] = 0;
  _$jscoverage['modules/sync-cli.js'][104] = 0;
  _$jscoverage['modules/sync-cli.js'][106] = 0;
  _$jscoverage['modules/sync-cli.js'][107] = 0;
  _$jscoverage['modules/sync-cli.js'][109] = 0;
  _$jscoverage['modules/sync-cli.js'][111] = 0;
  _$jscoverage['modules/sync-cli.js'][112] = 0;
  _$jscoverage['modules/sync-cli.js'][113] = 0;
  _$jscoverage['modules/sync-cli.js'][114] = 0;
  _$jscoverage['modules/sync-cli.js'][115] = 0;
  _$jscoverage['modules/sync-cli.js'][116] = 0;
  _$jscoverage['modules/sync-cli.js'][117] = 0;
  _$jscoverage['modules/sync-cli.js'][119] = 0;
  _$jscoverage['modules/sync-cli.js'][121] = 0;
  _$jscoverage['modules/sync-cli.js'][122] = 0;
  _$jscoverage['modules/sync-cli.js'][128] = 0;
  _$jscoverage['modules/sync-cli.js'][129] = 0;
  _$jscoverage['modules/sync-cli.js'][130] = 0;
  _$jscoverage['modules/sync-cli.js'][132] = 0;
  _$jscoverage['modules/sync-cli.js'][135] = 0;
  _$jscoverage['modules/sync-cli.js'][136] = 0;
  _$jscoverage['modules/sync-cli.js'][141] = 0;
  _$jscoverage['modules/sync-cli.js'][144] = 0;
  _$jscoverage['modules/sync-cli.js'][148] = 0;
  _$jscoverage['modules/sync-cli.js'][149] = 0;
  _$jscoverage['modules/sync-cli.js'][150] = 0;
  _$jscoverage['modules/sync-cli.js'][151] = 0;
  _$jscoverage['modules/sync-cli.js'][152] = 0;
  _$jscoverage['modules/sync-cli.js'][153] = 0;
  _$jscoverage['modules/sync-cli.js'][160] = 0;
  _$jscoverage['modules/sync-cli.js'][161] = 0;
  _$jscoverage['modules/sync-cli.js'][164] = 0;
  _$jscoverage['modules/sync-cli.js'][165] = 0;
  _$jscoverage['modules/sync-cli.js'][166] = 0;
  _$jscoverage['modules/sync-cli.js'][167] = 0;
  _$jscoverage['modules/sync-cli.js'][170] = 0;
  _$jscoverage['modules/sync-cli.js'][174] = 0;
  _$jscoverage['modules/sync-cli.js'][175] = 0;
  _$jscoverage['modules/sync-cli.js'][177] = 0;
  _$jscoverage['modules/sync-cli.js'][178] = 0;
  _$jscoverage['modules/sync-cli.js'][180] = 0;
  _$jscoverage['modules/sync-cli.js'][183] = 0;
  _$jscoverage['modules/sync-cli.js'][188] = 0;
  _$jscoverage['modules/sync-cli.js'][192] = 0;
  _$jscoverage['modules/sync-cli.js'][193] = 0;
  _$jscoverage['modules/sync-cli.js'][194] = 0;
  _$jscoverage['modules/sync-cli.js'][195] = 0;
  _$jscoverage['modules/sync-cli.js'][198] = 0;
  _$jscoverage['modules/sync-cli.js'][199] = 0;
  _$jscoverage['modules/sync-cli.js'][202] = 0;
  _$jscoverage['modules/sync-cli.js'][207] = 0;
  _$jscoverage['modules/sync-cli.js'][211] = 0;
  _$jscoverage['modules/sync-cli.js'][215] = 0;
  _$jscoverage['modules/sync-cli.js'][216] = 0;
  _$jscoverage['modules/sync-cli.js'][217] = 0;
  _$jscoverage['modules/sync-cli.js'][218] = 0;
  _$jscoverage['modules/sync-cli.js'][220] = 0;
  _$jscoverage['modules/sync-cli.js'][222] = 0;
  _$jscoverage['modules/sync-cli.js'][227] = 0;
  _$jscoverage['modules/sync-cli.js'][228] = 0;
  _$jscoverage['modules/sync-cli.js'][229] = 0;
  _$jscoverage['modules/sync-cli.js'][234] = 0;
  _$jscoverage['modules/sync-cli.js'][235] = 0;
  _$jscoverage['modules/sync-cli.js'][246] = 0;
  _$jscoverage['modules/sync-cli.js'][247] = 0;
  _$jscoverage['modules/sync-cli.js'][261] = 0;
  _$jscoverage['modules/sync-cli.js'][264] = 0;
  _$jscoverage['modules/sync-cli.js'][265] = 0;
  _$jscoverage['modules/sync-cli.js'][269] = 0;
  _$jscoverage['modules/sync-cli.js'][271] = 0;
  _$jscoverage['modules/sync-cli.js'][272] = 0;
  _$jscoverage['modules/sync-cli.js'][273] = 0;
  _$jscoverage['modules/sync-cli.js'][274] = 0;
  _$jscoverage['modules/sync-cli.js'][279] = 0;
  _$jscoverage['modules/sync-cli.js'][284] = 0;
  _$jscoverage['modules/sync-cli.js'][285] = 0;
  _$jscoverage['modules/sync-cli.js'][286] = 0;
  _$jscoverage['modules/sync-cli.js'][293] = 0;
  _$jscoverage['modules/sync-cli.js'][294] = 0;
  _$jscoverage['modules/sync-cli.js'][301] = 0;
  _$jscoverage['modules/sync-cli.js'][303] = 0;
  _$jscoverage['modules/sync-cli.js'][304] = 0;
  _$jscoverage['modules/sync-cli.js'][306] = 0;
  _$jscoverage['modules/sync-cli.js'][311] = 0;
  _$jscoverage['modules/sync-cli.js'][313] = 0;
  _$jscoverage['modules/sync-cli.js'][314] = 0;
  _$jscoverage['modules/sync-cli.js'][316] = 0;
  _$jscoverage['modules/sync-cli.js'][321] = 0;
  _$jscoverage['modules/sync-cli.js'][323] = 0;
  _$jscoverage['modules/sync-cli.js'][324] = 0;
  _$jscoverage['modules/sync-cli.js'][325] = 0;
  _$jscoverage['modules/sync-cli.js'][326] = 0;
  _$jscoverage['modules/sync-cli.js'][327] = 0;
  _$jscoverage['modules/sync-cli.js'][330] = 0;
  _$jscoverage['modules/sync-cli.js'][331] = 0;
  _$jscoverage['modules/sync-cli.js'][337] = 0;
  _$jscoverage['modules/sync-cli.js'][339] = 0;
  _$jscoverage['modules/sync-cli.js'][340] = 0;
  _$jscoverage['modules/sync-cli.js'][342] = 0;
  _$jscoverage['modules/sync-cli.js'][347] = 0;
  _$jscoverage['modules/sync-cli.js'][349] = 0;
  _$jscoverage['modules/sync-cli.js'][350] = 0;
  _$jscoverage['modules/sync-cli.js'][351] = 0;
  _$jscoverage['modules/sync-cli.js'][352] = 0;
  _$jscoverage['modules/sync-cli.js'][353] = 0;
  _$jscoverage['modules/sync-cli.js'][356] = 0;
  _$jscoverage['modules/sync-cli.js'][357] = 0;
  _$jscoverage['modules/sync-cli.js'][363] = 0;
  _$jscoverage['modules/sync-cli.js'][365] = 0;
  _$jscoverage['modules/sync-cli.js'][366] = 0;
  _$jscoverage['modules/sync-cli.js'][368] = 0;
  _$jscoverage['modules/sync-cli.js'][373] = 0;
  _$jscoverage['modules/sync-cli.js'][375] = 0;
  _$jscoverage['modules/sync-cli.js'][376] = 0;
  _$jscoverage['modules/sync-cli.js'][377] = 0;
  _$jscoverage['modules/sync-cli.js'][378] = 0;
  _$jscoverage['modules/sync-cli.js'][379] = 0;
  _$jscoverage['modules/sync-cli.js'][380] = 0;
  _$jscoverage['modules/sync-cli.js'][383] = 0;
  _$jscoverage['modules/sync-cli.js'][384] = 0;
  _$jscoverage['modules/sync-cli.js'][390] = 0;
  _$jscoverage['modules/sync-cli.js'][391] = 0;
  _$jscoverage['modules/sync-cli.js'][392] = 0;
  _$jscoverage['modules/sync-cli.js'][398] = 0;
  _$jscoverage['modules/sync-cli.js'][399] = 0;
  _$jscoverage['modules/sync-cli.js'][400] = 0;
  _$jscoverage['modules/sync-cli.js'][406] = 0;
  _$jscoverage['modules/sync-cli.js'][408] = 0;
  _$jscoverage['modules/sync-cli.js'][409] = 0;
  _$jscoverage['modules/sync-cli.js'][410] = 0;
  _$jscoverage['modules/sync-cli.js'][411] = 0;
  _$jscoverage['modules/sync-cli.js'][412] = 0;
  _$jscoverage['modules/sync-cli.js'][415] = 0;
  _$jscoverage['modules/sync-cli.js'][416] = 0;
  _$jscoverage['modules/sync-cli.js'][422] = 0;
  _$jscoverage['modules/sync-cli.js'][424] = 0;
  _$jscoverage['modules/sync-cli.js'][425] = 0;
  _$jscoverage['modules/sync-cli.js'][426] = 0;
  _$jscoverage['modules/sync-cli.js'][427] = 0;
  _$jscoverage['modules/sync-cli.js'][428] = 0;
  _$jscoverage['modules/sync-cli.js'][431] = 0;
  _$jscoverage['modules/sync-cli.js'][432] = 0;
  _$jscoverage['modules/sync-cli.js'][438] = 0;
  _$jscoverage['modules/sync-cli.js'][439] = 0;
  _$jscoverage['modules/sync-cli.js'][442] = 0;
  _$jscoverage['modules/sync-cli.js'][444] = 0;
  _$jscoverage['modules/sync-cli.js'][445] = 0;
  _$jscoverage['modules/sync-cli.js'][451] = 0;
  _$jscoverage['modules/sync-cli.js'][456] = 0;
  _$jscoverage['modules/sync-cli.js'][458] = 0;
  _$jscoverage['modules/sync-cli.js'][459] = 0;
  _$jscoverage['modules/sync-cli.js'][461] = 0;
  _$jscoverage['modules/sync-cli.js'][464] = 0;
  _$jscoverage['modules/sync-cli.js'][468] = 0;
  _$jscoverage['modules/sync-cli.js'][469] = 0;
  _$jscoverage['modules/sync-cli.js'][473] = 0;
  _$jscoverage['modules/sync-cli.js'][474] = 0;
  _$jscoverage['modules/sync-cli.js'][475] = 0;
  _$jscoverage['modules/sync-cli.js'][479] = 0;
  _$jscoverage['modules/sync-cli.js'][480] = 0;
  _$jscoverage['modules/sync-cli.js'][482] = 0;
  _$jscoverage['modules/sync-cli.js'][484] = 0;
  _$jscoverage['modules/sync-cli.js'][486] = 0;
  _$jscoverage['modules/sync-cli.js'][488] = 0;
  _$jscoverage['modules/sync-cli.js'][489] = 0;
  _$jscoverage['modules/sync-cli.js'][491] = 0;
  _$jscoverage['modules/sync-cli.js'][492] = 0;
  _$jscoverage['modules/sync-cli.js'][494] = 0;
  _$jscoverage['modules/sync-cli.js'][496] = 0;
  _$jscoverage['modules/sync-cli.js'][500] = 0;
  _$jscoverage['modules/sync-cli.js'][501] = 0;
  _$jscoverage['modules/sync-cli.js'][502] = 0;
  _$jscoverage['modules/sync-cli.js'][503] = 0;
  _$jscoverage['modules/sync-cli.js'][504] = 0;
  _$jscoverage['modules/sync-cli.js'][505] = 0;
  _$jscoverage['modules/sync-cli.js'][506] = 0;
  _$jscoverage['modules/sync-cli.js'][507] = 0;
  _$jscoverage['modules/sync-cli.js'][508] = 0;
  _$jscoverage['modules/sync-cli.js'][510] = 0;
  _$jscoverage['modules/sync-cli.js'][511] = 0;
  _$jscoverage['modules/sync-cli.js'][512] = 0;
  _$jscoverage['modules/sync-cli.js'][513] = 0;
  _$jscoverage['modules/sync-cli.js'][514] = 0;
  _$jscoverage['modules/sync-cli.js'][516] = 0;
  _$jscoverage['modules/sync-cli.js'][522] = 0;
  _$jscoverage['modules/sync-cli.js'][525] = 0;
  _$jscoverage['modules/sync-cli.js'][526] = 0;
  _$jscoverage['modules/sync-cli.js'][527] = 0;
  _$jscoverage['modules/sync-cli.js'][528] = 0;
  _$jscoverage['modules/sync-cli.js'][530] = 0;
  _$jscoverage['modules/sync-cli.js'][531] = 0;
  _$jscoverage['modules/sync-cli.js'][532] = 0;
  _$jscoverage['modules/sync-cli.js'][534] = 0;
  _$jscoverage['modules/sync-cli.js'][536] = 0;
  _$jscoverage['modules/sync-cli.js'][537] = 0;
  _$jscoverage['modules/sync-cli.js'][538] = 0;
  _$jscoverage['modules/sync-cli.js'][539] = 0;
  _$jscoverage['modules/sync-cli.js'][540] = 0;
  _$jscoverage['modules/sync-cli.js'][541] = 0;
  _$jscoverage['modules/sync-cli.js'][543] = 0;
  _$jscoverage['modules/sync-cli.js'][544] = 0;
  _$jscoverage['modules/sync-cli.js'][546] = 0;
  _$jscoverage['modules/sync-cli.js'][547] = 0;
  _$jscoverage['modules/sync-cli.js'][548] = 0;
  _$jscoverage['modules/sync-cli.js'][552] = 0;
  _$jscoverage['modules/sync-cli.js'][553] = 0;
  _$jscoverage['modules/sync-cli.js'][554] = 0;
  _$jscoverage['modules/sync-cli.js'][555] = 0;
  _$jscoverage['modules/sync-cli.js'][558] = 0;
  _$jscoverage['modules/sync-cli.js'][560] = 0;
  _$jscoverage['modules/sync-cli.js'][561] = 0;
  _$jscoverage['modules/sync-cli.js'][563] = 0;
  _$jscoverage['modules/sync-cli.js'][564] = 0;
  _$jscoverage['modules/sync-cli.js'][568] = 0;
  _$jscoverage['modules/sync-cli.js'][570] = 0;
  _$jscoverage['modules/sync-cli.js'][571] = 0;
  _$jscoverage['modules/sync-cli.js'][572] = 0;
  _$jscoverage['modules/sync-cli.js'][573] = 0;
  _$jscoverage['modules/sync-cli.js'][574] = 0;
  _$jscoverage['modules/sync-cli.js'][575] = 0;
  _$jscoverage['modules/sync-cli.js'][576] = 0;
  _$jscoverage['modules/sync-cli.js'][577] = 0;
  _$jscoverage['modules/sync-cli.js'][584] = 0;
  _$jscoverage['modules/sync-cli.js'][587] = 0;
  _$jscoverage['modules/sync-cli.js'][590] = 0;
  _$jscoverage['modules/sync-cli.js'][593] = 0;
  _$jscoverage['modules/sync-cli.js'][596] = 0;
  _$jscoverage['modules/sync-cli.js'][600] = 0;
  _$jscoverage['modules/sync-cli.js'][602] = 0;
  _$jscoverage['modules/sync-cli.js'][603] = 0;
  _$jscoverage['modules/sync-cli.js'][605] = 0;
  _$jscoverage['modules/sync-cli.js'][608] = 0;
  _$jscoverage['modules/sync-cli.js'][609] = 0;
  _$jscoverage['modules/sync-cli.js'][610] = 0;
  _$jscoverage['modules/sync-cli.js'][611] = 0;
  _$jscoverage['modules/sync-cli.js'][612] = 0;
  _$jscoverage['modules/sync-cli.js'][613] = 0;
  _$jscoverage['modules/sync-cli.js'][616] = 0;
  _$jscoverage['modules/sync-cli.js'][617] = 0;
  _$jscoverage['modules/sync-cli.js'][619] = 0;
  _$jscoverage['modules/sync-cli.js'][621] = 0;
  _$jscoverage['modules/sync-cli.js'][622] = 0;
  _$jscoverage['modules/sync-cli.js'][628] = 0;
  _$jscoverage['modules/sync-cli.js'][629] = 0;
  _$jscoverage['modules/sync-cli.js'][630] = 0;
  _$jscoverage['modules/sync-cli.js'][634] = 0;
  _$jscoverage['modules/sync-cli.js'][635] = 0;
  _$jscoverage['modules/sync-cli.js'][645] = 0;
  _$jscoverage['modules/sync-cli.js'][647] = 0;
  _$jscoverage['modules/sync-cli.js'][649] = 0;
  _$jscoverage['modules/sync-cli.js'][650] = 0;
  _$jscoverage['modules/sync-cli.js'][651] = 0;
  _$jscoverage['modules/sync-cli.js'][652] = 0;
  _$jscoverage['modules/sync-cli.js'][653] = 0;
  _$jscoverage['modules/sync-cli.js'][656] = 0;
  _$jscoverage['modules/sync-cli.js'][658] = 0;
  _$jscoverage['modules/sync-cli.js'][659] = 0;
  _$jscoverage['modules/sync-cli.js'][660] = 0;
  _$jscoverage['modules/sync-cli.js'][661] = 0;
  _$jscoverage['modules/sync-cli.js'][663] = 0;
  _$jscoverage['modules/sync-cli.js'][665] = 0;
  _$jscoverage['modules/sync-cli.js'][669] = 0;
  _$jscoverage['modules/sync-cli.js'][671] = 0;
  _$jscoverage['modules/sync-cli.js'][672] = 0;
  _$jscoverage['modules/sync-cli.js'][673] = 0;
  _$jscoverage['modules/sync-cli.js'][674] = 0;
  _$jscoverage['modules/sync-cli.js'][677] = 0;
  _$jscoverage['modules/sync-cli.js'][678] = 0;
  _$jscoverage['modules/sync-cli.js'][679] = 0;
  _$jscoverage['modules/sync-cli.js'][680] = 0;
  _$jscoverage['modules/sync-cli.js'][681] = 0;
  _$jscoverage['modules/sync-cli.js'][684] = 0;
  _$jscoverage['modules/sync-cli.js'][685] = 0;
  _$jscoverage['modules/sync-cli.js'][686] = 0;
  _$jscoverage['modules/sync-cli.js'][687] = 0;
  _$jscoverage['modules/sync-cli.js'][691] = 0;
  _$jscoverage['modules/sync-cli.js'][693] = 0;
  _$jscoverage['modules/sync-cli.js'][694] = 0;
  _$jscoverage['modules/sync-cli.js'][695] = 0;
  _$jscoverage['modules/sync-cli.js'][697] = 0;
  _$jscoverage['modules/sync-cli.js'][699] = 0;
  _$jscoverage['modules/sync-cli.js'][700] = 0;
  _$jscoverage['modules/sync-cli.js'][707] = 0;
  _$jscoverage['modules/sync-cli.js'][708] = 0;
  _$jscoverage['modules/sync-cli.js'][709] = 0;
  _$jscoverage['modules/sync-cli.js'][710] = 0;
  _$jscoverage['modules/sync-cli.js'][711] = 0;
  _$jscoverage['modules/sync-cli.js'][716] = 0;
  _$jscoverage['modules/sync-cli.js'][717] = 0;
  _$jscoverage['modules/sync-cli.js'][718] = 0;
  _$jscoverage['modules/sync-cli.js'][720] = 0;
  _$jscoverage['modules/sync-cli.js'][722] = 0;
  _$jscoverage['modules/sync-cli.js'][723] = 0;
  _$jscoverage['modules/sync-cli.js'][724] = 0;
  _$jscoverage['modules/sync-cli.js'][725] = 0;
  _$jscoverage['modules/sync-cli.js'][727] = 0;
  _$jscoverage['modules/sync-cli.js'][728] = 0;
  _$jscoverage['modules/sync-cli.js'][729] = 0;
  _$jscoverage['modules/sync-cli.js'][730] = 0;
  _$jscoverage['modules/sync-cli.js'][731] = 0;
  _$jscoverage['modules/sync-cli.js'][733] = 0;
  _$jscoverage['modules/sync-cli.js'][737] = 0;
  _$jscoverage['modules/sync-cli.js'][738] = 0;
  _$jscoverage['modules/sync-cli.js'][741] = 0;
  _$jscoverage['modules/sync-cli.js'][743] = 0;
  _$jscoverage['modules/sync-cli.js'][748] = 0;
  _$jscoverage['modules/sync-cli.js'][756] = 0;
  _$jscoverage['modules/sync-cli.js'][757] = 0;
  _$jscoverage['modules/sync-cli.js'][759] = 0;
  _$jscoverage['modules/sync-cli.js'][761] = 0;
  _$jscoverage['modules/sync-cli.js'][769] = 0;
  _$jscoverage['modules/sync-cli.js'][770] = 0;
  _$jscoverage['modules/sync-cli.js'][771] = 0;
  _$jscoverage['modules/sync-cli.js'][773] = 0;
  _$jscoverage['modules/sync-cli.js'][774] = 0;
  _$jscoverage['modules/sync-cli.js'][777] = 0;
  _$jscoverage['modules/sync-cli.js'][778] = 0;
  _$jscoverage['modules/sync-cli.js'][780] = 0;
  _$jscoverage['modules/sync-cli.js'][782] = 0;
  _$jscoverage['modules/sync-cli.js'][787] = 0;
  _$jscoverage['modules/sync-cli.js'][788] = 0;
  _$jscoverage['modules/sync-cli.js'][792] = 0;
  _$jscoverage['modules/sync-cli.js'][794] = 0;
  _$jscoverage['modules/sync-cli.js'][797] = 0;
  _$jscoverage['modules/sync-cli.js'][802] = 0;
  _$jscoverage['modules/sync-cli.js'][804] = 0;
  _$jscoverage['modules/sync-cli.js'][810] = 0;
  _$jscoverage['modules/sync-cli.js'][813] = 0;
  _$jscoverage['modules/sync-cli.js'][814] = 0;
  _$jscoverage['modules/sync-cli.js'][819] = 0;
  _$jscoverage['modules/sync-cli.js'][821] = 0;
  _$jscoverage['modules/sync-cli.js'][822] = 0;
  _$jscoverage['modules/sync-cli.js'][823] = 0;
  _$jscoverage['modules/sync-cli.js'][825] = 0;
  _$jscoverage['modules/sync-cli.js'][827] = 0;
  _$jscoverage['modules/sync-cli.js'][828] = 0;
  _$jscoverage['modules/sync-cli.js'][830] = 0;
  _$jscoverage['modules/sync-cli.js'][838] = 0;
  _$jscoverage['modules/sync-cli.js'][840] = 0;
  _$jscoverage['modules/sync-cli.js'][841] = 0;
  _$jscoverage['modules/sync-cli.js'][842] = 0;
  _$jscoverage['modules/sync-cli.js'][845] = 0;
  _$jscoverage['modules/sync-cli.js'][846] = 0;
  _$jscoverage['modules/sync-cli.js'][847] = 0;
  _$jscoverage['modules/sync-cli.js'][848] = 0;
  _$jscoverage['modules/sync-cli.js'][849] = 0;
  _$jscoverage['modules/sync-cli.js'][853] = 0;
  _$jscoverage['modules/sync-cli.js'][854] = 0;
  _$jscoverage['modules/sync-cli.js'][855] = 0;
  _$jscoverage['modules/sync-cli.js'][856] = 0;
  _$jscoverage['modules/sync-cli.js'][859] = 0;
  _$jscoverage['modules/sync-cli.js'][867] = 0;
  _$jscoverage['modules/sync-cli.js'][868] = 0;
  _$jscoverage['modules/sync-cli.js'][869] = 0;
  _$jscoverage['modules/sync-cli.js'][871] = 0;
  _$jscoverage['modules/sync-cli.js'][872] = 0;
  _$jscoverage['modules/sync-cli.js'][874] = 0;
  _$jscoverage['modules/sync-cli.js'][877] = 0;
  _$jscoverage['modules/sync-cli.js'][878] = 0;
  _$jscoverage['modules/sync-cli.js'][879] = 0;
  _$jscoverage['modules/sync-cli.js'][882] = 0;
  _$jscoverage['modules/sync-cli.js'][885] = 0;
  _$jscoverage['modules/sync-cli.js'][886] = 0;
  _$jscoverage['modules/sync-cli.js'][889] = 0;
  _$jscoverage['modules/sync-cli.js'][892] = 0;
  _$jscoverage['modules/sync-cli.js'][893] = 0;
  _$jscoverage['modules/sync-cli.js'][894] = 0;
  _$jscoverage['modules/sync-cli.js'][895] = 0;
  _$jscoverage['modules/sync-cli.js'][897] = 0;
  _$jscoverage['modules/sync-cli.js'][898] = 0;
  _$jscoverage['modules/sync-cli.js'][899] = 0;
  _$jscoverage['modules/sync-cli.js'][900] = 0;
  _$jscoverage['modules/sync-cli.js'][901] = 0;
  _$jscoverage['modules/sync-cli.js'][902] = 0;
  _$jscoverage['modules/sync-cli.js'][905] = 0;
  _$jscoverage['modules/sync-cli.js'][906] = 0;
  _$jscoverage['modules/sync-cli.js'][907] = 0;
  _$jscoverage['modules/sync-cli.js'][910] = 0;
  _$jscoverage['modules/sync-cli.js'][914] = 0;
  _$jscoverage['modules/sync-cli.js'][915] = 0;
  _$jscoverage['modules/sync-cli.js'][916] = 0;
  _$jscoverage['modules/sync-cli.js'][923] = 0;
  _$jscoverage['modules/sync-cli.js'][924] = 0;
  _$jscoverage['modules/sync-cli.js'][925] = 0;
  _$jscoverage['modules/sync-cli.js'][926] = 0;
  _$jscoverage['modules/sync-cli.js'][928] = 0;
  _$jscoverage['modules/sync-cli.js'][929] = 0;
  _$jscoverage['modules/sync-cli.js'][930] = 0;
  _$jscoverage['modules/sync-cli.js'][931] = 0;
  _$jscoverage['modules/sync-cli.js'][932] = 0;
  _$jscoverage['modules/sync-cli.js'][933] = 0;
  _$jscoverage['modules/sync-cli.js'][934] = 0;
  _$jscoverage['modules/sync-cli.js'][937] = 0;
  _$jscoverage['modules/sync-cli.js'][938] = 0;
  _$jscoverage['modules/sync-cli.js'][940] = 0;
  _$jscoverage['modules/sync-cli.js'][944] = 0;
  _$jscoverage['modules/sync-cli.js'][945] = 0;
  _$jscoverage['modules/sync-cli.js'][946] = 0;
  _$jscoverage['modules/sync-cli.js'][947] = 0;
  _$jscoverage['modules/sync-cli.js'][950] = 0;
  _$jscoverage['modules/sync-cli.js'][951] = 0;
  _$jscoverage['modules/sync-cli.js'][952] = 0;
  _$jscoverage['modules/sync-cli.js'][956] = 0;
  _$jscoverage['modules/sync-cli.js'][960] = 0;
  _$jscoverage['modules/sync-cli.js'][961] = 0;
  _$jscoverage['modules/sync-cli.js'][962] = 0;
  _$jscoverage['modules/sync-cli.js'][963] = 0;
  _$jscoverage['modules/sync-cli.js'][964] = 0;
  _$jscoverage['modules/sync-cli.js'][969] = 0;
  _$jscoverage['modules/sync-cli.js'][970] = 0;
  _$jscoverage['modules/sync-cli.js'][972] = 0;
  _$jscoverage['modules/sync-cli.js'][973] = 0;
  _$jscoverage['modules/sync-cli.js'][974] = 0;
  _$jscoverage['modules/sync-cli.js'][975] = 0;
  _$jscoverage['modules/sync-cli.js'][977] = 0;
  _$jscoverage['modules/sync-cli.js'][979] = 0;
  _$jscoverage['modules/sync-cli.js'][981] = 0;
  _$jscoverage['modules/sync-cli.js'][982] = 0;
  _$jscoverage['modules/sync-cli.js'][985] = 0;
  _$jscoverage['modules/sync-cli.js'][986] = 0;
  _$jscoverage['modules/sync-cli.js'][987] = 0;
  _$jscoverage['modules/sync-cli.js'][988] = 0;
  _$jscoverage['modules/sync-cli.js'][989] = 0;
  _$jscoverage['modules/sync-cli.js'][993] = 0;
  _$jscoverage['modules/sync-cli.js'][994] = 0;
  _$jscoverage['modules/sync-cli.js'][995] = 0;
  _$jscoverage['modules/sync-cli.js'][996] = 0;
  _$jscoverage['modules/sync-cli.js'][998] = 0;
  _$jscoverage['modules/sync-cli.js'][999] = 0;
  _$jscoverage['modules/sync-cli.js'][1000] = 0;
  _$jscoverage['modules/sync-cli.js'][1001] = 0;
  _$jscoverage['modules/sync-cli.js'][1002] = 0;
  _$jscoverage['modules/sync-cli.js'][1003] = 0;
  _$jscoverage['modules/sync-cli.js'][1004] = 0;
  _$jscoverage['modules/sync-cli.js'][1011] = 0;
  _$jscoverage['modules/sync-cli.js'][1012] = 0;
  _$jscoverage['modules/sync-cli.js'][1013] = 0;
  _$jscoverage['modules/sync-cli.js'][1014] = 0;
  _$jscoverage['modules/sync-cli.js'][1015] = 0;
  _$jscoverage['modules/sync-cli.js'][1016] = 0;
  _$jscoverage['modules/sync-cli.js'][1019] = 0;
  _$jscoverage['modules/sync-cli.js'][1020] = 0;
  _$jscoverage['modules/sync-cli.js'][1021] = 0;
  _$jscoverage['modules/sync-cli.js'][1022] = 0;
  _$jscoverage['modules/sync-cli.js'][1033] = 0;
  _$jscoverage['modules/sync-cli.js'][1035] = 0;
  _$jscoverage['modules/sync-cli.js'][1036] = 0;
  _$jscoverage['modules/sync-cli.js'][1037] = 0;
  _$jscoverage['modules/sync-cli.js'][1038] = 0;
  _$jscoverage['modules/sync-cli.js'][1040] = 0;
  _$jscoverage['modules/sync-cli.js'][1041] = 0;
  _$jscoverage['modules/sync-cli.js'][1043] = 0;
  _$jscoverage['modules/sync-cli.js'][1045] = 0;
  _$jscoverage['modules/sync-cli.js'][1046] = 0;
  _$jscoverage['modules/sync-cli.js'][1048] = 0;
  _$jscoverage['modules/sync-cli.js'][1050] = 0;
  _$jscoverage['modules/sync-cli.js'][1051] = 0;
  _$jscoverage['modules/sync-cli.js'][1053] = 0;
  _$jscoverage['modules/sync-cli.js'][1055] = 0;
  _$jscoverage['modules/sync-cli.js'][1057] = 0;
  _$jscoverage['modules/sync-cli.js'][1059] = 0;
  _$jscoverage['modules/sync-cli.js'][1060] = 0;
  _$jscoverage['modules/sync-cli.js'][1064] = 0;
  _$jscoverage['modules/sync-cli.js'][1074] = 0;
  _$jscoverage['modules/sync-cli.js'][1076] = 0;
  _$jscoverage['modules/sync-cli.js'][1077] = 0;
  _$jscoverage['modules/sync-cli.js'][1078] = 0;
  _$jscoverage['modules/sync-cli.js'][1079] = 0;
  _$jscoverage['modules/sync-cli.js'][1081] = 0;
  _$jscoverage['modules/sync-cli.js'][1082] = 0;
  _$jscoverage['modules/sync-cli.js'][1083] = 0;
  _$jscoverage['modules/sync-cli.js'][1084] = 0;
  _$jscoverage['modules/sync-cli.js'][1086] = 0;
  _$jscoverage['modules/sync-cli.js'][1087] = 0;
  _$jscoverage['modules/sync-cli.js'][1089] = 0;
  _$jscoverage['modules/sync-cli.js'][1091] = 0;
  _$jscoverage['modules/sync-cli.js'][1093] = 0;
  _$jscoverage['modules/sync-cli.js'][1095] = 0;
  _$jscoverage['modules/sync-cli.js'][1096] = 0;
  _$jscoverage['modules/sync-cli.js'][1100] = 0;
  _$jscoverage['modules/sync-cli.js'][1109] = 0;
  _$jscoverage['modules/sync-cli.js'][1115] = 0;
  _$jscoverage['modules/sync-cli.js'][1116] = 0;
  _$jscoverage['modules/sync-cli.js'][1117] = 0;
  _$jscoverage['modules/sync-cli.js'][1118] = 0;
  _$jscoverage['modules/sync-cli.js'][1121] = 0;
  _$jscoverage['modules/sync-cli.js'][1122] = 0;
  _$jscoverage['modules/sync-cli.js'][1123] = 0;
  _$jscoverage['modules/sync-cli.js'][1124] = 0;
  _$jscoverage['modules/sync-cli.js'][1126] = 0;
  _$jscoverage['modules/sync-cli.js'][1127] = 0;
  _$jscoverage['modules/sync-cli.js'][1128] = 0;
  _$jscoverage['modules/sync-cli.js'][1131] = 0;
  _$jscoverage['modules/sync-cli.js'][1132] = 0;
  _$jscoverage['modules/sync-cli.js'][1135] = 0;
  _$jscoverage['modules/sync-cli.js'][1137] = 0;
  _$jscoverage['modules/sync-cli.js'][1139] = 0;
  _$jscoverage['modules/sync-cli.js'][1141] = 0;
  _$jscoverage['modules/sync-cli.js'][1142] = 0;
  _$jscoverage['modules/sync-cli.js'][1143] = 0;
  _$jscoverage['modules/sync-cli.js'][1145] = 0;
  _$jscoverage['modules/sync-cli.js'][1146] = 0;
  _$jscoverage['modules/sync-cli.js'][1147] = 0;
  _$jscoverage['modules/sync-cli.js'][1154] = 0;
  _$jscoverage['modules/sync-cli.js'][1155] = 0;
  _$jscoverage['modules/sync-cli.js'][1160] = 0;
  _$jscoverage['modules/sync-cli.js'][1161] = 0;
  _$jscoverage['modules/sync-cli.js'][1164] = 0;
  _$jscoverage['modules/sync-cli.js'][1171] = 0;
  _$jscoverage['modules/sync-cli.js'][1172] = 0;
  _$jscoverage['modules/sync-cli.js'][1175] = 0;
  _$jscoverage['modules/sync-cli.js'][1182] = 0;
  _$jscoverage['modules/sync-cli.js'][1183] = 0;
  _$jscoverage['modules/sync-cli.js'][1184] = 0;
  _$jscoverage['modules/sync-cli.js'][1186] = 0;
  _$jscoverage['modules/sync-cli.js'][1187] = 0;
  _$jscoverage['modules/sync-cli.js'][1188] = 0;
  _$jscoverage['modules/sync-cli.js'][1189] = 0;
  _$jscoverage['modules/sync-cli.js'][1190] = 0;
  _$jscoverage['modules/sync-cli.js'][1191] = 0;
  _$jscoverage['modules/sync-cli.js'][1192] = 0;
  _$jscoverage['modules/sync-cli.js'][1195] = 0;
  _$jscoverage['modules/sync-cli.js'][1196] = 0;
  _$jscoverage['modules/sync-cli.js'][1200] = 0;
  _$jscoverage['modules/sync-cli.js'][1201] = 0;
  _$jscoverage['modules/sync-cli.js'][1203] = 0;
  _$jscoverage['modules/sync-cli.js'][1204] = 0;
  _$jscoverage['modules/sync-cli.js'][1205] = 0;
  _$jscoverage['modules/sync-cli.js'][1206] = 0;
  _$jscoverage['modules/sync-cli.js'][1215] = 0;
  _$jscoverage['modules/sync-cli.js'][1216] = 0;
  _$jscoverage['modules/sync-cli.js'][1217] = 0;
  _$jscoverage['modules/sync-cli.js'][1218] = 0;
  _$jscoverage['modules/sync-cli.js'][1219] = 0;
  _$jscoverage['modules/sync-cli.js'][1220] = 0;
  _$jscoverage['modules/sync-cli.js'][1221] = 0;
  _$jscoverage['modules/sync-cli.js'][1222] = 0;
  _$jscoverage['modules/sync-cli.js'][1223] = 0;
  _$jscoverage['modules/sync-cli.js'][1224] = 0;
  _$jscoverage['modules/sync-cli.js'][1225] = 0;
  _$jscoverage['modules/sync-cli.js'][1226] = 0;
  _$jscoverage['modules/sync-cli.js'][1227] = 0;
  _$jscoverage['modules/sync-cli.js'][1228] = 0;
  _$jscoverage['modules/sync-cli.js'][1229] = 0;
  _$jscoverage['modules/sync-cli.js'][1240] = 0;
  _$jscoverage['modules/sync-cli.js'][1241] = 0;
  _$jscoverage['modules/sync-cli.js'][1242] = 0;
  _$jscoverage['modules/sync-cli.js'][1244] = 0;
  _$jscoverage['modules/sync-cli.js'][1245] = 0;
  _$jscoverage['modules/sync-cli.js'][1246] = 0;
  _$jscoverage['modules/sync-cli.js'][1247] = 0;
  _$jscoverage['modules/sync-cli.js'][1248] = 0;
  _$jscoverage['modules/sync-cli.js'][1250] = 0;
  _$jscoverage['modules/sync-cli.js'][1251] = 0;
  _$jscoverage['modules/sync-cli.js'][1252] = 0;
  _$jscoverage['modules/sync-cli.js'][1253] = 0;
  _$jscoverage['modules/sync-cli.js'][1260] = 0;
  _$jscoverage['modules/sync-cli.js'][1261] = 0;
  _$jscoverage['modules/sync-cli.js'][1262] = 0;
  _$jscoverage['modules/sync-cli.js'][1264] = 0;
  _$jscoverage['modules/sync-cli.js'][1265] = 0;
  _$jscoverage['modules/sync-cli.js'][1266] = 0;
  _$jscoverage['modules/sync-cli.js'][1267] = 0;
  _$jscoverage['modules/sync-cli.js'][1276] = 0;
  _$jscoverage['modules/sync-cli.js'][1277] = 0;
  _$jscoverage['modules/sync-cli.js'][1282] = 0;
  _$jscoverage['modules/sync-cli.js'][1283] = 0;
  _$jscoverage['modules/sync-cli.js'][1288] = 0;
}
_$jscoverage['modules/sync-cli.js'][1]++;
var JSON = require("JSON");
_$jscoverage['modules/sync-cli.js'][2]++;
var actAPI = require("./api_act");
_$jscoverage['modules/sync-cli.js'][3]++;
var cloudAPI = require("./api_cloud");
_$jscoverage['modules/sync-cli.js'][4]++;
var CryptoJS = require("../../libs/generated/crypto");
_$jscoverage['modules/sync-cli.js'][5]++;
var Lawnchair = require("../../libs/generated/lawnchair");
_$jscoverage['modules/sync-cli.js'][7]++;
var self = {defaults: {"sync_frequency": 10, "auto_sync_local_updates": true, "notify_client_storage_failed": true, "notify_sync_started": true, "notify_sync_complete": true, "notify_offline_update": true, "notify_collision_detected": true, "notify_remote_update_failed": true, "notify_local_update_applied": true, "notify_remote_update_applied": true, "notify_delta_received": true, "notify_record_delta_received": true, "notify_sync_failed": true, "do_console_log": false, "crashed_count_wait": 10, "resend_crashed_updates": true, "sync_active": true, "storage_strategy": "html5-filesystem", "file_system_quota": 61644800}, notifications: {"CLIENT_STORAGE_FAILED": "client_storage_failed", "SYNC_STARTED": "sync_started", "SYNC_COMPLETE": "sync_complete", "OFFLINE_UPDATE": "offline_update", "COLLISION_DETECTED": "collision_detected", "REMOTE_UPDATE_FAILED": "remote_update_failed", "REMOTE_UPDATE_APPLIED": "remote_update_applied", "LOCAL_UPDATE_APPLIED": "local_update_applied", "DELTA_RECEIVED": "delta_received", "RECORD_DELTA_RECEIVED": "record_delta_received", "SYNC_FAILED": "sync_failed"}, datasets: {}, config: undefined, notify_callback: undefined, hasCustomSync: undefined, init: (function (options) {
  _$jscoverage['modules/sync-cli.js'][87]++;
  self.consoleLog("sync - init called");
  _$jscoverage['modules/sync-cli.js'][89]++;
  self.config = JSON.parse(JSON.stringify(self.defaults));
  _$jscoverage['modules/sync-cli.js'][90]++;
  for (var i in options) {
    _$jscoverage['modules/sync-cli.js'][91]++;
    self.config[i] = options[i];
}
  _$jscoverage['modules/sync-cli.js'][94]++;
  self.datasetMonitor();
}), notify: (function (callback) {
  _$jscoverage['modules/sync-cli.js'][98]++;
  self.notify_callback = callback;
}), manage: (function (dataset_id, options, query_params, meta_data, cb) {
  _$jscoverage['modules/sync-cli.js'][102]++;
  self.consoleLog("manage - START");
  _$jscoverage['modules/sync-cli.js'][104]++;
  var options = options || {};
  _$jscoverage['modules/sync-cli.js'][106]++;
  var doManage = (function (dataset) {
  _$jscoverage['modules/sync-cli.js'][107]++;
  self.consoleLog("doManage dataset :: initialised = " + dataset.initialised + " :: " + dataset_id + " :: " + JSON.stringify(options));
  _$jscoverage['modules/sync-cli.js'][109]++;
  var datasetConfig = self.setOptions(options);
  _$jscoverage['modules/sync-cli.js'][111]++;
  dataset.query_params = query_params || dataset.query_params || {};
  _$jscoverage['modules/sync-cli.js'][112]++;
  dataset.meta_data = meta_data || dataset.meta_data || {};
  _$jscoverage['modules/sync-cli.js'][113]++;
  dataset.config = datasetConfig;
  _$jscoverage['modules/sync-cli.js'][114]++;
  dataset.syncRunning = false;
  _$jscoverage['modules/sync-cli.js'][115]++;
  dataset.syncPending = true;
  _$jscoverage['modules/sync-cli.js'][116]++;
  dataset.initialised = true;
  _$jscoverage['modules/sync-cli.js'][117]++;
  dataset.meta = {};
  _$jscoverage['modules/sync-cli.js'][119]++;
  self.saveDataSet(dataset_id, (function () {
  _$jscoverage['modules/sync-cli.js'][121]++;
  if (cb) {
    _$jscoverage['modules/sync-cli.js'][122]++;
    cb();
  }
}));
});
  _$jscoverage['modules/sync-cli.js'][128]++;
  self.getDataSet(dataset_id, (function (dataset) {
  _$jscoverage['modules/sync-cli.js'][129]++;
  self.consoleLog("manage - dataset already loaded");
  _$jscoverage['modules/sync-cli.js'][130]++;
  doManage(dataset);
}), (function (err) {
  _$jscoverage['modules/sync-cli.js'][132]++;
  self.consoleLog("manage - dataset not loaded... trying to load");
  _$jscoverage['modules/sync-cli.js'][135]++;
  self.loadDataSet(dataset_id, (function (dataset) {
  _$jscoverage['modules/sync-cli.js'][136]++;
  self.consoleLog("manage - dataset loaded from local storage");
  _$jscoverage['modules/sync-cli.js'][141]++;
  self.doNotify(dataset_id, null, self.notifications.LOCAL_UPDATE_APPLIED, "load");
  _$jscoverage['modules/sync-cli.js'][144]++;
  doManage(dataset);
}), (function (err) {
  _$jscoverage['modules/sync-cli.js'][148]++;
  self.consoleLog("manage - Creating new dataset for id " + dataset_id);
  _$jscoverage['modules/sync-cli.js'][149]++;
  var dataset = {};
  _$jscoverage['modules/sync-cli.js'][150]++;
  dataset.data = {};
  _$jscoverage['modules/sync-cli.js'][151]++;
  dataset.pending = {};
  _$jscoverage['modules/sync-cli.js'][152]++;
  self.datasets[dataset_id] = dataset;
  _$jscoverage['modules/sync-cli.js'][153]++;
  doManage(dataset);
}));
}));
}), setOptions: (function (options) {
  _$jscoverage['modules/sync-cli.js'][160]++;
  if (! self.config) {
    _$jscoverage['modules/sync-cli.js'][161]++;
    self.config = JSON.parse(JSON.stringify(self.defaults));
  }
  _$jscoverage['modules/sync-cli.js'][164]++;
  var datasetConfig = JSON.parse(JSON.stringify(self.config));
  _$jscoverage['modules/sync-cli.js'][165]++;
  var optionsIn = JSON.parse(JSON.stringify(options));
  _$jscoverage['modules/sync-cli.js'][166]++;
  for (var k in optionsIn) {
    _$jscoverage['modules/sync-cli.js'][167]++;
    datasetConfig[k] = optionsIn[k];
}
  _$jscoverage['modules/sync-cli.js'][170]++;
  return datasetConfig;
}), list: (function (dataset_id, success, failure) {
  _$jscoverage['modules/sync-cli.js'][174]++;
  self.getDataSet(dataset_id, (function (dataset) {
  _$jscoverage['modules/sync-cli.js'][175]++;
  if (dataset && dataset.data) {
    _$jscoverage['modules/sync-cli.js'][177]++;
    var res = JSON.parse(JSON.stringify(dataset.data));
    _$jscoverage['modules/sync-cli.js'][178]++;
    success(res);
  }
  else {
    _$jscoverage['modules/sync-cli.js'][180]++;
    if (failure) {
      _$jscoverage['modules/sync-cli.js'][180]++;
      failure("no_data");
    }
  }
}), (function (code, msg) {
  _$jscoverage['modules/sync-cli.js'][183]++;
  if (failure) {
    _$jscoverage['modules/sync-cli.js'][183]++;
    failure(code, msg);
  }
}));
}), create: (function (dataset_id, data, success, failure) {
  _$jscoverage['modules/sync-cli.js'][188]++;
  self.addPendingObj(dataset_id, null, data, "create", success, failure);
}), read: (function (dataset_id, uid, success, failure) {
  _$jscoverage['modules/sync-cli.js'][192]++;
  self.getDataSet(dataset_id, (function (dataset) {
  _$jscoverage['modules/sync-cli.js'][193]++;
  var rec = dataset.data[uid];
  _$jscoverage['modules/sync-cli.js'][194]++;
  if (! rec) {
    _$jscoverage['modules/sync-cli.js'][195]++;
    failure("unknown_uid");
  }
  else {
    _$jscoverage['modules/sync-cli.js'][198]++;
    var res = JSON.parse(JSON.stringify(rec));
    _$jscoverage['modules/sync-cli.js'][199]++;
    success(res);
  }
}), (function (code, msg) {
  _$jscoverage['modules/sync-cli.js'][202]++;
  if (failure) {
    _$jscoverage['modules/sync-cli.js'][202]++;
    failure(code, msg);
  }
}));
}), update: (function (dataset_id, uid, data, success, failure) {
  _$jscoverage['modules/sync-cli.js'][207]++;
  self.addPendingObj(dataset_id, uid, data, "update", success, failure);
}), "delete": (function (dataset_id, uid, success, failure) {
  _$jscoverage['modules/sync-cli.js'][211]++;
  self.addPendingObj(dataset_id, uid, null, "delete", success, failure);
}), getPending: (function (dataset_id, cb) {
  _$jscoverage['modules/sync-cli.js'][215]++;
  self.getDataSet(dataset_id, (function (dataset) {
  _$jscoverage['modules/sync-cli.js'][216]++;
  var res;
  _$jscoverage['modules/sync-cli.js'][217]++;
  if (dataset) {
    _$jscoverage['modules/sync-cli.js'][218]++;
    res = dataset.pending;
  }
  _$jscoverage['modules/sync-cli.js'][220]++;
  cb(res);
}), (function (err, datatset_id) {
  _$jscoverage['modules/sync-cli.js'][222]++;
  self.consoleLog(err);
}));
}), clearPending: (function (dataset_id, cb) {
  _$jscoverage['modules/sync-cli.js'][227]++;
  self.getDataSet(dataset_id, (function (dataset) {
  _$jscoverage['modules/sync-cli.js'][228]++;
  dataset.pending = {};
  _$jscoverage['modules/sync-cli.js'][229]++;
  self.saveDataSet(dataset_id, cb);
}));
}), listCollisions: (function (dataset_id, success, failure) {
  _$jscoverage['modules/sync-cli.js'][234]++;
  self.getDataSet(dataset_id, (function (dataset) {
  _$jscoverage['modules/sync-cli.js'][235]++;
  self.doCloudCall({"dataset_id": dataset_id, "req": {"fn": "listCollisions", "meta_data": dataset.meta_data}}, success, failure);
}), failure);
}), removeCollision: (function (dataset_id, colissionHash, success, failure) {
  _$jscoverage['modules/sync-cli.js'][246]++;
  self.getDataSet(dataset_id, (function (dataset) {
  _$jscoverage['modules/sync-cli.js'][247]++;
  self.doCloudCall({"dataset_id": dataset_id, "req": {"fn": "removeCollision", "hash": colissionHash, meta_data: dataset.meta_data}}, success, failure);
}));
}), isOnline: (function (callback) {
  _$jscoverage['modules/sync-cli.js'][261]++;
  var online = true;
  _$jscoverage['modules/sync-cli.js'][264]++;
  if (typeof navigator.onLine !== "undefined") {
    _$jscoverage['modules/sync-cli.js'][265]++;
    online = navigator.onLine;
  }
  _$jscoverage['modules/sync-cli.js'][269]++;
  if (online) {
    _$jscoverage['modules/sync-cli.js'][271]++;
    if (typeof navigator.network !== "undefined" && typeof navigator.network.connection !== "undefined") {
      _$jscoverage['modules/sync-cli.js'][272]++;
      var networkType = navigator.network.connection.type;
      _$jscoverage['modules/sync-cli.js'][273]++;
      if (networkType === "none" || networkType === null) {
        _$jscoverage['modules/sync-cli.js'][274]++;
        online = false;
      }
    }
  }
  _$jscoverage['modules/sync-cli.js'][279]++;
  return callback(online);
}), doNotify: (function (dataset_id, uid, code, message) {
  _$jscoverage['modules/sync-cli.js'][284]++;
  if (self.notify_callback) {
    _$jscoverage['modules/sync-cli.js'][285]++;
    if (self.config["notify_" + code]) {
      _$jscoverage['modules/sync-cli.js'][286]++;
      var notification = {"dataset_id": dataset_id, "uid": uid, "code": code, "message": message};
      _$jscoverage['modules/sync-cli.js'][293]++;
      setTimeout((function () {
  _$jscoverage['modules/sync-cli.js'][294]++;
  self.notify_callback(notification);
}), 0);
    }
  }
}), getDataSet: (function (dataset_id, success, failure) {
  _$jscoverage['modules/sync-cli.js'][301]++;
  var dataset = self.datasets[dataset_id];
  _$jscoverage['modules/sync-cli.js'][303]++;
  if (dataset) {
    _$jscoverage['modules/sync-cli.js'][304]++;
    success(dataset);
  }
  else {
    _$jscoverage['modules/sync-cli.js'][306]++;
    failure("unknown_dataset " + dataset_id, dataset_id);
  }
}), getQueryParams: (function (dataset_id, success, failure) {
  _$jscoverage['modules/sync-cli.js'][311]++;
  var dataset = self.datasets[dataset_id];
  _$jscoverage['modules/sync-cli.js'][313]++;
  if (dataset) {
    _$jscoverage['modules/sync-cli.js'][314]++;
    success(dataset.query_params);
  }
  else {
    _$jscoverage['modules/sync-cli.js'][316]++;
    failure("unknown_dataset " + dataset_id, dataset_id);
  }
}), setQueryParams: (function (dataset_id, queryParams, success, failure) {
  _$jscoverage['modules/sync-cli.js'][321]++;
  var dataset = self.datasets[dataset_id];
  _$jscoverage['modules/sync-cli.js'][323]++;
  if (dataset) {
    _$jscoverage['modules/sync-cli.js'][324]++;
    dataset.query_params = queryParams;
    _$jscoverage['modules/sync-cli.js'][325]++;
    self.saveDataSet(dataset_id);
    _$jscoverage['modules/sync-cli.js'][326]++;
    if (success) {
      _$jscoverage['modules/sync-cli.js'][327]++;
      success(dataset.query_params);
    }
  }
  else {
    _$jscoverage['modules/sync-cli.js'][330]++;
    if (failure) {
      _$jscoverage['modules/sync-cli.js'][331]++;
      failure("unknown_dataset " + dataset_id, dataset_id);
    }
  }
}), getMetaData: (function (dataset_id, success, failure) {
  _$jscoverage['modules/sync-cli.js'][337]++;
  var dataset = self.datasets[dataset_id];
  _$jscoverage['modules/sync-cli.js'][339]++;
  if (dataset) {
    _$jscoverage['modules/sync-cli.js'][340]++;
    success(dataset.meta_data);
  }
  else {
    _$jscoverage['modules/sync-cli.js'][342]++;
    failure("unknown_dataset " + dataset_id, dataset_id);
  }
}), setMetaData: (function (dataset_id, metaData, success, failure) {
  _$jscoverage['modules/sync-cli.js'][347]++;
  var dataset = self.datasets[dataset_id];
  _$jscoverage['modules/sync-cli.js'][349]++;
  if (dataset) {
    _$jscoverage['modules/sync-cli.js'][350]++;
    dataset.meta_data = metaData;
    _$jscoverage['modules/sync-cli.js'][351]++;
    self.saveDataSet(dataset_id);
    _$jscoverage['modules/sync-cli.js'][352]++;
    if (success) {
      _$jscoverage['modules/sync-cli.js'][353]++;
      success(dataset.meta_data);
    }
  }
  else {
    _$jscoverage['modules/sync-cli.js'][356]++;
    if (failure) {
      _$jscoverage['modules/sync-cli.js'][357]++;
      failure("unknown_dataset " + dataset_id, dataset_id);
    }
  }
}), getConfig: (function (dataset_id, success, failure) {
  _$jscoverage['modules/sync-cli.js'][363]++;
  var dataset = self.datasets[dataset_id];
  _$jscoverage['modules/sync-cli.js'][365]++;
  if (dataset) {
    _$jscoverage['modules/sync-cli.js'][366]++;
    success(dataset.config);
  }
  else {
    _$jscoverage['modules/sync-cli.js'][368]++;
    failure("unknown_dataset " + dataset_id, dataset_id);
  }
}), setConfig: (function (dataset_id, config, success, failure) {
  _$jscoverage['modules/sync-cli.js'][373]++;
  var dataset = self.datasets[dataset_id];
  _$jscoverage['modules/sync-cli.js'][375]++;
  if (dataset) {
    _$jscoverage['modules/sync-cli.js'][376]++;
    var fullConfig = self.setOptions(config);
    _$jscoverage['modules/sync-cli.js'][377]++;
    dataset.config = fullConfig;
    _$jscoverage['modules/sync-cli.js'][378]++;
    self.saveDataSet(dataset_id);
    _$jscoverage['modules/sync-cli.js'][379]++;
    if (success) {
      _$jscoverage['modules/sync-cli.js'][380]++;
      success(dataset.config);
    }
  }
  else {
    _$jscoverage['modules/sync-cli.js'][383]++;
    if (failure) {
      _$jscoverage['modules/sync-cli.js'][384]++;
      failure("unknown_dataset " + dataset_id, dataset_id);
    }
  }
}), stopSync: (function (dataset_id, success, failure) {
  _$jscoverage['modules/sync-cli.js'][390]++;
  self.setConfig(dataset_id, {"sync_active": false}, (function () {
  _$jscoverage['modules/sync-cli.js'][391]++;
  if (success) {
    _$jscoverage['modules/sync-cli.js'][392]++;
    success();
  }
}), failure);
}), startSync: (function (dataset_id, success, failure) {
  _$jscoverage['modules/sync-cli.js'][398]++;
  self.setConfig(dataset_id, {"sync_active": true}, (function () {
  _$jscoverage['modules/sync-cli.js'][399]++;
  if (success) {
    _$jscoverage['modules/sync-cli.js'][400]++;
    success();
  }
}), failure);
}), doSync: (function (dataset_id, success, failure) {
  _$jscoverage['modules/sync-cli.js'][406]++;
  var dataset = self.datasets[dataset_id];
  _$jscoverage['modules/sync-cli.js'][408]++;
  if (dataset) {
    _$jscoverage['modules/sync-cli.js'][409]++;
    dataset.syncPending = true;
    _$jscoverage['modules/sync-cli.js'][410]++;
    self.saveDataSet(dataset_id);
    _$jscoverage['modules/sync-cli.js'][411]++;
    if (success) {
      _$jscoverage['modules/sync-cli.js'][412]++;
      success();
    }
  }
  else {
    _$jscoverage['modules/sync-cli.js'][415]++;
    if (failure) {
      _$jscoverage['modules/sync-cli.js'][416]++;
      failure("unknown_dataset " + dataset_id, dataset_id);
    }
  }
}), forceSync: (function (dataset_id, success, failure) {
  _$jscoverage['modules/sync-cli.js'][422]++;
  var dataset = self.datasets[dataset_id];
  _$jscoverage['modules/sync-cli.js'][424]++;
  if (dataset) {
    _$jscoverage['modules/sync-cli.js'][425]++;
    dataset.syncForced = true;
    _$jscoverage['modules/sync-cli.js'][426]++;
    self.saveDataSet(dataset_id);
    _$jscoverage['modules/sync-cli.js'][427]++;
    if (success) {
      _$jscoverage['modules/sync-cli.js'][428]++;
      success();
    }
  }
  else {
    _$jscoverage['modules/sync-cli.js'][431]++;
    if (failure) {
      _$jscoverage['modules/sync-cli.js'][432]++;
      failure("unknown_dataset " + dataset_id, dataset_id);
    }
  }
}), sortObject: (function (object) {
  _$jscoverage['modules/sync-cli.js'][438]++;
  if (typeof object !== "object" || object === null) {
    _$jscoverage['modules/sync-cli.js'][439]++;
    return object;
  }
  _$jscoverage['modules/sync-cli.js'][442]++;
  var result = [];
  _$jscoverage['modules/sync-cli.js'][444]++;
  Object.keys(object).sort().forEach((function (key) {
  _$jscoverage['modules/sync-cli.js'][445]++;
  result.push({key: key, value: self.sortObject(object[key])});
}));
  _$jscoverage['modules/sync-cli.js'][451]++;
  return result;
}), sortedStringify: (function (obj) {
  _$jscoverage['modules/sync-cli.js'][456]++;
  var str = "";
  _$jscoverage['modules/sync-cli.js'][458]++;
  try {
    _$jscoverage['modules/sync-cli.js'][459]++;
    str = JSON.stringify(self.sortObject(obj));
  }
  catch (e) {
    _$jscoverage['modules/sync-cli.js'][461]++;
    console.error("Error stringifying sorted object:" + e);
  }
  _$jscoverage['modules/sync-cli.js'][464]++;
  return str;
}), generateHash: (function (object) {
  _$jscoverage['modules/sync-cli.js'][468]++;
  var hash = CryptoJS.SHA1(self.sortedStringify(object));
  _$jscoverage['modules/sync-cli.js'][469]++;
  return hash.toString();
}), addPendingObj: (function (dataset_id, uid, data, action, success, failure) {
  _$jscoverage['modules/sync-cli.js'][473]++;
  self.isOnline((function (online) {
  _$jscoverage['modules/sync-cli.js'][474]++;
  if (! online) {
    _$jscoverage['modules/sync-cli.js'][475]++;
    self.doNotify(dataset_id, uid, self.notifications.OFFLINE_UPDATE, action);
  }
}));
  _$jscoverage['modules/sync-cli.js'][479]++;
  function storePendingObject(obj) {
    _$jscoverage['modules/sync-cli.js'][480]++;
    obj.hash = self.generateHash(obj);
    _$jscoverage['modules/sync-cli.js'][482]++;
    self.getDataSet(dataset_id, (function (dataset) {
  _$jscoverage['modules/sync-cli.js'][484]++;
  dataset.pending[obj.hash] = obj;
  _$jscoverage['modules/sync-cli.js'][486]++;
  self.updateDatasetFromLocal(dataset, obj);
  _$jscoverage['modules/sync-cli.js'][488]++;
  if (self.config.auto_sync_local_updates) {
    _$jscoverage['modules/sync-cli.js'][489]++;
    dataset.syncPending = true;
  }
  _$jscoverage['modules/sync-cli.js'][491]++;
  self.saveDataSet(dataset_id);
  _$jscoverage['modules/sync-cli.js'][492]++;
  self.doNotify(dataset_id, uid, self.notifications.LOCAL_UPDATE_APPLIED, action);
  _$jscoverage['modules/sync-cli.js'][494]++;
  success(obj);
}), (function (code, msg) {
  _$jscoverage['modules/sync-cli.js'][496]++;
  if (failure) {
    _$jscoverage['modules/sync-cli.js'][496]++;
    failure(code, msg);
  }
}));
}
  _$jscoverage['modules/sync-cli.js'][500]++;
  var pendingObj = {};
  _$jscoverage['modules/sync-cli.js'][501]++;
  pendingObj.inFlight = false;
  _$jscoverage['modules/sync-cli.js'][502]++;
  pendingObj.action = action;
  _$jscoverage['modules/sync-cli.js'][503]++;
  pendingObj.post = JSON.parse(JSON.stringify(data));
  _$jscoverage['modules/sync-cli.js'][504]++;
  pendingObj.postHash = self.generateHash(pendingObj.post);
  _$jscoverage['modules/sync-cli.js'][505]++;
  pendingObj.timestamp = new Date().getTime();
  _$jscoverage['modules/sync-cli.js'][506]++;
  if ("create" === action) {
    _$jscoverage['modules/sync-cli.js'][507]++;
    pendingObj.uid = pendingObj.postHash;
    _$jscoverage['modules/sync-cli.js'][508]++;
    storePendingObject(pendingObj);
  }
  else {
    _$jscoverage['modules/sync-cli.js'][510]++;
    self.read(dataset_id, uid, (function (rec) {
  _$jscoverage['modules/sync-cli.js'][511]++;
  pendingObj.uid = uid;
  _$jscoverage['modules/sync-cli.js'][512]++;
  pendingObj.pre = rec.data;
  _$jscoverage['modules/sync-cli.js'][513]++;
  pendingObj.preHash = self.generateHash(rec.data);
  _$jscoverage['modules/sync-cli.js'][514]++;
  storePendingObject(pendingObj);
}), (function (code, msg) {
  _$jscoverage['modules/sync-cli.js'][516]++;
  failure(code, msg);
}));
  }
}), syncLoop: (function (dataset_id) {
  _$jscoverage['modules/sync-cli.js'][522]++;
  self.getDataSet(dataset_id, (function (dataSet) {
  _$jscoverage['modules/sync-cli.js'][525]++;
  dataSet.syncPending = false;
  _$jscoverage['modules/sync-cli.js'][526]++;
  dataSet.syncRunning = true;
  _$jscoverage['modules/sync-cli.js'][527]++;
  dataSet.syncLoopStart = new Date().getTime();
  _$jscoverage['modules/sync-cli.js'][528]++;
  self.doNotify(dataset_id, null, self.notifications.SYNC_STARTED, null);
  _$jscoverage['modules/sync-cli.js'][530]++;
  self.isOnline((function (online) {
  _$jscoverage['modules/sync-cli.js'][531]++;
  if (! online) {
    _$jscoverage['modules/sync-cli.js'][532]++;
    self.syncComplete(dataset_id, "offline", self.notifications.SYNC_FAILED);
  }
  else {
    _$jscoverage['modules/sync-cli.js'][534]++;
    self.checkHasCustomSync(dataset_id, (function () {
  _$jscoverage['modules/sync-cli.js'][536]++;
  var syncLoopParams = {};
  _$jscoverage['modules/sync-cli.js'][537]++;
  syncLoopParams.fn = "sync";
  _$jscoverage['modules/sync-cli.js'][538]++;
  syncLoopParams.dataset_id = dataset_id;
  _$jscoverage['modules/sync-cli.js'][539]++;
  syncLoopParams.query_params = dataSet.query_params;
  _$jscoverage['modules/sync-cli.js'][540]++;
  syncLoopParams.config = dataSet.config;
  _$jscoverage['modules/sync-cli.js'][541]++;
  syncLoopParams.meta_data = dataSet.meta_data;
  _$jscoverage['modules/sync-cli.js'][543]++;
  syncLoopParams.dataset_hash = dataSet.hash;
  _$jscoverage['modules/sync-cli.js'][544]++;
  syncLoopParams.acknowledgements = dataSet.acknowledgements || [];
  _$jscoverage['modules/sync-cli.js'][546]++;
  var pending = dataSet.pending;
  _$jscoverage['modules/sync-cli.js'][547]++;
  var pendingArray = [];
  _$jscoverage['modules/sync-cli.js'][548]++;
  for (var i in pending) {
    _$jscoverage['modules/sync-cli.js'][552]++;
    if (! pending[i].inFlight && ! pending[i].crashed && ! pending[i].delayed) {
      _$jscoverage['modules/sync-cli.js'][553]++;
      pending[i].inFlight = true;
      _$jscoverage['modules/sync-cli.js'][554]++;
      pending[i].inFlightDate = new Date().getTime();
      _$jscoverage['modules/sync-cli.js'][555]++;
      pendingArray.push(pending[i]);
    }
}
  _$jscoverage['modules/sync-cli.js'][558]++;
  syncLoopParams.pending = pendingArray;
  _$jscoverage['modules/sync-cli.js'][560]++;
  if (pendingArray.length > 0) {
    _$jscoverage['modules/sync-cli.js'][561]++;
    self.consoleLog("Starting sync loop - global hash = " + dataSet.hash + " :: params = " + JSON.stringify(syncLoopParams, null, 2));
  }
  _$jscoverage['modules/sync-cli.js'][563]++;
  try {
    _$jscoverage['modules/sync-cli.js'][564]++;
    self.doCloudCall({"dataset_id": dataset_id, "req": syncLoopParams}, (function (res) {
  _$jscoverage['modules/sync-cli.js'][568]++;
  var rec;
  _$jscoverage['modules/sync-cli.js'][570]++;
  function processUpdates(updates, notification, acknowledgements) {
    _$jscoverage['modules/sync-cli.js'][571]++;
    if (updates) {
      _$jscoverage['modules/sync-cli.js'][572]++;
      for (var up in updates) {
        _$jscoverage['modules/sync-cli.js'][573]++;
        rec = updates[up];
        _$jscoverage['modules/sync-cli.js'][574]++;
        acknowledgements.push(rec);
        _$jscoverage['modules/sync-cli.js'][575]++;
        if (dataSet.pending[up] && dataSet.pending[up].inFlight && ! dataSet.pending[up].crashed) {
          _$jscoverage['modules/sync-cli.js'][576]++;
          delete dataSet.pending[up];
          _$jscoverage['modules/sync-cli.js'][577]++;
          self.doNotify(dataset_id, rec.uid, notification, rec);
        }
}
    }
}
  _$jscoverage['modules/sync-cli.js'][584]++;
  self.updatePendingFromNewData(dataset_id, dataSet, res);
  _$jscoverage['modules/sync-cli.js'][587]++;
  self.updateCrashedInFlightFromNewData(dataset_id, dataSet, res);
  _$jscoverage['modules/sync-cli.js'][590]++;
  self.updateDelayedFromNewData(dataset_id, dataSet, res);
  _$jscoverage['modules/sync-cli.js'][593]++;
  self.updateNewDataFromInFlight(dataset_id, dataSet, res);
  _$jscoverage['modules/sync-cli.js'][596]++;
  self.updateNewDataFromPending(dataset_id, dataSet, res);
  _$jscoverage['modules/sync-cli.js'][600]++;
  if (res.records) {
    _$jscoverage['modules/sync-cli.js'][602]++;
    dataSet.data = res.records;
    _$jscoverage['modules/sync-cli.js'][603]++;
    dataSet.hash = res.hash;
    _$jscoverage['modules/sync-cli.js'][605]++;
    self.doNotify(dataset_id, res.hash, self.notifications.DELTA_RECEIVED, "full dataset");
  }
  _$jscoverage['modules/sync-cli.js'][608]++;
  if (res.updates) {
    _$jscoverage['modules/sync-cli.js'][609]++;
    var acknowledgements = [];
    _$jscoverage['modules/sync-cli.js'][610]++;
    processUpdates(res.updates.applied, self.notifications.REMOTE_UPDATE_APPLIED, acknowledgements);
    _$jscoverage['modules/sync-cli.js'][611]++;
    processUpdates(res.updates.failed, self.notifications.REMOTE_UPDATE_FAILED, acknowledgements);
    _$jscoverage['modules/sync-cli.js'][612]++;
    processUpdates(res.updates.collisions, self.notifications.COLLISION_DETECTED, acknowledgements);
    _$jscoverage['modules/sync-cli.js'][613]++;
    dataSet.acknowledgements = acknowledgements;
  }
  _$jscoverage['modules/sync-cli.js'][616]++;
  if (! res.records && res.hash && res.hash !== dataSet.hash) {
    _$jscoverage['modules/sync-cli.js'][617]++;
    self.consoleLog("Local dataset stale - syncing records :: local hash= " + dataSet.hash + " - remoteHash=" + res.hash);
    _$jscoverage['modules/sync-cli.js'][619]++;
    self.syncRecords(dataset_id);
  }
  else {
    _$jscoverage['modules/sync-cli.js'][621]++;
    self.consoleLog("Local dataset up to date");
    _$jscoverage['modules/sync-cli.js'][622]++;
    self.syncComplete(dataset_id, "online", self.notifications.SYNC_COMPLETE);
  }
}), (function (msg, err) {
  _$jscoverage['modules/sync-cli.js'][628]++;
  self.markInFlightAsCrashed(dataSet);
  _$jscoverage['modules/sync-cli.js'][629]++;
  self.consoleLog("syncLoop failed : msg=" + msg + " :: err = " + err);
  _$jscoverage['modules/sync-cli.js'][630]++;
  self.syncComplete(dataset_id, msg, self.notifications.SYNC_FAILED);
}));
  }
  catch (e) {
    _$jscoverage['modules/sync-cli.js'][634]++;
    self.consoleLog("Error performing sync - " + e);
    _$jscoverage['modules/sync-cli.js'][635]++;
    self.syncComplete(dataset_id, e, self.notifications.SYNC_FAILED);
  }
}));
  }
}));
}));
}), syncRecords: (function (dataset_id) {
  _$jscoverage['modules/sync-cli.js'][645]++;
  self.getDataSet(dataset_id, (function (dataSet) {
  _$jscoverage['modules/sync-cli.js'][647]++;
  var localDataSet = dataSet.data || {};
  _$jscoverage['modules/sync-cli.js'][649]++;
  var clientRecs = {};
  _$jscoverage['modules/sync-cli.js'][650]++;
  for (var i in localDataSet) {
    _$jscoverage['modules/sync-cli.js'][651]++;
    var uid = i;
    _$jscoverage['modules/sync-cli.js'][652]++;
    var hash = localDataSet[i].hash;
    _$jscoverage['modules/sync-cli.js'][653]++;
    clientRecs[uid] = hash;
}
  _$jscoverage['modules/sync-cli.js'][656]++;
  var syncRecParams = {};
  _$jscoverage['modules/sync-cli.js'][658]++;
  syncRecParams.fn = "syncRecords";
  _$jscoverage['modules/sync-cli.js'][659]++;
  syncRecParams.dataset_id = dataset_id;
  _$jscoverage['modules/sync-cli.js'][660]++;
  syncRecParams.query_params = dataSet.query_params;
  _$jscoverage['modules/sync-cli.js'][661]++;
  syncRecParams.clientRecs = clientRecs;
  _$jscoverage['modules/sync-cli.js'][663]++;
  self.consoleLog("syncRecParams :: " + JSON.stringify(syncRecParams));
  _$jscoverage['modules/sync-cli.js'][665]++;
  self.doCloudCall({"dataset_id": dataset_id, "req": syncRecParams}, (function (res) {
  _$jscoverage['modules/sync-cli.js'][669]++;
  var i;
  _$jscoverage['modules/sync-cli.js'][671]++;
  if (res.create) {
    _$jscoverage['modules/sync-cli.js'][672]++;
    for (i in res.create) {
      _$jscoverage['modules/sync-cli.js'][673]++;
      localDataSet[i] = {"hash": res.create[i].hash, "data": res.create[i].data};
      _$jscoverage['modules/sync-cli.js'][674]++;
      self.doNotify(dataset_id, i, self.notifications.RECORD_DELTA_RECEIVED, "create");
}
  }
  _$jscoverage['modules/sync-cli.js'][677]++;
  if (res.update) {
    _$jscoverage['modules/sync-cli.js'][678]++;
    for (i in res.update) {
      _$jscoverage['modules/sync-cli.js'][679]++;
      localDataSet[i].hash = res.update[i].hash;
      _$jscoverage['modules/sync-cli.js'][680]++;
      localDataSet[i].data = res.update[i].data;
      _$jscoverage['modules/sync-cli.js'][681]++;
      self.doNotify(dataset_id, i, self.notifications.RECORD_DELTA_RECEIVED, "update");
}
  }
  _$jscoverage['modules/sync-cli.js'][684]++;
  if (res["delete"]) {
    _$jscoverage['modules/sync-cli.js'][685]++;
    for (i in res["delete"]) {
      _$jscoverage['modules/sync-cli.js'][686]++;
      delete localDataSet[i];
      _$jscoverage['modules/sync-cli.js'][687]++;
      self.doNotify(dataset_id, i, self.notifications.RECORD_DELTA_RECEIVED, "delete");
}
  }
  _$jscoverage['modules/sync-cli.js'][691]++;
  self.doNotify(dataset_id, res.hash, self.notifications.DELTA_RECEIVED, "partial dataset");
  _$jscoverage['modules/sync-cli.js'][693]++;
  dataSet.data = localDataSet;
  _$jscoverage['modules/sync-cli.js'][694]++;
  if (res.hash) {
    _$jscoverage['modules/sync-cli.js'][695]++;
    dataSet.hash = res.hash;
  }
  _$jscoverage['modules/sync-cli.js'][697]++;
  self.syncComplete(dataset_id, "online", self.notifications.SYNC_COMPLETE);
}), (function (msg, err) {
  _$jscoverage['modules/sync-cli.js'][699]++;
  self.consoleLog("syncRecords failed : msg=" + msg + " :: err=" + err);
  _$jscoverage['modules/sync-cli.js'][700]++;
  self.syncComplete(dataset_id, msg, self.notifications.SYNC_FAILED);
}));
}));
}), syncComplete: (function (dataset_id, status, notification) {
  _$jscoverage['modules/sync-cli.js'][707]++;
  self.getDataSet(dataset_id, (function (dataset) {
  _$jscoverage['modules/sync-cli.js'][708]++;
  dataset.syncRunning = false;
  _$jscoverage['modules/sync-cli.js'][709]++;
  dataset.syncLoopEnd = new Date().getTime();
  _$jscoverage['modules/sync-cli.js'][710]++;
  self.saveDataSet(dataset_id);
  _$jscoverage['modules/sync-cli.js'][711]++;
  self.doNotify(dataset_id, dataset.hash, notification, status);
}));
}), checkDatasets: (function () {
  _$jscoverage['modules/sync-cli.js'][716]++;
  for (var dataset_id in self.datasets) {
    _$jscoverage['modules/sync-cli.js'][717]++;
    if (self.datasets.hasOwnProperty(dataset_id)) {
      _$jscoverage['modules/sync-cli.js'][718]++;
      var dataset = self.datasets[dataset_id];
      _$jscoverage['modules/sync-cli.js'][720]++;
      if (! dataset.syncRunning && (dataset.config.sync_active || dataset.syncForced)) {
        _$jscoverage['modules/sync-cli.js'][722]++;
        var lastSyncStart = dataset.syncLoopStart;
        _$jscoverage['modules/sync-cli.js'][723]++;
        var lastSyncCmp = dataset.syncLoopEnd;
        _$jscoverage['modules/sync-cli.js'][724]++;
        if (lastSyncStart == null) {
          _$jscoverage['modules/sync-cli.js'][725]++;
          self.consoleLog(dataset_id + " - Performing initial sync");
          _$jscoverage['modules/sync-cli.js'][727]++;
          dataset.syncPending = true;
        }
        else {
          _$jscoverage['modules/sync-cli.js'][728]++;
          if (lastSyncCmp != null) {
            _$jscoverage['modules/sync-cli.js'][729]++;
            var timeSinceLastSync = new Date().getTime() - lastSyncCmp;
            _$jscoverage['modules/sync-cli.js'][730]++;
            var syncFrequency = dataset.config.sync_frequency * 1000;
            _$jscoverage['modules/sync-cli.js'][731]++;
            if (timeSinceLastSync > syncFrequency) {
              _$jscoverage['modules/sync-cli.js'][733]++;
              dataset.syncPending = true;
            }
          }
        }
        _$jscoverage['modules/sync-cli.js'][737]++;
        if (dataset.syncForced) {
          _$jscoverage['modules/sync-cli.js'][738]++;
          dataset.syncPending = true;
        }
        _$jscoverage['modules/sync-cli.js'][741]++;
        if (dataset.syncPending) {
          _$jscoverage['modules/sync-cli.js'][743]++;
          dataset.syncForced = false;
          _$jscoverage['modules/sync-cli.js'][748]++;
          self.syncLoop(dataset_id);
        }
      }
    }
}
}), checkHasCustomSync: (function (dataset_id, cb) {
  _$jscoverage['modules/sync-cli.js'][756]++;
  if (self.hasCustomSync != null) {
    _$jscoverage['modules/sync-cli.js'][757]++;
    return cb();
  }
  _$jscoverage['modules/sync-cli.js'][759]++;
  self.consoleLog("starting check has custom sync");
  _$jscoverage['modules/sync-cli.js'][761]++;
  actAPI({"act": dataset_id, "req": {"fn": "sync"}}, (function (res) {
  _$jscoverage['modules/sync-cli.js'][769]++;
  self.consoleLog("checkHasCustomSync - success - ", res);
  _$jscoverage['modules/sync-cli.js'][770]++;
  self.hasCustomSync = true;
  _$jscoverage['modules/sync-cli.js'][771]++;
  return cb();
}), (function (msg, err) {
  _$jscoverage['modules/sync-cli.js'][773]++;
  self.consoleLog("checkHasCustomSync - failure - ", err);
  _$jscoverage['modules/sync-cli.js'][774]++;
  if (err.status && err.status === 500) {
    _$jscoverage['modules/sync-cli.js'][777]++;
    self.consoleLog("checkHasCustomSync - failed with 500, endpoint does exists");
    _$jscoverage['modules/sync-cli.js'][778]++;
    self.hasCustomSync = true;
  }
  else {
    _$jscoverage['modules/sync-cli.js'][780]++;
    self.hasCustomSync = false;
  }
  _$jscoverage['modules/sync-cli.js'][782]++;
  return cb();
}));
}), doCloudCall: (function (params, success, failure) {
  _$jscoverage['modules/sync-cli.js'][787]++;
  if (self.hasCustomSync) {
    _$jscoverage['modules/sync-cli.js'][788]++;
    actAPI({"act": params.dataset_id, "req": params.req}, (function (res) {
  _$jscoverage['modules/sync-cli.js'][792]++;
  success(res);
}), (function (msg, err) {
  _$jscoverage['modules/sync-cli.js'][794]++;
  failure(msg, err);
}));
  }
  else {
    _$jscoverage['modules/sync-cli.js'][797]++;
    cloudAPI({"path": "/mbaas/sync/" + params.dataset_id, "method": "post", "data": params.req}, (function (res) {
  _$jscoverage['modules/sync-cli.js'][802]++;
  success(res);
}), (function (msg, err) {
  _$jscoverage['modules/sync-cli.js'][804]++;
  failure(msg, err);
}));
  }
}), datasetMonitor: (function () {
  _$jscoverage['modules/sync-cli.js'][810]++;
  self.checkDatasets();
  _$jscoverage['modules/sync-cli.js'][813]++;
  setTimeout((function () {
  _$jscoverage['modules/sync-cli.js'][814]++;
  self.datasetMonitor();
}), 500);
}), saveDataSet: (function (dataset_id, cb) {
  _$jscoverage['modules/sync-cli.js'][819]++;
  var onFail = (function (msg, err) {
  _$jscoverage['modules/sync-cli.js'][821]++;
  var errMsg = "save to local storage failed  msg:" + msg + " err:" + err;
  _$jscoverage['modules/sync-cli.js'][822]++;
  self.doNotify(dataset_id, null, self.notifications.CLIENT_STORAGE_FAILED, errMsg);
  _$jscoverage['modules/sync-cli.js'][823]++;
  self.consoleLog(errMsg);
});
  _$jscoverage['modules/sync-cli.js'][825]++;
  self.getDataSet(dataset_id, (function (dataset) {
  _$jscoverage['modules/sync-cli.js'][827]++;
  Lawnchair({fail: onFail, adapter: self.config.storage_strategy, size: self.config.file_system_quota}, (function () {
  _$jscoverage['modules/sync-cli.js'][828]++;
  this.save({key: "dataset_" + dataset_id, val: dataset}, (function () {
  _$jscoverage['modules/sync-cli.js'][830]++;
  if (cb) {
    _$jscoverage['modules/sync-cli.js'][830]++;
    return cb();
  }
}));
}));
}));
}), loadDataSet: (function (dataset_id, success, failure) {
  _$jscoverage['modules/sync-cli.js'][838]++;
  var onFail = (function (msg, err) {
  _$jscoverage['modules/sync-cli.js'][840]++;
  var errMsg = "load from local storage failed  msg:" + msg;
  _$jscoverage['modules/sync-cli.js'][841]++;
  self.doNotify(dataset_id, null, self.notifications.CLIENT_STORAGE_FAILED, errMsg);
  _$jscoverage['modules/sync-cli.js'][842]++;
  self.consoleLog(errMsg);
});
  _$jscoverage['modules/sync-cli.js'][845]++;
  Lawnchair({fail: onFail, adapter: self.config.storage_strategy, size: self.config.file_system_quota}, (function () {
  _$jscoverage['modules/sync-cli.js'][845]++;
  this.get("dataset_" + dataset_id, (function (data) {
  _$jscoverage['modules/sync-cli.js'][846]++;
  if (data && data.val !== null) {
    _$jscoverage['modules/sync-cli.js'][847]++;
    var dataset = data.val;
    _$jscoverage['modules/sync-cli.js'][848]++;
    if (typeof dataset === "string") {
      _$jscoverage['modules/sync-cli.js'][849]++;
      dataset = JSON.parse(dataset);
    }
    _$jscoverage['modules/sync-cli.js'][853]++;
    dataset.initialised = false;
    _$jscoverage['modules/sync-cli.js'][854]++;
    self.datasets[dataset_id] = dataset;
    _$jscoverage['modules/sync-cli.js'][855]++;
    self.consoleLog("load from local storage success for dataset_id :" + dataset_id);
    _$jscoverage['modules/sync-cli.js'][856]++;
    if (success) {
      _$jscoverage['modules/sync-cli.js'][856]++;
      return success(dataset);
    }
  }
  else {
    _$jscoverage['modules/sync-cli.js'][859]++;
    if (failure) {
      _$jscoverage['modules/sync-cli.js'][859]++;
      return failure();
    }
  }
}));
}));
}), updateDatasetFromLocal: (function (dataset, pendingRec) {
  _$jscoverage['modules/sync-cli.js'][867]++;
  var pending = dataset.pending;
  _$jscoverage['modules/sync-cli.js'][868]++;
  var previousPendingUid;
  _$jscoverage['modules/sync-cli.js'][869]++;
  var previousPending;
  _$jscoverage['modules/sync-cli.js'][871]++;
  var uid = pendingRec.uid;
  _$jscoverage['modules/sync-cli.js'][872]++;
  self.consoleLog("updating local dataset for uid " + uid + " - action = " + pendingRec.action);
  _$jscoverage['modules/sync-cli.js'][874]++;
  dataset.meta[uid] = dataset.meta[uid] || {};
  _$jscoverage['modules/sync-cli.js'][877]++;
  if (pendingRec.action === "create") {
    _$jscoverage['modules/sync-cli.js'][878]++;
    if (dataset.data[uid]) {
      _$jscoverage['modules/sync-cli.js'][879]++;
      self.consoleLog("dataset already exists for uid in create :: " + JSON.stringify(dataset.data[uid]));
      _$jscoverage['modules/sync-cli.js'][882]++;
      if (dataset.meta[uid].fromPending) {
        _$jscoverage['modules/sync-cli.js'][885]++;
        previousPendingUid = dataset.meta[uid].pendingUid;
        _$jscoverage['modules/sync-cli.js'][886]++;
        delete pending[previousPendingUid];
      }
    }
    _$jscoverage['modules/sync-cli.js'][889]++;
    dataset.data[uid] = {};
  }
  _$jscoverage['modules/sync-cli.js'][892]++;
  if (pendingRec.action === "update") {
    _$jscoverage['modules/sync-cli.js'][893]++;
    if (dataset.data[uid]) {
      _$jscoverage['modules/sync-cli.js'][894]++;
      if (dataset.meta[uid].fromPending) {
        _$jscoverage['modules/sync-cli.js'][895]++;
        self.consoleLog("updating an existing pending record for dataset :: " + JSON.stringify(dataset.data[uid]));
        _$jscoverage['modules/sync-cli.js'][897]++;
        previousPendingUid = dataset.meta[uid].pendingUid;
        _$jscoverage['modules/sync-cli.js'][898]++;
        dataset.meta[uid].previousPendingUid = previousPendingUid;
        _$jscoverage['modules/sync-cli.js'][899]++;
        previousPending = pending[previousPendingUid];
        _$jscoverage['modules/sync-cli.js'][900]++;
        if (previousPending) {
          _$jscoverage['modules/sync-cli.js'][901]++;
          if (! previousPending.inFlight) {
            _$jscoverage['modules/sync-cli.js'][902]++;
            self.consoleLog("existing pre-flight pending record = " + JSON.stringify(previousPending));
            _$jscoverage['modules/sync-cli.js'][905]++;
            previousPending.post = pendingRec.post;
            _$jscoverage['modules/sync-cli.js'][906]++;
            previousPending.postHash = pendingRec.postHash;
            _$jscoverage['modules/sync-cli.js'][907]++;
            delete pending[pendingRec.hash];
            _$jscoverage['modules/sync-cli.js'][910]++;
            pendingRec.hash = previousPendingUid;
          }
          else {
            _$jscoverage['modules/sync-cli.js'][914]++;
            self.consoleLog("existing in-inflight pending record = " + JSON.stringify(previousPending));
            _$jscoverage['modules/sync-cli.js'][915]++;
            pendingRec.delayed = true;
            _$jscoverage['modules/sync-cli.js'][916]++;
            pendingRec.waiting = previousPending.hash;
          }
        }
      }
    }
  }
  _$jscoverage['modules/sync-cli.js'][923]++;
  if (pendingRec.action === "delete") {
    _$jscoverage['modules/sync-cli.js'][924]++;
    if (dataset.data[uid]) {
      _$jscoverage['modules/sync-cli.js'][925]++;
      if (dataset.meta[uid].fromPending) {
        _$jscoverage['modules/sync-cli.js'][926]++;
        self.consoleLog("Deleting an existing pending record for dataset :: " + JSON.stringify(dataset.data[uid]));
        _$jscoverage['modules/sync-cli.js'][928]++;
        previousPendingUid = dataset.meta[uid].pendingUid;
        _$jscoverage['modules/sync-cli.js'][929]++;
        dataset.meta[uid].previousPendingUid = previousPendingUid;
        _$jscoverage['modules/sync-cli.js'][930]++;
        previousPending = pending[previousPendingUid];
        _$jscoverage['modules/sync-cli.js'][931]++;
        if (previousPending) {
          _$jscoverage['modules/sync-cli.js'][932]++;
          if (! previousPending.inFlight) {
            _$jscoverage['modules/sync-cli.js'][933]++;
            self.consoleLog("existing pending record = " + JSON.stringify(previousPending));
            _$jscoverage['modules/sync-cli.js'][934]++;
            if (previousPending.action === "create") {
              _$jscoverage['modules/sync-cli.js'][937]++;
              delete pending[pendingRec.hash];
              _$jscoverage['modules/sync-cli.js'][938]++;
              delete pending[previousPendingUid];
            }
            _$jscoverage['modules/sync-cli.js'][940]++;
            if (previousPending.action === "update") {
              _$jscoverage['modules/sync-cli.js'][944]++;
              pendingRec.pre = previousPending.pre;
              _$jscoverage['modules/sync-cli.js'][945]++;
              pendingRec.preHash = previousPending.preHash;
              _$jscoverage['modules/sync-cli.js'][946]++;
              pendingRec.inFlight = false;
              _$jscoverage['modules/sync-cli.js'][947]++;
              delete pending[previousPendingUid];
            }
          }
          else {
            _$jscoverage['modules/sync-cli.js'][950]++;
            self.consoleLog("existing in-inflight pending record = " + JSON.stringify(previousPending));
            _$jscoverage['modules/sync-cli.js'][951]++;
            pendingRec.delayed = true;
            _$jscoverage['modules/sync-cli.js'][952]++;
            pendingRec.waiting = previousPending.hash;
          }
        }
      }
      _$jscoverage['modules/sync-cli.js'][956]++;
      delete dataset.data[uid];
    }
  }
  _$jscoverage['modules/sync-cli.js'][960]++;
  if (dataset.data[uid]) {
    _$jscoverage['modules/sync-cli.js'][961]++;
    dataset.data[uid].data = pendingRec.post;
    _$jscoverage['modules/sync-cli.js'][962]++;
    dataset.data[uid].hash = pendingRec.postHash;
    _$jscoverage['modules/sync-cli.js'][963]++;
    dataset.meta[uid].fromPending = true;
    _$jscoverage['modules/sync-cli.js'][964]++;
    dataset.meta[uid].pendingUid = pendingRec.hash;
  }
}), updatePendingFromNewData: (function (dataset_id, dataset, newData) {
  _$jscoverage['modules/sync-cli.js'][969]++;
  var pending = dataset.pending;
  _$jscoverage['modules/sync-cli.js'][970]++;
  var newRec;
  _$jscoverage['modules/sync-cli.js'][972]++;
  if (pending && newData.records) {
    _$jscoverage['modules/sync-cli.js'][973]++;
    for (var pendingHash in pending) {
      _$jscoverage['modules/sync-cli.js'][974]++;
      if (pending.hasOwnProperty(pendingHash)) {
        _$jscoverage['modules/sync-cli.js'][975]++;
        var pendingRec = pending[pendingHash];
        _$jscoverage['modules/sync-cli.js'][977]++;
        dataset.meta[pendingRec.uid] = dataset.meta[pendingRec.uid] || {};
        _$jscoverage['modules/sync-cli.js'][979]++;
        if (pendingRec.inFlight === false) {
          _$jscoverage['modules/sync-cli.js'][981]++;
          self.consoleLog("updatePendingFromNewData - Found Non inFlight record -> action=" + pendingRec.action + " :: uid=" + pendingRec.uid + " :: hash=" + pendingRec.hash);
          _$jscoverage['modules/sync-cli.js'][982]++;
          if (pendingRec.action === "update" || pendingRec.action === "delete") {
            _$jscoverage['modules/sync-cli.js'][985]++;
            newRec = newData.records[pendingRec.uid];
            _$jscoverage['modules/sync-cli.js'][986]++;
            if (newRec) {
              _$jscoverage['modules/sync-cli.js'][987]++;
              self.consoleLog("updatePendingFromNewData - Updating pre values for existing pending record " + pendingRec.uid);
              _$jscoverage['modules/sync-cli.js'][988]++;
              pendingRec.pre = newRec.data;
              _$jscoverage['modules/sync-cli.js'][989]++;
              pendingRec.preHash = newRec.hash;
            }
            else {
              _$jscoverage['modules/sync-cli.js'][993]++;
              var previousPendingUid = dataset.meta[pendingRec.uid].previousPendingUid;
              _$jscoverage['modules/sync-cli.js'][994]++;
              var previousPending = pending[previousPendingUid];
              _$jscoverage['modules/sync-cli.js'][995]++;
              if (previousPending) {
                _$jscoverage['modules/sync-cli.js'][996]++;
                if (newData && newData.updates && newData.updates.applied && newData.updates.applied[previousPending.hash]) {
                  _$jscoverage['modules/sync-cli.js'][998]++;
                  var newUid = newData.updates.applied[previousPending.hash].uid;
                  _$jscoverage['modules/sync-cli.js'][999]++;
                  newRec = newData.records[newUid];
                  _$jscoverage['modules/sync-cli.js'][1000]++;
                  if (newRec) {
                    _$jscoverage['modules/sync-cli.js'][1001]++;
                    self.consoleLog("updatePendingFromNewData - Updating pre values for existing pending record which was previously a create " + pendingRec.uid + " ==> " + newUid);
                    _$jscoverage['modules/sync-cli.js'][1002]++;
                    pendingRec.pre = newRec.data;
                    _$jscoverage['modules/sync-cli.js'][1003]++;
                    pendingRec.preHash = newRec.hash;
                    _$jscoverage['modules/sync-cli.js'][1004]++;
                    pendingRec.uid = newUid;
                  }
                }
              }
            }
          }
          _$jscoverage['modules/sync-cli.js'][1011]++;
          if (pendingRec.action === "create") {
            _$jscoverage['modules/sync-cli.js'][1012]++;
            if (newData && newData.updates && newData.updates.applied && newData.updates.applied[pendingHash]) {
              _$jscoverage['modules/sync-cli.js'][1013]++;
              self.consoleLog("updatePendingFromNewData - Found an update for a pending create " + JSON.stringify(newData.updates.applied[pendingHash]));
              _$jscoverage['modules/sync-cli.js'][1014]++;
              newRec = newData.records[newData.updates.applied[pendingHash].uid];
              _$jscoverage['modules/sync-cli.js'][1015]++;
              if (newRec) {
                _$jscoverage['modules/sync-cli.js'][1016]++;
                self.consoleLog("updatePendingFromNewData - Changing pending create to an update based on new record  " + JSON.stringify(newRec));
                _$jscoverage['modules/sync-cli.js'][1019]++;
                pendingRec.action = "update";
                _$jscoverage['modules/sync-cli.js'][1020]++;
                pendingRec.pre = newRec.data;
                _$jscoverage['modules/sync-cli.js'][1021]++;
                pendingRec.preHash = newRec.hash;
                _$jscoverage['modules/sync-cli.js'][1022]++;
                pendingRec.uid = newData.updates.applied[pendingHash].uid;
              }
            }
          }
        }
      }
}
  }
}), updateNewDataFromInFlight: (function (dataset_id, dataset, newData) {
  _$jscoverage['modules/sync-cli.js'][1033]++;
  var pending = dataset.pending;
  _$jscoverage['modules/sync-cli.js'][1035]++;
  if (pending && newData.records) {
    _$jscoverage['modules/sync-cli.js'][1036]++;
    for (var pendingHash in pending) {
      _$jscoverage['modules/sync-cli.js'][1037]++;
      if (pending.hasOwnProperty(pendingHash)) {
        _$jscoverage['modules/sync-cli.js'][1038]++;
        var pendingRec = pending[pendingHash];
        _$jscoverage['modules/sync-cli.js'][1040]++;
        if (pendingRec.inFlight) {
          _$jscoverage['modules/sync-cli.js'][1041]++;
          var updateReceivedForPending = (newData && newData.updates && newData.updates.hashes && newData.updates.hashes[pendingHash])? true: false;
          _$jscoverage['modules/sync-cli.js'][1043]++;
          self.consoleLog("updateNewDataFromInFlight - Found inflight pending Record - action = " + pendingRec.action + " :: hash = " + pendingHash + " :: updateReceivedForPending=" + updateReceivedForPending);
          _$jscoverage['modules/sync-cli.js'][1045]++;
          if (! updateReceivedForPending) {
            _$jscoverage['modules/sync-cli.js'][1046]++;
            var newRec = newData.records[pendingRec.uid];
            _$jscoverage['modules/sync-cli.js'][1048]++;
            if (pendingRec.action === "update" && newRec) {
              _$jscoverage['modules/sync-cli.js'][1050]++;
              newRec.data = pendingRec.post;
              _$jscoverage['modules/sync-cli.js'][1051]++;
              newRec.hash = pendingRec.postHash;
            }
            else {
              _$jscoverage['modules/sync-cli.js'][1053]++;
              if (pendingRec.action === "delete" && newRec) {
                _$jscoverage['modules/sync-cli.js'][1055]++;
                delete newData.records[pendingRec.uid];
              }
              else {
                _$jscoverage['modules/sync-cli.js'][1057]++;
                if (pendingRec.action === "create") {
                  _$jscoverage['modules/sync-cli.js'][1059]++;
                  self.consoleLog("updateNewDataFromInFlight - re adding pending create to incomming dataset");
                  _$jscoverage['modules/sync-cli.js'][1060]++;
                  var newPendingCreate = {data: pendingRec.post, hash: pendingRec.postHash};
                  _$jscoverage['modules/sync-cli.js'][1064]++;
                  newData.records[pendingRec.uid] = newPendingCreate;
                }
              }
            }
          }
        }
      }
}
  }
}), updateNewDataFromPending: (function (dataset_id, dataset, newData) {
  _$jscoverage['modules/sync-cli.js'][1074]++;
  var pending = dataset.pending;
  _$jscoverage['modules/sync-cli.js'][1076]++;
  if (pending && newData.records) {
    _$jscoverage['modules/sync-cli.js'][1077]++;
    for (var pendingHash in pending) {
      _$jscoverage['modules/sync-cli.js'][1078]++;
      if (pending.hasOwnProperty(pendingHash)) {
        _$jscoverage['modules/sync-cli.js'][1079]++;
        var pendingRec = pending[pendingHash];
        _$jscoverage['modules/sync-cli.js'][1081]++;
        if (pendingRec.inFlight === false) {
          _$jscoverage['modules/sync-cli.js'][1082]++;
          self.consoleLog("updateNewDataFromPending - Found Non inFlight record -> action=" + pendingRec.action + " :: uid=" + pendingRec.uid + " :: hash=" + pendingRec.hash);
          _$jscoverage['modules/sync-cli.js'][1083]++;
          var newRec = newData.records[pendingRec.uid];
          _$jscoverage['modules/sync-cli.js'][1084]++;
          if (pendingRec.action === "update" && newRec) {
            _$jscoverage['modules/sync-cli.js'][1086]++;
            newRec.data = pendingRec.post;
            _$jscoverage['modules/sync-cli.js'][1087]++;
            newRec.hash = pendingRec.postHash;
          }
          else {
            _$jscoverage['modules/sync-cli.js'][1089]++;
            if (pendingRec.action === "delete" && newRec) {
              _$jscoverage['modules/sync-cli.js'][1091]++;
              delete newData.records[pendingRec.uid];
            }
            else {
              _$jscoverage['modules/sync-cli.js'][1093]++;
              if (pendingRec.action === "create") {
                _$jscoverage['modules/sync-cli.js'][1095]++;
                self.consoleLog("updateNewDataFromPending - re adding pending create to incomming dataset");
                _$jscoverage['modules/sync-cli.js'][1096]++;
                var newPendingCreate = {data: pendingRec.post, hash: pendingRec.postHash};
                _$jscoverage['modules/sync-cli.js'][1100]++;
                newData.records[pendingRec.uid] = newPendingCreate;
              }
            }
          }
        }
      }
}
  }
}), updateCrashedInFlightFromNewData: (function (dataset_id, dataset, newData) {
  _$jscoverage['modules/sync-cli.js'][1109]++;
  var updateNotifications = {applied: self.notifications.REMOTE_UPDATE_APPLIED, failed: self.notifications.REMOTE_UPDATE_FAILED, collisions: self.notifications.COLLISION_DETECTED};
  _$jscoverage['modules/sync-cli.js'][1115]++;
  var pending = dataset.pending;
  _$jscoverage['modules/sync-cli.js'][1116]++;
  var resolvedCrashes = {};
  _$jscoverage['modules/sync-cli.js'][1117]++;
  var pendingHash;
  _$jscoverage['modules/sync-cli.js'][1118]++;
  var pendingRec;
  _$jscoverage['modules/sync-cli.js'][1121]++;
  if (pending) {
    _$jscoverage['modules/sync-cli.js'][1122]++;
    for (pendingHash in pending) {
      _$jscoverage['modules/sync-cli.js'][1123]++;
      if (pending.hasOwnProperty(pendingHash)) {
        _$jscoverage['modules/sync-cli.js'][1124]++;
        pendingRec = pending[pendingHash];
        _$jscoverage['modules/sync-cli.js'][1126]++;
        if (pendingRec.inFlight && pendingRec.crashed) {
          _$jscoverage['modules/sync-cli.js'][1127]++;
          self.consoleLog("updateCrashedInFlightFromNewData - Found crashed inFlight pending record uid=" + pendingRec.uid + " :: hash=" + pendingRec.hash);
          _$jscoverage['modules/sync-cli.js'][1128]++;
          if (newData && newData.updates && newData.updates.hashes) {
            _$jscoverage['modules/sync-cli.js'][1131]++;
            var crashedUpdate = newData.updates.hashes[pendingHash];
            _$jscoverage['modules/sync-cli.js'][1132]++;
            if (crashedUpdate) {
              _$jscoverage['modules/sync-cli.js'][1135]++;
              resolvedCrashes[crashedUpdate.uid] = crashedUpdate;
              _$jscoverage['modules/sync-cli.js'][1137]++;
              self.consoleLog("updateCrashedInFlightFromNewData - Resolving status for crashed inflight pending record " + JSON.stringify(crashedUpdate));
              _$jscoverage['modules/sync-cli.js'][1139]++;
              if (crashedUpdate.type === "failed") {
                _$jscoverage['modules/sync-cli.js'][1141]++;
                if (crashedUpdate.action === "create") {
                  _$jscoverage['modules/sync-cli.js'][1142]++;
                  self.consoleLog("updateCrashedInFlightFromNewData - Deleting failed create from dataset");
                  _$jscoverage['modules/sync-cli.js'][1143]++;
                  delete dataset.data[crashedUpdate.uid];
                }
                else {
                  _$jscoverage['modules/sync-cli.js'][1145]++;
                  if (crashedUpdate.action === "update" || crashedUpdate.action === "delete") {
                    _$jscoverage['modules/sync-cli.js'][1146]++;
                    self.consoleLog("updateCrashedInFlightFromNewData - Reverting failed " + crashedUpdate.action + " in dataset");
                    _$jscoverage['modules/sync-cli.js'][1147]++;
                    dataset.data[crashedUpdate.uid] = {data: pendingRec.pre, hash: pendingRec.preHash};
                  }
                }
              }
              _$jscoverage['modules/sync-cli.js'][1154]++;
              delete pending[pendingHash];
              _$jscoverage['modules/sync-cli.js'][1155]++;
              self.doNotify(dataset_id, crashedUpdate.uid, updateNotifications[crashedUpdate.type], crashedUpdate);
            }
            else {
              _$jscoverage['modules/sync-cli.js'][1160]++;
              if (pendingRec.crashedCount) {
                _$jscoverage['modules/sync-cli.js'][1161]++;
                pendingRec.crashedCount++;
              }
              else {
                _$jscoverage['modules/sync-cli.js'][1164]++;
                pendingRec.crashedCount = 1;
              }
            }
          }
          else {
            _$jscoverage['modules/sync-cli.js'][1171]++;
            if (pendingRec.crashedCount) {
              _$jscoverage['modules/sync-cli.js'][1172]++;
              pendingRec.crashedCount++;
            }
            else {
              _$jscoverage['modules/sync-cli.js'][1175]++;
              pendingRec.crashedCount = 1;
            }
          }
        }
      }
}
    _$jscoverage['modules/sync-cli.js'][1182]++;
    for (pendingHash in pending) {
      _$jscoverage['modules/sync-cli.js'][1183]++;
      if (pending.hasOwnProperty(pendingHash)) {
        _$jscoverage['modules/sync-cli.js'][1184]++;
        pendingRec = pending[pendingHash];
        _$jscoverage['modules/sync-cli.js'][1186]++;
        if (pendingRec.inFlight && pendingRec.crashed) {
          _$jscoverage['modules/sync-cli.js'][1187]++;
          if (pendingRec.crashedCount > dataset.config.crashed_count_wait) {
            _$jscoverage['modules/sync-cli.js'][1188]++;
            self.consoleLog("updateCrashedInFlightFromNewData - Crashed inflight pending record has reached crashed_count_wait limit : " + JSON.stringify(pendingRec));
            _$jscoverage['modules/sync-cli.js'][1189]++;
            if (dataset.config.resend_crashed_updates) {
              _$jscoverage['modules/sync-cli.js'][1190]++;
              self.consoleLog("updateCrashedInFlightFromNewData - Retryig crashed inflight pending record");
              _$jscoverage['modules/sync-cli.js'][1191]++;
              pendingRec.crashed = false;
              _$jscoverage['modules/sync-cli.js'][1192]++;
              pendingRec.inFlight = false;
            }
            else {
              _$jscoverage['modules/sync-cli.js'][1195]++;
              self.consoleLog("updateCrashedInFlightFromNewData - Deleting crashed inflight pending record");
              _$jscoverage['modules/sync-cli.js'][1196]++;
              delete pending[pendingHash];
            }
          }
        }
        else {
          _$jscoverage['modules/sync-cli.js'][1200]++;
          if (! pendingRec.inFlight && pendingRec.crashed) {
            _$jscoverage['modules/sync-cli.js'][1201]++;
            self.consoleLog("updateCrashedInFlightFromNewData - Trying to resolve issues with crashed non in flight record - uid = " + pendingRec.uid);
            _$jscoverage['modules/sync-cli.js'][1203]++;
            var crashedRef = resolvedCrashes[pendingRec.uid];
            _$jscoverage['modules/sync-cli.js'][1204]++;
            if (crashedRef) {
              _$jscoverage['modules/sync-cli.js'][1205]++;
              self.consoleLog("updateCrashedInFlightFromNewData - Found a stalled pending record backed up behind a resolved crash uid=" + pendingRec.uid + " :: hash=" + pendingRec.hash);
              _$jscoverage['modules/sync-cli.js'][1206]++;
              pendingRec.crashed = false;
            }
          }
        }
      }
}
  }
}), updateDelayedFromNewData: (function (dataset_id, dataset, newData) {
  _$jscoverage['modules/sync-cli.js'][1215]++;
  var pending = dataset.pending;
  _$jscoverage['modules/sync-cli.js'][1216]++;
  var pendingHash;
  _$jscoverage['modules/sync-cli.js'][1217]++;
  var pendingRec;
  _$jscoverage['modules/sync-cli.js'][1218]++;
  if (pending) {
    _$jscoverage['modules/sync-cli.js'][1219]++;
    for (pendingHash in pending) {
      _$jscoverage['modules/sync-cli.js'][1220]++;
      if (pending.hasOwnProperty(pendingHash)) {
        _$jscoverage['modules/sync-cli.js'][1221]++;
        pendingRec = pending[pendingHash];
        _$jscoverage['modules/sync-cli.js'][1222]++;
        if (pendingRec.delayed && pendingRec.waiting) {
          _$jscoverage['modules/sync-cli.js'][1223]++;
          self.consoleLog("updateDelayedFromNewData - Found delayed pending record uid=" + pendingRec.uid + " :: hash=" + pendingRec.hash + " :: waiting=" + pendingRec.waiting);
          _$jscoverage['modules/sync-cli.js'][1224]++;
          if (newData && newData.updates && newData.updates.hashes) {
            _$jscoverage['modules/sync-cli.js'][1225]++;
            var waitingRec = newData.updates.hashes[pendingRec.waiting];
            _$jscoverage['modules/sync-cli.js'][1226]++;
            if (waitingRec) {
              _$jscoverage['modules/sync-cli.js'][1227]++;
              self.consoleLog("updateDelayedFromNewData - Waiting pending record is resolved rec=" + JSON.stringify(waitingRec));
              _$jscoverage['modules/sync-cli.js'][1228]++;
              pendingRec.delayed = false;
              _$jscoverage['modules/sync-cli.js'][1229]++;
              pendingRec.waiting = undefined;
            }
          }
        }
      }
}
  }
}), markInFlightAsCrashed: (function (dataset) {
  _$jscoverage['modules/sync-cli.js'][1240]++;
  var pending = dataset.pending;
  _$jscoverage['modules/sync-cli.js'][1241]++;
  var pendingHash;
  _$jscoverage['modules/sync-cli.js'][1242]++;
  var pendingRec;
  _$jscoverage['modules/sync-cli.js'][1244]++;
  if (pending) {
    _$jscoverage['modules/sync-cli.js'][1245]++;
    var crashedRecords = {};
    _$jscoverage['modules/sync-cli.js'][1246]++;
    for (pendingHash in pending) {
      _$jscoverage['modules/sync-cli.js'][1247]++;
      if (pending.hasOwnProperty(pendingHash)) {
        _$jscoverage['modules/sync-cli.js'][1248]++;
        pendingRec = pending[pendingHash];
        _$jscoverage['modules/sync-cli.js'][1250]++;
        if (pendingRec.inFlight) {
          _$jscoverage['modules/sync-cli.js'][1251]++;
          self.consoleLog("Marking in flight pending record as crashed : " + pendingHash);
          _$jscoverage['modules/sync-cli.js'][1252]++;
          pendingRec.crashed = true;
          _$jscoverage['modules/sync-cli.js'][1253]++;
          crashedRecords[pendingRec.uid] = pendingRec;
        }
      }
}
    _$jscoverage['modules/sync-cli.js'][1260]++;
    for (pendingHash in pending) {
      _$jscoverage['modules/sync-cli.js'][1261]++;
      if (pending.hasOwnProperty(pendingHash)) {
        _$jscoverage['modules/sync-cli.js'][1262]++;
        pendingRec = pending[pendingHash];
        _$jscoverage['modules/sync-cli.js'][1264]++;
        if (! pendingRec.inFlight && ! pendingRec.delayed) {
          _$jscoverage['modules/sync-cli.js'][1265]++;
          var crashedRef = crashedRecords[pendingRec.uid];
          _$jscoverage['modules/sync-cli.js'][1266]++;
          if (crashedRef) {
            _$jscoverage['modules/sync-cli.js'][1267]++;
            pendingRec.crashed = true;
          }
        }
      }
}
  }
}), consoleLog: (function (msg) {
  _$jscoverage['modules/sync-cli.js'][1276]++;
  if (self.config.do_console_log) {
    _$jscoverage['modules/sync-cli.js'][1277]++;
    console.log(msg);
  }
})};
_$jscoverage['modules/sync-cli.js'][1282]++;
(function () {
  _$jscoverage['modules/sync-cli.js'][1283]++;
  self.config = self.defaults;
})();
_$jscoverage['modules/sync-cli.js'][1288]++;
module.exports = {init: self.init, manage: self.manage, notify: self.notify, doList: self.list, doCreate: self.create, doRead: self.read, doUpdate: self.update, doDelete: self["delete"], listCollisions: self.listCollisions, removeCollision: self.removeCollision, getPending: self.getPending, clearPending: self.clearPending, getDataset: self.getDataSet, getQueryParams: self.getQueryParams, setQueryParams: self.setQueryParams, getMetaData: self.getMetaData, setMetaData: self.setMetaData, getConfig: self.getConfig, setConfig: self.setConfig, startSync: self.startSync, stopSync: self.stopSync, doSync: self.doSync, forceSync: self.forceSync, generateHash: self.generateHash};
_$jscoverage['modules/sync-cli.js'].source = ["var JSON = require(\"JSON\");","var actAPI = require(\"./api_act\");","var cloudAPI = require(\"./api_cloud\");","var CryptoJS = require(\"../../libs/generated/crypto\");","var Lawnchair = require('../../libs/generated/lawnchair');","","var self = {","","  // CONFIG","  defaults: {","    \"sync_frequency\": 10,","    // How often to synchronise data with the cloud in seconds.","    \"auto_sync_local_updates\": true,","    // Should local chages be syned to the cloud immediately, or should they wait for the next sync interval","    \"notify_client_storage_failed\": true,","    // Should a notification event be triggered when loading/saving to client storage fails","    \"notify_sync_started\": true,","    // Should a notification event be triggered when a sync cycle with the server has been started","    \"notify_sync_complete\": true,","    // Should a notification event be triggered when a sync cycle with the server has been completed","    \"notify_offline_update\": true,","    // Should a notification event be triggered when an attempt was made to update a record while offline","    \"notify_collision_detected\": true,","    // Should a notification event be triggered when an update failed due to data collision","    \"notify_remote_update_failed\": true,","    // Should a notification event be triggered when an update failed for a reason other than data collision","    \"notify_local_update_applied\": true,","    // Should a notification event be triggered when an update was applied to the local data store","    \"notify_remote_update_applied\": true,","    // Should a notification event be triggered when an update was applied to the remote data store","    \"notify_delta_received\": true,","    // Should a notification event be triggered when a delta was received from the remote data store for the dataset ","    \"notify_record_delta_received\": true,","    // Should a notification event be triggered when a delta was received from the remote data store for a record","    \"notify_sync_failed\": true,","    // Should a notification event be triggered when the sync loop failed to complete","    \"do_console_log\": false,","    // Should log statements be written to console.log","    \"crashed_count_wait\" : 10,","    // How many syncs should we check for updates on crashed in flight updates before we give up searching","    \"resend_crashed_updates\" : true,","    // If we have reached the crashed_count_wait limit, should we re-try sending the crashed in flight pending record","    \"sync_active\" : true,","    // Is the background sync with the cloud currently active","    \"storage_strategy\" : \"html5-filesystem\",","    // Storage strategy to use for Lawnchair - supported strategies are 'html5-filesystem' and 'dom'","    \"file_system_quota\" : 50 * 1024 * 1204","    // Amount of space to request from the HTML5 filesystem API when running in browser","  },","","  notifications: {","    \"CLIENT_STORAGE_FAILED\": \"client_storage_failed\",","    // loading/saving to client storage failed","    \"SYNC_STARTED\": \"sync_started\",","    // A sync cycle with the server has been started","    \"SYNC_COMPLETE\": \"sync_complete\",","    // A sync cycle with the server has been completed","    \"OFFLINE_UPDATE\": \"offline_update\",","    // An attempt was made to update a record while offline","    \"COLLISION_DETECTED\": \"collision_detected\",","    //Update Failed due to data collision","    \"REMOTE_UPDATE_FAILED\": \"remote_update_failed\",","    // Update Failed for a reason other than data collision","    \"REMOTE_UPDATE_APPLIED\": \"remote_update_applied\",","    // An update was applied to the remote data store","    \"LOCAL_UPDATE_APPLIED\": \"local_update_applied\",","    // An update was applied to the local data store","    \"DELTA_RECEIVED\": \"delta_received\",","    // A delta was received from the remote data store for the dataset ","    \"RECORD_DELTA_RECEIVED\": \"record_delta_received\",","    // A delta was received from the remote data store for the record ","    \"SYNC_FAILED\": \"sync_failed\"","    // Sync loop failed to complete","  },","","  datasets: {},","","  // Initialise config to default values;","  config: undefined,","","  notify_callback: undefined,","","  hasCustomSync : undefined,","","  // PUBLIC FUNCTION IMPLEMENTATIONS","  init: function(options) {","    self.consoleLog('sync - init called');","","    self.config = JSON.parse(JSON.stringify(self.defaults));","    for (var i in options) {","      self.config[i] = options[i];","    }","","    self.datasetMonitor();","  },","","  notify: function(callback) {","    self.notify_callback = callback;","  },","","  manage: function(dataset_id, options, query_params, meta_data, cb) {","    self.consoleLog('manage - START');","","    var options = options || {};","","    var doManage = function(dataset) {","      self.consoleLog('doManage dataset :: initialised = ' + dataset.initialised + \" :: \" + dataset_id + ' :: ' + JSON.stringify(options));","","      var datasetConfig = self.setOptions(options);","","      dataset.query_params = query_params || dataset.query_params || {};","      dataset.meta_data = meta_data || dataset.meta_data || {};","      dataset.config = datasetConfig;","      dataset.syncRunning = false;","      dataset.syncPending = true;","      dataset.initialised = true;","      dataset.meta = {};","","      self.saveDataSet(dataset_id, function() {","","        if( cb ) {","          cb();","        }","      });","    };","","    // Check if the dataset is already loaded","    self.getDataSet(dataset_id, function(dataset) {","      self.consoleLog('manage - dataset already loaded');","      doManage(dataset);","    }, function(err) {","      self.consoleLog('manage - dataset not loaded... trying to load');","","      // Not already loaded, try to load from local storage","      self.loadDataSet(dataset_id, function(dataset) {","          self.consoleLog('manage - dataset loaded from local storage');","","          // Loading from local storage worked","","          // Fire the local update event to indicate that dataset was loaded from local storage","          self.doNotify(dataset_id, null, self.notifications.LOCAL_UPDATE_APPLIED, \"load\");","","          // Put the dataet under the management of the sync service","          doManage(dataset);","        },","        function(err) {","          // No dataset in memory or local storage - create a new one and put it in memory","          self.consoleLog('manage - Creating new dataset for id ' + dataset_id);","          var dataset = {};","          dataset.data = {};","          dataset.pending = {};","          self.datasets[dataset_id] = dataset;","          doManage(dataset);","        });","    });","  },","","  setOptions: function(options) {","    // Make sure config is initialised","    if( ! self.config ) {","      self.config = JSON.parse(JSON.stringify(self.defaults));","    }","","    var datasetConfig = JSON.parse(JSON.stringify(self.config));","    var optionsIn = JSON.parse(JSON.stringify(options));","    for (var k in optionsIn) {","      datasetConfig[k] = optionsIn[k];","    }","","    return datasetConfig;","  },","","  list: function(dataset_id, success, failure) {","    self.getDataSet(dataset_id, function(dataset) {","      if (dataset &amp;&amp; dataset.data) {","        // Return a copy of the dataset so updates will not automatically make it back into the dataset","        var res = JSON.parse(JSON.stringify(dataset.data));","        success(res);","      } else {","        if(failure) failure('no_data');","      }","    }, function(code, msg) {","      if(failure) failure(code, msg);","    });","  },","","  create: function(dataset_id, data, success, failure) {","    self.addPendingObj(dataset_id, null, data, \"create\", success, failure);","  },","","  read: function(dataset_id, uid, success, failure) {","      self.getDataSet(dataset_id, function(dataset) {","      var rec = dataset.data[uid];","      if (!rec) {","        failure(\"unknown_uid\");","      } else {","        // Return a copy of the record so updates will not automatically make it back into the dataset","        var res = JSON.parse(JSON.stringify(rec));","        success(res);","      }","    }, function(code, msg) {","      if(failure) failure(code, msg);","    });","  },","","  update: function(dataset_id, uid, data, success, failure) {","    self.addPendingObj(dataset_id, uid, data, \"update\", success, failure);","  },","","  'delete': function(dataset_id, uid, success, failure) {","    self.addPendingObj(dataset_id, uid, null, \"delete\", success, failure);","  },","","  getPending: function(dataset_id, cb) {","    self.getDataSet(dataset_id, function(dataset) {","      var res;","      if( dataset ) {","        res = dataset.pending;","      }","      cb(res);","    }, function(err, datatset_id) {","        self.consoleLog(err);","    });","  },","","  clearPending: function(dataset_id, cb) {","    self.getDataSet(dataset_id, function(dataset) {","      dataset.pending = {};","      self.saveDataSet(dataset_id, cb);","    });","  },","","  listCollisions : function(dataset_id, success, failure){","    self.getDataSet(dataset_id, function(dataset) {","      self.doCloudCall({","        \"dataset_id\": dataset_id,","        \"req\": {","          \"fn\": \"listCollisions\",","          \"meta_data\" : dataset.meta_data","        }","      }, success, failure);","    }, failure);","  },","","  removeCollision: function(dataset_id, colissionHash, success, failure) {","    self.getDataSet(dataset_id, function(dataset) {","      self.doCloudCall({","        \"dataset_id\" : dataset_id,","        \"req\": {","          \"fn\": \"removeCollision\",","          \"hash\": colissionHash,","          meta_data: dataset.meta_data","        }","      }, success, failure);","    });","  },","","","  // PRIVATE FUNCTIONS","  isOnline: function(callback) {","    var online = true;","","    // first, check if navigator.online is available","    if(typeof navigator.onLine !== \"undefined\"){","      online = navigator.onLine;","    }","","    // second, check if Phonegap is available and has online info","    if(online){","      //use phonegap to determin if the network is available","      if(typeof navigator.network !== \"undefined\" &amp;&amp; typeof navigator.network.connection !== \"undefined\"){","        var networkType = navigator.network.connection.type;","        if(networkType === \"none\" || networkType === null) {","          online = false;","        }","      }","    }","","    return callback(online);","  },","","  doNotify: function(dataset_id, uid, code, message) {","","    if( self.notify_callback ) {","      if ( self.config['notify_' + code] ) {","        var notification = {","          \"dataset_id\" : dataset_id,","          \"uid\" : uid,","          \"code\" : code,","          \"message\" : message","        };","        // make sure user doesn't block","        setTimeout(function () {","          self.notify_callback(notification);","        }, 0);","      }","    }","  },","","  getDataSet: function(dataset_id, success, failure) {","    var dataset = self.datasets[dataset_id];","","    if (dataset) {","      success(dataset);","    } else {","      failure('unknown_dataset ' + dataset_id, dataset_id);","    }","  },","","  getQueryParams: function(dataset_id, success, failure) {","    var dataset = self.datasets[dataset_id];","","    if (dataset) {","      success(dataset.query_params);","    } else {","      failure('unknown_dataset ' + dataset_id, dataset_id);","    }","  },","","  setQueryParams: function(dataset_id, queryParams, success, failure) {","    var dataset = self.datasets[dataset_id];","","    if (dataset) {","      dataset.query_params = queryParams;","      self.saveDataSet(dataset_id);","      if( success ) {","        success(dataset.query_params);","      }","    } else {","      if ( failure ) {","        failure('unknown_dataset ' + dataset_id, dataset_id);","      }","    }","  },","","  getMetaData: function(dataset_id, success, failure) {","    var dataset = self.datasets[dataset_id];","","    if (dataset) {","      success(dataset.meta_data);","    } else {","      failure('unknown_dataset ' + dataset_id, dataset_id);","    }","  },","","  setMetaData: function(dataset_id, metaData, success, failure) {","    var dataset = self.datasets[dataset_id];","","    if (dataset) {","      dataset.meta_data = metaData;","      self.saveDataSet(dataset_id);","      if( success ) {","        success(dataset.meta_data);","      }","    } else {","      if( failure ) {","        failure('unknown_dataset ' + dataset_id, dataset_id);","      }","    }","  },","","  getConfig: function(dataset_id, success, failure) {","    var dataset = self.datasets[dataset_id];","","    if (dataset) {","      success(dataset.config);","    } else {","      failure('unknown_dataset ' + dataset_id, dataset_id);","    }","  },","","  setConfig: function(dataset_id, config, success, failure) {","    var dataset = self.datasets[dataset_id];","","    if (dataset) {","      var fullConfig = self.setOptions(config);","      dataset.config = fullConfig;","      self.saveDataSet(dataset_id);","      if( success ) {","        success(dataset.config);","      }","    } else {","      if( failure ) {","        failure('unknown_dataset ' + dataset_id, dataset_id);","      }","    }","  },","","  stopSync: function(dataset_id, success, failure) {","    self.setConfig(dataset_id, {\"sync_active\" : false}, function() {","      if( success ) {","        success();","      }","    }, failure);","  },","","  startSync: function(dataset_id, success, failure) {","    self.setConfig(dataset_id, {\"sync_active\" : true}, function() {","      if( success ) {","        success();","      }","    }, failure);","  },","","  doSync: function(dataset_id, success, failure) {","    var dataset = self.datasets[dataset_id];","","    if (dataset) {","      dataset.syncPending = true;","      self.saveDataSet(dataset_id);","      if( success ) {","        success();","      }","    } else {","      if( failure ) {","        failure('unknown_dataset ' + dataset_id, dataset_id);","      }","    }","  },","","  forceSync: function(dataset_id, success, failure) {","    var dataset = self.datasets[dataset_id];","","    if (dataset) {","      dataset.syncForced = true;","      self.saveDataSet(dataset_id);","      if( success ) {","        success();","      }","    } else {","      if( failure ) {","        failure('unknown_dataset ' + dataset_id, dataset_id);","      }","    }","  },","","  sortObject : function(object) {","    if (typeof object !== \"object\" || object === null) {","      return object;","    }","","    var result = [];","","    Object.keys(object).sort().forEach(function(key) {","      result.push({","        key: key,","        value: self.sortObject(object[key])","      });","    });","","    return result;","  },","","  sortedStringify : function(obj) {","","    var str = '';","","    try {","      str = JSON.stringify(self.sortObject(obj));","    } catch (e) {","      console.error('Error stringifying sorted object:' + e);","    }","","    return str;","  },","","  generateHash: function(object) {","    var hash = CryptoJS.SHA1(self.sortedStringify(object));","    return hash.toString();","  },","","  addPendingObj: function(dataset_id, uid, data, action, success, failure) {","    self.isOnline(function (online) {","      if (!online) {","        self.doNotify(dataset_id, uid, self.notifications.OFFLINE_UPDATE, action);","      }","    });","","    function storePendingObject(obj) {","      obj.hash = self.generateHash(obj);","","      self.getDataSet(dataset_id, function(dataset) {","","        dataset.pending[obj.hash] = obj;","","        self.updateDatasetFromLocal(dataset, obj);","","        if(self.config.auto_sync_local_updates) {","          dataset.syncPending = true;","        }","        self.saveDataSet(dataset_id);","        self.doNotify(dataset_id, uid, self.notifications.LOCAL_UPDATE_APPLIED, action);","","        success(obj);","      }, function(code, msg) {","        if(failure) failure(code, msg);","      });","    }","","    var pendingObj = {};","    pendingObj.inFlight = false;","    pendingObj.action = action;","    pendingObj.post = JSON.parse(JSON.stringify(data));","    pendingObj.postHash = self.generateHash(pendingObj.post);","    pendingObj.timestamp = new Date().getTime();","    if( \"create\" === action ) {","      pendingObj.uid = pendingObj.postHash;","      storePendingObject(pendingObj);","    } else {","      self.read(dataset_id, uid, function(rec) {","        pendingObj.uid = uid;","        pendingObj.pre = rec.data;","        pendingObj.preHash = self.generateHash(rec.data);","        storePendingObject(pendingObj);","      }, function(code, msg) {","        failure(code, msg);","      });","    }","  },","","  syncLoop: function(dataset_id) {","    self.getDataSet(dataset_id, function(dataSet) {","    ","      // The sync loop is currently active","      dataSet.syncPending = false;","      dataSet.syncRunning = true;","      dataSet.syncLoopStart = new Date().getTime();","      self.doNotify(dataset_id, null, self.notifications.SYNC_STARTED, null);","","      self.isOnline(function(online) {","        if (!online) {","          self.syncComplete(dataset_id, \"offline\", self.notifications.SYNC_FAILED);","        } else {","          self.checkHasCustomSync(dataset_id, function() {","","            var syncLoopParams = {};","            syncLoopParams.fn = 'sync';","            syncLoopParams.dataset_id = dataset_id;","            syncLoopParams.query_params = dataSet.query_params;","            syncLoopParams.config = dataSet.config;","            syncLoopParams.meta_data = dataSet.meta_data;","            //var datasetHash = self.generateLocalDatasetHash(dataSet);","            syncLoopParams.dataset_hash = dataSet.hash;","            syncLoopParams.acknowledgements = dataSet.acknowledgements || [];","","            var pending = dataSet.pending;","            var pendingArray = [];","            for(var i in pending ) {","              // Mark the pending records we are about to submit as inflight and add them to the array for submission","              // Don't re-add previous inFlight pending records who whave crashed - i.e. who's current state is unknown","              // Don't add delayed records","              if( !pending[i].inFlight &amp;&amp; !pending[i].crashed &amp;&amp; !pending[i].delayed) {","                pending[i].inFlight = true;","                pending[i].inFlightDate = new Date().getTime();","                pendingArray.push(pending[i]);","              }","            }","            syncLoopParams.pending = pendingArray;","","            if( pendingArray.length &gt; 0 ) {","              self.consoleLog('Starting sync loop - global hash = ' + dataSet.hash + ' :: params = ' + JSON.stringify(syncLoopParams, null, 2));","            }","            try {","              self.doCloudCall({","                'dataset_id': dataset_id,","                'req': syncLoopParams","              }, function(res) {","                var rec;","","                function processUpdates(updates, notification, acknowledgements) {","                  if( updates ) {","                    for (var up in updates) {","                      rec = updates[up];","                      acknowledgements.push(rec);","                      if( dataSet.pending[up] &amp;&amp; dataSet.pending[up].inFlight &amp;&amp; !dataSet.pending[up].crashed ) {","                        delete dataSet.pending[up];","                        self.doNotify(dataset_id, rec.uid, notification, rec);","                      }","                    }","                  }","                }","","                // Check to see if any new pending records need to be updated to reflect the current state of play.","                self.updatePendingFromNewData(dataset_id, dataSet, res);","","                // Check to see if any previously crashed inflight records can now be resolved","                self.updateCrashedInFlightFromNewData(dataset_id, dataSet, res);","","                //Check to see if any delayed pending records can now be set to ready","                self.updateDelayedFromNewData(dataset_id, dataSet, res);","","                // Update the new dataset with details of any inflight updates which we have not received a response on","                self.updateNewDataFromInFlight(dataset_id, dataSet, res);","","                // Update the new dataset with details of any pending updates","                self.updateNewDataFromPending(dataset_id, dataSet, res);","","","","                if (res.records) {","                  // Full Dataset returned","                  dataSet.data = res.records;","                  dataSet.hash = res.hash;","","                  self.doNotify(dataset_id, res.hash, self.notifications.DELTA_RECEIVED, 'full dataset');","                }","","                if (res.updates) {","                  var acknowledgements = [];","                  processUpdates(res.updates.applied, self.notifications.REMOTE_UPDATE_APPLIED, acknowledgements);","                  processUpdates(res.updates.failed, self.notifications.REMOTE_UPDATE_FAILED, acknowledgements);","                  processUpdates(res.updates.collisions, self.notifications.COLLISION_DETECTED, acknowledgements);","                  dataSet.acknowledgements = acknowledgements;","                }","","                if (!res.records &amp;&amp; res.hash &amp;&amp; res.hash !== dataSet.hash) {","                  self.consoleLog(\"Local dataset stale - syncing records :: local hash= \" + dataSet.hash + \" - remoteHash=\" + res.hash);","                  // Different hash value returned - Sync individual records","                  self.syncRecords(dataset_id);","                } else {","                  self.consoleLog(\"Local dataset up to date\");","                  self.syncComplete(dataset_id,  \"online\", self.notifications.SYNC_COMPLETE);","                }","              }, function(msg, err) {","                // The AJAX call failed to complete succesfully, so the state of the current pending updates is unknown","                // Mark them as \"crashed\". The next time a syncLoop completets successfully, we will review the crashed","                // records to see if we can determine their current state.","                self.markInFlightAsCrashed(dataSet);","                self.consoleLog(\"syncLoop failed : msg=\" + msg + \" :: err = \" + err);","                self.syncComplete(dataset_id, msg, self.notifications.SYNC_FAILED);","              });","            }","            catch (e) {","              self.consoleLog('Error performing sync - ' + e);","              self.syncComplete(dataset_id, e, self.notifications.SYNC_FAILED);","            }","          });","        }","      });","    });","  },","","  syncRecords: function(dataset_id) {","","    self.getDataSet(dataset_id, function(dataSet) {","","      var localDataSet = dataSet.data || {};","","      var clientRecs = {};","      for (var i in localDataSet) {","        var uid = i;","        var hash = localDataSet[i].hash;","        clientRecs[uid] = hash;","      }","","      var syncRecParams = {};","","      syncRecParams.fn = 'syncRecords';","      syncRecParams.dataset_id = dataset_id;","      syncRecParams.query_params = dataSet.query_params;","      syncRecParams.clientRecs = clientRecs;","","      self.consoleLog(\"syncRecParams :: \" + JSON.stringify(syncRecParams));","","      self.doCloudCall({","        'dataset_id': dataset_id,","        'req': syncRecParams","      }, function(res) {","        var i;","","        if (res.create) {","          for (i in res.create) {","            localDataSet[i] = {\"hash\" : res.create[i].hash, \"data\" : res.create[i].data};","            self.doNotify(dataset_id, i, self.notifications.RECORD_DELTA_RECEIVED, \"create\");","          }","        }","        if (res.update) {","          for (i in res.update) {","            localDataSet[i].hash = res.update[i].hash;","            localDataSet[i].data = res.update[i].data;","            self.doNotify(dataset_id, i, self.notifications.RECORD_DELTA_RECEIVED, \"update\");","          }","        }","        if (res['delete']) {","          for (i in res['delete']) {","            delete localDataSet[i];","            self.doNotify(dataset_id, i, self.notifications.RECORD_DELTA_RECEIVED, \"delete\");","          }","        }","","        self.doNotify(dataset_id, res.hash, self.notifications.DELTA_RECEIVED, 'partial dataset');","","        dataSet.data = localDataSet;","        if(res.hash) {","          dataSet.hash = res.hash;","        }","        self.syncComplete(dataset_id, \"online\", self.notifications.SYNC_COMPLETE);","      }, function(msg, err) {","        self.consoleLog(\"syncRecords failed : msg=\" + msg + \" :: err=\" + err);","        self.syncComplete(dataset_id, msg, self.notifications.SYNC_FAILED);","      });","    });","  },","","  syncComplete: function(dataset_id, status, notification) {","","    self.getDataSet(dataset_id, function(dataset) {","      dataset.syncRunning = false;","      dataset.syncLoopEnd = new Date().getTime();","      self.saveDataSet(dataset_id);","      self.doNotify(dataset_id, dataset.hash, notification, status);","    });","  },","","  checkDatasets: function() {","    for( var dataset_id in self.datasets ) {","      if( self.datasets.hasOwnProperty(dataset_id) ) {","        var dataset = self.datasets[dataset_id];","","        if( !dataset.syncRunning &amp;&amp; (dataset.config.sync_active || dataset.syncForced)) {","          // Check to see if it is time for the sync loop to run again","          var lastSyncStart = dataset.syncLoopStart;","          var lastSyncCmp = dataset.syncLoopEnd;","          if( lastSyncStart == null ) {","            self.consoleLog(dataset_id +' - Performing initial sync');","            // Dataset has never been synced before - do initial sync","            dataset.syncPending = true;","          } else if (lastSyncCmp != null) {","            var timeSinceLastSync = new Date().getTime() - lastSyncCmp;","            var syncFrequency = dataset.config.sync_frequency * 1000;","            if( timeSinceLastSync &gt; syncFrequency ) {","              // Time between sync loops has passed - do another sync","              dataset.syncPending = true;","            }","          } ","","          if( dataset.syncForced ) {","            dataset.syncPending = true;","          }","","          if( dataset.syncPending ) {","            // Reset syncForced in case it was what caused the sync cycle to run.","            dataset.syncForced = false;","","            // If the dataset requres syncing, run the sync loop. This may be because the sync interval has passed","            // or because the sync_frequency has been changed or because a change was made to the dataset and the","            // immediate_sync flag set to true","            self.syncLoop(dataset_id);","          }","        }","      }","    }","  },","","  checkHasCustomSync : function(dataset_id, cb) {","    if(self.hasCustomSync != null) {","      return cb();","    }","    self.consoleLog('starting check has custom sync');","","    actAPI({","      'act' : dataset_id,","      'req': {","        'fn': 'sync'","      }","    }, function(res) {","      //if the custom sync is defined in the cloud, this call should success.","      //if failed, we think this the custom sync is not defined","      self.consoleLog('checkHasCustomSync - success - ', res);","      self.hasCustomSync = true;","      return cb();","    }, function(msg,err) {","      self.consoleLog('checkHasCustomSync - failure - ', err);","      if(err.status &amp;&amp; err.status === 500){","        //if we receive 500, it could be that there is an error occured due to missing parameters or similar,","        //but the endpoint is defined.","        self.consoleLog('checkHasCustomSync - failed with 500, endpoint does exists');","        self.hasCustomSync = true;","      } else {","        self.hasCustomSync = false;","      }","      return cb();","    });","  },","","  doCloudCall: function(params, success, failure) {","    if( self.hasCustomSync ) {","      actAPI({","        'act' : params.dataset_id,","        'req' : params.req","      }, function(res) {","        success(res);","      }, function(msg, err) {","        failure(msg, err);","      });      ","    } else {","      cloudAPI({","        'path' : '/mbaas/sync/' + params.dataset_id,","        'method' : 'post',","        'data' : params.req","      }, function(res) {","        success(res);","      }, function(msg, err) {","        failure(msg, err);","      })","    }","  },","","  datasetMonitor: function() {","    self.checkDatasets();","","    // Re-execute datasetMonitor every 500ms so we keep invoking checkDatasets();","    setTimeout(function() {","      self.datasetMonitor();","    }, 500);","  },","","  saveDataSet: function (dataset_id, cb) {","    var onFail =  function(msg, err) {","      // save failed","      var errMsg = 'save to local storage failed  msg:' + msg + ' err:' + err;","      self.doNotify(dataset_id, null, self.notifications.CLIENT_STORAGE_FAILED, errMsg);","      self.consoleLog(errMsg);","    };","    self.getDataSet(dataset_id, function(dataset) {","      // save dataset to local storage","      Lawnchair({fail:onFail, adapter: self.config.storage_strategy, size:self.config.file_system_quota}, function (){","        this.save({key:\"dataset_\" + dataset_id, val:dataset}, function(){","          //save success","          if(cb) return cb();","        });","      });","    });","  },","","  loadDataSet: function (dataset_id, success, failure) {","    // load dataset from local storage","    var onFail = function(msg, err) {","      // load failed","      var errMsg = 'load from local storage failed  msg:' + msg;","      self.doNotify(dataset_id, null, self.notifications.CLIENT_STORAGE_FAILED, errMsg);","      self.consoleLog(errMsg);","    };","","        Lawnchair({fail:onFail, adapter: self.config.storage_strategy, size:self.config.file_system_quota},function (){       this.get( \"dataset_\" + dataset_id, function (data){","         if (data &amp;&amp; data.val !== null) {","            var dataset = data.val;","            if(typeof dataset === \"string\"){","              dataset = JSON.parse(dataset);","            }","            // Datasets should not be auto initialised when loaded - the mange function should be called for each dataset","            // the user wants sync","            dataset.initialised = false;","            self.datasets[dataset_id] = dataset; // TODO: do we need to handle binary data?","            self.consoleLog('load from local storage success for dataset_id :' + dataset_id);","            if(success) return success(dataset);","          } else {","            // no data yet, probably first time. failure calback should handle this","            if(failure) return failure();","          }","       });","    });","  },","","","  updateDatasetFromLocal: function(dataset, pendingRec) {","    var pending = dataset.pending;","    var previousPendingUid;","    var previousPending;","","    var uid = pendingRec.uid;","    self.consoleLog('updating local dataset for uid ' + uid + ' - action = ' + pendingRec.action);","","    dataset.meta[uid] = dataset.meta[uid] || {};","","    // Creating a new record","    if( pendingRec.action === \"create\" ) {","      if( dataset.data[uid] ) {","        self.consoleLog('dataset already exists for uid in create :: ' + JSON.stringify(dataset.data[uid]));","","        // We are trying to do a create using a uid which already exists","        if (dataset.meta[uid].fromPending) {","          // We are trying to create on top of an existing pending record","          // Remove the previous pending record and use this one instead","          previousPendingUid = dataset.meta[uid].pendingUid;","          delete pending[previousPendingUid];","        }","      }","      dataset.data[uid] = {};","    }","","    if( pendingRec.action === \"update\" ) {","      if( dataset.data[uid] ) {","        if (dataset.meta[uid].fromPending) {","          self.consoleLog('updating an existing pending record for dataset :: ' + JSON.stringify(dataset.data[uid]));","          // We are trying to update an existing pending record","          previousPendingUid = dataset.meta[uid].pendingUid;","          dataset.meta[uid].previousPendingUid = previousPendingUid;","          previousPending = pending[previousPendingUid];","          if(previousPending) {","            if(!previousPending.inFlight){","              self.consoleLog('existing pre-flight pending record = ' + JSON.stringify(previousPending));","              // We are trying to perform an update on an existing pending record","              // modify the original record to have the latest value and delete the pending update","              previousPending.post = pendingRec.post;","              previousPending.postHash = pendingRec.postHash;","              delete pending[pendingRec.hash];","              // Update the pending record to have the hash of the previous record as this is what is now being","              // maintained in the pending array &amp; is what we want in the meta record","              pendingRec.hash = previousPendingUid;","            } else {","              //we are performing changes to a pending record which is inFlight. Until the status of this pending record is resolved,","              //we should not submit this pending record to the cloud. Mark it as delayed.","              self.consoleLog('existing in-inflight pending record = ' + JSON.stringify(previousPending));","              pendingRec.delayed = true;","              pendingRec.waiting = previousPending.hash;","            }","          }","        }","      }","    }","","    if( pendingRec.action === \"delete\" ) {","      if( dataset.data[uid] ) {","        if (dataset.meta[uid].fromPending) {","          self.consoleLog('Deleting an existing pending record for dataset :: ' + JSON.stringify(dataset.data[uid]));","          // We are trying to delete an existing pending record","          previousPendingUid = dataset.meta[uid].pendingUid;","          dataset.meta[uid].previousPendingUid = previousPendingUid;","          previousPending = pending[previousPendingUid];","          if( previousPending ) {","            if(!previousPending.inFlight){","              self.consoleLog('existing pending record = ' + JSON.stringify(previousPending));","              if( previousPending.action === \"create\" ) {","                // We are trying to perform a delete on an existing pending create","                // These cancel each other out so remove them both","                delete pending[pendingRec.hash];","                delete pending[previousPendingUid];","              }","              if( previousPending.action === \"update\" ) {","                // We are trying to perform a delete on an existing pending update","                // Use the pre value from the pending update for the delete and","                // get rid of the pending update","                pendingRec.pre = previousPending.pre;","                pendingRec.preHash = previousPending.preHash;","                pendingRec.inFlight = false;","                delete pending[previousPendingUid];","              }","            } else {","              self.consoleLog('existing in-inflight pending record = ' + JSON.stringify(previousPending));","              pendingRec.delayed = true;","              pendingRec.waiting = previousPending.hash;","            }","          }","        }","        delete dataset.data[uid];","      }","    }","","    if( dataset.data[uid] ) {","      dataset.data[uid].data = pendingRec.post;","      dataset.data[uid].hash = pendingRec.postHash;","      dataset.meta[uid].fromPending = true;","      dataset.meta[uid].pendingUid = pendingRec.hash;","    }","  },","","  updatePendingFromNewData: function(dataset_id, dataset, newData) {","    var pending = dataset.pending;","    var newRec;","","    if( pending &amp;&amp; newData.records) {","      for( var pendingHash in pending ) {","        if( pending.hasOwnProperty(pendingHash) ) {","          var pendingRec = pending[pendingHash];","","          dataset.meta[pendingRec.uid] = dataset.meta[pendingRec.uid] || {};","","          if( pendingRec.inFlight === false ) {","            // Pending record that has not been submitted","            self.consoleLog('updatePendingFromNewData - Found Non inFlight record -&gt; action=' + pendingRec.action +' :: uid=' + pendingRec.uid  + ' :: hash=' + pendingRec.hash);","            if( pendingRec.action === \"update\" || pendingRec.action === \"delete\") {","              // Update the pre value of pending record to reflect the latest data returned from sync.","              // This will prevent a collision being reported when the pending record is sent.","              newRec = newData.records[pendingRec.uid];","              if( newRec ) {","                self.consoleLog('updatePendingFromNewData - Updating pre values for existing pending record ' + pendingRec.uid);","                pendingRec.pre = newRec.data;","                pendingRec.preHash = newRec.hash;","              }","              else {","                // The update/delete may be for a newly created record in which case the uid will have changed.","                var previousPendingUid = dataset.meta[pendingRec.uid].previousPendingUid;","                var previousPending = pending[previousPendingUid];","                if( previousPending ) {","                  if( newData &amp;&amp; newData.updates &amp;&amp;  newData.updates.applied &amp;&amp; newData.updates.applied[previousPending.hash] ) {","                    // There is an update in from a previous pending action","                    var newUid = newData.updates.applied[previousPending.hash].uid;","                    newRec = newData.records[newUid];","                    if( newRec ) {","                      self.consoleLog('updatePendingFromNewData - Updating pre values for existing pending record which was previously a create ' + pendingRec.uid + ' ==&gt; ' + newUid);","                      pendingRec.pre = newRec.data;","                      pendingRec.preHash = newRec.hash;","                      pendingRec.uid = newUid;","                    }","                  }","                }","              }","            }","","            if( pendingRec.action === \"create\" ) {","              if( newData &amp;&amp; newData.updates &amp;&amp;  newData.updates.applied &amp;&amp; newData.updates.applied[pendingHash] ) {","                self.consoleLog('updatePendingFromNewData - Found an update for a pending create ' + JSON.stringify(newData.updates.applied[pendingHash]));","                newRec = newData.records[newData.updates.applied[pendingHash].uid];","                if( newRec ) {","                  self.consoleLog('updatePendingFromNewData - Changing pending create to an update based on new record  ' + JSON.stringify(newRec));","","                  // Set up the pending create as an update","                  pendingRec.action = \"update\";","                  pendingRec.pre = newRec.data;","                  pendingRec.preHash = newRec.hash;","                  pendingRec.uid = newData.updates.applied[pendingHash].uid;","                }","              }","            }","          }","        }","      }","    }","  },","","  updateNewDataFromInFlight: function(dataset_id, dataset, newData) {","    var pending = dataset.pending;","","    if( pending &amp;&amp; newData.records) {","      for( var pendingHash in pending ) {","        if( pending.hasOwnProperty(pendingHash) ) {","          var pendingRec = pending[pendingHash];","","          if( pendingRec.inFlight ) {","            var updateReceivedForPending = (newData &amp;&amp; newData.updates &amp;&amp;  newData.updates.hashes &amp;&amp; newData.updates.hashes[pendingHash]) ? true : false;","","            self.consoleLog('updateNewDataFromInFlight - Found inflight pending Record - action = ' + pendingRec.action + ' :: hash = ' + pendingHash + ' :: updateReceivedForPending=' + updateReceivedForPending);","","            if( ! updateReceivedForPending ) {","              var newRec = newData.records[pendingRec.uid];","","              if( pendingRec.action === \"update\" &amp;&amp; newRec) {","                // Modify the new Record to have the updates from the pending record so the local dataset is consistent","                newRec.data = pendingRec.post;","                newRec.hash = pendingRec.postHash;","              }","              else if( pendingRec.action === \"delete\" &amp;&amp; newRec) {","                // Remove the record from the new dataset so the local dataset is consistent","                delete newData.records[pendingRec.uid];","              }","              else if( pendingRec.action === \"create\" ) {","                // Add the pending create into the new dataset so it is not lost from the UI","                self.consoleLog('updateNewDataFromInFlight - re adding pending create to incomming dataset');","                var newPendingCreate = {","                  data: pendingRec.post,","                  hash: pendingRec.postHash","                };","                newData.records[pendingRec.uid] = newPendingCreate;","              }","            }","          }","        }","      }","    }","  },","","  updateNewDataFromPending: function(dataset_id, dataset, newData) {","    var pending = dataset.pending;","","    if( pending &amp;&amp; newData.records) {","      for( var pendingHash in pending ) {","        if( pending.hasOwnProperty(pendingHash) ) {","          var pendingRec = pending[pendingHash];","","          if( pendingRec.inFlight === false ) {","            self.consoleLog('updateNewDataFromPending - Found Non inFlight record -&gt; action=' + pendingRec.action +' :: uid=' + pendingRec.uid  + ' :: hash=' + pendingRec.hash);","            var newRec = newData.records[pendingRec.uid];","            if( pendingRec.action === \"update\" &amp;&amp; newRec) {","              // Modify the new Record to have the updates from the pending record so the local dataset is consistent","              newRec.data = pendingRec.post;","              newRec.hash = pendingRec.postHash;","            }","            else if( pendingRec.action === \"delete\" &amp;&amp; newRec) {","              // Remove the record from the new dataset so the local dataset is consistent","              delete newData.records[pendingRec.uid];","            }","            else if( pendingRec.action === \"create\" ) {","              // Add the pending create into the new dataset so it is not lost from the UI","              self.consoleLog('updateNewDataFromPending - re adding pending create to incomming dataset');","              var newPendingCreate = {","                data: pendingRec.post,","                hash: pendingRec.postHash","              };","              newData.records[pendingRec.uid] = newPendingCreate;","            }","          }","        }","      }","    }","  },","","  updateCrashedInFlightFromNewData: function(dataset_id, dataset, newData) {","    var updateNotifications = {","      applied: self.notifications.REMOTE_UPDATE_APPLIED,","      failed: self.notifications.REMOTE_UPDATE_FAILED,","      collisions: self.notifications.COLLISION_DETECTED","    };","","    var pending = dataset.pending;","    var resolvedCrashes = {};","    var pendingHash;","    var pendingRec;","","","    if( pending ) {","      for( pendingHash in pending ) {","        if( pending.hasOwnProperty(pendingHash) ) {","          pendingRec = pending[pendingHash];","","          if( pendingRec.inFlight &amp;&amp; pendingRec.crashed) {","            self.consoleLog('updateCrashedInFlightFromNewData - Found crashed inFlight pending record uid=' + pendingRec.uid + ' :: hash=' + pendingRec.hash );","            if( newData &amp;&amp; newData.updates &amp;&amp; newData.updates.hashes) {","","              // Check if the updates received contain any info about the crashed in flight update","              var crashedUpdate = newData.updates.hashes[pendingHash];","              if( crashedUpdate ) {","                // We have found an update on one of our in flight crashed records","","                resolvedCrashes[crashedUpdate.uid] = crashedUpdate;","","                self.consoleLog('updateCrashedInFlightFromNewData - Resolving status for crashed inflight pending record ' + JSON.stringify(crashedUpdate));","","                if( crashedUpdate.type === 'failed' ) {","                  // Crashed update failed - revert local dataset","                  if( crashedUpdate.action === 'create' ) {","                    self.consoleLog('updateCrashedInFlightFromNewData - Deleting failed create from dataset');","                    delete dataset.data[crashedUpdate.uid];","                  }","                  else if ( crashedUpdate.action === 'update' || crashedUpdate.action === 'delete' ) {","                    self.consoleLog('updateCrashedInFlightFromNewData - Reverting failed ' + crashedUpdate.action + ' in dataset');","                    dataset.data[crashedUpdate.uid] = {","                      data : pendingRec.pre,","                      hash : pendingRec.preHash","                    };","                  }","                }","","                delete pending[pendingHash];","                self.doNotify(dataset_id, crashedUpdate.uid, updateNotifications[crashedUpdate.type], crashedUpdate);","              }","              else {","                // No word on our crashed update - increment a counter to reflect another sync that did not give us","                // any update on our crashed record.","                if( pendingRec.crashedCount ) {","                  pendingRec.crashedCount++;","                }","                else {","                  pendingRec.crashedCount = 1;","                }","              }","            }","            else {","              // No word on our crashed update - increment a counter to reflect another sync that did not give us","              // any update on our crashed record.","              if( pendingRec.crashedCount ) {","                pendingRec.crashedCount++;","              }","              else {","                pendingRec.crashedCount = 1;","              }","            }","          }","        }","      }","","      for( pendingHash in pending ) {","        if( pending.hasOwnProperty(pendingHash) ) {","          pendingRec = pending[pendingHash];","","          if( pendingRec.inFlight &amp;&amp; pendingRec.crashed) {","            if( pendingRec.crashedCount &gt; dataset.config.crashed_count_wait ) {","              self.consoleLog('updateCrashedInFlightFromNewData - Crashed inflight pending record has reached crashed_count_wait limit : ' + JSON.stringify(pendingRec));","              if( dataset.config.resend_crashed_updates ) {","                self.consoleLog('updateCrashedInFlightFromNewData - Retryig crashed inflight pending record');","                pendingRec.crashed = false;","                pendingRec.inFlight = false;","              }","              else {","                self.consoleLog('updateCrashedInFlightFromNewData - Deleting crashed inflight pending record');","                delete pending[pendingHash];","              }","            }","          }","          else if (!pendingRec.inFlight &amp;&amp; pendingRec.crashed ) {","            self.consoleLog('updateCrashedInFlightFromNewData - Trying to resolve issues with crashed non in flight record - uid = ' + pendingRec.uid);","            // Stalled pending record because a previous pending update on the same record crashed","            var crashedRef = resolvedCrashes[pendingRec.uid];","            if( crashedRef ) {","              self.consoleLog('updateCrashedInFlightFromNewData - Found a stalled pending record backed up behind a resolved crash uid=' + pendingRec.uid + ' :: hash=' + pendingRec.hash);","              pendingRec.crashed = false;","            }","          }","        }","      }","    }","  },","","  updateDelayedFromNewData: function(dataset_id, dataset, newData){","    var pending = dataset.pending;","    var pendingHash;","    var pendingRec;","    if(pending){","      for( pendingHash in pending ){","        if( pending.hasOwnProperty(pendingHash) ){","          pendingRec = pending[pendingHash];","          if( pendingRec.delayed &amp;&amp; pendingRec.waiting ){","            self.consoleLog('updateDelayedFromNewData - Found delayed pending record uid=' + pendingRec.uid + ' :: hash=' + pendingRec.hash + ' :: waiting=' + pendingRec.waiting);","            if( newData &amp;&amp; newData.updates &amp;&amp; newData.updates.hashes ){","              var waitingRec = newData.updates.hashes[pendingRec.waiting];","              if(waitingRec){","                self.consoleLog('updateDelayedFromNewData - Waiting pending record is resolved rec=' + JSON.stringify(waitingRec));","                pendingRec.delayed = false;","                pendingRec.waiting = undefined;","              }","            }","          }","        }","      }","    }","  },","","","  markInFlightAsCrashed : function(dataset) {","    var pending = dataset.pending;","    var pendingHash;","    var pendingRec;","","    if( pending ) {","      var crashedRecords = {};","      for( pendingHash in pending ) {","        if( pending.hasOwnProperty(pendingHash) ) {","          pendingRec = pending[pendingHash];","","          if( pendingRec.inFlight ) {","            self.consoleLog('Marking in flight pending record as crashed : ' + pendingHash);","            pendingRec.crashed = true;","            crashedRecords[pendingRec.uid] = pendingRec;","          }","        }","      }","","      // Check for any pending updates that would be modifying a crashed record. These can not go out until the","      // status of the crashed record is determined","      for( pendingHash in pending ) {","        if( pending.hasOwnProperty(pendingHash) ) {","          pendingRec = pending[pendingHash];","","          if( ! pendingRec.inFlight &amp;&amp; ! pendingRec.delayed ) {","            var crashedRef = crashedRecords[pendingRec.uid];","            if( crashedRef ) {","              pendingRec.crashed = true;","            }","          }","        }","      }","    }","  },","","  consoleLog: function(msg) {","    if( self.config.do_console_log ) {","      console.log(msg);","    }","  }","};","","(function() {","  self.config = self.defaults;","  //Initialse the sync service with default config","  //self.init({});","})();","","module.exports = {","  init: self.init,","  manage: self.manage,","  notify: self.notify,","  doList: self.list,","  doCreate: self.create,","  doRead: self.read,","  doUpdate: self.update,","  doDelete: self['delete'],","  listCollisions: self.listCollisions,","  removeCollision: self.removeCollision,","  getPending : self.getPending,","  clearPending : self.clearPending,","  getDataset : self.getDataSet,","  getQueryParams: self.getQueryParams,","  setQueryParams: self.setQueryParams,","  getMetaData: self.getMetaData,","  setMetaData: self.setMetaData,","  getConfig: self.getConfig,","  setConfig: self.setConfig,","  startSync: self.startSync,","  stopSync: self.stopSync,","  doSync: self.doSync,","  forceSync: self.forceSync,","  generateHash: self.generateHash","};"];

},{"../../libs/generated/crypto":1,"../../libs/generated/lawnchair":2,"./api_act":55,"./api_cloud":56,"JSON":3}],74:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/uuid.js']) {
  _$jscoverage['modules/uuid.js'] = [];
  _$jscoverage['modules/uuid.js'][1] = 0;
  _$jscoverage['modules/uuid.js'][5] = 0;
  _$jscoverage['modules/uuid.js'][6] = 0;
  _$jscoverage['modules/uuid.js'][7] = 0;
  _$jscoverage['modules/uuid.js'][8] = 0;
  _$jscoverage['modules/uuid.js'][10] = 0;
  _$jscoverage['modules/uuid.js'][11] = 0;
  _$jscoverage['modules/uuid.js'][12] = 0;
  _$jscoverage['modules/uuid.js'][13] = 0;
}
_$jscoverage['modules/uuid.js'][1]++;
module.exports = {createUUID: (function () {
  _$jscoverage['modules/uuid.js'][5]++;
  var s = [];
  _$jscoverage['modules/uuid.js'][6]++;
  var hexDigitals = "0123456789ABCDEF";
  _$jscoverage['modules/uuid.js'][7]++;
  for (var i = 0; i < 32; i++) {
    _$jscoverage['modules/uuid.js'][8]++;
    s[i] = hexDigitals.substr(Math.floor(Math.random() * 16), 1);
}
  _$jscoverage['modules/uuid.js'][10]++;
  s[12] = "4";
  _$jscoverage['modules/uuid.js'][11]++;
  s[16] = hexDigitals.substr((s[16] & 3) | 8, 1);
  _$jscoverage['modules/uuid.js'][12]++;
  var uuid = s.join("");
  _$jscoverage['modules/uuid.js'][13]++;
  return uuid;
})};
_$jscoverage['modules/uuid.js'].source = ["module.exports = {","  createUUID : function () {","    //from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript","    //based on RFC 4122, section 4.4 (Algorithms for creating UUID from truely random pr pseudo-random number)","    var s = [];","    var hexDigitals = \"0123456789ABCDEF\";","    for (var i = 0; i &lt; 32; i++) {","      s[i] = hexDigitals.substr(Math.floor(Math.random() * 0x10), 1);","    }","    s[12] = \"4\";","    s[16] = hexDigitals.substr((s[16] &amp; 0x3) | 0x8, 1);","    var uuid = s.join(\"\");","    return uuid;","  }","};"];

},{}],75:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['modules/waitForCloud.js']) {
  _$jscoverage['modules/waitForCloud.js'] = [];
  _$jscoverage['modules/waitForCloud.js'][1] = 0;
  _$jscoverage['modules/waitForCloud.js'][2] = 0;
  _$jscoverage['modules/waitForCloud.js'][3] = 0;
  _$jscoverage['modules/waitForCloud.js'][4] = 0;
  _$jscoverage['modules/waitForCloud.js'][5] = 0;
  _$jscoverage['modules/waitForCloud.js'][9] = 0;
  _$jscoverage['modules/waitForCloud.js'][11] = 0;
  _$jscoverage['modules/waitForCloud.js'][12] = 0;
  _$jscoverage['modules/waitForCloud.js'][13] = 0;
  _$jscoverage['modules/waitForCloud.js'][16] = 0;
  _$jscoverage['modules/waitForCloud.js'][17] = 0;
  _$jscoverage['modules/waitForCloud.js'][18] = 0;
  _$jscoverage['modules/waitForCloud.js'][20] = 0;
  _$jscoverage['modules/waitForCloud.js'][21] = 0;
  _$jscoverage['modules/waitForCloud.js'][23] = 0;
  _$jscoverage['modules/waitForCloud.js'][24] = 0;
  _$jscoverage['modules/waitForCloud.js'][25] = 0;
  _$jscoverage['modules/waitForCloud.js'][26] = 0;
  _$jscoverage['modules/waitForCloud.js'][27] = 0;
  _$jscoverage['modules/waitForCloud.js'][28] = 0;
  _$jscoverage['modules/waitForCloud.js'][29] = 0;
  _$jscoverage['modules/waitForCloud.js'][31] = 0;
  _$jscoverage['modules/waitForCloud.js'][32] = 0;
  _$jscoverage['modules/waitForCloud.js'][33] = 0;
  _$jscoverage['modules/waitForCloud.js'][34] = 0;
  _$jscoverage['modules/waitForCloud.js'][41] = 0;
  _$jscoverage['modules/waitForCloud.js'][42] = 0;
  _$jscoverage['modules/waitForCloud.js'][45] = 0;
  _$jscoverage['modules/waitForCloud.js'][46] = 0;
  _$jscoverage['modules/waitForCloud.js'][47] = 0;
  _$jscoverage['modules/waitForCloud.js'][48] = 0;
  _$jscoverage['modules/waitForCloud.js'][50] = 0;
  _$jscoverage['modules/waitForCloud.js'][54] = 0;
  _$jscoverage['modules/waitForCloud.js'][55] = 0;
  _$jscoverage['modules/waitForCloud.js'][58] = 0;
  _$jscoverage['modules/waitForCloud.js'][59] = 0;
  _$jscoverage['modules/waitForCloud.js'][63] = 0;
  _$jscoverage['modules/waitForCloud.js'][64] = 0;
  _$jscoverage['modules/waitForCloud.js'][65] = 0;
  _$jscoverage['modules/waitForCloud.js'][66] = 0;
  _$jscoverage['modules/waitForCloud.js'][67] = 0;
  _$jscoverage['modules/waitForCloud.js'][68] = 0;
  _$jscoverage['modules/waitForCloud.js'][73] = 0;
  _$jscoverage['modules/waitForCloud.js'][74] = 0;
  _$jscoverage['modules/waitForCloud.js'][75] = 0;
  _$jscoverage['modules/waitForCloud.js'][76] = 0;
  _$jscoverage['modules/waitForCloud.js'][78] = 0;
  _$jscoverage['modules/waitForCloud.js'][81] = 0;
  _$jscoverage['modules/waitForCloud.js'][85] = 0;
}
_$jscoverage['modules/waitForCloud.js'][1]++;
var initializer = require("./initializer");
_$jscoverage['modules/waitForCloud.js'][2]++;
var events = require("./events");
_$jscoverage['modules/waitForCloud.js'][3]++;
var CloudHost = require("./hosts");
_$jscoverage['modules/waitForCloud.js'][4]++;
var constants = require("./constants");
_$jscoverage['modules/waitForCloud.js'][5]++;
var logger = require("./logger");
_$jscoverage['modules/waitForCloud.js'][9]++;
var cloud_host;
_$jscoverage['modules/waitForCloud.js'][11]++;
var is_initialising = false;
_$jscoverage['modules/waitForCloud.js'][12]++;
var is_cloud_ready = false;
_$jscoverage['modules/waitForCloud.js'][13]++;
var init_error = null;
_$jscoverage['modules/waitForCloud.js'][16]++;
var ready = (function (cb) {
  _$jscoverage['modules/waitForCloud.js'][17]++;
  if (is_cloud_ready) {
    _$jscoverage['modules/waitForCloud.js'][18]++;
    return cb(null, {host: getCloudHostUrl()});
  }
  else {
    _$jscoverage['modules/waitForCloud.js'][20]++;
    events.once(constants.INIT_EVENT, (function (err, host) {
  _$jscoverage['modules/waitForCloud.js'][21]++;
  return cb(err, host);
}));
    _$jscoverage['modules/waitForCloud.js'][23]++;
    if (! is_initialising) {
      _$jscoverage['modules/waitForCloud.js'][24]++;
      is_initialising = true;
      _$jscoverage['modules/waitForCloud.js'][25]++;
      initializer.init((function (err, initRes) {
  _$jscoverage['modules/waitForCloud.js'][26]++;
  is_initialising = false;
  _$jscoverage['modules/waitForCloud.js'][27]++;
  if (err) {
    _$jscoverage['modules/waitForCloud.js'][28]++;
    init_error = err;
    _$jscoverage['modules/waitForCloud.js'][29]++;
    return events.emit(constants.INIT_EVENT, err);
  }
  else {
    _$jscoverage['modules/waitForCloud.js'][31]++;
    init_error = null;
    _$jscoverage['modules/waitForCloud.js'][32]++;
    is_cloud_ready = true;
    _$jscoverage['modules/waitForCloud.js'][33]++;
    cloud_host = new CloudHost(initRes.cloud);
    _$jscoverage['modules/waitForCloud.js'][34]++;
    return events.emit(constants.INIT_EVENT, null, {host: getCloudHostUrl()});
  }
}));
    }
  }
});
_$jscoverage['modules/waitForCloud.js'][41]++;
var getCloudHost = (function () {
  _$jscoverage['modules/waitForCloud.js'][42]++;
  return cloud_host;
});
_$jscoverage['modules/waitForCloud.js'][45]++;
var getCloudHostUrl = (function () {
  _$jscoverage['modules/waitForCloud.js'][46]++;
  if (typeof cloud_host !== "undefined") {
    _$jscoverage['modules/waitForCloud.js'][47]++;
    var appProps = require("./appProps").getAppProps();
    _$jscoverage['modules/waitForCloud.js'][48]++;
    return cloud_host.getHost(appProps.mode);
  }
  else {
    _$jscoverage['modules/waitForCloud.js'][50]++;
    return undefined;
  }
});
_$jscoverage['modules/waitForCloud.js'][54]++;
var isReady = (function () {
  _$jscoverage['modules/waitForCloud.js'][55]++;
  return is_cloud_ready;
});
_$jscoverage['modules/waitForCloud.js'][58]++;
var getInitError = (function () {
  _$jscoverage['modules/waitForCloud.js'][59]++;
  return init_error;
});
_$jscoverage['modules/waitForCloud.js'][63]++;
var reset = (function () {
  _$jscoverage['modules/waitForCloud.js'][64]++;
  is_cloud_ready = false;
  _$jscoverage['modules/waitForCloud.js'][65]++;
  is_initialising = false;
  _$jscoverage['modules/waitForCloud.js'][66]++;
  cloud_host = undefined;
  _$jscoverage['modules/waitForCloud.js'][67]++;
  init_error = undefined;
  _$jscoverage['modules/waitForCloud.js'][68]++;
  ready((function () {
}));
});
_$jscoverage['modules/waitForCloud.js'][73]++;
ready((function (error, host) {
  _$jscoverage['modules/waitForCloud.js'][74]++;
  if (error) {
    _$jscoverage['modules/waitForCloud.js'][75]++;
    if (error.message !== "app_config_missing") {
      _$jscoverage['modules/waitForCloud.js'][76]++;
      logger.error("Failed to initialise fh.");
    }
    else {
      _$jscoverage['modules/waitForCloud.js'][78]++;
      logger.info("No fh config file");
    }
  }
  else {
    _$jscoverage['modules/waitForCloud.js'][81]++;
    logger.info("fh cloud is ready");
  }
}));
_$jscoverage['modules/waitForCloud.js'][85]++;
module.exports = {ready: ready, isReady: isReady, getCloudHost: getCloudHost, getCloudHostUrl: getCloudHostUrl, getInitError: getInitError, reset: reset};
_$jscoverage['modules/waitForCloud.js'].source = ["var initializer = require(\"./initializer\");","var events = require(\"./events\");","var CloudHost = require(\"./hosts\");","var constants = require(\"./constants\");","var logger = require(\"./logger\");","","","//the cloud configurations","var cloud_host;","","var is_initialising = false;","var is_cloud_ready = false;","var init_error = null;","","","var ready = function(cb){","  if(is_cloud_ready){","    return cb(null, {host: getCloudHostUrl()});","  } else {","    events.once(constants.INIT_EVENT, function(err, host){","      return cb(err, host);","    });","    if(!is_initialising){","      is_initialising = true;","      initializer.init(function(err, initRes){","        is_initialising = false;","        if(err){","          init_error = err;","          return events.emit(constants.INIT_EVENT, err);","        } else {","          init_error = null;","          is_cloud_ready = true;","          cloud_host = new CloudHost(initRes.cloud);","          return events.emit(constants.INIT_EVENT, null, {host: getCloudHostUrl()});","        }","      });","    }","  }","}","","var getCloudHost = function(){","  return cloud_host;","}","","var getCloudHostUrl = function(){","  if(typeof cloud_host !== \"undefined\"){","    var appProps = require(\"./appProps\").getAppProps();","    return cloud_host.getHost(appProps.mode);","  } else {","    return undefined;","  }","}","","var isReady = function(){","  return is_cloud_ready;","}","","var getInitError = function(){","  return init_error;","}","","//for test","var reset = function(){","  is_cloud_ready = false;","  is_initialising = false;","  cloud_host = undefined;","  init_error = undefined;","  ready(function(){","    ","  });","}","","ready(function(error, host){","  if(error){","    if(error.message !== \"app_config_missing\"){","      logger.error(\"Failed to initialise fh.\");","    } else {","      logger.info(\"No fh config file\");","    }","  } else {","    logger.info(\"fh cloud is ready\");","  }","});","","module.exports = {","  ready: ready,","  isReady: isReady,","  getCloudHost: getCloudHost,","  getCloudHostUrl: getCloudHostUrl,","  getInitError: getInitError,","  reset: reset","}"];

},{"./appProps":57,"./constants":58,"./events":61,"./hosts":64,"./initializer":65,"./logger":68}],76:[function(require,module,exports){
var constants = require("./modules/constants");
var logger = require("./modules/logger");
var ajax = require("./modules/ajax");
var events = require("./modules/events");
var cloud = require("./modules/waitForCloud");
var api_act = require("./modules/api_act");
var api_auth = require("./modules/api_auth");
var api_sec = require("./modules/api_sec");
var api_hash = require("./modules/api_hash");
var api_sync = require("./modules/sync-cli");
var api_mbaas = require("./modules/api_mbaas");
var api_cloud = require("./modules/api_cloud");
var fhparams = require("./modules/fhparams");
var appProps = require("./modules/appProps");
var device = require("./modules/device");

var defaultFail = function(msg, error){
  logger.error(msg + ":" + JSON.stringify(error));
};

var addListener = function(type, listener){
  events.addListener(type, listener);
  if(type === constants.INIT_EVENT){
    //for fhinit event, need to check the status of cloud and may need to fire the listener immediately.
    if(cloud.isReady()){
      listener(null, {host: cloud.getCloudHostUrl()});
    } else if(cloud.getInitError()){
      listener(cloud.getInitError());
    }
  } 
};

var once = function(type, listener){
  if(type === constants.INIT_EVENT && cloud.isReady()){
    listener(null, {host: cloud.getCloudHostUrl()});
  } else if(type === constants.INIT_EVENT && cloud.getInitError()){
    listener(cloud.getInitError());
  } else {
    events.once(type, listener);
  }
};

//Legacy shim. Init hapens based on fhconfig.json or, for v2, global var called fh_app_props which is injected as part of the index.html wrapper
var init = function(opts, success, fail){
  logger.warn("$fh.init will be deprecated soon");
  cloud.ready(function(err, host){
    if(err){
      if(typeof fail === "function"){
        return fail(err);
      }
    } else {
      if(typeof success === "function"){
        success(host.host);
      }
    }
  });
};

var fh = window.$fh || {};
fh.init = init;
fh.act = api_act;
fh.auth = api_auth;
fh.cloud = api_cloud;
fh.sec = api_sec;
fh.hash = api_hash;
fh.sync = api_sync;
fh.ajax = fh.__ajax = ajax;
fh.mbaas = api_mbaas;
fh._getDeviceId = device.getDeviceId;

fh.getCloudURL = function(){
  return cloud.getCloudHostUrl();
};

fh.getFHParams = function(){
  return fhparams.buildFHParams();
};

//events
fh.addListener = addListener;
fh.on = addListener;
fh.once = once;
var methods = ["removeListener", "removeAllListeners", "setMaxListeners", "listeners", "emit"];
for(var i=0;i<methods.length;i++){
  fh[methods[i]] = events[methods[i]];
}

//keep backward compatibility
fh.on(constants.INIT_EVENT, function(err, host){
  if(err){
    fh.cloud_props = {};
    fh.app_props = {};
  } else {
    fh.cloud_props = {hosts: {url: host.host}};
    fh.app_props = appProps.getAppProps();
  }
});

//for test
fh.reset = cloud.reset;
//we should really stop polluting global name space. Ideally we should ask browserify to use "$fh" when umd-fy the module. However, "$" is not allowed as the standard module name.
//So, we assign $fh to the window name space directly here. (otherwise, we have to fork the grunt browserify plugin, then fork browerify and the dependent umd module, really not worthing the effort).
window.$fh = fh;
module.exports = fh;






},{"./modules/ajax":78,"./modules/api_act":79,"./modules/api_auth":80,"./modules/api_cloud":81,"./modules/api_hash":82,"./modules/api_mbaas":83,"./modules/api_sec":84,"./modules/appProps":85,"./modules/constants":87,"./modules/device":89,"./modules/events":90,"./modules/fhparams":91,"./modules/logger":97,"./modules/sync-cli":105,"./modules/waitForCloud":107}],77:[function(require,module,exports){
var XDomainRequestWrapper = function(xdr){
  this.xdr = xdr;
  this.isWrapper = true;
  this.readyState = 0;
  this.onreadystatechange = null;
  this.status = 0;
  this.statusText = "";
  this.responseText = "";
  var self = this;
  this.xdr.onload = function(){
      self.readyState = 4;
      self.status = 200;
      self.statusText = "";
      self.responseText = self.xdr.responseText;
      if(self.onreadystatechange){
          self.onreadystatechange();
      }
  };
  this.xdr.onerror = function(){
      if(self.onerror){
          self.onerror();
      }
      self.readyState = 4;
      self.status = 0;
      self.statusText = "";
      if(self.onreadystatechange){
          self.onreadystatechange();
      }
  };
  this.xdr.ontimeout = function(){
      self.readyState = 4;
      self.status = 408;
      self.statusText = "timeout";
      if(self.onreadystatechange){
          self.onreadystatechange();
      }
  };
};

XDomainRequestWrapper.prototype.open = function(method, url, asyn){
  this.xdr.open(method, url);
};

XDomainRequestWrapper.prototype.send = function(data){
  this.xdr.send(data);
};

XDomainRequestWrapper.prototype.abort = function(){
  this.xdr.abort();
};

XDomainRequestWrapper.prototype.setRequestHeader = function(n, v){
  //not supported by xdr
  //Good doc on limitations of XDomainRequest http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  //XDomainRequest doesn't allow setting custom request headers. But it is the only available option to do CORS requests in IE8 & 9. In IE10, they finally start to use standard XMLHttpRequest.
  //To support FH auth tokens in IE8&9, we have to find a different way of doing it.
};

XDomainRequestWrapper.prototype.getResponseHeader = function(n){
  //not supported by xdr
};

module.exports = XDomainRequestWrapper;

},{}],78:[function(require,module,exports){
//a shameless copy from https://github.com/ForbesLindesay/ajax/blob/master/index.js. 
//it has the same methods and config options as jQuery/zeptojs but very light weight. see http://api.jquery.com/jQuery.ajax/
//a few small changes are made for supporting IE 8 and other features:
//1. use getXhr function to replace the default XMLHttpRequest implementation for supporting IE8
//2. Integrate with events emitter. So to subscribe ajax events, you can do $fh.on("ajaxStart", handler). See http://api.jquery.com/Ajax_Events/ for full list of events
//3. allow passing xhr factory method through options: e.g. $fh.ajax({xhr: function(){/*own implementation of xhr*/}}); 
//4. Use fh_timeout value as the default timeout
//5. an extra option called "tryJSONP" to allow try the same call with JSONP if normal CORS failed - should only be used internally
//6. for jsonp, allow to specify the callback query param name using the "jsonp" option

var eventsHandler = require("./events");
var XDomainRequestWrapper = require("./XDomainRequestWrapper");
var consts = require("./constants");
var logger = require("./logger");

var type
try {
  type = require('type-of')
} catch (ex) {
  //hide from browserify
  var r = require
  type = r('type')
}

var jsonpID = 0,
  document = window.document,
  key,
  name,
  rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
  scriptTypeRE = /^(?:text|application)\/javascript/i,
  xmlTypeRE = /^(?:text|application)\/xml/i,
  jsonType = 'application/json',
  htmlType = 'text/html',
  blankRE = /^\s*$/;

var ajax = module.exports = function (options) {
  var settings = extend({}, options || {})
  for (key in ajax.settings)
    if (settings[key] === undefined) settings[key] = ajax.settings[key]

  ajaxStart(settings)

  if (!settings.crossDomain) settings.crossDomain = /^([\w-]+:)?\/\/([^\/]+)/.test(settings.url) &&
    RegExp.$2 != window.location.host

  var dataType = settings.dataType,
    hasPlaceholder = /=\?/.test(settings.url)
    if (dataType == 'jsonp' || hasPlaceholder) {
      if (!hasPlaceholder) {
        settings.url = appendQuery(settings.url, (settings.jsonp? settings.jsonp: '_callback') + '=?');
      }
      return ajax.JSONP(settings)
    }

  if (!settings.url) settings.url = window.location.toString()
  serializeData(settings)

  var mime = settings.accepts[dataType],
    baseHeaders = {},
    protocol = /^([\w-]+:)\/\//.test(settings.url) ? RegExp.$1 : window.location.protocol,
    xhr = settings.xhr(settings.crossDomain),
    abortTimeout

  if (!settings.crossDomain) baseHeaders['X-Requested-With'] = 'XMLHttpRequest'
  if (mime) {
    baseHeaders['Accept'] = mime
    if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]
    xhr.overrideMimeType && xhr.overrideMimeType(mime)
  }
  if (settings.contentType || (settings.data && !settings.formdata && settings.type.toUpperCase() != 'GET'))
    baseHeaders['Content-Type'] = (settings.contentType || 'application/x-www-form-urlencoded')
  settings.headers = extend(baseHeaders, settings.headers || {})

  xhr.onreadystatechange = function () {
    if (xhr.readyState == 4) {
      clearTimeout(abortTimeout)
      var result, error = false
      if(settings.tryJSONP){
        //check if the request has fail. In some cases, we may want to try jsonp as well. Again, FH only...
        if(xhr.status === 0 && settings.crossDomain && !xhr.isTimeout &&  protocol != 'file:'){
          logger.debug("retry ajax call with jsonp")
          settings.type = "GET";
          settings.dataType = "jsonp";
          settings.data = "_jsonpdata=" + settings.data;
          return ajax(settings);
        }
      }
      if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {
        dataType = dataType || mimeToDataType(xhr.getResponseHeader('content-type'))
        result = xhr.responseText
        logger.debug("ajax response :: status = " + xhr.status + " :: body = " + result)

        try {
          if (dataType == 'script')(1, eval)(result)
          else if (dataType == 'xml') result = xhr.responseXML
          else if (dataType == 'json') result = blankRE.test(result) ? null : JSON.parse(result)
        } catch (e) {
          error = e
        }

        if (error) {
          logger.debug("ajax error", error);
          ajaxError(error, 'parsererror', xhr, settings)
        }
        else ajaxSuccess(result, xhr, settings)
      } else {
        ajaxError(null, 'error', xhr, settings)
      }
    }
  }

  var async = 'async' in settings ? settings.async : true
  logger.debug("ajax call settings", settings)
  xhr.open(settings.type, settings.url, async)

  for (name in settings.headers) xhr.setRequestHeader(name, settings.headers[name])

  if (ajaxBeforeSend(xhr, settings) === false) {
    logger.debug("ajax call is aborted due to ajaxBeforeSend")
    xhr.abort()
    return false
  }

  if (settings.timeout > 0) abortTimeout = setTimeout(function () {
    logger.debug("ajax call timed out")
    xhr.onreadystatechange = empty
    xhr.abort()
    xhr.isTimeout = true
    ajaxError(null, 'timeout', xhr, settings)
  }, settings.timeout)

  // avoid sending empty string (#319)
  xhr.send(settings.data ? settings.data : null)
  return xhr
}


// trigger a custom event and return true
function triggerAndReturn(context, eventName, data) {
  eventsHandler.emit(eventName, data);
  return true;
}

// trigger an Ajax "global" event
function triggerGlobal(settings, context, eventName, data) {
  if (settings.global) return triggerAndReturn(context || document, eventName, data)
}

// Number of active Ajax requests
ajax.active = 0

function ajaxStart(settings) {
  if (settings.global && ajax.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')
}

function ajaxStop(settings) {
  if (settings.global && !(--ajax.active)) triggerGlobal(settings, null, 'ajaxStop')
}

// triggers an extra global event "ajaxBeforeSend" that's like "ajaxSend" but cancelable
function ajaxBeforeSend(xhr, settings) {
  var context = settings.context
  if (settings.beforeSend.call(context, xhr, settings) === false)
    return false

  triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])
}

function ajaxSuccess(data, xhr, settings) {
  var context = settings.context,
    status = 'success'
  settings.success.call(context, data, status, xhr)
  triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])
  ajaxComplete(status, xhr, settings)
}
// type: "timeout", "error", "abort", "parsererror"
function ajaxError(error, type, xhr, settings) {
  var context = settings.context
  settings.error.call(context, xhr, type, error)
  triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error])
  ajaxComplete(type, xhr, settings)
}
// status: "success", "notmodified", "error", "timeout", "abort", "parsererror"
function ajaxComplete(status, xhr, settings) {
  var context = settings.context
  settings.complete.call(context, xhr, status)
  triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])
  ajaxStop(settings)
}

// Empty function, used as default callback
function empty() {}

ajax.JSONP = function (options) {
  if (!('type' in options)) return ajax(options)

  var callbackName = 'jsonp' + (++jsonpID),
    script = document.createElement('script'),
    abort = function () {
      //todo: remove script
      //$(script).remove()
      if (callbackName in window) window[callbackName] = empty
      ajaxComplete('abort', xhr, options)
    },
    xhr = {
      abort: abort
    }, abortTimeout,
    head = document.getElementsByTagName("head")[0] || document.documentElement

  if (options.error) script.onerror = function () {
    xhr.abort()
    options.error()
  }

  window[callbackName] = function (data) {
    clearTimeout(abortTimeout)
    //todo: remove script
    //$(script).remove()
    delete window[callbackName]
    ajaxSuccess(data, xhr, options)
  }

  serializeData(options)
  script.src = options.url.replace(/=\?/, '=' + callbackName)

  // Use insertBefore instead of appendChild to circumvent an IE6 bug.
  // This arises when a base node is used (see jQuery bugs #2709 and #4378).
  head.insertBefore(script, head.firstChild);

  if (options.timeout > 0) abortTimeout = setTimeout(function () {
    xhr.abort()
    ajaxComplete('timeout', xhr, options)
  }, options.timeout)

  return xhr
}

function isIE(){
  var ie = false;
  if(navigator.userAgent && navigator.userAgent.indexOf("MSIE") >=0 ){
    ie = true;
  }
  return ie;
}

function getXhr(crossDomain){
  var xhr = null;
  //always use XMLHttpRequest if available
  if(window.XMLHttpRequest){
    xhr = new XMLHttpRequest();
  }
  //for IE8
  if(isIE() && (crossDomain === true) && typeof window.XDomainRequest !== "undefined"){
    xhr = new XDomainRequestWrapper(new XDomainRequest());
  }
  return xhr;
}

ajax.settings = {
  // Default type of request
  type: 'GET',
  // Callback that is executed before request
  beforeSend: empty,
  // Callback that is executed if the request succeeds
  success: empty,
  // Callback that is executed the the server drops error
  error: empty,
  // Callback that is executed on request complete (both: error and success)
  complete: empty,
  // The context for the callbacks
  context: null,
  // Whether to trigger "global" Ajax events
  global: true,
  // Transport
  xhr: getXhr,
  // MIME types mapping
  accepts: {
    script: 'text/javascript, application/javascript',
    json: jsonType,
    xml: 'application/xml, text/xml',
    html: htmlType,
    text: 'text/plain'
  },
  // Whether the request is to another domain
  crossDomain: false,
  // Default timeout
  timeout: consts.fh_timeout
}

function mimeToDataType(mime) {
  return mime && (mime == htmlType ? 'html' :
    mime == jsonType ? 'json' :
    scriptTypeRE.test(mime) ? 'script' :
    xmlTypeRE.test(mime) && 'xml') || 'text'
}

function appendQuery(url, query) {
  return (url + '&' + query).replace(/[&?]{1,2}/, '?')
}

// serialize payload and append it to the URL for GET requests
function serializeData(options) {
  if (type(options.data) === 'object') {
    if(typeof options.data.append === "function"){
      //we are dealing with FormData, do not serialize
      options.formdata = true;
    } else {
      options.data = param(options.data)
    }
  }
  if (options.data && (!options.type || options.type.toUpperCase() == 'GET'))
    options.url = appendQuery(options.url, options.data)
}

ajax.get = function (url, success) {
  return ajax({
    url: url,
    success: success
  })
}

ajax.post = function (url, data, success, dataType) {
  if (type(data) === 'function') dataType = dataType || success, success = data, data = null
  return ajax({
    type: 'POST',
    url: url,
    data: data,
    success: success,
    dataType: dataType
  })
}

ajax.getJSON = function (url, success) {
  return ajax({
    url: url,
    success: success,
    dataType: 'json'
  })
}

var escape = encodeURIComponent;

function serialize(params, obj, traditional, scope) {
  var array = type(obj) === 'array';
  for (var key in obj) {
    var value = obj[key];

    if (scope) key = traditional ? scope : scope + '[' + (array ? '' : key) + ']'
    // handle data in serializeArray() format
    if (!scope && array) params.add(value.name, value.value)
    // recurse into nested objects
    else if (traditional ? (type(value) === 'array') : (type(value) === 'object'))
      serialize(params, value, traditional, key)
    else params.add(key, value)
  }
}

function param(obj, traditional) {
  var params = []
  params.add = function (k, v) {
    this.push(escape(k) + '=' + escape(v))
  }
  serialize(params, obj, traditional)
  return params.join('&').replace('%20', '+')
}

function extend(target) {
  var slice = Array.prototype.slice;
  slice.call(arguments, 1).forEach(function (source) {
    for (key in source)
      if (source[key] !== undefined)
        target[key] = source[key]
  })
  return target
}
},{"./XDomainRequestWrapper":77,"./constants":87,"./events":90,"./logger":97,"type-of":51}],79:[function(require,module,exports){
var logger =require("./logger");
var cloud = require("./waitForCloud");
var fhparams = require("./fhparams");
var ajax = require("./ajax");
var JSON = require("JSON");
var handleError = require("./handleError");

function doActCall(opts, success, fail){
  var cloud_host = cloud.getCloudHost();
  var url = cloud_host.getActUrl(opts.act);
  var params = opts.req || {};
  params = fhparams.addFHParams(params);
  return ajax({
    "url": url,
    "tryJSONP": true,
    "type": "POST",
    "dataType": "json",
    "data": JSON.stringify(params),
    "contentType": "application/json",
    "timeout": opts.timeout,
    "success": success,
    "error": function(req, statusText, error){
      return handleError(fail, req, statusText, error);
    }
  })
}

module.exports = function(opts, success, fail){
  logger.debug("act is called");
  if(!fail){
    fail = function(msg, error){
      logger.debug(msg + ":" + JSON.stringify(error));
    };
  }

  if(!opts.act){
    return fail('act_no_action', {});
  }

  cloud.ready(function(err, cloudHost){
    logger.debug("Calling fhact now");
    if(err){
      return fail(err.message, err);
    } else {
      doActCall(opts, success, fail);
    }
  })
}
},{"./ajax":78,"./fhparams":91,"./handleError":92,"./logger":97,"./waitForCloud":107,"JSON":3}],80:[function(require,module,exports){
var logger =require("./logger");
var cloud = require("./waitForCloud");
var fhparams = require("./fhparams");
var ajax = require("./ajax");
var JSON = require("JSON");
var handleError = require("./handleError");
var device = require("./device");
var constants = require("./constants");
var checkAuth = require("./checkAuth");
var appProps = require("./appProps");

module.exports = function(opts, success, fail){
  if(!fail){
    fail = function(msg, error){
      logger.debug(msg + ":" + JSON.stringify(error));
    };
  }
  if (!opts.policyId) {
    return fail('auth_no_policyId', {});
  }
  if (!opts.clientToken) {
    return fail('auth_no_clientToken', {});
  }

  cloud.ready(function(err, data){
    if(err){
      return fail(err.message, err);
    } else {
      var req = {};
      req.policyId = opts.policyId;
      req.clientToken = opts.clientToken;
      if (opts.endRedirectUrl) {
        req.endRedirectUrl = opts.endRedirectUrl;
        if (opts.authCallback) {
          req.endRedirectUrl += (/\?/.test(req.endRedirectUrl) ? "&" : "?") + "_fhAuthCallback=" + opts.authCallback;
        }
      }
      req.params = {};
      if (opts.params) {
        req.params = opts.params;
      }
      var endurl = opts.endRedirectUrl || "status=complete";
      req.device = device.getDeviceId();
      var app_props = appProps.getAppProps();
      var path = app_props.host + constants.boxprefix + "admin/authpolicy/auth";
      req = fhparams.addFHParams(req);

      ajax({
        "url": path,
        "type": "POST",
        "tryJSONP": true,
        "data": JSON.stringify(req),
        "dataType": "json",
        "contentType": "application/json",
        "timeout" : opts.timeout || app_props.timeout || constants.fh_timeout,
        success: function(res) {
          checkAuth.handleAuthResponse(endurl, res, success, fail);
        },
        error: function(req, statusText, error) {
          handleError(fail, req, statusText, error);
        }
      });
    }
  });
}
},{"./ajax":78,"./appProps":85,"./checkAuth":86,"./constants":87,"./device":89,"./fhparams":91,"./handleError":92,"./logger":97,"./waitForCloud":107,"JSON":3}],81:[function(require,module,exports){
var logger =require("./logger");
var cloud = require("./waitForCloud");
var fhparams = require("./fhparams");
var ajax = require("./ajax");
var JSON = require("JSON");
var handleError = require("./handleError");

function doCloudCall(opts, success, fail){
  var cloud_host = cloud.getCloudHost();
  var url = cloud_host.getCloudUrl(opts.path);
  var params = opts.data || {};
  params = fhparams.addFHParams(params);
  return ajax({
    "url": url,
    "type": opts.method || "POST",
    "dataType": opts.dataType || "json",
    "data": JSON.stringify(params),
    "contentType": opts.contentType || "application/json",
    "timeout": opts.timeout,
    "success": success,
    "error": function(req, statusText, error){
      return handleError(fail, req, statusText, error);
    }
  })
}

module.exports = function(opts, success, fail){
  logger.debug("cloud is called");
  if(!fail){
    fail = function(msg, error){
      logger.debug(msg + ":" + JSON.stringify(error));
    };
  }

  cloud.ready(function(err, cloudHost){
    logger.debug("Calling fhact now");
    if(err){
      return fail(err.message, err);
    } else {
      doCloudCall(opts, success, fail);
    }
  })
}
},{"./ajax":78,"./fhparams":91,"./handleError":92,"./logger":97,"./waitForCloud":107,"JSON":3}],82:[function(require,module,exports){
var hashImpl = require("./security/hash");

module.exports = function(p, s, f){
  var params = {};
  if(typeof p.algorithm === "undefined"){
    p.algorithm = "MD5";
  }
  params.act = "hash";
  params.params = p;
  hashImpl(params, s, f);
};
},{"./security/hash":103}],83:[function(require,module,exports){
var logger =require("./logger");
var cloud = require("./waitForCloud");
var fhparams = require("./fhparams");
var ajax = require("./ajax");
var JSON = require("JSON");
var handleError = require("./handleError");
var consts = require("./constants");


module.exports = function(opts, success, fail){
  logger.debug("mbaas is called.");
  if(!fail){
    fail = function(msg, error){
      console.debug(msg + ":" + JSON.stringify(error));
    };
  }

  var mbaas = opts.service;
  var params = opts.params;

  cloud.ready(function(err, cloudHost){
    logger.debug("Calling mbaas now");
    if(err){
      return fail(err.message, err);
    } else {
      var cloud_host = cloud.getCloudHost();
      var url = cloud_host.getMBAASUrl(mbaas);
      params = fhparams.addFHParams(params);
      return ajax({
        "url": url,
        "tryJSONP": true,
        "type": "POST",
        "dataType": "json",
        "data": JSON.stringify(params),
        "contentType": "application/json",
        "timeout": opts.timeout || consts.fh_timeout,
        "success": success,
        "error": function(req, statusText, error){
          return handleError(fail, req, statusText, error);
        }
      });
    }
  });
} 

},{"./ajax":78,"./constants":87,"./fhparams":91,"./handleError":92,"./logger":97,"./waitForCloud":107,"JSON":3}],84:[function(require,module,exports){
var keygen = require("./security/aes-keygen");
var aes = require("./security/aes-node");
var rsa = require("./security/rsa-node");
var hash = require("./security/hash");

module.exports = function(p, s, f){
  if (!p.act) {
    f('bad_act', {}, p);
    return;
  }
  if (!p.params) {
    f('no_params', {}, p);
    return;
  }
  if (!p.params.algorithm) {
    f('no_params_algorithm', {}, p);
    return;
  }
  p.params.algorithm = p.params.algorithm.toLowerCase();
  if(p.act === "hash"){
    return hash(p, s, f);
  } else if(p.act === "encrypt"){
    if(p.params.algorithm === "aes"){
      return aes.encrypt(p, s, f);
    } else if(p.params.algorithm === "rsa"){
      return rsa.encrypt(p, s, f);
    } else {
      return f('encrypt_bad_algorithm:' + p.params.algorithm, {}, p);
    }
  } else if(p.act === "decrypt"){
    if(p.params.algorithm === "aes"){
      return aes.decrypt(p, s, f);
    } else {
      return f('decrypt_bad_algorithm:' + p.params.algorithm, {}, p);
    }
  } else if(p.act === "keygen"){
    if(p.params.algorithm === "aes"){
      return keygen(p, s, f);
    } else {
      return f('keygen_bad_algorithm:' + p.params.algorithm, {}, p);
    }
  }
}
},{"./security/aes-keygen":101,"./security/aes-node":102,"./security/hash":103,"./security/rsa-node":104}],85:[function(require,module,exports){
var consts = require("./constants");
var ajax = require("./ajax");
var logger = require("./logger");
var qs = require("./queryMap");

var app_props = null;

var load = function(cb) {
  var doc_url = document.location.href;
  var url_params = qs(doc_url);
  var local = (typeof url_params.url !== 'undefined');

  // For local environments, no init needed
  if (local) {
    app_props = {};
    app_props.local = true;
    app_props.host = url_params.url;
    app_props.appid = "000000000000000000000000";
    app_props.appkey = "0000000000000000000000000000000000000000";
    app_props.projectid = "000000000000000000000000";
    app_props.connectiontag = "0.0.1";
    app_props.loglevel = url_params.loglevel;
    return cb(null, app_props);
  }

  var config_url = url_params.fhconfig || consts.config_js;
  ajax({
    url: config_url,
    dataType: "json",
    success: function(data) {
      logger.debug("fhconfig = " + JSON.stringify(data));
      //when load the config file on device, because file:// protocol is used, it will never call fail call back. The success callback will be called but the data value will be null.
      if (null === data) {
        return cb(new Error("app_config_missing"));
      } else {
        app_props = data;

        cb(null, app_props);
      }
    },
    error: function(req, statusText, error) {
      //fh v2 only
      if(window.fh_app_props){
        return cb(null, window.fh_app_props);
      }
      logger.error(consts.config_js + " Not Found");
      cb(new Error("app_config_missing"));
    }
  });
};

var setAppProps = function(props) {
  app_props = props;
};

var getAppProps = function() {
  return app_props;
};

module.exports = {
  load: load,
  getAppProps: getAppProps,
  setAppProps: setAppProps
};
},{"./ajax":78,"./constants":87,"./logger":97,"./queryMap":99}],86:[function(require,module,exports){
var logger = require("./logger");
var queryMap = require("./queryMap");
var JSON = require("JSON");
var fhparams = require("./fhparams");

var checkAuth = function(url) {
  if (/\_fhAuthCallback/.test(url)) {
    var qmap = queryMap(url);
    if (qmap) {
      var fhCallback = qmap["_fhAuthCallback"];
      if (fhCallback) {
        if (qmap['result'] && qmap['result'] === 'success') {
          var sucRes = {'sessionToken': qmap['fh_auth_session'], 'authResponse' : JSON.parse(decodeURIComponent(decodeURIComponent(qmap['authResponse'])))};
          fhparams.setAuthSessionToken(qmap['fh_auth_session']);
          window[fhCallback](null, sucRes);
        } else {
          window[fhCallback]({'message':qmap['message']});
        }
      }
    }
  }
};

var handleAuthResponse = function(endurl, res, success, fail){
  if(res.status && res.status === "ok"){

    var onComplete = function(res){
      if(res.sessionToken){
        fhparams.setAuthSessionToken(res.sessionToken);
      }
      success(res);
    };
    //for OAuth, a url will be returned which means the user should be directed to that url to authenticate.
    //we try to use the ChildBrower plugin if it can be found. Otherwise send the url to the success function to allow developer to handle it.
    if(res.url){
      var inappBrowserWindow = null;
      var locationChange = function(new_url){
        if(new_url.indexOf(endurl) > -1){
          if(inappBrowserWindow){
            inappBrowserWindow.close();
          }
          var qmap = queryMap(new_url);
          if(qmap) {
            if(qmap['result'] && qmap['result'] === 'success'){
              var sucRes = {'sessionToken': qmap['fh_auth_session'], 'authResponse' : JSON.parse(decodeURIComponent(decodeURIComponent(qmap['authResponse'])))};
              onComplete(sucRes);
            } else {
              if(fail){
                fail("auth_failed", {'message':qmap['message']});
              }
            }
          } else {
            if(fail){
                fail("auth_failed", {'message':qmap['message']});
            }
          }
        }
      };
      if(window.PhoneGap || window.cordova){
        if(window.plugins && window.plugins.childBrowser){
          //found childbrowser plugin,add the event listener and load it
          //we need to know when the OAuth process is finished by checking for the presence of endurl. If the endurl is found, it means the authentication finished and we should find if it's successful.
          if(typeof window.plugins.childBrowser.showWebPage === "function"){
            window.plugins.childBrowser.onLocationChange = locationChange;
            window.plugins.childBrowser.showWebPage(res.url);
            inappBrowserWindow = window.plugins.childBrowser;
          }
        } else {
          try {
            inappBrowserWindow = window.open(res.url, "_blank", 'location=yes');
            inappBrowserWindow.addEventListener("loadstart", function(ev){
              locationChange(ev.url);
            });
          } catch(e){
            logger.info("InAppBrowser plugin is not intalled.");
            onComplete(res);
          }
        }
      } else {
       document.location.href = res.url;
      }
    } else {
      onComplete(res);
    }
  } else {
    if(fail){
      fail("auth_failed", res);
    }
  }
};

//This is mainly for using $fh.auth inside browsers. If the authentication method is OAuth, at the end of the process, the user will be re-directed to
//a url that we specified for checking if the auth is successful. So we always check the url to see if we are on the re-directed page.
if (window.addEventListener) {
  window.addEventListener('load', function(){
    checkAuth(window.location.href);
  }, false); //W3C
} else {
  window.attachEvent('onload', function(){
    checkAuth(window.location.href);
  }); //IE
}

module.exports = {
  "handleAuthResponse": handleAuthResponse
};

},{"./fhparams":91,"./logger":97,"./queryMap":99,"JSON":3}],87:[function(require,module,exports){
module.exports = {
  "fh_timeout": 20000,
  "boxprefix": "/box/srv/1.1/",
  "sdk_version": "BUILD_VERSION",
  "config_js": "fhconfig.json",
  "INIT_EVENT": "fhinit"
};
},{}],88:[function(require,module,exports){
module.exports = {
  readCookieValue  : function (cookie_name) {
    var name_str = cookie_name + "=";
    var cookies = document.cookie.split(";");
    for (var i = 0; i < cookies.length; i++) {
      var c = cookies[i];
      while (c.charAt(0) === ' ') {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(name_str) === 0) {
        return c.substring(name_str.length, c.length);
      }
    }
    return null;
  },

  createCookie : function (cookie_name, cookie_value) {
    var date = new Date();
    date.setTime(date.getTime() + 36500 * 24 * 60 * 60 * 1000); //100 years
    var expires = "; expires=" + date.toGMTString();
    document.cookie = cookie_name + "=" + cookie_value + expires + "; path = /";
  }
};

},{}],89:[function(require,module,exports){
var cookies = require("./cookies");
var uuidModule = require("./uuid");
var logger = require("./logger");

module.exports = {
  //try to get the unique device identifier
  "getDeviceId": function(){
    //check for cordova/phonegap first
    if(typeof window.fhdevice !== "undefined" && typeof window.fhdevice.uuid !== "undefined"){
      return window.fhdevice.uuid;
    } else if(typeof window.device !== "undefined" && typeof window.device.uuid !== "undefined"){
      return window.device.uuid;
    }  else if(typeof navigator.device !== "undefined" && typeof navigator.device.uuid !== "undefined"){
      return navigator.device.uuid;
    } else {
      var _mock_uuid_cookie_name = "mock_uuid";
      var uuid = cookies.readCookieValue(_mock_uuid_cookie_name);
      if(null == uuid){
          uuid = uuidModule.createUUID();
          cookies.createCookie(_mock_uuid_cookie_name, uuid);
      }
      return uuid;
    }
  },

  //this is for fixing analytics issues when upgrading from io6 to ios7. Probably can be deprecated now
  "getCuidMap": function(){
    if(typeof window.fhdevice !== "undefined" && typeof window.fhdevice.cuidMap !== "undefined"){
      return window.fhdevice.cuidMap;
    } else if(typeof window.device !== "undefined" && typeof window.device.cuidMap !== "undefined"){
      return window.device.cuidMap;
    }  else if(typeof navigator.device !== "undefined" && typeof navigator.device.cuidMap !== "undefined"){
      return navigator.device.cuidMap;
    }

    return null;
  },

  "getDestination": function(){
    var destination = null;
    var platformsToTest = require("./platformsMap");


    var userAgent = navigator.userAgent;

    var dest_override = document.location.search.split("fh_destination_code=");
    if (dest_override.length > 1) {
     destination = dest_override[1];
    } else if (typeof window.fh_destination_code !== 'undefined') {
      destination = window.fh_destination_code;
    } else {
      platformsToTest.forEach(function(testDestination){
        testDestination.test.forEach(function(destinationTest){
          if(userAgent.indexOf(destinationTest) > -1){
            destination = testDestination.destination;
          }
        });
      });
    }

    if(destination == null){ //No user agents were found, set to default web
      destination = "web";
    }

    logger.debug("destination = " + destination);

    return destination;
  }
}

},{"./cookies":88,"./logger":97,"./platformsMap":98,"./uuid":106}],90:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;

var emitter = new EventEmitter();
emitter.setMaxListeners(0);

module.exports = emitter;
},{"events":43}],91:[function(require,module,exports){
var device = require("./device");
var sdkversion = require("./sdkversion");
var appProps = require("./appProps");
var logger = require("./logger");

var defaultParams = null;
var authSessionToken = null;
//TODO: review these options, we probably only needs all of them for init calls, but we shouldn't need all of them for act calls
var buildFHParams = function(){
  if(defaultParams){
    return defaultParams;
  }
  var fhparams = {};
  fhparams.cuid = device.getDeviceId();
  fhparams.cuidMap = device.getCuidMap();
  fhparams.destination = device.getDestination();
  
  if(window.device || navigator.device){
    fhparams.device = window.device || navigator.device;
  }

  //backward compatible
  if (typeof window.fh_app_version !== 'undefined'){
    fhparams.app_version = fh_app_version;
  }
  if (typeof window.fh_project_version !== 'undefined'){
    fhparams.project_version = fh_project_version;
  }
  if (typeof window.fh_project_app_version !== 'undefined'){
    fhparams.project_app_version = fh_project_app_version;
  }
  fhparams.sdk_version = sdkversion();
  if(authSessionToken){
    fhparams.sessionToken = authSessionToken;
  }

  var app_props = appProps.getAppProps();
  if(app_props){
    fhparams.appid = app_props.appid;
    fhparams.appkey = app_props.appkey;
    fhparams.projectid = app_props.projectid;
    fhparams.analyticsTag =  app_props.analyticsTag;
    fhparams.connectiontag = app_props.connectiontag;
    if(app_props.init){
      fhparams.init = typeof(app_props.init) === "string" ? JSON.parse(app_props.init) : app_props.init;
    }
  }
  
  defaultParams = fhparams;
  logger.debug("fhparams = ", defaultParams);
  return fhparams;
}

var addFHParams = function(params){
  var params = params || {};
  params.__fh = buildFHParams();
  return params;
}

var setAuthSessionToken = function(sessionToken){
  authSessionToken = sessionToken;
}

module.exports = {
  "buildFHParams": buildFHParams,
  "addFHParams": addFHParams,
  "setAuthSessionToken":setAuthSessionToken
}

},{"./appProps":85,"./device":89,"./logger":97,"./sdkversion":100}],92:[function(require,module,exports){
var JSON = require("JSON");

module.exports = function(fail, req, resStatus, error){
  var errraw;
  var statusCode = 0;
  if(req){
    try{
      statusCode = req.status;
      var res = JSON.parse(req.responseText);
      errraw = res.error || res.msg;
      if (errraw instanceof Array) {
        errraw = errraw.join('\n');
      }
    } catch(e){
      errraw = req.responseText;
    }
  }
  if(fail){
    fail(errraw, {
      status: statusCode,
      message: resStatus,
      error: error
    });
  }
};

},{"JSON":3}],93:[function(require,module,exports){
var constants = require("./constants");
var appProps = require("./appProps");

function removeEndSlash(input){
  var ret = input;
  if(ret.charAt(ret.length - 1) === "/"){
    ret = ret.substring(0, ret.length-1);
  }
  return ret;
}

function removeStartSlash(input){
  var ret = input;
  if(ret.length > 1 && ret.charAt(0) === "/"){
    ret = ret.substring(1, ret.length);
  }
  return ret;
}

function CloudHost(cloud_props){
  this.cloud_props = cloud_props;
  this.cloud_host = undefined;
  this.isLegacy = false;
}

CloudHost.prototype.getHost = function(appType){
  if(this.cloud_host){
    return this.cloud_host;
  } else {
    var url;
    var app_type;
    if(this.cloud_props && this.cloud_props.hosts){
      url = this.cloud_props.hosts.url;

      if (typeof url === 'undefined') {
        // resolve url the old way i.e. depending on
        // -burnt in app mode
        // -returned dev or live url
        // -returned dev or live type (node or fh(rhino or proxying))
        var cloud_host = this.cloud_props.hosts.releaseCloudUrl;
        app_type = this.cloud_props.hosts.releaseCloudType;

        if(typeof appType !== "undefined" && appType.indexOf("dev") > -1){
          cloud_host = this.cloud_props.hosts.debugCloudUrl;
          app_type = this.cloud_props.hosts.debugCloudType;
        }
        url = cloud_host;
      }
    }
    url = removeEndSlash(url);
    this.cloud_host = url;
    if(app_type === "fh"){
      this.isLegacy = true;
    }
    return url;
  }
}

CloudHost.prototype.getActUrl = function(act){
  var app_props = appProps.getAppProps() || {};
  if(typeof this.cloud_host === "undefined"){
    this.getHost(app_props.mode);
  }
  if(this.isLegacy){
    return this.cloud_host + constants.boxprefix + "act/" + this.cloud_props.domain + "/" + app_props.appid + "/" + act + "/" + app_props.appid;
  } else {
    return this.cloud_host + "/cloud/" + act;
  }
}

CloudHost.prototype.getMBAASUrl = function(service){
  var app_props = appProps.getAppProps() || {};
  if(typeof this.cloud_host === "undefined"){
    this.getHost(app_props.mode);
  }
  return this.cloud_host + "/mbaas/" + service;
}

CloudHost.prototype.getCloudUrl = function(path){
  var app_props = appProps.getAppProps() || {};
  if(typeof this.cloud_host === "undefined"){
    this.getHost(app_props.mode);
  }
  return this.cloud_host + "/" + removeStartSlash(path);
}



module.exports = CloudHost;
},{"./appProps":85,"./constants":87}],94:[function(require,module,exports){
var loadScript = require("./loadScript");
var Lawnchair = require('../../libs/generated/lawnchair');
var lawnchairext = require('./lawnchair-ext');
var consts = require("./constants");
var fhparams = require("./fhparams");
var ajax = require("./ajax");
var handleError = require("./handleError");
var logger = require("./logger");
var JSON = require("JSON");
var hashFunc = require("./security/hash");
var appProps = require("./appProps");

var init = function(cb) {
  appProps.load(function(err, data) {
    if (err) return cb(err);
    return loadCloudProps(data, cb);
  });
}

var loadCloudProps = function(app_props, callback) {
  if(app_props.loglevel){
    logger.setLevel(app_props.loglevel);
  }
  // If local - shortcircuit the init - just return the host
  if (app_props.local) {
    var res = {
      "domain": "local",
      "firstTime": false,
      "hosts": {
        "debugCloudType": "node",
        "debugCloudUrl": app_props.host,
        "releaseCloudType": "node",
        "releaseCloudUrl": app_props.host,
        "type": "cloud_nodejs",
        "url": app_props.host
      },
      "init": {
        "trackId": "000000000000000000000000"
      },
      "status": "ok"
    };

    return callback(null, {
      cloud: res
    });
  }


  //now we have app props, add the fileStorageAdapter
  lawnchairext.addAdapter(app_props, hashFunc);
  //dom adapter doens't work on windows phone, so don't specify the adapter if the dom one failed
  //we specify the order of lawnchair adapters to use, lawnchair will find the right one to use, to keep backward compatibility, keep the order
  //as dom, webkit-sqlite, localFileStorage, window-name
  var lcConf = {
    name: "fh_init_storage",
    adapter: ["dom", "webkit-sqlite", "localFileStorage", "window-name"],
    fail: function(msg, err) {
      var error_message = 'read/save from/to local storage failed  msg:' + msg + ' err:' + err;
      return fail(error_message, {});
    }
  };

  var storage = null;
  try {
    storage = new Lawnchair(lcConf, function() {});
  } catch (e) {
    //when dom adapter failed, Lawnchair throws an error
    //shoudn't go in here anymore
    lcConf.adapter = undefined;
    storage = new Lawnchair(lcConf, function() {});
  }

  var path = app_props.host + consts.boxprefix + "app/init";

  storage.get('fh_init', function(storage_res) {
    var savedHost = null;
    if (storage_res && storage_res.value !== null && typeof(storage_res.value) !== "undefined" && storage_res !== "") {
      storage_res = typeof(storage_res) === "string" ? JSON.parse(storage_res) : storage_res;
      storage_res.value = typeof(storage_res.value) === "string" ? JSON.parse(storage_res.value) : storage_res.value;
      if (storage_res.value.init) {
        app_props.init = storage_res.value.init;
      } else {
        //keep it backward compatible.
        app_props.init = typeof(storage_res.value) === "string" ? JSON.parse(storage_res.value) : storage_res.value;
      }
      if (storage_res.value.hosts) {
        savedHost = storage_res.value;
      }
    }
    var data = fhparams.buildFHParams();

    ajax({
      "url": path,
      "type": "POST",
      "tryJSONP": true,
      "dataType": "json",
      "contentType": "application/json",
      "data": JSON.stringify(data),
      "timeout": app_props.timeout || consts.fh_timeout,
      "success": function(initRes) {
        storage.save({
          key: "fh_init",
          value: initRes
        }, function() {});
        if (callback) {
          callback(null, {
            cloud: initRes
          });
        }
      },
      "error": function(req, statusText, error) {
        //use the cached host if we have a copy
        if (savedHost) {
          if (callback) {
            callback(null, {
              cloud: savedHost
            });
          }
        } else {
          handleError(function(msg, err) {
            if (callback) {
              callback({
                error: err,
                message: msg
              });
            }
          }, req, statusText, error);
        }
      }
    });
  });
};

module.exports = {
  "init": init,
  "loadCloudProps": loadCloudProps
}
},{"../../libs/generated/lawnchair":2,"./ajax":78,"./appProps":85,"./constants":87,"./fhparams":91,"./handleError":92,"./lawnchair-ext":95,"./loadScript":96,"./logger":97,"./security/hash":103,"JSON":3}],95:[function(require,module,exports){
var Lawnchair = require('../../libs/generated/lawnchair');

var fileStorageAdapter = function (app_props, hashFunc) {
  // private methods

  function doLog(mess){
    if(console){
      console.log(mess);
    }
  }

  var fail = function (e, i) {
    if(console) console.log('error in file system adapter !', e, i);
    else throw e;
  };


  function filenameForKey(key, cb) {
    key = app_props.appid + key;

    hashFunc({
      algorithm: "MD5",
      text: key
    }, function(result) {
      var filename = result.hashvalue + '.txt';
      if (typeof navigator.externalstorage !== "undefined") {
        navigator.externalstorage.enable(function handleSuccess(res){
          var path = filename;
          if(res.path ) {
            path = res.path;
            if(!path.match(/\/$/)) {
              path += '/';
            }
            path += filename;
          }
          filename = path;
          return cb(filename);
        },function handleError(err){
          return cb(filename);
        })
      } else {
        doLog('filenameForKey key=' + key+ ' , Filename: ' + filename);
        return cb(filename);
      }
    });
  }

  return {

    valid: function () { return !!(window.requestFileSystem) },

    init : function (options, callback){
      //calls the parent function fn and applies this scope
      if(options && 'function' === typeof options.fail ) fail = options.fail;
      if (callback) this.fn(this.name, callback).call(this, this);
    },

    keys: function (callback){
      throw "Currently not supported";
    },

    save : function (obj, callback){
      var key = obj.key;
      var value = obj.val||obj.value;
      filenameForKey(key, function(hash) {
        window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, function gotFS(fileSystem) {

          fileSystem.root.getFile(hash, {
            create: true
          }, function gotFileEntry(fileEntry) {
            fileEntry.createWriter(function gotFileWriter(writer) {
              writer.onwrite = function() {
                return callback({
                  key: key,
                  val: value
                });
              };
              writer.write(value);
            }, function() {
              fail('[save] Failed to create file writer');
            });
          }, function() {
            fail('[save] Failed to getFile');
          });
        }, function() {
          fail('[save] Failed to requestFileSystem');
        });
      });
    },

    batch : function (records, callback){
      throw "Currently not supported";
    },

    get : function (key, callback){
      filenameForKey(key, function(hash) {
        window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, function gotFS(fileSystem) {
          fileSystem.root.getFile(hash, {}, function gotFileEntry(fileEntry) {
            fileEntry.file(function gotFile(file) {
              var reader = new FileReader();
              reader.onloadend = function (evt) {
                var text = evt.target.result;
                // Check for URLencoded
                // PG 2.2 bug in readAsText()
                try {
                  text = decodeURIComponent(text);
                } catch (e) {
                  // Swallow exception if not URLencoded
                  // Just use the result
                }
                return callback({
                  key: key,
                  val: text
                });
              };
              reader.readAsText(file);
            }, function() {
              fail('[load] Failed to getFile');
            });
          }, function() {
            // Success callback on key load failure
            callback({
              key: key,
              val: null
            });
          });
        }, function() {
          fail('[load] Failed to get fileSystem');
        });
      });
    },

    exists : function (key, callback){
      filenameForKey(key,function (hash){
        window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, function gotFS(fileSystem) {
          fileSystem.root.getFile(hash, {},
            function gotFileEntry(fileEntry) {
              return callback(true);
            }, function (err){
              return callback(false);
            });
        });
      });
    },

    all : function (callback){
      throw "Currently not supported";
    },

    remove : function (key, callback){
      filenameForKey(key, function(hash) {

        window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, function gotFS(fileSystem) {
          fileSystem.root.getFile(hash, {}, function gotFileEntry(fileEntry) {

            fileEntry.remove(function() {
              return callback({
                key: key,
                val: null
              });
            }, function() {
              fail('[remove] Failed to remove file');
            });
          }, function() {
            fail('[remove] Failed to getFile');
          });
        }, function() {
          fail('[remove] Failed to get fileSystem');
        });
      });
    },

    nuke : function (callback){
      throw "Currently not supported";
    }


  };
}

var addAdapter = function(app_props, hashFunc){
  Lawnchair.adapter('localFileStorage', fileStorageAdapter(app_props, hashFunc));
}

module.exports = {
  addAdapter: addAdapter
}
},{"../../libs/generated/lawnchair":2}],96:[function(require,module,exports){
module.exports = function (url, callback) {
  var script;
  var head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;
  script = document.createElement("script");
  script.async = "async";
  script.src = url;
  script.type = "text/javascript";
  script.onload = script.onreadystatechange = function () {
    if (!script.readyState || /loaded|complete/.test(script.readyState)) {
      script.onload = script.onreadystatechange = null;
      if (head && script.parentNode) {
        head.removeChild(script);
      }
      script = undefined;
      if (callback && typeof callback === "function") {
        callback();
      }
    }
  };
  head.insertBefore(script, head.firstChild);
};

},{}],97:[function(require,module,exports){
var console = require('console');
var log = require('loglevel');

log.setLevel('info');

/**
 * APIs:
 * see https://github.com/pimterry/loglevel.
 * In short, you can use:
 * log.setLevel(loglevel) - default to info
 * log.enableAll() - enable all log messages
 * log.disableAll() - disable all log messages
 *
 * log.trace(msg)
 * log.debug(msg)
 * log.info(msg)
 * log.warn(msg)
 * log.error(msg)
 *
 * Available levels: { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3, "ERROR": 4, "SILENT": 5}
 * Use either string or integer value
 */
module.exports = log;
},{"console":42,"loglevel":48}],98:[function(require,module,exports){
module.exports = [
  {
    "destination" :"ipad",
    "test": ["iPad"]
  },
  {
    "destination" :"iphone",
    "test": ["iPhone"]
  },
  {
    "destination" :"android",
    "test": ["Android"]
  },
  {
    "destination" :"blackberry",
    "test": ["BlackBerry", "BB10", "RIM Tablet OS"]//Blackberry 10 does not contain "Blackberry"
  },
  {
    "destination" :"windowsphone",
    "test": ["Windows Phone 8"]
  },
  {
    "destination" :"windowsphone7",
    "test": ["Windows Phone OS 7"]
  }
];

},{}],99:[function(require,module,exports){
module.exports = function(url) {
  var qmap = {};
  var i = url.split("?");
  if (i.length === 2) {
    var queryString = i[1];
    var pairs = queryString.split("&");
    qmap = {};
    for (var p = 0; p < pairs.length; p++) {
      var q = pairs[p];
      var qp = q.split("=");
      qmap[qp[0]] = qp[1];
    }
  }
  return qmap;
};
},{}],100:[function(require,module,exports){
var constants = require("./constants");

module.exports = function() {
  var type = "FH_JS_SDK";
  if (typeof window.fh_destination_code !== 'undefined') {
    type = "FH_HYBRID_SDK";
  } else if(window.PhoneGap || window.cordova) {
    type = "FH_PHONEGAP_SDK";
  }
  return type + "/" + constants.sdk_version;
};

},{"./constants":87}],101:[function(require,module,exports){
var rsa = require("../../../libs/rsa");
var SecureRandom = rsa.SecureRandom;
var byte2Hex = rsa.byte2Hex;

var generateRandomKey = function(keysize){
  var r = new SecureRandom();
  var key = new Array(keysize);
  r.nextBytes(key);
  var result = "";
  for(var i=0;i<key.length;i++){
    result += byte2Hex(key[i]);
  }
  return result;
};

var aes_keygen = function(p, s, f){
  if (!p.params.keysize) {
    f('no_params_keysize', {}, p);
    return;
  }
  if (p.params.algorithm.toLowerCase() !== "aes") {
    f('keygen_bad_algorithm', {}, p);
    return;
  }
  var keysize = parseInt(p.params.keysize, 10);
  //keysize is in bit, need to convert to bytes to generate random key
  //but the legacy code has a bug, it doesn't do the convert, so if the keysize is less than 100, don't convert
  if(keysize > 100){
    keysize = keysize/8;
  }
  if(typeof SecureRandom === "undefined"){
    return f("security library is not loaded.");
  }
  return s({
    'algorithm': 'AES',
    'secretkey': generateRandomKey(keysize),
    'iv': generateRandomKey(keysize)
  });
}

module.exports = aes_keygen;
},{"../../../libs/rsa":4}],102:[function(require,module,exports){
var CryptoJS = require("../../../libs/generated/crypto");

var encrypt = function(p, s, f){
  var fields = ['key', 'plaintext', 'iv'];
  if(p.params.algorithm.toLowerCase() !== "aes"){
    return f('encrypt_bad_algorithm', {}, p);
  }
  for (var i = 0; i < fields; i++) {
    var field = fields[i];
    if (!p.params[field]) {
      return f('no_params_' + field, {}, p);
    }
  }
  var encrypted = CryptoJS.AES.encrypt(p.params.plaintext, CryptoJS.enc.Hex.parse(p.params.key), {iv: CryptoJS.enc.Hex.parse(p.params.iv)});
  cipher_text = CryptoJS.enc.Hex.stringify(encrypted.ciphertext);
  return s({ciphertext: cipher_text});
}

var decrypt = function(p, s, f){
  var fields = ['key', 'ciphertext', 'iv'];
  if(p.params.algorithm.toLowerCase() !== "aes"){
    return f('decrypt_bad_algorithm', {}, p);
  }
  for (var i = 0; i < fields; i++) {
    var field = fields[i];
    if (!p.params[field]) {
      return f('no_params_' + field, {}, p);
    }
  }
  var data = CryptoJS.enc.Hex.parse(p.params.ciphertext);
  var encodeData = CryptoJS.enc.Base64.stringify(data);
  var decrypted = CryptoJS.AES.decrypt(encodeData, CryptoJS.enc.Hex.parse(p.params.key), {iv: CryptoJS.enc.Hex.parse(p.params.iv)});
  plain_text = decrypted.toString(CryptoJS.enc.Utf8);
  return s({plaintext:plain_text});
}

module.exports = {
  encrypt: encrypt,
  decrypt: decrypt
}
},{"../../../libs/generated/crypto":1}],103:[function(require,module,exports){
var CryptoJS = require("../../../libs/generated/crypto");


var hash = function(p, s, f){
  if (!p.params.text) {
    f('hash_no_text', {}, p);
    return;
  }
  var hashValue;
  if (p.params.algorithm.toLowerCase() === "md5") {
    hashValue = CryptoJS.MD5(p.params.text).toString(CryptoJS.enc.Hex);
  } else if(p.params.algorithm.toLowerCase() === "sha1"){
    hashValue = CryptoJS.SHA1(p.params.text).toString(CryptoJS.enc.Hex);
  } else if(p.params.algorithm.toLowerCase() === "sha256"){
    hashValue = CryptoJS.SHA256(p.params.text).toString(CryptoJS.enc.Hex);
  } else if(p.params.algorithm.toLowerCase() === "sha512"){
    hashValue = CryptoJS.SHA512(p.params.text).toString(CryptoJS.enc.Hex);
  } else {
    return f("hash_unsupported_algorithm: " + p.params.algorithm);
  }
  return s({"hashvalue": hashValue});
}

module.exports = hash;
},{"../../../libs/generated/crypto":1}],104:[function(require,module,exports){
var rsa = require("../../../libs/rsa");
var RSAKey = rsa.RSAKey;

var encrypt = function(p, s, f){
  var fields = ['modulu', 'plaintext'];
  if(p.params.algorithm.toLowerCase() !== "rsa"){
    return f('encrypt_bad_algorithm', {}, p);
  }
  for (var i = 0; i < fields; i++) {
    var field = fields[i];
    if (!p.params[field]) {
      return f('no_params_' + field, {}, p);
    }
  }
  var key = new RSAKey();
  key.setPublic(p.params.modulu, "10001");
  var ori_text = p.params.plaintext;
  cipher_text = key.encrypt(ori_text);
  return s({ciphertext:cipher_text});
}

module.exports = {
  encrypt: encrypt
}
},{"../../../libs/rsa":4}],105:[function(require,module,exports){
var JSON = require("JSON");
var actAPI = require("./api_act");
var cloudAPI = require("./api_cloud");
var CryptoJS = require("../../libs/generated/crypto");
var Lawnchair = require('../../libs/generated/lawnchair');

var self = {

  // CONFIG
  defaults: {
    "sync_frequency": 10,
    // How often to synchronise data with the cloud in seconds.
    "auto_sync_local_updates": true,
    // Should local chages be syned to the cloud immediately, or should they wait for the next sync interval
    "notify_client_storage_failed": true,
    // Should a notification event be triggered when loading/saving to client storage fails
    "notify_sync_started": true,
    // Should a notification event be triggered when a sync cycle with the server has been started
    "notify_sync_complete": true,
    // Should a notification event be triggered when a sync cycle with the server has been completed
    "notify_offline_update": true,
    // Should a notification event be triggered when an attempt was made to update a record while offline
    "notify_collision_detected": true,
    // Should a notification event be triggered when an update failed due to data collision
    "notify_remote_update_failed": true,
    // Should a notification event be triggered when an update failed for a reason other than data collision
    "notify_local_update_applied": true,
    // Should a notification event be triggered when an update was applied to the local data store
    "notify_remote_update_applied": true,
    // Should a notification event be triggered when an update was applied to the remote data store
    "notify_delta_received": true,
    // Should a notification event be triggered when a delta was received from the remote data store for the dataset 
    "notify_record_delta_received": true,
    // Should a notification event be triggered when a delta was received from the remote data store for a record
    "notify_sync_failed": true,
    // Should a notification event be triggered when the sync loop failed to complete
    "do_console_log": false,
    // Should log statements be written to console.log
    "crashed_count_wait" : 10,
    // How many syncs should we check for updates on crashed in flight updates before we give up searching
    "resend_crashed_updates" : true,
    // If we have reached the crashed_count_wait limit, should we re-try sending the crashed in flight pending record
    "sync_active" : true,
    // Is the background sync with the cloud currently active
    "storage_strategy" : "html5-filesystem",
    // Storage strategy to use for Lawnchair - supported strategies are 'html5-filesystem' and 'dom'
    "file_system_quota" : 50 * 1024 * 1204
    // Amount of space to request from the HTML5 filesystem API when running in browser
  },

  notifications: {
    "CLIENT_STORAGE_FAILED": "client_storage_failed",
    // loading/saving to client storage failed
    "SYNC_STARTED": "sync_started",
    // A sync cycle with the server has been started
    "SYNC_COMPLETE": "sync_complete",
    // A sync cycle with the server has been completed
    "OFFLINE_UPDATE": "offline_update",
    // An attempt was made to update a record while offline
    "COLLISION_DETECTED": "collision_detected",
    //Update Failed due to data collision
    "REMOTE_UPDATE_FAILED": "remote_update_failed",
    // Update Failed for a reason other than data collision
    "REMOTE_UPDATE_APPLIED": "remote_update_applied",
    // An update was applied to the remote data store
    "LOCAL_UPDATE_APPLIED": "local_update_applied",
    // An update was applied to the local data store
    "DELTA_RECEIVED": "delta_received",
    // A delta was received from the remote data store for the dataset 
    "RECORD_DELTA_RECEIVED": "record_delta_received",
    // A delta was received from the remote data store for the record 
    "SYNC_FAILED": "sync_failed"
    // Sync loop failed to complete
  },

  datasets: {},

  // Initialise config to default values;
  config: undefined,

  notify_callback: undefined,

  hasCustomSync : undefined,

  // PUBLIC FUNCTION IMPLEMENTATIONS
  init: function(options) {
    self.consoleLog('sync - init called');

    self.config = JSON.parse(JSON.stringify(self.defaults));
    for (var i in options) {
      self.config[i] = options[i];
    }

    self.datasetMonitor();
  },

  notify: function(callback) {
    self.notify_callback = callback;
  },

  manage: function(dataset_id, options, query_params, meta_data, cb) {
    self.consoleLog('manage - START');

    var options = options || {};

    var doManage = function(dataset) {
      self.consoleLog('doManage dataset :: initialised = ' + dataset.initialised + " :: " + dataset_id + ' :: ' + JSON.stringify(options));

      var datasetConfig = self.setOptions(options);

      dataset.query_params = query_params || dataset.query_params || {};
      dataset.meta_data = meta_data || dataset.meta_data || {};
      dataset.config = datasetConfig;
      dataset.syncRunning = false;
      dataset.syncPending = true;
      dataset.initialised = true;
      dataset.meta = {};

      self.saveDataSet(dataset_id, function() {

        if( cb ) {
          cb();
        }
      });
    };

    // Check if the dataset is already loaded
    self.getDataSet(dataset_id, function(dataset) {
      self.consoleLog('manage - dataset already loaded');
      doManage(dataset);
    }, function(err) {
      self.consoleLog('manage - dataset not loaded... trying to load');

      // Not already loaded, try to load from local storage
      self.loadDataSet(dataset_id, function(dataset) {
          self.consoleLog('manage - dataset loaded from local storage');

          // Loading from local storage worked

          // Fire the local update event to indicate that dataset was loaded from local storage
          self.doNotify(dataset_id, null, self.notifications.LOCAL_UPDATE_APPLIED, "load");

          // Put the dataet under the management of the sync service
          doManage(dataset);
        },
        function(err) {
          // No dataset in memory or local storage - create a new one and put it in memory
          self.consoleLog('manage - Creating new dataset for id ' + dataset_id);
          var dataset = {};
          dataset.data = {};
          dataset.pending = {};
          self.datasets[dataset_id] = dataset;
          doManage(dataset);
        });
    });
  },

  setOptions: function(options) {
    // Make sure config is initialised
    if( ! self.config ) {
      self.config = JSON.parse(JSON.stringify(self.defaults));
    }

    var datasetConfig = JSON.parse(JSON.stringify(self.config));
    var optionsIn = JSON.parse(JSON.stringify(options));
    for (var k in optionsIn) {
      datasetConfig[k] = optionsIn[k];
    }

    return datasetConfig;
  },

  list: function(dataset_id, success, failure) {
    self.getDataSet(dataset_id, function(dataset) {
      if (dataset && dataset.data) {
        // Return a copy of the dataset so updates will not automatically make it back into the dataset
        var res = JSON.parse(JSON.stringify(dataset.data));
        success(res);
      } else {
        if(failure) failure('no_data');
      }
    }, function(code, msg) {
      if(failure) failure(code, msg);
    });
  },

  create: function(dataset_id, data, success, failure) {
    self.addPendingObj(dataset_id, null, data, "create", success, failure);
  },

  read: function(dataset_id, uid, success, failure) {
      self.getDataSet(dataset_id, function(dataset) {
      var rec = dataset.data[uid];
      if (!rec) {
        failure("unknown_uid");
      } else {
        // Return a copy of the record so updates will not automatically make it back into the dataset
        var res = JSON.parse(JSON.stringify(rec));
        success(res);
      }
    }, function(code, msg) {
      if(failure) failure(code, msg);
    });
  },

  update: function(dataset_id, uid, data, success, failure) {
    self.addPendingObj(dataset_id, uid, data, "update", success, failure);
  },

  'delete': function(dataset_id, uid, success, failure) {
    self.addPendingObj(dataset_id, uid, null, "delete", success, failure);
  },

  getPending: function(dataset_id, cb) {
    self.getDataSet(dataset_id, function(dataset) {
      var res;
      if( dataset ) {
        res = dataset.pending;
      }
      cb(res);
    }, function(err, datatset_id) {
        self.consoleLog(err);
    });
  },

  clearPending: function(dataset_id, cb) {
    self.getDataSet(dataset_id, function(dataset) {
      dataset.pending = {};
      self.saveDataSet(dataset_id, cb);
    });
  },

  listCollisions : function(dataset_id, success, failure){
    self.getDataSet(dataset_id, function(dataset) {
      self.doCloudCall({
        "dataset_id": dataset_id,
        "req": {
          "fn": "listCollisions",
          "meta_data" : dataset.meta_data
        }
      }, success, failure);
    }, failure);
  },

  removeCollision: function(dataset_id, colissionHash, success, failure) {
    self.getDataSet(dataset_id, function(dataset) {
      self.doCloudCall({
        "dataset_id" : dataset_id,
        "req": {
          "fn": "removeCollision",
          "hash": colissionHash,
          meta_data: dataset.meta_data
        }
      }, success, failure);
    });
  },


  // PRIVATE FUNCTIONS
  isOnline: function(callback) {
    var online = true;

    // first, check if navigator.online is available
    if(typeof navigator.onLine !== "undefined"){
      online = navigator.onLine;
    }

    // second, check if Phonegap is available and has online info
    if(online){
      //use phonegap to determin if the network is available
      if(typeof navigator.network !== "undefined" && typeof navigator.network.connection !== "undefined"){
        var networkType = navigator.network.connection.type;
        if(networkType === "none" || networkType === null) {
          online = false;
        }
      }
    }

    return callback(online);
  },

  doNotify: function(dataset_id, uid, code, message) {

    if( self.notify_callback ) {
      if ( self.config['notify_' + code] ) {
        var notification = {
          "dataset_id" : dataset_id,
          "uid" : uid,
          "code" : code,
          "message" : message
        };
        // make sure user doesn't block
        setTimeout(function () {
          self.notify_callback(notification);
        }, 0);
      }
    }
  },

  getDataSet: function(dataset_id, success, failure) {
    var dataset = self.datasets[dataset_id];

    if (dataset) {
      success(dataset);
    } else {
      failure('unknown_dataset ' + dataset_id, dataset_id);
    }
  },

  getQueryParams: function(dataset_id, success, failure) {
    var dataset = self.datasets[dataset_id];

    if (dataset) {
      success(dataset.query_params);
    } else {
      failure('unknown_dataset ' + dataset_id, dataset_id);
    }
  },

  setQueryParams: function(dataset_id, queryParams, success, failure) {
    var dataset = self.datasets[dataset_id];

    if (dataset) {
      dataset.query_params = queryParams;
      self.saveDataSet(dataset_id);
      if( success ) {
        success(dataset.query_params);
      }
    } else {
      if ( failure ) {
        failure('unknown_dataset ' + dataset_id, dataset_id);
      }
    }
  },

  getMetaData: function(dataset_id, success, failure) {
    var dataset = self.datasets[dataset_id];

    if (dataset) {
      success(dataset.meta_data);
    } else {
      failure('unknown_dataset ' + dataset_id, dataset_id);
    }
  },

  setMetaData: function(dataset_id, metaData, success, failure) {
    var dataset = self.datasets[dataset_id];

    if (dataset) {
      dataset.meta_data = metaData;
      self.saveDataSet(dataset_id);
      if( success ) {
        success(dataset.meta_data);
      }
    } else {
      if( failure ) {
        failure('unknown_dataset ' + dataset_id, dataset_id);
      }
    }
  },

  getConfig: function(dataset_id, success, failure) {
    var dataset = self.datasets[dataset_id];

    if (dataset) {
      success(dataset.config);
    } else {
      failure('unknown_dataset ' + dataset_id, dataset_id);
    }
  },

  setConfig: function(dataset_id, config, success, failure) {
    var dataset = self.datasets[dataset_id];

    if (dataset) {
      var fullConfig = self.setOptions(config);
      dataset.config = fullConfig;
      self.saveDataSet(dataset_id);
      if( success ) {
        success(dataset.config);
      }
    } else {
      if( failure ) {
        failure('unknown_dataset ' + dataset_id, dataset_id);
      }
    }
  },

  stopSync: function(dataset_id, success, failure) {
    self.setConfig(dataset_id, {"sync_active" : false}, function() {
      if( success ) {
        success();
      }
    }, failure);
  },

  startSync: function(dataset_id, success, failure) {
    self.setConfig(dataset_id, {"sync_active" : true}, function() {
      if( success ) {
        success();
      }
    }, failure);
  },

  doSync: function(dataset_id, success, failure) {
    var dataset = self.datasets[dataset_id];

    if (dataset) {
      dataset.syncPending = true;
      self.saveDataSet(dataset_id);
      if( success ) {
        success();
      }
    } else {
      if( failure ) {
        failure('unknown_dataset ' + dataset_id, dataset_id);
      }
    }
  },

  forceSync: function(dataset_id, success, failure) {
    var dataset = self.datasets[dataset_id];

    if (dataset) {
      dataset.syncForced = true;
      self.saveDataSet(dataset_id);
      if( success ) {
        success();
      }
    } else {
      if( failure ) {
        failure('unknown_dataset ' + dataset_id, dataset_id);
      }
    }
  },

  sortObject : function(object) {
    if (typeof object !== "object" || object === null) {
      return object;
    }

    var result = [];

    Object.keys(object).sort().forEach(function(key) {
      result.push({
        key: key,
        value: self.sortObject(object[key])
      });
    });

    return result;
  },

  sortedStringify : function(obj) {

    var str = '';

    try {
      str = JSON.stringify(self.sortObject(obj));
    } catch (e) {
      console.error('Error stringifying sorted object:' + e);
    }

    return str;
  },

  generateHash: function(object) {
    var hash = CryptoJS.SHA1(self.sortedStringify(object));
    return hash.toString();
  },

  addPendingObj: function(dataset_id, uid, data, action, success, failure) {
    self.isOnline(function (online) {
      if (!online) {
        self.doNotify(dataset_id, uid, self.notifications.OFFLINE_UPDATE, action);
      }
    });

    function storePendingObject(obj) {
      obj.hash = self.generateHash(obj);

      self.getDataSet(dataset_id, function(dataset) {

        dataset.pending[obj.hash] = obj;

        self.updateDatasetFromLocal(dataset, obj);

        if(self.config.auto_sync_local_updates) {
          dataset.syncPending = true;
        }
        self.saveDataSet(dataset_id);
        self.doNotify(dataset_id, uid, self.notifications.LOCAL_UPDATE_APPLIED, action);

        success(obj);
      }, function(code, msg) {
        if(failure) failure(code, msg);
      });
    }

    var pendingObj = {};
    pendingObj.inFlight = false;
    pendingObj.action = action;
    pendingObj.post = JSON.parse(JSON.stringify(data));
    pendingObj.postHash = self.generateHash(pendingObj.post);
    pendingObj.timestamp = new Date().getTime();
    if( "create" === action ) {
      pendingObj.uid = pendingObj.postHash;
      storePendingObject(pendingObj);
    } else {
      self.read(dataset_id, uid, function(rec) {
        pendingObj.uid = uid;
        pendingObj.pre = rec.data;
        pendingObj.preHash = self.generateHash(rec.data);
        storePendingObject(pendingObj);
      }, function(code, msg) {
        failure(code, msg);
      });
    }
  },

  syncLoop: function(dataset_id) {
    self.getDataSet(dataset_id, function(dataSet) {
    
      // The sync loop is currently active
      dataSet.syncPending = false;
      dataSet.syncRunning = true;
      dataSet.syncLoopStart = new Date().getTime();
      self.doNotify(dataset_id, null, self.notifications.SYNC_STARTED, null);

      self.isOnline(function(online) {
        if (!online) {
          self.syncComplete(dataset_id, "offline", self.notifications.SYNC_FAILED);
        } else {
          self.checkHasCustomSync(dataset_id, function() {

            var syncLoopParams = {};
            syncLoopParams.fn = 'sync';
            syncLoopParams.dataset_id = dataset_id;
            syncLoopParams.query_params = dataSet.query_params;
            syncLoopParams.config = dataSet.config;
            syncLoopParams.meta_data = dataSet.meta_data;
            //var datasetHash = self.generateLocalDatasetHash(dataSet);
            syncLoopParams.dataset_hash = dataSet.hash;
            syncLoopParams.acknowledgements = dataSet.acknowledgements || [];

            var pending = dataSet.pending;
            var pendingArray = [];
            for(var i in pending ) {
              // Mark the pending records we are about to submit as inflight and add them to the array for submission
              // Don't re-add previous inFlight pending records who whave crashed - i.e. who's current state is unknown
              // Don't add delayed records
              if( !pending[i].inFlight && !pending[i].crashed && !pending[i].delayed) {
                pending[i].inFlight = true;
                pending[i].inFlightDate = new Date().getTime();
                pendingArray.push(pending[i]);
              }
            }
            syncLoopParams.pending = pendingArray;

            if( pendingArray.length > 0 ) {
              self.consoleLog('Starting sync loop - global hash = ' + dataSet.hash + ' :: params = ' + JSON.stringify(syncLoopParams, null, 2));
            }
            try {
              self.doCloudCall({
                'dataset_id': dataset_id,
                'req': syncLoopParams
              }, function(res) {
                var rec;

                function processUpdates(updates, notification, acknowledgements) {
                  if( updates ) {
                    for (var up in updates) {
                      rec = updates[up];
                      acknowledgements.push(rec);
                      if( dataSet.pending[up] && dataSet.pending[up].inFlight && !dataSet.pending[up].crashed ) {
                        delete dataSet.pending[up];
                        self.doNotify(dataset_id, rec.uid, notification, rec);
                      }
                    }
                  }
                }

                // Check to see if any new pending records need to be updated to reflect the current state of play.
                self.updatePendingFromNewData(dataset_id, dataSet, res);

                // Check to see if any previously crashed inflight records can now be resolved
                self.updateCrashedInFlightFromNewData(dataset_id, dataSet, res);

                //Check to see if any delayed pending records can now be set to ready
                self.updateDelayedFromNewData(dataset_id, dataSet, res);

                // Update the new dataset with details of any inflight updates which we have not received a response on
                self.updateNewDataFromInFlight(dataset_id, dataSet, res);

                // Update the new dataset with details of any pending updates
                self.updateNewDataFromPending(dataset_id, dataSet, res);



                if (res.records) {
                  // Full Dataset returned
                  dataSet.data = res.records;
                  dataSet.hash = res.hash;

                  self.doNotify(dataset_id, res.hash, self.notifications.DELTA_RECEIVED, 'full dataset');
                }

                if (res.updates) {
                  var acknowledgements = [];
                  processUpdates(res.updates.applied, self.notifications.REMOTE_UPDATE_APPLIED, acknowledgements);
                  processUpdates(res.updates.failed, self.notifications.REMOTE_UPDATE_FAILED, acknowledgements);
                  processUpdates(res.updates.collisions, self.notifications.COLLISION_DETECTED, acknowledgements);
                  dataSet.acknowledgements = acknowledgements;
                }

                if (!res.records && res.hash && res.hash !== dataSet.hash) {
                  self.consoleLog("Local dataset stale - syncing records :: local hash= " + dataSet.hash + " - remoteHash=" + res.hash);
                  // Different hash value returned - Sync individual records
                  self.syncRecords(dataset_id);
                } else {
                  self.consoleLog("Local dataset up to date");
                  self.syncComplete(dataset_id,  "online", self.notifications.SYNC_COMPLETE);
                }
              }, function(msg, err) {
                // The AJAX call failed to complete succesfully, so the state of the current pending updates is unknown
                // Mark them as "crashed". The next time a syncLoop completets successfully, we will review the crashed
                // records to see if we can determine their current state.
                self.markInFlightAsCrashed(dataSet);
                self.consoleLog("syncLoop failed : msg=" + msg + " :: err = " + err);
                self.syncComplete(dataset_id, msg, self.notifications.SYNC_FAILED);
              });
            }
            catch (e) {
              self.consoleLog('Error performing sync - ' + e);
              self.syncComplete(dataset_id, e, self.notifications.SYNC_FAILED);
            }
          });
        }
      });
    });
  },

  syncRecords: function(dataset_id) {

    self.getDataSet(dataset_id, function(dataSet) {

      var localDataSet = dataSet.data || {};

      var clientRecs = {};
      for (var i in localDataSet) {
        var uid = i;
        var hash = localDataSet[i].hash;
        clientRecs[uid] = hash;
      }

      var syncRecParams = {};

      syncRecParams.fn = 'syncRecords';
      syncRecParams.dataset_id = dataset_id;
      syncRecParams.query_params = dataSet.query_params;
      syncRecParams.clientRecs = clientRecs;

      self.consoleLog("syncRecParams :: " + JSON.stringify(syncRecParams));

      self.doCloudCall({
        'dataset_id': dataset_id,
        'req': syncRecParams
      }, function(res) {
        var i;

        if (res.create) {
          for (i in res.create) {
            localDataSet[i] = {"hash" : res.create[i].hash, "data" : res.create[i].data};
            self.doNotify(dataset_id, i, self.notifications.RECORD_DELTA_RECEIVED, "create");
          }
        }
        if (res.update) {
          for (i in res.update) {
            localDataSet[i].hash = res.update[i].hash;
            localDataSet[i].data = res.update[i].data;
            self.doNotify(dataset_id, i, self.notifications.RECORD_DELTA_RECEIVED, "update");
          }
        }
        if (res['delete']) {
          for (i in res['delete']) {
            delete localDataSet[i];
            self.doNotify(dataset_id, i, self.notifications.RECORD_DELTA_RECEIVED, "delete");
          }
        }

        self.doNotify(dataset_id, res.hash, self.notifications.DELTA_RECEIVED, 'partial dataset');

        dataSet.data = localDataSet;
        if(res.hash) {
          dataSet.hash = res.hash;
        }
        self.syncComplete(dataset_id, "online", self.notifications.SYNC_COMPLETE);
      }, function(msg, err) {
        self.consoleLog("syncRecords failed : msg=" + msg + " :: err=" + err);
        self.syncComplete(dataset_id, msg, self.notifications.SYNC_FAILED);
      });
    });
  },

  syncComplete: function(dataset_id, status, notification) {

    self.getDataSet(dataset_id, function(dataset) {
      dataset.syncRunning = false;
      dataset.syncLoopEnd = new Date().getTime();
      self.saveDataSet(dataset_id);
      self.doNotify(dataset_id, dataset.hash, notification, status);
    });
  },

  checkDatasets: function() {
    for( var dataset_id in self.datasets ) {
      if( self.datasets.hasOwnProperty(dataset_id) ) {
        var dataset = self.datasets[dataset_id];

        if( !dataset.syncRunning && (dataset.config.sync_active || dataset.syncForced)) {
          // Check to see if it is time for the sync loop to run again
          var lastSyncStart = dataset.syncLoopStart;
          var lastSyncCmp = dataset.syncLoopEnd;
          if( lastSyncStart == null ) {
            self.consoleLog(dataset_id +' - Performing initial sync');
            // Dataset has never been synced before - do initial sync
            dataset.syncPending = true;
          } else if (lastSyncCmp != null) {
            var timeSinceLastSync = new Date().getTime() - lastSyncCmp;
            var syncFrequency = dataset.config.sync_frequency * 1000;
            if( timeSinceLastSync > syncFrequency ) {
              // Time between sync loops has passed - do another sync
              dataset.syncPending = true;
            }
          } 

          if( dataset.syncForced ) {
            dataset.syncPending = true;
          }

          if( dataset.syncPending ) {
            // Reset syncForced in case it was what caused the sync cycle to run.
            dataset.syncForced = false;

            // If the dataset requres syncing, run the sync loop. This may be because the sync interval has passed
            // or because the sync_frequency has been changed or because a change was made to the dataset and the
            // immediate_sync flag set to true
            self.syncLoop(dataset_id);
          }
        }
      }
    }
  },

  checkHasCustomSync : function(dataset_id, cb) {
    if(self.hasCustomSync != null) {
      return cb();
    }
    self.consoleLog('starting check has custom sync');

    actAPI({
      'act' : dataset_id,
      'req': {
        'fn': 'sync'
      }
    }, function(res) {
      //if the custom sync is defined in the cloud, this call should success.
      //if failed, we think this the custom sync is not defined
      self.consoleLog('checkHasCustomSync - success - ', res);
      self.hasCustomSync = true;
      return cb();
    }, function(msg,err) {
      self.consoleLog('checkHasCustomSync - failure - ', err);
      if(err.status && err.status === 500){
        //if we receive 500, it could be that there is an error occured due to missing parameters or similar,
        //but the endpoint is defined.
        self.consoleLog('checkHasCustomSync - failed with 500, endpoint does exists');
        self.hasCustomSync = true;
      } else {
        self.hasCustomSync = false;
      }
      return cb();
    });
  },

  doCloudCall: function(params, success, failure) {
    if( self.hasCustomSync ) {
      actAPI({
        'act' : params.dataset_id,
        'req' : params.req
      }, function(res) {
        success(res);
      }, function(msg, err) {
        failure(msg, err);
      });      
    } else {
      cloudAPI({
        'path' : '/mbaas/sync/' + params.dataset_id,
        'method' : 'post',
        'data' : params.req
      }, function(res) {
        success(res);
      }, function(msg, err) {
        failure(msg, err);
      })
    }
  },

  datasetMonitor: function() {
    self.checkDatasets();

    // Re-execute datasetMonitor every 500ms so we keep invoking checkDatasets();
    setTimeout(function() {
      self.datasetMonitor();
    }, 500);
  },

  saveDataSet: function (dataset_id, cb) {
    var onFail =  function(msg, err) {
      // save failed
      var errMsg = 'save to local storage failed  msg:' + msg + ' err:' + err;
      self.doNotify(dataset_id, null, self.notifications.CLIENT_STORAGE_FAILED, errMsg);
      self.consoleLog(errMsg);
    };
    self.getDataSet(dataset_id, function(dataset) {
      // save dataset to local storage
      Lawnchair({fail:onFail, adapter: self.config.storage_strategy, size:self.config.file_system_quota}, function (){
        this.save({key:"dataset_" + dataset_id, val:dataset}, function(){
          //save success
          if(cb) return cb();
        });
      });
    });
  },

  loadDataSet: function (dataset_id, success, failure) {
    // load dataset from local storage
    var onFail = function(msg, err) {
      // load failed
      var errMsg = 'load from local storage failed  msg:' + msg;
      self.doNotify(dataset_id, null, self.notifications.CLIENT_STORAGE_FAILED, errMsg);
      self.consoleLog(errMsg);
    };

        Lawnchair({fail:onFail, adapter: self.config.storage_strategy, size:self.config.file_system_quota},function (){       this.get( "dataset_" + dataset_id, function (data){
         if (data && data.val !== null) {
            var dataset = data.val;
            if(typeof dataset === "string"){
              dataset = JSON.parse(dataset);
            }
            // Datasets should not be auto initialised when loaded - the mange function should be called for each dataset
            // the user wants sync
            dataset.initialised = false;
            self.datasets[dataset_id] = dataset; // TODO: do we need to handle binary data?
            self.consoleLog('load from local storage success for dataset_id :' + dataset_id);
            if(success) return success(dataset);
          } else {
            // no data yet, probably first time. failure calback should handle this
            if(failure) return failure();
          }
       });
    });
  },


  updateDatasetFromLocal: function(dataset, pendingRec) {
    var pending = dataset.pending;
    var previousPendingUid;
    var previousPending;

    var uid = pendingRec.uid;
    self.consoleLog('updating local dataset for uid ' + uid + ' - action = ' + pendingRec.action);

    dataset.meta[uid] = dataset.meta[uid] || {};

    // Creating a new record
    if( pendingRec.action === "create" ) {
      if( dataset.data[uid] ) {
        self.consoleLog('dataset already exists for uid in create :: ' + JSON.stringify(dataset.data[uid]));

        // We are trying to do a create using a uid which already exists
        if (dataset.meta[uid].fromPending) {
          // We are trying to create on top of an existing pending record
          // Remove the previous pending record and use this one instead
          previousPendingUid = dataset.meta[uid].pendingUid;
          delete pending[previousPendingUid];
        }
      }
      dataset.data[uid] = {};
    }

    if( pendingRec.action === "update" ) {
      if( dataset.data[uid] ) {
        if (dataset.meta[uid].fromPending) {
          self.consoleLog('updating an existing pending record for dataset :: ' + JSON.stringify(dataset.data[uid]));
          // We are trying to update an existing pending record
          previousPendingUid = dataset.meta[uid].pendingUid;
          dataset.meta[uid].previousPendingUid = previousPendingUid;
          previousPending = pending[previousPendingUid];
          if(previousPending) {
            if(!previousPending.inFlight){
              self.consoleLog('existing pre-flight pending record = ' + JSON.stringify(previousPending));
              // We are trying to perform an update on an existing pending record
              // modify the original record to have the latest value and delete the pending update
              previousPending.post = pendingRec.post;
              previousPending.postHash = pendingRec.postHash;
              delete pending[pendingRec.hash];
              // Update the pending record to have the hash of the previous record as this is what is now being
              // maintained in the pending array & is what we want in the meta record
              pendingRec.hash = previousPendingUid;
            } else {
              //we are performing changes to a pending record which is inFlight. Until the status of this pending record is resolved,
              //we should not submit this pending record to the cloud. Mark it as delayed.
              self.consoleLog('existing in-inflight pending record = ' + JSON.stringify(previousPending));
              pendingRec.delayed = true;
              pendingRec.waiting = previousPending.hash;
            }
          }
        }
      }
    }

    if( pendingRec.action === "delete" ) {
      if( dataset.data[uid] ) {
        if (dataset.meta[uid].fromPending) {
          self.consoleLog('Deleting an existing pending record for dataset :: ' + JSON.stringify(dataset.data[uid]));
          // We are trying to delete an existing pending record
          previousPendingUid = dataset.meta[uid].pendingUid;
          dataset.meta[uid].previousPendingUid = previousPendingUid;
          previousPending = pending[previousPendingUid];
          if( previousPending ) {
            if(!previousPending.inFlight){
              self.consoleLog('existing pending record = ' + JSON.stringify(previousPending));
              if( previousPending.action === "create" ) {
                // We are trying to perform a delete on an existing pending create
                // These cancel each other out so remove them both
                delete pending[pendingRec.hash];
                delete pending[previousPendingUid];
              }
              if( previousPending.action === "update" ) {
                // We are trying to perform a delete on an existing pending update
                // Use the pre value from the pending update for the delete and
                // get rid of the pending update
                pendingRec.pre = previousPending.pre;
                pendingRec.preHash = previousPending.preHash;
                pendingRec.inFlight = false;
                delete pending[previousPendingUid];
              }
            } else {
              self.consoleLog('existing in-inflight pending record = ' + JSON.stringify(previousPending));
              pendingRec.delayed = true;
              pendingRec.waiting = previousPending.hash;
            }
          }
        }
        delete dataset.data[uid];
      }
    }

    if( dataset.data[uid] ) {
      dataset.data[uid].data = pendingRec.post;
      dataset.data[uid].hash = pendingRec.postHash;
      dataset.meta[uid].fromPending = true;
      dataset.meta[uid].pendingUid = pendingRec.hash;
    }
  },

  updatePendingFromNewData: function(dataset_id, dataset, newData) {
    var pending = dataset.pending;
    var newRec;

    if( pending && newData.records) {
      for( var pendingHash in pending ) {
        if( pending.hasOwnProperty(pendingHash) ) {
          var pendingRec = pending[pendingHash];

          dataset.meta[pendingRec.uid] = dataset.meta[pendingRec.uid] || {};

          if( pendingRec.inFlight === false ) {
            // Pending record that has not been submitted
            self.consoleLog('updatePendingFromNewData - Found Non inFlight record -> action=' + pendingRec.action +' :: uid=' + pendingRec.uid  + ' :: hash=' + pendingRec.hash);
            if( pendingRec.action === "update" || pendingRec.action === "delete") {
              // Update the pre value of pending record to reflect the latest data returned from sync.
              // This will prevent a collision being reported when the pending record is sent.
              newRec = newData.records[pendingRec.uid];
              if( newRec ) {
                self.consoleLog('updatePendingFromNewData - Updating pre values for existing pending record ' + pendingRec.uid);
                pendingRec.pre = newRec.data;
                pendingRec.preHash = newRec.hash;
              }
              else {
                // The update/delete may be for a newly created record in which case the uid will have changed.
                var previousPendingUid = dataset.meta[pendingRec.uid].previousPendingUid;
                var previousPending = pending[previousPendingUid];
                if( previousPending ) {
                  if( newData && newData.updates &&  newData.updates.applied && newData.updates.applied[previousPending.hash] ) {
                    // There is an update in from a previous pending action
                    var newUid = newData.updates.applied[previousPending.hash].uid;
                    newRec = newData.records[newUid];
                    if( newRec ) {
                      self.consoleLog('updatePendingFromNewData - Updating pre values for existing pending record which was previously a create ' + pendingRec.uid + ' ==> ' + newUid);
                      pendingRec.pre = newRec.data;
                      pendingRec.preHash = newRec.hash;
                      pendingRec.uid = newUid;
                    }
                  }
                }
              }
            }

            if( pendingRec.action === "create" ) {
              if( newData && newData.updates &&  newData.updates.applied && newData.updates.applied[pendingHash] ) {
                self.consoleLog('updatePendingFromNewData - Found an update for a pending create ' + JSON.stringify(newData.updates.applied[pendingHash]));
                newRec = newData.records[newData.updates.applied[pendingHash].uid];
                if( newRec ) {
                  self.consoleLog('updatePendingFromNewData - Changing pending create to an update based on new record  ' + JSON.stringify(newRec));

                  // Set up the pending create as an update
                  pendingRec.action = "update";
                  pendingRec.pre = newRec.data;
                  pendingRec.preHash = newRec.hash;
                  pendingRec.uid = newData.updates.applied[pendingHash].uid;
                }
              }
            }
          }
        }
      }
    }
  },

  updateNewDataFromInFlight: function(dataset_id, dataset, newData) {
    var pending = dataset.pending;

    if( pending && newData.records) {
      for( var pendingHash in pending ) {
        if( pending.hasOwnProperty(pendingHash) ) {
          var pendingRec = pending[pendingHash];

          if( pendingRec.inFlight ) {
            var updateReceivedForPending = (newData && newData.updates &&  newData.updates.hashes && newData.updates.hashes[pendingHash]) ? true : false;

            self.consoleLog('updateNewDataFromInFlight - Found inflight pending Record - action = ' + pendingRec.action + ' :: hash = ' + pendingHash + ' :: updateReceivedForPending=' + updateReceivedForPending);

            if( ! updateReceivedForPending ) {
              var newRec = newData.records[pendingRec.uid];

              if( pendingRec.action === "update" && newRec) {
                // Modify the new Record to have the updates from the pending record so the local dataset is consistent
                newRec.data = pendingRec.post;
                newRec.hash = pendingRec.postHash;
              }
              else if( pendingRec.action === "delete" && newRec) {
                // Remove the record from the new dataset so the local dataset is consistent
                delete newData.records[pendingRec.uid];
              }
              else if( pendingRec.action === "create" ) {
                // Add the pending create into the new dataset so it is not lost from the UI
                self.consoleLog('updateNewDataFromInFlight - re adding pending create to incomming dataset');
                var newPendingCreate = {
                  data: pendingRec.post,
                  hash: pendingRec.postHash
                };
                newData.records[pendingRec.uid] = newPendingCreate;
              }
            }
          }
        }
      }
    }
  },

  updateNewDataFromPending: function(dataset_id, dataset, newData) {
    var pending = dataset.pending;

    if( pending && newData.records) {
      for( var pendingHash in pending ) {
        if( pending.hasOwnProperty(pendingHash) ) {
          var pendingRec = pending[pendingHash];

          if( pendingRec.inFlight === false ) {
            self.consoleLog('updateNewDataFromPending - Found Non inFlight record -> action=' + pendingRec.action +' :: uid=' + pendingRec.uid  + ' :: hash=' + pendingRec.hash);
            var newRec = newData.records[pendingRec.uid];
            if( pendingRec.action === "update" && newRec) {
              // Modify the new Record to have the updates from the pending record so the local dataset is consistent
              newRec.data = pendingRec.post;
              newRec.hash = pendingRec.postHash;
            }
            else if( pendingRec.action === "delete" && newRec) {
              // Remove the record from the new dataset so the local dataset is consistent
              delete newData.records[pendingRec.uid];
            }
            else if( pendingRec.action === "create" ) {
              // Add the pending create into the new dataset so it is not lost from the UI
              self.consoleLog('updateNewDataFromPending - re adding pending create to incomming dataset');
              var newPendingCreate = {
                data: pendingRec.post,
                hash: pendingRec.postHash
              };
              newData.records[pendingRec.uid] = newPendingCreate;
            }
          }
        }
      }
    }
  },

  updateCrashedInFlightFromNewData: function(dataset_id, dataset, newData) {
    var updateNotifications = {
      applied: self.notifications.REMOTE_UPDATE_APPLIED,
      failed: self.notifications.REMOTE_UPDATE_FAILED,
      collisions: self.notifications.COLLISION_DETECTED
    };

    var pending = dataset.pending;
    var resolvedCrashes = {};
    var pendingHash;
    var pendingRec;


    if( pending ) {
      for( pendingHash in pending ) {
        if( pending.hasOwnProperty(pendingHash) ) {
          pendingRec = pending[pendingHash];

          if( pendingRec.inFlight && pendingRec.crashed) {
            self.consoleLog('updateCrashedInFlightFromNewData - Found crashed inFlight pending record uid=' + pendingRec.uid + ' :: hash=' + pendingRec.hash );
            if( newData && newData.updates && newData.updates.hashes) {

              // Check if the updates received contain any info about the crashed in flight update
              var crashedUpdate = newData.updates.hashes[pendingHash];
              if( crashedUpdate ) {
                // We have found an update on one of our in flight crashed records

                resolvedCrashes[crashedUpdate.uid] = crashedUpdate;

                self.consoleLog('updateCrashedInFlightFromNewData - Resolving status for crashed inflight pending record ' + JSON.stringify(crashedUpdate));

                if( crashedUpdate.type === 'failed' ) {
                  // Crashed update failed - revert local dataset
                  if( crashedUpdate.action === 'create' ) {
                    self.consoleLog('updateCrashedInFlightFromNewData - Deleting failed create from dataset');
                    delete dataset.data[crashedUpdate.uid];
                  }
                  else if ( crashedUpdate.action === 'update' || crashedUpdate.action === 'delete' ) {
                    self.consoleLog('updateCrashedInFlightFromNewData - Reverting failed ' + crashedUpdate.action + ' in dataset');
                    dataset.data[crashedUpdate.uid] = {
                      data : pendingRec.pre,
                      hash : pendingRec.preHash
                    };
                  }
                }

                delete pending[pendingHash];
                self.doNotify(dataset_id, crashedUpdate.uid, updateNotifications[crashedUpdate.type], crashedUpdate);
              }
              else {
                // No word on our crashed update - increment a counter to reflect another sync that did not give us
                // any update on our crashed record.
                if( pendingRec.crashedCount ) {
                  pendingRec.crashedCount++;
                }
                else {
                  pendingRec.crashedCount = 1;
                }
              }
            }
            else {
              // No word on our crashed update - increment a counter to reflect another sync that did not give us
              // any update on our crashed record.
              if( pendingRec.crashedCount ) {
                pendingRec.crashedCount++;
              }
              else {
                pendingRec.crashedCount = 1;
              }
            }
          }
        }
      }

      for( pendingHash in pending ) {
        if( pending.hasOwnProperty(pendingHash) ) {
          pendingRec = pending[pendingHash];

          if( pendingRec.inFlight && pendingRec.crashed) {
            if( pendingRec.crashedCount > dataset.config.crashed_count_wait ) {
              self.consoleLog('updateCrashedInFlightFromNewData - Crashed inflight pending record has reached crashed_count_wait limit : ' + JSON.stringify(pendingRec));
              if( dataset.config.resend_crashed_updates ) {
                self.consoleLog('updateCrashedInFlightFromNewData - Retryig crashed inflight pending record');
                pendingRec.crashed = false;
                pendingRec.inFlight = false;
              }
              else {
                self.consoleLog('updateCrashedInFlightFromNewData - Deleting crashed inflight pending record');
                delete pending[pendingHash];
              }
            }
          }
          else if (!pendingRec.inFlight && pendingRec.crashed ) {
            self.consoleLog('updateCrashedInFlightFromNewData - Trying to resolve issues with crashed non in flight record - uid = ' + pendingRec.uid);
            // Stalled pending record because a previous pending update on the same record crashed
            var crashedRef = resolvedCrashes[pendingRec.uid];
            if( crashedRef ) {
              self.consoleLog('updateCrashedInFlightFromNewData - Found a stalled pending record backed up behind a resolved crash uid=' + pendingRec.uid + ' :: hash=' + pendingRec.hash);
              pendingRec.crashed = false;
            }
          }
        }
      }
    }
  },

  updateDelayedFromNewData: function(dataset_id, dataset, newData){
    var pending = dataset.pending;
    var pendingHash;
    var pendingRec;
    if(pending){
      for( pendingHash in pending ){
        if( pending.hasOwnProperty(pendingHash) ){
          pendingRec = pending[pendingHash];
          if( pendingRec.delayed && pendingRec.waiting ){
            self.consoleLog('updateDelayedFromNewData - Found delayed pending record uid=' + pendingRec.uid + ' :: hash=' + pendingRec.hash + ' :: waiting=' + pendingRec.waiting);
            if( newData && newData.updates && newData.updates.hashes ){
              var waitingRec = newData.updates.hashes[pendingRec.waiting];
              if(waitingRec){
                self.consoleLog('updateDelayedFromNewData - Waiting pending record is resolved rec=' + JSON.stringify(waitingRec));
                pendingRec.delayed = false;
                pendingRec.waiting = undefined;
              }
            }
          }
        }
      }
    }
  },


  markInFlightAsCrashed : function(dataset) {
    var pending = dataset.pending;
    var pendingHash;
    var pendingRec;

    if( pending ) {
      var crashedRecords = {};
      for( pendingHash in pending ) {
        if( pending.hasOwnProperty(pendingHash) ) {
          pendingRec = pending[pendingHash];

          if( pendingRec.inFlight ) {
            self.consoleLog('Marking in flight pending record as crashed : ' + pendingHash);
            pendingRec.crashed = true;
            crashedRecords[pendingRec.uid] = pendingRec;
          }
        }
      }

      // Check for any pending updates that would be modifying a crashed record. These can not go out until the
      // status of the crashed record is determined
      for( pendingHash in pending ) {
        if( pending.hasOwnProperty(pendingHash) ) {
          pendingRec = pending[pendingHash];

          if( ! pendingRec.inFlight && ! pendingRec.delayed ) {
            var crashedRef = crashedRecords[pendingRec.uid];
            if( crashedRef ) {
              pendingRec.crashed = true;
            }
          }
        }
      }
    }
  },

  consoleLog: function(msg) {
    if( self.config.do_console_log ) {
      console.log(msg);
    }
  }
};

(function() {
  self.config = self.defaults;
  //Initialse the sync service with default config
  //self.init({});
})();

module.exports = {
  init: self.init,
  manage: self.manage,
  notify: self.notify,
  doList: self.list,
  doCreate: self.create,
  doRead: self.read,
  doUpdate: self.update,
  doDelete: self['delete'],
  listCollisions: self.listCollisions,
  removeCollision: self.removeCollision,
  getPending : self.getPending,
  clearPending : self.clearPending,
  getDataset : self.getDataSet,
  getQueryParams: self.getQueryParams,
  setQueryParams: self.setQueryParams,
  getMetaData: self.getMetaData,
  setMetaData: self.setMetaData,
  getConfig: self.getConfig,
  setConfig: self.setConfig,
  startSync: self.startSync,
  stopSync: self.stopSync,
  doSync: self.doSync,
  forceSync: self.forceSync,
  generateHash: self.generateHash
};
},{"../../libs/generated/crypto":1,"../../libs/generated/lawnchair":2,"./api_act":79,"./api_cloud":81,"JSON":3}],106:[function(require,module,exports){
module.exports = {
  createUUID : function () {
    //from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
    //based on RFC 4122, section 4.4 (Algorithms for creating UUID from truely random pr pseudo-random number)
    var s = [];
    var hexDigitals = "0123456789ABCDEF";
    for (var i = 0; i < 32; i++) {
      s[i] = hexDigitals.substr(Math.floor(Math.random() * 0x10), 1);
    }
    s[12] = "4";
    s[16] = hexDigitals.substr((s[16] & 0x3) | 0x8, 1);
    var uuid = s.join("");
    return uuid;
  }
};

},{}],107:[function(require,module,exports){
var initializer = require("./initializer");
var events = require("./events");
var CloudHost = require("./hosts");
var constants = require("./constants");
var logger = require("./logger");


//the cloud configurations
var cloud_host;

var is_initialising = false;
var is_cloud_ready = false;
var init_error = null;


var ready = function(cb){
  if(is_cloud_ready){
    return cb(null, {host: getCloudHostUrl()});
  } else {
    events.once(constants.INIT_EVENT, function(err, host){
      return cb(err, host);
    });
    if(!is_initialising){
      is_initialising = true;
      initializer.init(function(err, initRes){
        is_initialising = false;
        if(err){
          init_error = err;
          return events.emit(constants.INIT_EVENT, err);
        } else {
          init_error = null;
          is_cloud_ready = true;
          cloud_host = new CloudHost(initRes.cloud);
          return events.emit(constants.INIT_EVENT, null, {host: getCloudHostUrl()});
        }
      });
    }
  }
}

var getCloudHost = function(){
  return cloud_host;
}

var getCloudHostUrl = function(){
  if(typeof cloud_host !== "undefined"){
    var appProps = require("./appProps").getAppProps();
    return cloud_host.getHost(appProps.mode);
  } else {
    return undefined;
  }
}

var isReady = function(){
  return is_cloud_ready;
}

var getInitError = function(){
  return init_error;
}

//for test
var reset = function(){
  is_cloud_ready = false;
  is_initialising = false;
  cloud_host = undefined;
  init_error = undefined;
  ready(function(){
    
  });
}

ready(function(error, host){
  if(error){
    if(error.message !== "app_config_missing"){
      logger.error("Failed to initialise fh.");
    } else {
      logger.info("No fh config file");
    }
  } else {
    logger.info("fh cloud is ready");
  }
});

module.exports = {
  ready: ready,
  isReady: isReady,
  getCloudHost: getCloudHost,
  getCloudHostUrl: getCloudHostUrl,
  getInitError: getInitError,
  reset: reset
}
},{"./appProps":85,"./constants":87,"./events":90,"./hosts":93,"./initializer":94,"./logger":97}],108:[function(require,module,exports){
require("../tests/test_ajax.js");
require("../tests/test_sec.js");
require("../tests/test_cloud_related.js");
require("../tests/test_legacy_act.js");
require("../tests/test_sync_offline.js");
require("../tests/test_sync_online.js");


},{"../tests/test_ajax.js":109,"../tests/test_cloud_related.js":110,"../tests/test_legacy_act.js":111,"../tests/test_sec.js":112,"../tests/test_sync_offline.js":113,"../tests/test_sync_online.js":114}],109:[function(require,module,exports){
var chai = require('chai');
var expect = chai.expect;
var sinonChai = require('sinon-chai');
chai.use(sinonChai);

var process = require("process");
if(document && document.location){
  if(document.location.href.indexOf("coverage=1") > -1){
    process.env.LIB_COV = 1;
  }
}

var ajax = process.env.LIB_COV? require("../../src-cov/modules/ajax") : require("../../src/modules/ajax");
var events = process.env.LIB_COV? require("../../src-cov/modules/events") : require("../../src/modules/events");


describe("test ajax module", function(){

    var server;

    beforeEach(function () { server = sinon.fakeServer.create(); });
    afterEach(function () { server.restore(); });

    it("should call the success callback", function(){
      var success = sinon.spy();
      var fail = sinon.spy();

      ajax.active = 0;

      var ajaxStart = sinon.spy();
      var ajaxSend = sinon.spy();
      var ajaxSuccess = sinon.spy();
      var ajaxComplete = sinon.spy();

      events.on("ajaxStart", ajaxStart);
      events.on("ajaxSend", ajaxSend);
      events.on("ajaxSuccess", ajaxSuccess);
      events.on("ajaxComplete", ajaxComplete);

      server.respondWith('GET', /test_ok/, [200, {"Content-Type": "application/json"}, JSON.stringify({"result": "ok"})]);
      
      ajax({
        url: "test_ok",
        method: "GET",
        dataType: "json",
        nojsonp: true,
        success: success,
        error: fail
      });

      server.respond();

      expect(success).to.have.been.called;
      expect(success).to.have.been.calledOnce;

      expect(ajaxStart).to.have.been.calledOnce;
      expect(ajaxSend).to.have.been.calledOnce;
      expect(ajaxSuccess).to.have.been.calledOnce;
      expect(ajaxComplete).to.have.been.calledOnce;
      
    });

    it("should call the error callback", function(){
      var success = sinon.spy();
      var fail = sinon.spy();

      ajax.active = 0;

      var ajaxStart = sinon.spy();
      var ajaxSend = sinon.spy();
      var ajaxError = sinon.spy();
      var ajaxComplete = sinon.spy();

      events.on("ajaxStart", ajaxStart);
      events.on("ajaxSend", ajaxSend);
      events.on("ajaxError", ajaxError);
      events.on("ajaxComplete", ajaxComplete);

      server.respondWith('GET', /test_error/, [404, {"Content-Type": "application/json"}, "NOT FOUND"]);

      ajax({
        url: "test_error",
        method: "GET",
        dataType: "json",
        nojsonp: true,
        success: success,
        error: fail
      });

      server.respond();

      expect(fail).to.have.been.called;
      expect(fail).to.have.been.calledOnce;

      expect(ajaxStart).to.have.been.calledOnce;
      expect(ajaxSend).to.have.been.calledOnce;
      expect(ajaxError).to.have.been.calledOnce;
      expect(ajaxComplete).to.have.been.calledOnce;

    });
  });


},{"../../src-cov/modules/ajax":54,"../../src-cov/modules/events":61,"../../src/modules/ajax":78,"../../src/modules/events":90,"chai":5,"process":49,"sinon-chai":50}],110:[function(require,module,exports){
var chai = require('chai');
var expect = chai.expect;
var sinonChai = require('sinon-chai');

var process = require("process");
if(document && document.location){
  if(document.location.href.indexOf("coverage=1") > -1){
    process.env.LIB_COV = 1;
  }
}

var ajax = process.env.LIB_COV? require("../../src-cov/modules/ajax") : require("../../src/modules/ajax");
var qs = process.env.LIB_COV? require("../../src-cov/modules/queryMap"): require("../../src/modules/queryMap");


chai.use(sinonChai);

var fhconfig = {
  "host": "http://localhost:8100",
  "appid" : "testappid",
  "appkey" : "testappkey",
  "projectid" : "testprojectid",
  "connectiontag" : "testconnectiontag"
}

var apphost = {
  domain: "testing",
  firstTime: false,
  hosts: {
    "url": "http://localhost:8101"
  },
  init: {
    "trackId": "testtrackid"
  }
}

var expectedUrl = "http://localhost:8101";
if(document && document.location){
  var doc_url = document.location.href;
  var url_params = qs(doc_url);
  var local = (typeof url_params.url !== 'undefined');
  if(local){
    expectedUrl = url_params.url;
  }
}


var buildFakeRes = function(data){
  return [200, {"Content-Type": "text/script"}, JSON.stringify(data)]; //we deliberately set the wrong content type here to make sure the response does get converted to JSON
}

var initFakeServer = function(server){
   server.respondWith('GET', /fhconfig.json/, buildFakeRes(fhconfig));

   server.respondWith('POST', /init/, buildFakeRes(apphost));
}

describe("test all cloud related", function(){

  var server;

  beforeEach(function () { server = sinon.fakeServer.create(); });
  afterEach(function () { server.restore(); });

  describe("test auto initialisation", function(){
    it("should emit fhinit events", function(){

      var callback = sinon.spy();
      var cb2 = sinon.spy();

      initFakeServer(server);
      var $fh = process.env.LIB_COV? require("../../src-cov/feedhenry") : require("../../src/feedhenry");
      //at this point, $fh is already initialised (and failed), it will not emit another fhinit event 
      //until another call to any $fh cloud APIs, so for testing, call reset which will force it to re-intialise again.
      $fh.reset();

      $fh.on('fhinit', callback);
      $fh.on('fhinit', cb2);

      server.respond();
      server.respond();
      //host url is overridden by the url in the request
      expect(callback).to.have.been.called;
      expect(callback).to.have.been.calledOnce;
      expect(callback).to.have.been.calledWith(null, {host: expectedUrl});

      expect(cb2).to.have.been.called;
      expect(cb2).to.have.been.calledOnce;

      var hostUrl = $fh.getCloudURL();
      expect(hostUrl).to.equal(expectedUrl);

      
      expect($fh).to.have.property("cloud_props");
      expect($fh.cloud_props).to.have.property("hosts");
      expect($fh.cloud_props.hosts).to.have.property("url");
      expect($fh.cloud_props.hosts.url).to.equal(expectedUrl);

      expect($fh).to.have.property("app_props");
    });
  });

  describe("test act/cloud call", function(){
    it("act call should success", function(){
      var success = sinon.spy();
      var fail = sinon.spy();

      initFakeServer(server);

      var data = {echo: 'hi'};

      server.respondWith('POST', /cloud\/echo/, buildFakeRes(data));

      var $fh = process.env.LIB_COV? require("../../src-cov/feedhenry") : require("../../src/feedhenry");
      $fh.reset();

      $fh.act({}, success, fail);

      expect(fail).to.have.been.calledOnce;

      var fail2 = sinon.spy();

      $fh.act({act: 'echo', req: {}}, success, fail2);

      server.respond();
      server.respond();
      server.respond();

      expect(success).to.have.been.calledOnce;
      expect(success).to.have.been.calledWith(data);

      expect(fail2).to.have.not.been.called;
    });

    it("should work with cloud call", function(){
      var success = sinon.spy();
      var fail = sinon.spy();

      initFakeServer(server);

      var data = {echo: 'hi'};

      server.respondWith('POST', /test\/echo/, buildFakeRes(data));

      var $fh = process.env.LIB_COV? require("../../src-cov/feedhenry") : require("../../src/feedhenry");
      $fh.reset();

      $fh.cloud({
        path: 'test/echo',
        method: 'POST'
      }, success, fail);

      server.respond();
      server.respond();
      server.respond();

      expect(success).to.have.been.calledOnce;
      expect(success).to.have.been.calledWith(data);
      expect(fail).to.have.not.been.called;
    });
  });

  describe("test auth call", function(){
    it("auth call should work", function(){
      initFakeServer(server);
      server.respondWith('POST', /authpolicy/, buildFakeRes({status: "ok"}));

      var $fh = process.env.LIB_COV? require("../../src-cov/feedhenry") : require("../../src/feedhenry");
      $fh.reset();

      var success = sinon.spy();
      var fail = sinon.spy();
      $fh.auth({}, success, fail);
      expect(fail).to.have.been.calledOnce;

      fail = sinon.spy();
      $fh.auth({policyId: 'testpolicy', clientToken: 'testtoken', transport: ajax}, success, fail);

      server.respond();
      server.respond();
      server.respond();

      expect(success).to.have.been.calledOnce;
      expect(fail).to.have.not.been.called;
    });
  });

  describe("test mbaas call", function(){
    it("mbaas call should call", function(){
      initFakeServer(server);
      server.respondWith('POST', /mbaas\/forms/, buildFakeRes({"status": "ok"}));

      var $fh = process.env.LIB_COV? require("../../src-cov/feedhenry") : require("../../src/feedhenry");
      $fh.reset();

      var success = sinon.spy();
      var fail = sinon.spy();

      $fh.mbaas({service: "forms"}, success, fail);

      server.respond();
      server.respond();
      server.respond();

      expect(success).to.have.been.calledOnce;
      expect(fail).to.have.not.been.called;
      expect(success).to.have.been.calledWith({"status": "ok"});

    });
  });
});
},{"../../src-cov/feedhenry":"f312fA","../../src-cov/modules/ajax":54,"../../src-cov/modules/queryMap":70,"../../src/feedhenry":76,"../../src/modules/ajax":78,"../../src/modules/queryMap":99,"chai":5,"process":49,"sinon-chai":50}],111:[function(require,module,exports){
var chai = require('chai');
var expect = chai.expect;
var sinonChai = require('sinon-chai');
chai.use(sinonChai);

var process = require("process");
if(document && document.location){
  if(document.location.href.indexOf("coverage=1") > -1){
    process.env.LIB_COV = 1;
  }
}

var qs = process.env.LIB_COV? require("../../src-cov/modules/queryMap"): require("../../src/modules/queryMap");

var fhconfig = {
  "host": "http://localhost:8100",
  "appid" : "testappid",
  "appkey" : "testappkey",
  "mode": "dev"
}

var legacyAppHost = {
  domain: "testing",
  firstTime: false,
  hosts: {
    "releaseCloudUrl": "http://localhost:8102",
    "releaseCloudType": "fh",
    "debugCloudUrl": "http://localhost:8103",
    "debugCloudType": "fh"
  },
  init: {
    "trackId": "testtrackid"
  }
}

var expectedUrl = "http://localhost:8103";
if(document && document.location){
  var doc_url = document.location.href;
  var url_params = qs(doc_url);
  var local = (typeof url_params.url !== 'undefined');
  if(local){
    expectedUrl = url_params.url;
  }
}

var buildFakeRes = function(data){
  return [200, {"Content-Type": "application/json"}, JSON.stringify(data)];
}

var initFakeServer = function(server){
   server.respondWith('GET', /fhconfig.json/, buildFakeRes(fhconfig));

   server.respondWith('POST', /init/, buildFakeRes(legacyAppHost));
}

describe("test legacy app props/app init", function(){
  var server;

  beforeEach(function () { server = sinon.fakeServer.create(); });
  afterEach(function () { server.restore(); });

  describe("test legacy app init", function(){
    it("$fh.init should initialise the app", function(){
      var callback = sinon.spy();

      initFakeServer(server);
      var $fh = process.env.LIB_COV? require("../../src-cov/feedhenry") : require("../../src/feedhenry");

      $fh.reset();

      $fh.init({}, callback);
      server.respond();
      server.respond();

      expect(callback).to.have.been.called;
      expect(callback).to.have.been.calledOnce;
      expect(callback).to.have.been.calledWith(expectedUrl);

      var hostUrl = $fh.getCloudURL();
      expect(hostUrl).to.equal(expectedUrl);
    });
  });

  describe("test auto initialisation", function(){
    it("should emit fhinit events", function(){

      var callback = sinon.spy();

      initFakeServer(server);
      var $fh = process.env.LIB_COV? require("../../src-cov/feedhenry") : require("../../src/feedhenry");
      
      $fh.reset();

      $fh.on('fhinit', callback);

      server.respond();
      server.respond();

      expect(callback).to.have.been.called;
      expect(callback).to.have.been.calledOnce;
      expect(callback).to.have.been.calledWith(null, {host: expectedUrl});

      var hostUrl = $fh.getCloudURL();
      expect(hostUrl).to.equal(expectedUrl);

    });
  });
});
},{"../../src-cov/feedhenry":"f312fA","../../src-cov/modules/queryMap":70,"../../src/feedhenry":76,"../../src/modules/queryMap":99,"chai":5,"process":49,"sinon-chai":50}],112:[function(require,module,exports){
var chai = require('chai');
var expect = chai.expect;
var sinonChai = require('sinon-chai');
chai.use(sinonChai);

var process = require("process");
if(document && document.location){
  if(document.location.href.indexOf("coverage=1") > -1){
    process.env.LIB_COV = 1;
  }
}

var $fh = process.env.LIB_COV? require("../../src-cov/feedhenry") : require("../../src/feedhenry");

describe("test security APIs", function(){
  it("AES keygen", function(){
    var fail = sinon.spy();

    $fh.sec({act:'keygen', params:{algorithm:'AES', keysize: 128}}, function(keys){
      expect(keys).to.have.property("secretkey");
      expect(keys).to.have.property("iv");
      expect(keys.secretkey.length).to.equal(128/8*2);
      expect(keys.iv.length).to.equal(128/8*2);
    }, fail);

    expect(fail).to.have.not.been.called;
  });

  it("AES encrypt/decrypt", function(){
    var sk = '75174B7CD709B84F35053B1855107EC6';
    var iv = '92587F0EF7AEDE613CD20725B5499649';
    var plaintext = '2be464fe54ccefa2c9bdc7231275a995';
    var ciphertext = '4fb2a388dabb4f11e71711c9279c5c496aed4f1d75e4115300fb30ff19ec323f9770be1945532377bb99d50bcee29667';

    $fh.sec({act:'encrypt', params:{key: sk, iv: iv, plaintext:plaintext, algorithm:'AES'}}, function(result){
      expect(ciphertext).to.equal(result.ciphertext);
    });

    $fh.sec({act:'decrypt', params:{key: sk, iv: iv, ciphertext:ciphertext, algorithm:'AES'}}, function(result){
      expect(plaintext).to.equal(result.plaintext);
    });
  });

  it("RSA encrypt", function(){
    var modulu = "a5261939975948bb7a58dffe5ff54e65f0498f9175f5a09288810b8975871e99\naf3b5dd94057b0fc07535f5f97444504fa35169d461d0d30cf0192e307727c06\n5168c788771c561a9400fb49175e9e6aa4e23fe11af69e9412dd23b0cb6684c4\nc2429bce139e848ab26d0829073351f4acd36074eafd036a5eb83359d2a698d3";
    var plaintext = "This is test";
    $fh.sec({act:'encrypt', params:{algorithm:'RSA', modulu: modulu, plaintext:plaintext}}, function(result){
      var pri = "8e9912f6d3645894e8d38cb58c0db81ff516cf4c7e5a14c7f1eddb1459d2cded\n4d8d293fc97aee6aefb861859c8b6a3d1dfe710463e1f9ddc72048c09751971c\n4a580aa51eb523357a3cc48d31cfad1d4a165066ed92d4748fb6571211da5cb1\n4bc11b6e2df7c1a559e6d5ac1cd5c94703a22891464fba23d0d965086277a161";
      var p = "d090ce58a92c75233a6486cb0a9209bf3583b64f540c76f5294bb97d285eed33\naec220bde14b2417951178ac152ceab6da7090905b478195498b352048f15e7d";
      var q = "cab575dc652bb66df15a0359609d51d1db184750c00c6698b90ef3465c996551\n03edbf0d54c56aec0ce3c4d22592338092a126a0cc49f65a4a30d222b411e58f";
      var dmp1 = "1a24bca8e273df2f0e47c199bbf678604e7df7215480c77c8db39f49b000ce2c\nf7500038acfff5433b7d582a01f1826e6f4d42e1c57f5e1fef7b12aabc59fd25";
      var dmq1 = "3d06982efbbe47339e1f6d36b1216b8a741d410b0c662f54f7118b27b9a4ec9d\n914337eb39841d8666f3034408cf94f5b62f11c402fc994fe15a05493150d9fd";
      var coeff = "3a3e731acd8960b7ff9eb81a7ff93bd1cfa74cbd56987db58b4594fb09c09084\ndb1734c8143f98b602b981aaa9243ca28deb69b5b280ee8dcee0fd2625e53250";
      expect(result).to.have.property("ciphertext");
    });
  });

  it("hash", function(){
    var hash_plain_text = "This is to test hash";
    var expected_md5_hash = "ee1d3042dc4d6cc9995665b667f1d45b";
    var expected_sha1_hash = "0f6671c91c659e162815bef002b36a90ba961306";
    var expected_sha256_hash = "77593f2fe4df58d6d11f9b31dcc6e7f55ec63d42ad87ea0df6a94b81b9307941";
    var expected_sha512_hash = "79d598a87aca45e51bd6c644976c20d6f7bb1cc32d635b350b24b2cd16a025e41d30df2a8696916e896c9a98e2b4bc62c05922c7e340c57e14e5d623af77e5b6";

    $fh.hash({algorithm:'md5', text: hash_plain_text}, function(result){
      expect(expected_md5_hash).to.equal(result.hashvalue);
    });

    $fh.hash({algorithm:'sha1', text: hash_plain_text}, function(result){
      expect(expected_sha1_hash).to.equal(result.hashvalue);
    });

    $fh.hash({algorithm:'sha256', text: hash_plain_text}, function(result){
      expect(expected_sha256_hash).to.equal(result.hashvalue);
    });

    $fh.hash({algorithm:'sha512', text: hash_plain_text}, function(result){
      expect(expected_sha512_hash).to.equal(result.hashvalue);
    });
  });
})
},{"../../src-cov/feedhenry":"f312fA","../../src/feedhenry":76,"chai":5,"process":49,"sinon-chai":50}],113:[function(require,module,exports){
var process = require("process");
if(document && document.location){
  if(document.location.href.indexOf("coverage=1") > -1){
    process.env.LIB_COV = 1;
  }
}
var syncClient = process.env.LIB_COV? require("../../src-cov/modules/sync-cli") : require("../../src/modules/sync-cli");
var chai = require('chai');
var expect = chai.expect;
var sinonChai = require('sinon-chai');
var _ = require("underscore");

chai.use(sinonChai);

//work around phantomjs's issue: https://github.com/ariya/phantomjs/issues/10647
var fakeNavigator = {};
for (var i in navigator) { 
    fakeNavigator[i] = navigator[i];
}
fakeNavigator.onLine = true;
navigator = fakeNavigator;

syncClient.init({
  do_console_log: true,
  sync_frequency: 1,
  sync_active: false,
  storage_strategy: ['memory'],
  crashed_count_wait: 0
});

describe("test sync framework offline", function(){
  this.timeout(5000);
  var dataSetId = "testDataset";
  before(function(done){
    syncClient.manage(dataSetId, null, null, null, done);
  });

  beforeEach(function(){

  });

  afterEach(function(done){
    syncClient.notify(undefined);
    syncClient.stopSync(dataSetId, done, done);
  });

  it("sync.manage", function(done){
    var opts = {"file_system_quota": 1*1024*1024, crashed_count_wait: 5};
    var qp = {"query":"test"};
    var meta_data = {"user": "test"};
    syncClient.manage(dataSetId, opts, qp, meta_data, function(){
      syncClient.getDataset(dataSetId, function(dataset){
        expect(dataset.config.file_system_quota).to.equal(1*1024*1024);
        expect(dataset.config.crashed_count_wait).to.equal(5);
        expect(dataset.config.do_console_log).to.equal(true);
        expect(dataset.query_params).equal(qp);
        expect(dataset.meta_data).equal(meta_data);

        expect(dataset.meta).to.be.empty;
        done();
      });
    });
  });

  it("sync.setConfig/getConfig", function(done){
    var opts = {"file_system_quota": 10*1024*1024, crashed_count_wait: 10};
    var fail = sinon.spy();
    syncClient.setConfig(dataSetId, opts, function(conf){
      expect(fail).to.have.not.been.called;

      syncClient.getConfig(dataSetId, function(config){
        expect(conf.file_system_quota).to.equal(10*1024*1024);
        expect(conf.crashed_count_wait).to.equal(10);

        expect(conf.do_console_log).to.equal(true);
        done();
      });
    }, fail);
  });

  it("sync.getQueryParams/setQueryParams", function(done){
    var qp = {"q":"t"};
    var fail = sinon.spy();

    syncClient.setQueryParams(dataSetId, qp, function(){
      expect(fail).have.not.been.called;

      syncClient.getQueryParams(dataSetId, function(query){
        expect(query).equal(qp);
        done();
      });

    }, fail);
  });

  it("sync.getMetaData/setMetaData", function(done){
    var mdata = {meta:"test"};

    var fail = sinon.spy();
    syncClient.setMetaData(dataSetId, mdata, function(){
      expect(fail).have.not.been.called;
      syncClient.getMetaData(dataSetId, function(meta){
        expect(meta).equal(mdata);
        done();
      });
    }, fail);
  });



  it("sync.notify", function(done){
    var startCallback = sinon.spy();
    var failCallback = sinon.spy();
    var compCallback = sinon.spy();


    syncClient.notify(function(e){
      switch(e.code){
        case "sync_started":
          startCallback(e.code);
          break;
        case "sync_failed":
          failCallback(e.code);
          break;
        case "sync_complete":
          compCallback();
          break;
        default:
          break;
      }
    });

    syncClient.startSync(dataSetId, function(){

      setTimeout(function(){
        expect(startCallback).to.have.been.called;
        expect(failCallback).to.have.been.called;
        expect(failCallback).to.have.been.calledWith('sync_failed');

        expect(compCallback).to.have.not.been.called;

        syncClient.stopSync(dataSetId, function(){
          done();
        });

      }, 600);

    });
  });

  var uid;

  it("sync.doCreate", function(done){
    var success = sinon.spy();
    var fail = sinon.spy();

    var updateCB = sinon.spy();

    var data = {"name": "item1"};
    var hash = syncClient.generateHash(data);
    uid = hash;

    syncClient.notify(function(e){
      switch(e.code){
        case 'local_update_applied':
          updateCB(e.dataset_id, e.uid, e.code, e.message);
          break;
        default:
          break;
      }
    })

    syncClient.doCreate(dataSetId, data, function(){

      expect(fail).to.have.not.been.called;
      //now the new data should be in the dataset as well as the pending set
      var getFail = sinon.spy();
      syncClient.getDataset(dataSetId, function(dataset){
        expect(getFail).to.have.not.been.called;

        //the current dataset should have the new data entry
        expect(dataset.data).to.have.keys(hash);
        expect(JSON.stringify(dataset.data[hash].data)).to.equal(JSON.stringify(data));

        //the new data entry should be added to the pending data
        expect(_.size(dataset.pending)).to.equal(1);
        var pendingObj = _.values(dataset.pending)[0];
        console.log(pendingObj);
        expect(pendingObj.action).to.equal("create");
        expect(pendingObj.inFlight).to.be.false;
        expect(pendingObj.uid).to.equal(hash);
        expect(JSON.stringify(pendingObj.post)).to.equal(JSON.stringify(data));
        expect(pendingObj.postHash).to.equal(hash);
        expect(pendingObj.pre).to.be.undefined;

        var meta = dataset.meta[hash];
        expect(meta.fromPending).to.be.true;
        expect(meta.pendingUid).to.equal(pendingObj.hash);

        //the notification function is called inside a setTimeout wrapper, so need to wait another 1ms to make sure
        //the notification does get invoked.
        setTimeout(function(){
          expect(updateCB).to.have.been.called;
          expect(updateCB).to.have.been.calledWith(dataSetId, null, "local_update_applied", "create");
          done();
        }, 1);
        
      }, getFail);

    }, fail);

  });


  it("sync.doUpdate", function(done){
    var success = sinon.spy();
    var fail = sinon.spy();

    var updateCB = sinon.spy();

    var data = {"name": "item1_updated"};
    var hash = syncClient.generateHash(data);

    syncClient.notify(function(e){
      switch(e.code){
        case 'local_update_applied':
          updateCB(e.dataset_id, e.uid, e.code, e.message);
          break;
        default:
          break;
      }
    });

    syncClient.doUpdate(dataSetId, uid, data, function(){
      expect(fail).to.have.not.been.called;

      var getFail = sinon.spy();

      syncClient.getDataset(dataSetId, function(dataset){
        expect(getFail).to.have.not.been.called;

        //now the dataset should have the updated data
        expect(JSON.stringify(dataset.data[uid].data)).to.equal(JSON.stringify(data));

        //check pending records, since we are updating a pending data record,
        //there should still only one pending data entry
        expect(_.size(dataset.pending)).to.equal(1);
        var pendingObj = _.values(dataset.pending)[0];

        console.log(pendingObj);
        //it should still be "create" action
        expect(pendingObj.action).to.equal("create");
        expect(pendingObj.inFlight).to.be.false;
        expect(pendingObj.uid).to.equal(uid);
        expect(JSON.stringify(pendingObj.post)).to.equal(JSON.stringify(data));
        expect(pendingObj.postHash).to.equal(hash);
        expect(pendingObj.pre).to.be.undefined;

        //the notification function is called inside a setTimeout wrapper, so need to wait another 1ms to make sure
        //the notification does get invoked.
        setTimeout(function(){
          expect(updateCB).to.have.been.called;
          expect(updateCB).to.have.been.calledWith(dataSetId, uid, "local_update_applied", "update");
          syncClient.notify(undefined);
          done();
        }, 1);

      }, getFail);

    }, fail);
  });

  it("sync.doList success", function(done){ 
    var fail = sinon.spy();

    syncClient.doList(dataSetId, function(data){
      expect(fail).to.have.not.been.called;

      expect(_.size(data)).to.equal(1);
      expect(data[uid].data.name).to.equal("item1_updated");
      done();
    }, fail);

  });

  it("sync.doList fail", function(done){
    var success = sinon.spy();

    syncClient.doList("invalidDataSet", success, function(err){
      expect(err).to.equal("unknown_dataset invalidDataSet");
      done();
    });
  });

  it("sync.doRead success", function(done){
    var fail = sinon.spy();

    syncClient.doRead(dataSetId, uid, function(data){
      expect(fail).to.have.not.been.called;
      expect(data.data.name).equal("item1_updated");
      done();
    }, fail);
  });

  it("sync.doRead fail", function(done){
    var success = sinon.spy();

    syncClient.doRead(dataSetId, "invalidid", success, function(err){
      expect(success).to.have.not.been.called;
      expect(err).to.equal("unknown_uid");
      done();
    });
  });

  it("sync.getPending", function(done){
    var fail = sinon.spy();

    syncClient.getPending(dataSetId, function(pending){
      expect(fail).have.not.been.called;
      expect(_.size(pending)).to.equal(1);
      done();
    }, fail);
  });

  it("sync.stopSync/startSync", function(done){

    var cb1 = sinon.spy();
    var cb2 = sinon.spy();

    syncClient.stopSync(dataSetId);

    syncClient.notify(function(e){
      console.log(e);
      switch(e.code){
        case "sync_started":
          cb1(e.code);
          break;
        case "sync_failed":
          cb2(e.code);
          break;
        default:
          break;
      }
    });

    setTimeout(function(){
      //a syncLoop should already be run, but since we stopped sync,
      //none of the notifications should be fired
      expect(cb1).not.have.been.called;
      expect(cb2).not.have.been.called;

      //start sync
      syncClient.startSync(dataSetId, function(){
        setTimeout(function(){
          expect(cb1).have.been.calledOnce;
          expect(cb2).have.been.calledOnce;

          done();
        }, 1001);
      });
      
    }, 1001);
  });

  it("sync.doDelete", function(done){
    var fail = sinon.spy();

    syncClient.doDelete(dataSetId, uid, function(dataset){
      expect(fail).to.have.not.been.called;

      //the data should be gone now
      expect(_.size(dataset.data)).to.equal(0);
      //the pending data should be gone as well
      expect(_.size(dataset.pending)).to.equal(0);
      done();
    }, fail);
  });

  it("sync.doSync", function(done){

    var cb1 = sinon.spy();
    var cb2 = sinon.spy();


    syncClient.notify(function(e){
      console.log(e);
      switch(e.code){
        case "sync_started":
          cb1(e.code);
          break;
        case "sync_failed":
          cb2(e.code);
          break;
        default:
          break;
      }
    });

    //start sync
    syncClient.startSync(dataSetId, function(){
      syncClient.doSync(dataSetId, function(){
        //once doSync is called, a sync loop should happen in next 500ms
        //no matter what the value of sync freqency
        setTimeout(function(){
          expect(cb1).have.been.calledOnce;
          expect(cb2).have.been.calledOnce;

          done();
        }, 501);
      });
    });
  });

  it("sync.forceSync", function(done){
    var cb1 = sinon.spy();
    var cb2 = sinon.spy();


    syncClient.notify(function(e){
      console.log(e);
      switch(e.code){
        case "sync_started":
          cb1(e.code);
          break;
        case "sync_failed":
          cb2(e.code);
          break;
        default:
          break;
      }
    });

    //sync is stopped, but if forceSync is called, a sync loop will still happen
    syncClient.forceSync(dataSetId, function(){
      //once doSync is called, a sync loop should happen in next 500ms
      //no matter what the value of sync freqency
      setTimeout(function(){
        expect(cb1).have.been.calledOnce;
        expect(cb2).have.been.calledOnce;

        done();
      }, 501);
    });
  });
});
},{"../../src-cov/modules/sync-cli":73,"../../src/modules/sync-cli":105,"chai":5,"process":49,"sinon-chai":50,"underscore":52}],114:[function(require,module,exports){
var process = require("process");
if(document && document.location){
  if(document.location.href.indexOf("coverage=1") > -1){
    process.env.LIB_COV = 1;
  }
}

var syncClient = process.env.LIB_COV? require("../../src-cov/modules/sync-cli") : require("../../src/modules/sync-cli");
var chai = require('chai');
var expect = chai.expect;
var sinonChai = require('sinon-chai');
var _ = require("underscore");

chai.use(sinonChai);

//work around phantomjs's issue: https://github.com/ariya/phantomjs/issues/10647
var fakeNavigator = {};
for (var i in navigator) { 
    fakeNavigator[i] = navigator[i];
}
fakeNavigator.onLine = true;
navigator = fakeNavigator;

var dataSetId = "myShoppingList";
var onSync = function(cb){
  syncClient.forceSync(dataSetId, function(){
    setTimeout(function(){
      cb();
    }, 501);
  });
}

syncClient.init({
  do_console_log: true,
  sync_frequency: 1,
  sync_active: false,
  storage_strategy: ['memory'],
  crashed_count_wait: 0
});

describe("test sync framework online with fake XMLHttpRequest", function(){
  this.timeout(10000);
  var header = { "Content-Type": "application/json" };
  var xhr, requests;
  before(function(done){
    syncClient.manage(dataSetId, {"sync_active": false}, {}, {}, done);
  });

  beforeEach(function(done){
    xhr = sinon.useFakeXMLHttpRequest();
    requests = [];

    xhr.onCreate = function(req){
      console.log("Got sync request", req);
      requests.push(req);
    }

    syncClient.clearPending(dataSetId, function(){
      done(); 
    });
  });

  afterEach(function(done){
    xhr.restore();
    syncClient.notify(undefined);
    syncClient.stopSync(dataSetId, done, done);
  });

  it("load initial dataset from remote", function(done){
    //since we want to check what requests have been sent and their data,
    //we turn off sync and use forceSync to control sync loop
    onSync(function(){
      //verify there is one request is in the queue
      expect(requests.length).to.equal(1);

      var reqObj = requests[0];
      expect(reqObj.url).to.have.string("/mbaas/sync/" + dataSetId);
      expect(reqObj.method.toLowerCase()).to.equal("post");
      var reqBody = JSON.parse(reqObj.requestBody);
      expect(reqBody.fn).to.equal("sync");
      expect(reqBody.pending).is.empty;

      //return hash
      var mockHash = "97d170e1550eee4afc0af065b78cda302a97674c";
      reqObj.respond(200, header, JSON.stringify({
        "hash": mockHash,
        "records": {},
        "updates": {}
      }));

      //server turned empty dataset, then the client dataset should be empty as well
      syncClient.getDataset(dataSetId, function(dataset){
        expect(dataset.data).is.empty;
        expect(dataset.hash).to.equal(mockHash);
        done();
      });
    });
  });

  it("try create a new record", function(done){

    var record = {"name":"item1", "created": 1396537178817};

    onSync(function(){
      expect(requests.length).to.equal(1);
      var reqObj = requests[0];
      var reqBody = JSON.parse(reqObj.requestBody);
      var mockHash = "97d170e1550eee4afc0af065b78cda302a97674c";
      expect(reqBody.dataset_hash).to.equal(mockHash);

      reqObj.respond(200, header, JSON.stringify({
        "updates": {}
      }));

      //server turned empty dataset, then the client dataset should be empty as well
      syncClient.getDataset(dataSetId, function(dataset){
        expect(dataset.data).is.empty;
        expect(dataset.hash).to.equal(mockHash);

        //now add a new record
        
        var fail = sinon.spy();
        syncClient.doCreate(dataSetId, record, function(){
          //try to create the same record multiple times will generate the same hash, 
          //which will only create one pending request
          syncClient.doCreate(dataSetId, record, function(){
            expect(fail).to.have.not.been.called;
            //force sync and check the request params
            onSync(function(){
              checkUpdateRequest();
            });
          });

        }, fail);
      });
    });

    var checkUpdateRequest = function(){
      expect(requests.length).to.equal(2);
      var reqObj = requests[1];
      var reqBody = JSON.parse(reqObj.requestBody);
      expect(reqBody.pending.length).to.equal(1);

      var pendingObj = reqBody.pending[0];
      expect(pendingObj.inFlight).to.be.true;
      expect(pendingObj.action).to.equal("create");
      expect(JSON.stringify(pendingObj.post)).to.equal(JSON.stringify(record));

      var pendingHash = pendingObj.hash;

      var mockRes = {
        "hash": "424e4dff5aa27c2fb7bf0fc74d39b94dae4572eb",
        "updates": {
            "hashes": {
            },
            "applied": {
            }
        }
      }

      mockRes.updates.hashes[pendingHash] = {
        "cuid": "9F3930FE2A434E0BA0AD6F5A40C77CD7",
        "type": "applied",
        "action": "create",
        "hash": "22870dd40b175292b3e60d63240d57b4b8b5a623",
        "uid": "533d775a8e8159d9c6000001",
        "msg": "''"
      }

      mockRes.updates.applied[pendingHash] = {
        "cuid": "9F3930FE2A434E0BA0AD6F5A40C77CD7",
        "type": "applied",
        "action": "create",
        "hash": "22870dd40b175292b3e60d63240d57b4b8b5a623",
        "uid": "533d775a8e8159d9c6000001",
        "msg": "''"
      }

      reqObj.respond(200, header, JSON.stringify(mockRes));
      //the sync client should try to syncRecords immediately
      
      expect(requests.length).to.equal(3);
      var reqObj1 = requests[2];
      var reqBody1 = JSON.parse(reqObj1.requestBody);

      expect(reqObj1.url).to.have.string("/mbaas/sync/" + dataSetId);
      expect(reqBody1.fn).to.equal("syncRecords");
      expect(_.size(reqBody1.clientRecs)).to.equal(1); //there is one record in the client

      var mockRes1 = {
        "create": {
            "533d775a8e8159d9c6000001": {
                "data": {
                    "name": "item1",
                    "created": 1396537178817
                },
                "hash": "9cd301d6d51d038249dd7cfaf3ac88e4f76dfeb2"
            }
        },
        "update": {},
        "delete": {
            "9cd301d6d51d038249dd7cfaf3ac88e4f76dfeb2": {}
        },
        "hash": "424e4dff5aa27c2fb7bf0fc74d39b94dae4572eb"
      }

      reqObj1.respond(200, header, JSON.stringify(mockRes1));
      //verify local dataset contains the same data as server
      syncClient.getDataset(dataSetId, function(dataset){
        expect(_.size(dataset.data)).to.equal(1);
        console.log(dataset);
        expect(_.keys(dataset.data)[0]).to.equal("533d775a8e8159d9c6000001");
        expect(_.values(dataset.data)[0].hash).to.equal("9cd301d6d51d038249dd7cfaf3ac88e4f76dfeb2");
        expect(JSON.stringify(_.values(dataset.data)[0].data)).to.equal(JSON.stringify(record));
        expect(dataset.hash).to.equal("424e4dff5aa27c2fb7bf0fc74d39b94dae4572eb");
        done();
      });
      
    }
  });

  it("try to update an existing record ", function(done){
    var pre = {"name":"item1", "created": 1396537178817};
    var record = { "name": "item1_updat_failed", "created": 1396537178817};
    var update = { "name": "item1_updated", "created": 1396537178817};
    var uid = "533d775a8e8159d9c6000001";
    syncClient.doUpdate(dataSetId, uid, record, function(){

      onSync(function(){
        expect(requests.length).to.equal(1);
        var reqObj = requests[0];
        var reqBody = JSON.parse(reqObj.requestBody);
        expect(reqBody.pending.length).to.equal(1);

        var pendingObj = reqBody.pending[0];
        expect(pendingObj.inFlight).to.be.true;
        expect(pendingObj.action).to.equal("update");
        expect(JSON.stringify((pendingObj.pre))).to.equal(JSON.stringify((pre)));
        expect(JSON.stringify(pendingObj.post)).to.equal(JSON.stringify(record));

        //pretend to be offline or bad network
        reqObj.respond(0, null, null);
        //verify the data is marked with crashed
        syncClient.getDataset(dataSetId, function(dataset){
          expect(dataset.data[uid].data.name).to.equal("item1_updat_failed");
          console.log(dataset.pending);
          expect(_.size(dataset.pending)).to.equal(1);
          expect(_.values(dataset.pending)[0].crashed).to.be.true;

          //now update an already crashed record:
          syncClient.doUpdate(dataSetId, uid, update, function(){
            syncClient.getDataset(dataSetId, function(dataset){
              //at this point, there should be 2 pending objects
              expect(_.size(dataset.pending)).to.equal(2);

              var delayed = _.findWhere(dataset.pending, {delayed: true});
              var crashed = _.findWhere(dataset.pending, {crashed: true});
              expect(delayed).not.null;

              onSync(function(){
                expect(requests.length).to.equal(2);
                var reqObj1 = requests[1];
                var reqBody1 = JSON.parse(reqObj1.requestBody);
                expect(reqBody1.pending.length).to.equal(0); //one is crashed and the other is delayed

                reqObj1.respond(200, header, JSON.stringify({hash: dataset.hash})); //increase the crash count

                expect(crashed.crashedCount).to.equal(1);

                onSync(function(){

                  //do another sync, this time the crash data should be sent again
                  //as the crashCount is greater than the threshold
                  expect(requests.length).to.equal(3);
                  var reqObj2 = requests[2];
                  var reqBody2 = JSON.parse(reqObj2.requestBody);
                  expect(reqBody2.pending.length).to.equal(1);
                  var pendingHash = reqBody2.pending[0].hash;
                  var predata = reqBody2.pending[0].pre;
                  var prehash = reqBody2.pending[0].preHash;


                  var mockRes = {
                    "hash": "424e4dff5aa27c2fb7bf0fc74d39b94dae4572eb",
                    "updates": {
                      "hashes": {
                      },
                      "collisions": {
                      }
                    }, 
                    "records": {

                    }
                  }

                   mockRes.updates.hashes[pendingHash] = mockRes.updates.collisions[pendingHash] = {
                    "cuid": "9F3930FE2A434E0BA0AD6F5A40C77CD7",
                    "type": "collision",
                    "action": "update",
                    "hash": pendingHash,
                    "uid": "533d775a8e8159d9c6000001",
                    "msg": "''"
                  }
                  
                  mockRes.records[uid] = {
                    data: predata,
                    hash: prehash
                  }


                  reqObj2.respond(200, header, JSON.stringify(mockRes));

                  expect(_.size(dataset.pending)).to.equal(1);

                  expect(_.values(dataset.pending)[0].pre.name).to.equal("item1");

                  onSync(function(){
                    expect(requests.length).to.equal(4);
                    var reqObj3 = requests[3];
                    var reqBody3 = JSON.parse(reqObj3.requestBody);

                    expect(reqBody3.pending.length).to.equal(1);
                    var pendingHash = reqBody3.pending[0].hash;
                    var predata = reqBody3.pending[0].pre;
                    var prehash = reqBody3.pending[0].preHash;

                    var mockRes = {
                      "hash": "932b0b7e6862d4634dc6f418da717c78c1a1d742",
                      "updates": {
                        "hashes": {
                        },
                        "applied": {
                        }
                      }
                    }

                     mockRes.updates.hashes[pendingHash] = mockRes.updates.applied[pendingHash] = {
                      "cuid": "9F3930FE2A434E0BA0AD6F5A40C77CD7",
                      "type": "applied",
                      "action": "update",
                      "hash": pendingHash,
                      "uid": "533d775a8e8159d9c6000001",
                      "msg": "''"
                    }

                    reqObj3.respond(200, header, JSON.stringify(mockRes));

                    //should start syncRecords
                    expect(requests.length).to.equal(5);

                    var reqObj4 = requests[4];
                    var mockRes1 = {
                        "create": {},
                        "update": {},
                        "delete": {},
                        "hash": "932b0b7e6862d4634dc6f418da717c78c1a1d742"
                    }
                    reqObj4.respond(200, header, JSON.stringify(mockRes1));

                    expect(dataset.hash).to.equal("932b0b7e6862d4634dc6f418da717c78c1a1d742");
                    expect(_.size(dataset.pending)).to.equal(0);
                    expect(dataset.data[uid].data.name).to.equal("item1_updated");

                    done();
                  });
                });
              });
            });
          });
        });
      });
    });
  });

  it("test create & delete", function(done){
    var record = {name:"item3"};
    syncClient.doCreate(dataSetId, record, function(res){
      syncClient.getDataset(dataSetId, function(dataset){
        expect(_.size(dataset.pending)).to.equal(1);
        var uid = res.uid;
        syncClient.doDelete(dataSetId, uid, function(res){
          expect(_.size(dataset.pending)).to.equal(0);
          done();
        });
      });
    });
  });

  it("test remote data change", function(done){
    onSync(function(){
      expect(requests.length).to.equal(1);

      var reqObj = requests[0];
      var reqBody = JSON.parse(reqObj.requestBody);

      expect(reqBody.pending.length).to.equal(0);

      var mockRes = {
        hash : "21daec303c7d93b7d806823eaaaab6b82f036097"
      }

      reqObj.respond(200, header, JSON.stringify(mockRes));

      expect(requests.length).to.equal(2);

      var reqObj1 = requests[1];
      var reqBody1 = JSON.parse(reqObj1.requestBody);
      expect(_.size(reqBody1.clientRecs)).to.equal(1);

      var mockRes1 = {
        hash : "21daec303c7d93b7d806823eaaaab6b82f036097",
        create: {
          "533d77a38e8159d9c6000003": {
            "data": {
                "name": "item2",
                "created": 1396537250692
            },
            "hash": "9f37f46126a1c18ff3b13de06d8fc6a8f4fd1167"
          }
        }
      }

      reqObj1.respond(200, header, JSON.stringify(mockRes1));

      syncClient.getDataset(dataSetId, function(dataset){
        expect(_.size(dataset.data)).to.equal(2);
        expect(dataset.data['533d77a38e8159d9c6000003'].data.name).to.equal("item2");
        done();
      });
    });
  });

  it("test delete existing data", function(done){
    var uid = "533d77a38e8159d9c6000003";
    var record = {name:"item_updated_again"};
    syncClient.doUpdate(dataSetId, uid, record, function(){
      syncClient.getDataset(dataSetId, function(dataset){
        expect(_.size(dataset.pending)).to.equal(1);

        syncClient.doDelete(dataSetId, uid, function(){

          expect(_.size(dataset.pending)).to.equal(1);
          expect(_.values(dataset.pending)[0].pre.name).to.equal("item2");

          onSync(function(){
            expect(requests.length).to.equal(1);

            var reqObj = requests[0];
            var reqBody = JSON.parse(reqObj.requestBody);

            expect(reqBody.pending.length).to.equal(1);
            expect(reqBody.pending[0].uid).to.equal(uid);

            var pendingHash = reqBody.pending[0].hash;

            var mockRes = {
                "hash": "f9f17defccf22d9bf1d0fb73e1f6af6b67c266e8",
                "updates": {
                  "hashes": {},
                  "applied": {}
                }
            }

            mockRes.updates.hashes[pendingHash] = mockRes.updates.applied[pendingHash] = {
              "cuid": "9F3930FE2A434E0BA0AD6F5A40C77CD7",
              "type": "applied",
              "action": "delete",
              "hash": pendingHash,
              "uid": "533d77a38e8159d9c6000003",
              "msg": "''"
            }

            reqObj.respond(200, header, JSON.stringify(mockRes));

            expect(requests.length).to.equal(2);
            
            var reqObj1 = requests[1];
            var reqBody1 = JSON.parse(reqObj1.requestBody);
            expect(reqBody1.fn).to.equal("syncRecords");

            expect(_.size(reqBody1.clientRecs)).to.equal(1);

            var mockRes1 = {
              "create": {},
              "update": {},
              "delete": {},
              "hash": "f9f17defccf22d9bf1d0fb73e1f6af6b67c266e8"
            }

            reqObj1.respond(200, header, JSON.stringify(mockRes1));

            syncClient.getDataset(dataSetId, function(dataset){
              expect(dataset.hash).to.equal("f9f17defccf22d9bf1d0fb73e1f6af6b67c266e8");
              expect(_.size(dataset.data)).to.equal(1);
              expect(_.size(dataset.pending)).to.equal(0);
              done();
            });
          });
        });
      });
    });
  });

  it("test update pending data", function(done){
    var record = {name:"item4"};
    var updated = {name:"item4_updated"};
    syncClient.doCreate(dataSetId, record, function(res){
      onSync(function(){
        expect(requests.length).to.equal(1);
        var reqObj = requests[0];
        var reqBody = JSON.parse(reqObj.requestBody);

        var pendingObj = reqBody.pending[0];
        var pendingHash = pendingObj.hash;

        //at this point, the new record should be inflight, try to update it
        syncClient.doUpdate(dataSetId, res.uid, updated, function(){
          //then got response for the update
          var mockRes = {
            "hash": "424e4dff5aa27c2fb7bf0fc74d39b944823234832",
            "updates": {
                "hashes": {
                },
                "applied": {
                }
            },
            records: {
              "533d775a8e8159d9c6000005": {
                "data": {
                  "cuid": "9F3930FE2A434E0BA0AD6F5A40C77CD7",
                  "type": "applied",
                  "action": "create",
                  "hash": pendingHash,
                  "uid": "533d775a8e8159d9c6000005",
                  "msg": "''"
                },
                "hash": pendingHash
              }
            }
          }

          mockRes.updates.hashes[pendingHash] = {
            "cuid": "9F3930FE2A434E0BA0AD6F5A40C77CD7",
            "type": "applied",
            "action": "create",
            "hash": pendingHash,
            "uid": "533d775a8e8159d9c6000005",
            "msg": "''"
          }

          mockRes.updates.applied[pendingHash] = {
            "cuid": "9F3930FE2A434E0BA0AD6F5A40C77CD7",
            "type": "applied",
            "action": "create",
            "hash": pendingHash,
            "uid": "533d775a8e8159d9c6000005",
            "msg": "''"
          }

          reqObj.respond(200, header, JSON.stringify(mockRes));

          syncClient.getDataset(dataSetId, function(dataset){
            var pending = dataset.pending;
            expect(_.size(pending)).to.equal(1);
            var pendingObj = _.values(pending)[0];
            expect(pendingObj.preHash).to.equal(pendingHash);
            expect(pendingObj.uid).to.equal("533d775a8e8159d9c6000005");
            done();
          });
        });
      });
    });
  });

  it("test create pending data", function(done){
    var record = {name:"item5"};
    onSync(function(){
      var reqObj = requests[0];
      var reqBody = JSON.parse(reqObj.requestBody);

      syncClient.doCreate(dataSetId, record, function(res){
        //at this point, there is one pending create, 
        syncClient.getDataset(dataSetId, function(dataset){
          var pendings = dataset.pending;
          console.log("pending", pendings);
          var pendingObj = _.values(pendings)[0];
          expect(pendingObj.action).to.equal("create");
          var pendingHash = pendingObj.hash;
          var mockRes = {
            "updates": {
                "hashes": {
                },
                "applied": {
                }
            },
            records: {
              "533d775a8e8159d9c6000006": {
                "data": {
                  "cuid": "9F3930FE2A434E0BA0AD6F5A40C77CD7",
                  "type": "applied",
                  "action": "create",
                  "hash": pendingHash,
                  "uid": "533d775a8e8159d9c6000006",
                  "msg": "''"
                },
                "hash": pendingHash
              }
            }
          }

          mockRes.updates.hashes[pendingHash] = {
            "cuid": "9F3930FE2A434E0BA0AD6F5A40C77CD7",
            "type": "applied",
            "action": "create",
            "hash": pendingHash,
            "uid": "533d775a8e8159d9c6000006",
            "msg": "''"
          }

          mockRes.updates.applied[pendingHash] = {
            "cuid": "9F3930FE2A434E0BA0AD6F5A40C77CD7",
            "type": "applied",
            "action": "create",
            "hash": pendingHash,
            "uid": "533d775a8e8159d9c6000006",
            "msg": "''"
          }

          reqObj.respond(200, header, JSON.stringify(mockRes));

          expect(pendingObj.action).to.equal("update");

          done();

        });
      });
    });
  });

  // it("test updateNewDataFromInFlight", function(done){
  //   var record = {name:"item6"};
  //   syncClient.doCreate(dataSetId, record, function(res){
  //     onSync(function(){
  //       var reqObj = requests[0];
  //       var reqBody = JSON.parse(reqObj.requestBody);
  //       var pendingObj = reqBody.pending[0];
  //       var mockRes = {
  //         records : {

  //         }
  //       }

  //       reqObj.respond(200, header, JSON.stringify(mockRes));

  //       syncClient.getDataset(dataSetId, function(dataset){
  //         expect(dataset.data[pendingObj.uid].data.name).to.equal("item6");
  //         done();
  //       });
  //     });
  //   });
  // });

  it("test updateNewDataFromInFlight create/update", function(done){
    var record = {name:"item7"};
    syncClient.doCreate(dataSetId, record, function(res){
      onSync(function(){
        var reqObj = requests[0];
        var reqBody = JSON.parse(reqObj.requestBody);
        var pendingObj = reqBody.pending[0];
        var mockRes = {
          records : {

          }
        }

        reqObj.respond(200, header, JSON.stringify(mockRes));
        
        syncClient.getDataset(dataSetId, function(dataset){
          expect(dataset.data[pendingObj.uid].data.name).to.equal("item7");
          
          syncClient.clearPending(dataSetId, function(){
            syncClient.doUpdate(dataSetId, res.uid, {name:"item8"}, function(){
              onSync(function(){
                var reqObj1 = requests[1];
                var reqBody1 = JSON.parse(reqObj1.requestBody);
                var pendingObj1 = reqBody1.pending[0];
                
                var mockRes1 = {
                  records : {

                  }
                }
                mockRes1.records[pendingObj1.uid] = {
                   data: {
                     name: "item9"
                   },
                   hash: "424e4dff5aa27c2fb7bf0fc74d39b944823asdfhfj"
                }
                reqObj1.respond(200, header, JSON.stringify(mockRes1));

                expect(dataset.data[pendingObj1.uid].data.name).to.equal("item8");

                syncClient.clearPending(dataSetId, function(){
                  syncClient.doDelete(dataSetId, res.uid, function(){
                    onSync(function(){
                      var reqObj2 = requests[2];
                      var reqBody2 = JSON.parse(reqObj2.requestBody);
                      var pendingObj2 = reqBody2.pending[0];
                      
                      var mockRes2 = {
                        records : {

                        }
                      }
                      mockRes2.records[pendingObj2.uid] = {
                         data: {
                           name: "item10"
                         },
                         hash: "424e4dff5aa27c2fb7bf0fc74d39b94482adfesfef"
                      }
                      reqObj2.respond(200, header, JSON.stringify(mockRes1));

                      done();
                    });
                  });
                });

              });
            });
          });
        });
      });
    });
  });

});
},{"../../src-cov/modules/sync-cli":73,"../../src/modules/sync-cli":105,"chai":5,"process":49,"sinon-chai":50,"underscore":52}]},{},[108])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbGlicy9nZW5lcmF0ZWQvY3J5cHRvLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbGlicy9nZW5lcmF0ZWQvbGF3bmNoYWlyLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbGlicy9qc29uMi5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL2xpYnMvcnNhLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbm9kZV9tb2R1bGVzL2NoYWkvaW5kZXguanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2Fzc2VydGlvbi5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2NvcmUvYXNzZXJ0aW9ucy5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9hc3NlcnQuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9pbnRlcmZhY2UvZXhwZWN0LmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvaW50ZXJmYWNlL3Nob3VsZC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2FkZENoYWluYWJsZU1ldGhvZC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2FkZE1ldGhvZC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2FkZFByb3BlcnR5LmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZmxhZy5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldEFjdHVhbC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldEVudW1lcmFibGVQcm9wZXJ0aWVzLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0TWVzc2FnZS5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldE5hbWUuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRQYXRoVmFsdWUuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRQcm9wZXJ0aWVzLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvaW5kZXguanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pbnNwZWN0LmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb2JqRGlzcGxheS5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZU1ldGhvZC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZVByb3BlcnR5LmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvdGVzdC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL3RyYW5zZmVyRmxhZ3MuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy90eXBlLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbm9kZV9tb2R1bGVzL2NoYWkvbm9kZV9tb2R1bGVzL2Fzc2VydGlvbi1lcnJvci9pbmRleC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL25vZGVfbW9kdWxlcy9kZWVwLWVxbC9pbmRleC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL25vZGVfbW9kdWxlcy9kZWVwLWVxbC9saWIvZXFsLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbm9kZV9tb2R1bGVzL2NoYWkvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL25vZGVfbW9kdWxlcy90eXBlLWRldGVjdC9pbmRleC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9jaGFpL25vZGVfbW9kdWxlcy9kZWVwLWVxbC9ub2RlX21vZHVsZXMvdHlwZS1kZXRlY3QvbGliL3R5cGUuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9hc3NlcnQvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYXNzZXJ0L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL25vZGVfbW9kdWxlcy9zaW5vbi1jaGFpL2xpYi9zaW5vbi1jaGFpLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbm9kZV9tb2R1bGVzL3R5cGUtb2YvaW5kZXguanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjLWNvdi9tb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy1jb3YvbW9kdWxlcy9hamF4LmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjLWNvdi9tb2R1bGVzL2FwaV9hY3QuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMtY292L21vZHVsZXMvYXBpX2Nsb3VkLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjLWNvdi9tb2R1bGVzL2FwcFByb3BzLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjLWNvdi9tb2R1bGVzL2NvbnN0YW50cy5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy1jb3YvbW9kdWxlcy9jb29raWVzLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjLWNvdi9tb2R1bGVzL2RldmljZS5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy1jb3YvbW9kdWxlcy9ldmVudHMuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMtY292L21vZHVsZXMvZmhwYXJhbXMuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMtY292L21vZHVsZXMvaGFuZGxlRXJyb3IuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMtY292L21vZHVsZXMvaG9zdHMuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMtY292L21vZHVsZXMvaW5pdGlhbGl6ZXIuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMtY292L21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy1jb3YvbW9kdWxlcy9sb2FkU2NyaXB0LmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjLWNvdi9tb2R1bGVzL2xvZ2dlci5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy1jb3YvbW9kdWxlcy9wbGF0Zm9ybXNNYXAuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMtY292L21vZHVsZXMvcXVlcnlNYXAuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMtY292L21vZHVsZXMvc2RrdmVyc2lvbi5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy1jb3YvbW9kdWxlcy9zZWN1cml0eS9oYXNoLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjLWNvdi9tb2R1bGVzL3N5bmMtY2xpLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjLWNvdi9tb2R1bGVzL3V1aWQuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMtY292L21vZHVsZXMvd2FpdEZvckNsb3VkLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjL2ZlZWRoZW5yeS5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy9tb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy9tb2R1bGVzL2FqYXguanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMvbW9kdWxlcy9hcGlfYWN0LmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjL21vZHVsZXMvYXBpX2F1dGguanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMvbW9kdWxlcy9hcGlfY2xvdWQuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMvbW9kdWxlcy9hcGlfaGFzaC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy9tb2R1bGVzL2FwaV9tYmFhcy5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy9tb2R1bGVzL2FwaV9zZWMuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMvbW9kdWxlcy9hcHBQcm9wcy5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy9tb2R1bGVzL2NoZWNrQXV0aC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy9tb2R1bGVzL2NvbnN0YW50cy5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy9tb2R1bGVzL2Nvb2tpZXMuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMvbW9kdWxlcy9kZXZpY2UuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMvbW9kdWxlcy9ldmVudHMuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMvbW9kdWxlcy9maHBhcmFtcy5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy9tb2R1bGVzL2hhbmRsZUVycm9yLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjL21vZHVsZXMvaG9zdHMuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMvbW9kdWxlcy9pbml0aWFsaXplci5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy9tb2R1bGVzL2xhd25jaGFpci1leHQuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMvbW9kdWxlcy9sb2FkU2NyaXB0LmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjL21vZHVsZXMvbG9nZ2VyLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjL21vZHVsZXMvcGxhdGZvcm1zTWFwLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjL21vZHVsZXMvcXVlcnlNYXAuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMvbW9kdWxlcy9zZGt2ZXJzaW9uLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjL21vZHVsZXMvc2VjdXJpdHkvYWVzLWtleWdlbi5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy9tb2R1bGVzL3NlY3VyaXR5L2Flcy1ub2RlLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjL21vZHVsZXMvc2VjdXJpdHkvaGFzaC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3NyYy9tb2R1bGVzL3NlY3VyaXR5L3JzYS1ub2RlLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjL21vZHVsZXMvc3luYy1jbGkuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay9zcmMvbW9kdWxlcy91dWlkLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvc3JjL21vZHVsZXMvd2FpdEZvckNsb3VkLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvdGVzdC9icm93c2VyL3N1aXRlLmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvdGVzdC90ZXN0cy90ZXN0X2FqYXguanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay90ZXN0L3Rlc3RzL3Rlc3RfY2xvdWRfcmVsYXRlZC5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3Rlc3QvdGVzdHMvdGVzdF9sZWdhY3lfYWN0LmpzIiwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvdGVzdC90ZXN0cy90ZXN0X3NlYy5qcyIsIi9Vc2Vycy93ZWlsaS93b3JrL2ZoLXNka3MvZmgtanMtc2RrL3Rlc3QvdGVzdHMvdGVzdF9zeW5jX29mZmxpbmUuanMiLCIvVXNlcnMvd2VpbGkvd29yay9maC1zZGtzL2ZoLWpzLXNkay90ZXN0L3Rlc3RzL3Rlc3Rfc3luY19vbmxpbmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3IwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZtQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Z4QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pRQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0bENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy96Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2h5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbjtfX2Jyb3dzZXJpZnlfc2hpbV9yZXF1aXJlX189cmVxdWlyZTsoZnVuY3Rpb24gYnJvd3NlcmlmeVNoaW0obW9kdWxlLCBleHBvcnRzLCByZXF1aXJlLCBkZWZpbmUsIGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKSB7XG4vKlxuIENyeXB0b0pTIHYzLjEuMlxuIGNvcmUuanNcbiBjb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbiAoYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiBjb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4gKi9cbi8qKlxuICogQ3J5cHRvSlMgY29yZSBjb21wb25lbnRzLlxuICovXG52YXIgQ3J5cHRvSlMgPSBDcnlwdG9KUyB8fCAoZnVuY3Rpb24gKE1hdGgsIHVuZGVmaW5lZCkge1xuICAvKipcbiAgICogQ3J5cHRvSlMgbmFtZXNwYWNlLlxuICAgKi9cbiAgdmFyIEMgPSB7fTtcblxuICAvKipcbiAgICogTGlicmFyeSBuYW1lc3BhY2UuXG4gICAqL1xuICB2YXIgQ19saWIgPSBDLmxpYiA9IHt9O1xuXG4gIC8qKlxuICAgKiBCYXNlIG9iamVjdCBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cbiAgICovXG4gIHZhciBCYXNlID0gQ19saWIuQmFzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRigpIHt9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhpcyBvYmplY3QuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyBQcm9wZXJ0aWVzIHRvIGNvcHkgaW50byB0aGUgbmV3IG9iamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBzdGF0aWNcbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICpcbiAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcbiAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZScsXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAqICAgICAgICAgfVxuICAgICAgICAgICAgICogICAgIH0pO1xuICAgICAgICovXG4gICAgICBleHRlbmQ6IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgLy8gU3Bhd25cbiAgICAgICAgRi5wcm90b3R5cGUgPSB0aGlzO1xuICAgICAgICB2YXIgc3VidHlwZSA9IG5ldyBGKCk7XG5cbiAgICAgICAgLy8gQXVnbWVudFxuICAgICAgICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgICAgICAgc3VidHlwZS5taXhJbihvdmVycmlkZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgaW5pdGlhbGl6ZXJcbiAgICAgICAgaWYgKCFzdWJ0eXBlLmhhc093blByb3BlcnR5KCdpbml0JykpIHtcbiAgICAgICAgICBzdWJ0eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdWJ0eXBlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxpemVyJ3MgcHJvdG90eXBlIGlzIHRoZSBzdWJ0eXBlIG9iamVjdFxuICAgICAgICBzdWJ0eXBlLmluaXQucHJvdG90eXBlID0gc3VidHlwZTtcblxuICAgICAgICAvLyBSZWZlcmVuY2Ugc3VwZXJ0eXBlXG4gICAgICAgIHN1YnR5cGUuJHN1cGVyID0gdGhpcztcblxuICAgICAgICByZXR1cm4gc3VidHlwZTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRXh0ZW5kcyB0aGlzIG9iamVjdCBhbmQgcnVucyB0aGUgaW5pdCBtZXRob2QuXG4gICAgICAgKiBBcmd1bWVudHMgdG8gY3JlYXRlKCkgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG4gICAgICAgKlxuICAgICAgICogQHN0YXRpY1xuICAgICAgICpcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKlxuICAgICAgICogICAgIHZhciBpbnN0YW5jZSA9IE15VHlwZS5jcmVhdGUoKTtcbiAgICAgICAqL1xuICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZXh0ZW5kKCk7XG4gICAgICAgIGluc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgb2JqZWN0LlxuICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIHNvbWUgbG9naWMgd2hlbiB5b3VyIG9iamVjdHMgYXJlIGNyZWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqXG4gICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG4gICAgICAgICAgICAgKiAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAqICAgICAgICAgICAgIC8vIC4uLlxuICAgICAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgKi9cbiAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQ29waWVzIHByb3BlcnRpZXMgaW50byB0aGlzIG9iamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBUaGUgcHJvcGVydGllcyB0byBtaXggaW4uXG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqXG4gICAgICAgKiAgICAgTXlUeXBlLm1peEluKHtcbiAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZSdcbiAgICAgICAgICAgICAqICAgICB9KTtcbiAgICAgICAqL1xuICAgICAgbWl4SW46IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElFIHdvbid0IGNvcHkgdG9TdHJpbmcgdXNpbmcgdGhlIGxvb3AgYWJvdmVcbiAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICB0aGlzLnRvU3RyaW5nID0gcHJvcGVydGllcy50b1N0cmluZztcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICpcbiAgICAgICAqICAgICB2YXIgY2xvbmUgPSBpbnN0YW5jZS5jbG9uZSgpO1xuICAgICAgICovXG4gICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0LnByb3RvdHlwZS5leHRlbmQodGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICAgKlxuICAgKiBAcHJvcGVydHkge0FycmF5fSB3b3JkcyBUaGUgYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG4gICAqL1xuICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5ID0gQmFzZS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgKE9wdGlvbmFsKSBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSgpO1xuICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddKTtcbiAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSwgNik7XG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24gKHdvcmRzLCBzaWdCeXRlcykge1xuICAgICAgd29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XG5cbiAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHNpZ0J5dGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgd29yZCBhcnJheSB0byBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciAoT3B0aW9uYWwpIFRoZSBlbmNvZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IENyeXB0b0pTLmVuYy5IZXhcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkgKyAnJztcbiAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xuICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKGVuY29kZXIpIHtcbiAgICAgIHJldHVybiAoZW5jb2RlciB8fCBIZXgpLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uY2F0ZW5hdGVzIGEgd29yZCBhcnJheSB0byB0aGlzIHdvcmQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5IHRvIGFwcGVuZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhpcyB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB3b3JkQXJyYXkxLmNvbmNhdCh3b3JkQXJyYXkyKTtcbiAgICAgKi9cbiAgICBjb25jYXQ6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcbiAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgdmFyIHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XG4gICAgICB2YXIgdGhhdFdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuICAgICAgdmFyIHRoaXNTaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG4gICAgICB2YXIgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG4gICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuICAgICAgdGhpcy5jbGFtcCgpO1xuXG4gICAgICAvLyBDb25jYXRcbiAgICAgIGlmICh0aGlzU2lnQnl0ZXMgJSA0KSB7XG4gICAgICAgIC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpKyspIHtcbiAgICAgICAgICB2YXIgdGhhdEJ5dGUgPSAodGhhdFdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcbiAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSB8PSB0aGF0Qnl0ZSA8PCAoMjQgLSAoKHRoaXNTaWdCeXRlcyArIGkpICUgNCkgKiA4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGF0V29yZHMubGVuZ3RoID4gMHhmZmZmKSB7XG4gICAgICAgIC8vIENvcHkgb25lIHdvcmQgYXQgYSB0aW1lXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpICs9IDQpIHtcbiAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSA9IHRoYXRXb3Jkc1tpID4+PiAyXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29weSBhbGwgd29yZHMgYXQgb25jZVxuICAgICAgICB0aGlzV29yZHMucHVzaC5hcHBseSh0aGlzV29yZHMsIHRoYXRXb3Jkcyk7XG4gICAgICB9XG4gICAgICB0aGlzLnNpZ0J5dGVzICs9IHRoYXRTaWdCeXRlcztcblxuICAgICAgLy8gQ2hhaW5hYmxlXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBpbnNpZ25pZmljYW50IGJpdHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuICAgICAqL1xuICAgIGNsYW1wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBTaG9ydGN1dHNcbiAgICAgIHZhciB3b3JkcyA9IHRoaXMud29yZHM7XG4gICAgICB2YXIgc2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXG4gICAgICAvLyBDbGFtcFxuICAgICAgd29yZHNbc2lnQnl0ZXMgPj4+IDJdICY9IDB4ZmZmZmZmZmYgPDwgKDMyIC0gKHNpZ0J5dGVzICUgNCkgKiA4KTtcbiAgICAgIHdvcmRzLmxlbmd0aCA9IE1hdGguY2VpbChzaWdCeXRlcyAvIDQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGNsb25lID0gd29yZEFycmF5LmNsb25lKCk7XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICAgIGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcblxuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgd29yZCBhcnJheSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG4gICAgICovXG4gICAgcmFuZG9tOiBmdW5jdGlvbiAobkJ5dGVzKSB7XG4gICAgICB2YXIgd29yZHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkJ5dGVzOyBpICs9IDQpIHtcbiAgICAgICAgd29yZHMucHVzaCgoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSB8IDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBuQnl0ZXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEVuY29kZXIgbmFtZXNwYWNlLlxuICAgKi9cbiAgdmFyIENfZW5jID0gQy5lbmMgPSB7fTtcblxuICAvKipcbiAgICogSGV4IGVuY29kaW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgdmFyIEhleCA9IENfZW5jLkhleCA9IHtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBoZXggc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuICAgICAqL1xuICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG4gICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cbiAgICAgIC8vIENvbnZlcnRcbiAgICAgIHZhciBoZXhDaGFycyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG4gICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcbiAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSAmIDB4MGYpLnRvU3RyaW5nKDE2KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoZXhDaGFycy5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHIgVGhlIGhleCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhTdHJpbmcpO1xuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbiAoaGV4U3RyKSB7XG4gICAgICAvLyBTaG9ydGN1dFxuICAgICAgdmFyIGhleFN0ckxlbmd0aCA9IGhleFN0ci5sZW5ndGg7XG5cbiAgICAgIC8vIENvbnZlcnRcbiAgICAgIHZhciB3b3JkcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZXhTdHJMZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB3b3Jkc1tpID4+PiAzXSB8PSBwYXJzZUludChoZXhTdHIuc3Vic3RyKGksIDIpLCAxNikgPDwgKDI0IC0gKGkgJSA4KSAqIDQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBoZXhTdHJMZW5ndGggLyAyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExhdGluMSBlbmNvZGluZyBzdHJhdGVneS5cbiAgICovXG4gIHZhciBMYXRpbjEgPSBDX2VuYy5MYXRpbjEgPSB7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgTGF0aW4xIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBMYXRpbjEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgbGF0aW4xU3RyaW5nID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KTtcbiAgICAgKi9cbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcbiAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG4gICAgICAvLyBDb252ZXJ0XG4gICAgICB2YXIgbGF0aW4xQ2hhcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG4gICAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYXRpbjFDaGFycy5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBMYXRpbjEgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXRpbjFTdHIgVGhlIExhdGluMSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5wYXJzZShsYXRpbjFTdHJpbmcpO1xuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbiAobGF0aW4xU3RyKSB7XG4gICAgICAvLyBTaG9ydGN1dFxuICAgICAgdmFyIGxhdGluMVN0ckxlbmd0aCA9IGxhdGluMVN0ci5sZW5ndGg7XG5cbiAgICAgIC8vIENvbnZlcnRcbiAgICAgIHZhciB3b3JkcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRpbjFTdHJMZW5ndGg7IGkrKykge1xuICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSAobGF0aW4xU3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGxhdGluMVN0ckxlbmd0aCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVVEYtOCBlbmNvZGluZyBzdHJhdGVneS5cbiAgICovXG4gIHZhciBVdGY4ID0gQ19lbmMuVXRmOCA9IHtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtOCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTggc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgdXRmOFN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuICAgICAqL1xuICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFVURi04IGRhdGEnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBVVEYtOCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjhTdHIgVGhlIFVURi04IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcbiAgICAgKi9cbiAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjhTdHIpIHtcbiAgICAgIHJldHVybiBMYXRpbjEucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHV0ZjhTdHIpKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBYnN0cmFjdCBidWZmZXJlZCBibG9jayBhbGdvcml0aG0gdGVtcGxhdGUuXG4gICAqXG4gICAqIFRoZSBwcm9wZXJ0eSBibG9ja1NpemUgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGNvbmNyZXRlIHN1YnR5cGUuXG4gICAqXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfbWluQnVmZmVyU2l6ZSBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBrZXB0IHVucHJvY2Vzc2VkIGluIHRoZSBidWZmZXIuIERlZmF1bHQ6IDBcbiAgICovXG4gIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IEJhc2UuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhpcyBibG9jayBhbGdvcml0aG0ncyBkYXRhIGJ1ZmZlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBJbml0aWFsIHZhbHVlc1xuICAgICAgdGhpcy5fZGF0YSA9IG5ldyBXb3JkQXJyYXkuaW5pdCgpO1xuICAgICAgdGhpcy5fbkRhdGFCeXRlcyA9IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYXBwZW5kLiBTdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gYSBXb3JkQXJyYXkgdXNpbmcgVVRGLTguXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCgnZGF0YScpO1xuICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQod29yZEFycmF5KTtcbiAgICAgKi9cbiAgICBfYXBwZW5kOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEgPSBVdGY4LnBhcnNlKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBlbmRcbiAgICAgIHRoaXMuX2RhdGEuY29uY2F0KGRhdGEpO1xuICAgICAgdGhpcy5fbkRhdGFCeXRlcyArPSBkYXRhLnNpZ0J5dGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgYXZhaWxhYmxlIGRhdGEgYmxvY2tzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBfZG9Qcm9jZXNzQmxvY2sob2Zmc2V0KSwgd2hpY2ggbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBhIGNvbmNyZXRlIHN1YnR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvRmx1c2ggV2hldGhlciBhbGwgYmxvY2tzIGFuZCBwYXJ0aWFsIGJsb2NrcyBzaG91bGQgYmUgcHJvY2Vzc2VkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcHJvY2Vzc2VkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xuICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoISEnZmx1c2gnKTtcbiAgICAgKi9cbiAgICBfcHJvY2VzczogZnVuY3Rpb24gKGRvRmx1c2gpIHtcbiAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG4gICAgICB2YXIgZGF0YVNpZ0J5dGVzID0gZGF0YS5zaWdCeXRlcztcbiAgICAgIHZhciBibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cbiAgICAgIC8vIENvdW50IGJsb2NrcyByZWFkeVxuICAgICAgdmFyIG5CbG9ja3NSZWFkeSA9IGRhdGFTaWdCeXRlcyAvIGJsb2NrU2l6ZUJ5dGVzO1xuICAgICAgaWYgKGRvRmx1c2gpIHtcbiAgICAgICAgLy8gUm91bmQgdXAgdG8gaW5jbHVkZSBwYXJ0aWFsIGJsb2Nrc1xuICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLmNlaWwobkJsb2Nrc1JlYWR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJvdW5kIGRvd24gdG8gaW5jbHVkZSBvbmx5IGZ1bGwgYmxvY2tzLFxuICAgICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxuICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLm1heCgobkJsb2Nrc1JlYWR5IHwgMCkgLSB0aGlzLl9taW5CdWZmZXJTaXplLCAwKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ291bnQgd29yZHMgcmVhZHlcbiAgICAgIHZhciBuV29yZHNSZWFkeSA9IG5CbG9ja3NSZWFkeSAqIGJsb2NrU2l6ZTtcblxuICAgICAgLy8gQ291bnQgYnl0ZXMgcmVhZHlcbiAgICAgIHZhciBuQnl0ZXNSZWFkeSA9IE1hdGgubWluKG5Xb3Jkc1JlYWR5ICogNCwgZGF0YVNpZ0J5dGVzKTtcblxuICAgICAgLy8gUHJvY2VzcyBibG9ja3NcbiAgICAgIGlmIChuV29yZHNSZWFkeSkge1xuICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBuV29yZHNSZWFkeTsgb2Zmc2V0ICs9IGJsb2NrU2l6ZSkge1xuICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtYWxnb3JpdGhtIGxvZ2ljXG4gICAgICAgICAgdGhpcy5fZG9Qcm9jZXNzQmxvY2soZGF0YVdvcmRzLCBvZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xuICAgICAgICB2YXIgcHJvY2Vzc2VkV29yZHMgPSBkYXRhV29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcbiAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuQnl0ZXNSZWFkeTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHByb2Nlc3NlZCB3b3Jkc1xuICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChwcm9jZXNzZWRXb3JkcywgbkJ5dGVzUmVhZHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgY2xvbmUgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLmNsb25lKCk7XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICAgIGNsb25lLl9kYXRhID0gdGhpcy5fZGF0YS5jbG9uZSgpO1xuXG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfSxcblxuICAgIF9taW5CdWZmZXJTaXplOiAwXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBYnN0cmFjdCBoYXNoZXIgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBoYXNoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDE2ICg1MTIgYml0cylcbiAgICovXG4gIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqL1xuICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBoYXNoZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgaGFzaCBjb21wdXRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGhhc2hlciA9IENyeXB0b0pTLmFsZ28uU0hBMjU2LmNyZWF0ZSgpO1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcbiAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGlzIGhhc2hlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgaGFzaGVyLnJlc2V0KCk7XG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG4gICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cbiAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG4gICAgICB0aGlzLl9kb1Jlc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SGFzaGVyfSBUaGlzIGhhc2hlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuICAgICAgLy8gQXBwZW5kXG4gICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgaGFzaFxuICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG4gICAgICAvLyBDaGFpbmFibGVcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5hbGl6ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24uXG4gICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgpO1xuICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuICAgICAqL1xuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuICAgICAgLy8gRmluYWwgbWVzc2FnZSB1cGRhdGVcbiAgICAgIGlmIChtZXNzYWdlVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcbiAgICAgIH1cblxuICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcbiAgICAgIHZhciBoYXNoID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9LFxuXG4gICAgYmxvY2tTaXplOiA1MTIvMzIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gYSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcbiAgICAgKi9cbiAgICBfY3JlYXRlSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGNmZykge1xuICAgICAgICByZXR1cm4gbmV3IGhhc2hlci5pbml0KGNmZykuZmluYWxpemUobWVzc2FnZSk7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIEhtYWNTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcbiAgICAgKi9cbiAgICBfY3JlYXRlSG1hY0hlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQWxnb3JpdGhtIG5hbWVzcGFjZS5cbiAgICovXG4gIHZhciBDX2FsZ28gPSBDLmFsZ28gPSB7fTtcblxuICByZXR1cm4gQztcbn0oTWF0aCkpO1xuLypcbiBDcnlwdG9KUyB2My4xLjJcbiBlbmMtYmFzZTY0LmpzXG4gY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG4gKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuICovXG4oZnVuY3Rpb24gKCkge1xuICAvLyBTaG9ydGN1dHNcbiAgdmFyIEMgPSBDcnlwdG9KUztcbiAgdmFyIENfbGliID0gQy5saWI7XG4gIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG4gIHZhciBDX2VuYyA9IEMuZW5jO1xuXG4gIC8qKlxuICAgKiBCYXNlNjQgZW5jb2Rpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0ID0ge1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgQmFzZTY0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGJhc2U2NFN0cmluZyA9IENyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG4gICAgICovXG4gICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG4gICAgICAvLyBTaG9ydGN1dHNcbiAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3JkcztcbiAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG4gICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblxuICAgICAgLy8gQ29udmVydFxuICAgICAgdmFyIGJhc2U2NENoYXJzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIGJ5dGUxID0gKHdvcmRzW2kgPj4+IDJdICAgICAgID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICAgICAgICYgMHhmZjtcbiAgICAgICAgdmFyIGJ5dGUyID0gKHdvcmRzWyhpICsgMSkgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAxKSAlIDQpICogOCkpICYgMHhmZjtcbiAgICAgICAgdmFyIGJ5dGUzID0gKHdvcmRzWyhpICsgMikgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAyKSAlIDQpICogOCkpICYgMHhmZjtcblxuICAgICAgICB2YXIgdHJpcGxldCA9IChieXRlMSA8PCAxNikgfCAoYnl0ZTIgPDwgOCkgfCBieXRlMztcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgKGogPCA0KSAmJiAoaSArIGogKiAwLjc1IDwgc2lnQnl0ZXMpOyBqKyspIHtcbiAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+ICg2ICogKDMgLSBqKSkpICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcbiAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuICAgICAgICB3aGlsZSAoYmFzZTY0Q2hhcnMubGVuZ3RoICUgNCkge1xuICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gocGFkZGluZ0NoYXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYXNlNjRDaGFycy5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRTdHIgVGhlIEJhc2U2NCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShiYXNlNjRTdHJpbmcpO1xuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbiAoYmFzZTY0U3RyKSB7XG4gICAgICAvLyBTaG9ydGN1dHNcbiAgICAgIHZhciBiYXNlNjRTdHJMZW5ndGggPSBiYXNlNjRTdHIubGVuZ3RoO1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgLy8gSWdub3JlIHBhZGRpbmdcbiAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG4gICAgICAgIHZhciBwYWRkaW5nSW5kZXggPSBiYXNlNjRTdHIuaW5kZXhPZihwYWRkaW5nQ2hhcik7XG4gICAgICAgIGlmIChwYWRkaW5nSW5kZXggIT0gLTEpIHtcbiAgICAgICAgICBiYXNlNjRTdHJMZW5ndGggPSBwYWRkaW5nSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ29udmVydFxuICAgICAgdmFyIHdvcmRzID0gW107XG4gICAgICB2YXIgbkJ5dGVzID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZTY0U3RyTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgJSA0KSB7XG4gICAgICAgICAgdmFyIGJpdHMxID0gbWFwLmluZGV4T2YoYmFzZTY0U3RyLmNoYXJBdChpIC0gMSkpIDw8ICgoaSAlIDQpICogMik7XG4gICAgICAgICAgdmFyIGJpdHMyID0gbWFwLmluZGV4T2YoYmFzZTY0U3RyLmNoYXJBdChpKSkgPj4+ICg2IC0gKGkgJSA0KSAqIDIpO1xuICAgICAgICAgIHdvcmRzW25CeXRlcyA+Pj4gMl0gfD0gKGJpdHMxIHwgYml0czIpIDw8ICgyNCAtIChuQnl0ZXMgJSA0KSAqIDgpO1xuICAgICAgICAgIG5CeXRlcysrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCBuQnl0ZXMpO1xuICAgIH0sXG5cbiAgICBfbWFwOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXG4gIH07XG59KCkpO1xuLypcbiBDcnlwdG9KUyB2My4xLjJcbiBjaXBoZXItY29yZVxuIGNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuIChjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuIGNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDaXBoZXIgY29yZSBjb21wb25lbnRzLlxuICovXG5DcnlwdG9KUy5saWIuQ2lwaGVyIHx8IChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG4gIC8vIFNob3J0Y3V0c1xuICB2YXIgQyA9IENyeXB0b0pTO1xuICB2YXIgQ19saWIgPSBDLmxpYjtcbiAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG07XG4gIHZhciBDX2VuYyA9IEMuZW5jO1xuICB2YXIgVXRmOCA9IENfZW5jLlV0Zjg7XG4gIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQ7XG4gIHZhciBDX2FsZ28gPSBDLmFsZ287XG4gIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGO1xuXG4gIC8qKlxuICAgKiBBYnN0cmFjdCBiYXNlIGNpcGhlciB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhpcyBjaXBoZXIncyBrZXkgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdlNpemUgVGhpcyBjaXBoZXIncyBJViBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9FTkNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBlbmNyeXB0aW9uIG1vZGUuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfREVDX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZGVjcnlwdGlvbiBtb2RlLlxuICAgKi9cbiAgdmFyIENpcGhlciA9IENfbGliLkNpcGhlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAgICovXG4gICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBlbmNyeXB0aW9uIG1vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0NpcGhlcn0gQSBjaXBoZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGVFbmNyeXB0b3Ioa2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcbiAgICAgKi9cbiAgICBjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChrZXksIGNmZykge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZGVjcnlwdGlvbiBtb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRGVjcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG4gICAgICovXG4gICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9ERUNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhmb3JtTW9kZSBFaXRoZXIgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiB0cmFuc29ybWF0aW9uIG1vZGUgY29uc3RhbnQuXG4gICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5BRVMuX0VOQ19YRk9STV9NT0RFLCBrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uICh4Zm9ybU1vZGUsIGtleSwgY2ZnKSB7XG4gICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcbiAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cbiAgICAgIC8vIFN0b3JlIHRyYW5zZm9ybSBtb2RlIGFuZCBrZXlcbiAgICAgIHRoaXMuX3hmb3JtTW9kZSA9IHhmb3JtTW9kZTtcbiAgICAgIHRoaXMuX2tleSA9IGtleTtcblxuICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGlzIGNpcGhlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgY2lwaGVyLnJlc2V0KCk7XG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG4gICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cbiAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXG4gICAgICB0aGlzLl9kb1Jlc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgZGF0YSB0byBiZSBlbmNyeXB0ZWQgb3IgZGVjcnlwdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgcHJvY2Vzc2luZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKCdkYXRhJyk7XG4gICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2Vzcyh3b3JkQXJyYXkpO1xuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XG4gICAgICAvLyBBcHBlbmRcbiAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcblxuICAgICAgLy8gUHJvY2VzcyBhdmFpbGFibGUgYmxvY2tzXG4gICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5hbGl6ZXMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGZpbmFsIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBmaW5hbCBwcm9jZXNzaW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCk7XG4gICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoJ2RhdGEnKTtcbiAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuICAgICAqL1xuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xuICAgICAgLy8gRmluYWwgZGF0YSB1cGRhdGVcbiAgICAgIGlmIChkYXRhVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcbiAgICAgIH1cblxuICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcbiAgICAgIHZhciBmaW5hbFByb2Nlc3NlZERhdGEgPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cbiAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZERhdGE7XG4gICAgfSxcblxuICAgIGtleVNpemU6IDEyOC8zMixcblxuICAgIGl2U2l6ZTogMTI4LzMyLFxuXG4gICAgX0VOQ19YRk9STV9NT0RFOiAxLFxuXG4gICAgX0RFQ19YRk9STV9NT0RFOiAyLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBzaG9ydGN1dCBmdW5jdGlvbnMgdG8gYSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGVuY3J5cHQgYW5kIGRlY3J5cHQgc2hvcnRjdXQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgQUVTID0gQ3J5cHRvSlMubGliLkNpcGhlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uQUVTKTtcbiAgICAgKi9cbiAgICBfY3JlYXRlSGVscGVyOiAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFBhc3N3b3JkQmFzZWRDaXBoZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUNpcGhlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGNpcGhlcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChtZXNzYWdlLCBrZXksIGNmZykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZW5jcnlwdChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5kZWNyeXB0KGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfSgpKVxuICB9KTtcblxuICAvKipcbiAgICogQWJzdHJhY3QgYmFzZSBzdHJlYW0gY2lwaGVyIHRlbXBsYXRlLlxuICAgKlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxICgzMiBiaXRzKVxuICAgKi9cbiAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlciA9IENpcGhlci5leHRlbmQoe1xuICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBQcm9jZXNzIHBhcnRpYWwgYmxvY2tzXG4gICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cbiAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2NrcztcbiAgICB9LFxuXG4gICAgYmxvY2tTaXplOiAxXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBNb2RlIG5hbWVzcGFjZS5cbiAgICovXG4gIHZhciBDX21vZGUgPSBDLm1vZGUgPSB7fTtcblxuICAvKipcbiAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgbW9kZSB0ZW1wbGF0ZS5cbiAgICovXG4gIHZhciBCbG9ja0NpcGhlck1vZGUgPSBDX2xpYi5CbG9ja0NpcGhlck1vZGUgPSBCYXNlLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGVuY3J5cHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVFbmNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG4gICAgICovXG4gICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuICAgICAgcmV0dXJuIHRoaXMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGRlY3J5cHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVEZWNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG4gICAgICovXG4gICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuICAgICAgcmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG1vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYud29yZHMpO1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG4gICAgICB0aGlzLl9jaXBoZXIgPSBjaXBoZXI7XG4gICAgICB0aGlzLl9pdiA9IGl2O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIENpcGhlciBCbG9jayBDaGFpbmluZyBtb2RlLlxuICAgKi9cbiAgdmFyIENCQyA9IENfbW9kZS5DQkMgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IGJhc2UgQ0JDIG1vZGUuXG4gICAgICovXG4gICAgdmFyIENCQyA9IEJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuICAgIC8qKlxuICAgICAqIENCQyBlbmNyeXB0b3IuXG4gICAgICovXG4gICAgQ0JDLkVuY3J5cHRvciA9IENCQy5leHRlbmQoe1xuICAgICAgLyoqXG4gICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICpcbiAgICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xuICAgICAgICovXG4gICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuICAgICAgICAvLyBYT1IgYW5kIGVuY3J5cHRcbiAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xuICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXG4gICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDQkMgZGVjcnlwdG9yLlxuICAgICAqL1xuICAgIENCQy5EZWNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcbiAgICAgIC8qKlxuICAgICAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqXG4gICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcbiAgICAgICAqL1xuICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcbiAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cbiAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG4gICAgICAgIHZhciB0aGlzQmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cbiAgICAgICAgLy8gRGVjcnlwdCBhbmQgWE9SXG4gICAgICAgIGNpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG4gICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblxuICAgICAgICAvLyBUaGlzIGJsb2NrIGJlY29tZXMgdGhlIHByZXZpb3VzIGJsb2NrXG4gICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHRoaXNCbG9jaztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHhvckJsb2NrKHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSkge1xuICAgICAgLy8gU2hvcnRjdXRcbiAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXG4gICAgICAvLyBDaG9vc2UgbWl4aW5nIGJsb2NrXG4gICAgICBpZiAoaXYpIHtcbiAgICAgICAgdmFyIGJsb2NrID0gaXY7XG5cbiAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBibG9jayA9IHRoaXMuX3ByZXZCbG9jaztcbiAgICAgIH1cblxuICAgICAgLy8gWE9SIGJsb2Nrc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBibG9ja1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ0JDO1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBQYWRkaW5nIG5hbWVzcGFjZS5cbiAgICovXG4gIHZhciBDX3BhZCA9IEMucGFkID0ge307XG5cbiAgLyoqXG4gICAqIFBLQ1MgIzUvNyBwYWRkaW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgdmFyIFBrY3M3ID0gQ19wYWQuUGtjczcgPSB7XG4gICAgLyoqXG4gICAgICogUGFkcyBkYXRhIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbXVsdGlwbGUgdGhhdCB0aGUgZGF0YSBzaG91bGQgYmUgcGFkZGVkIHRvLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcucGFkKHdvcmRBcnJheSwgNCk7XG4gICAgICovXG4gICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG4gICAgICAvLyBTaG9ydGN1dFxuICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuICAgICAgLy8gQ291bnQgcGFkZGluZyBieXRlc1xuICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBibG9ja1NpemVCeXRlcyAtIGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcztcblxuICAgICAgLy8gQ3JlYXRlIHBhZGRpbmcgd29yZFxuICAgICAgdmFyIHBhZGRpbmdXb3JkID0gKG5QYWRkaW5nQnl0ZXMgPDwgMjQpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgMTYpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgOCkgfCBuUGFkZGluZ0J5dGVzO1xuXG4gICAgICAvLyBDcmVhdGUgcGFkZGluZ1xuICAgICAgdmFyIHBhZGRpbmdXb3JkcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFkZGluZ0J5dGVzOyBpICs9IDQpIHtcbiAgICAgICAgcGFkZGluZ1dvcmRzLnB1c2gocGFkZGluZ1dvcmQpO1xuICAgICAgfVxuICAgICAgdmFyIHBhZGRpbmcgPSBXb3JkQXJyYXkuY3JlYXRlKHBhZGRpbmdXb3JkcywgblBhZGRpbmdCeXRlcyk7XG5cbiAgICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgICBkYXRhLmNvbmNhdChwYWRkaW5nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5wYWRzIGRhdGEgdGhhdCBoYWQgYmVlbiBwYWRkZWQgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHVucGFkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcudW5wYWQod29yZEFycmF5KTtcbiAgICAgKi9cbiAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIC8vIEdldCBudW1iZXIgb2YgcGFkZGluZyBieXRlcyBmcm9tIGxhc3QgYnl0ZVxuICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBkYXRhLndvcmRzWyhkYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcblxuICAgICAgLy8gUmVtb3ZlIHBhZGRpbmdcbiAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIHRlbXBsYXRlLlxuICAgKlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiA0ICgxMjggYml0cylcbiAgICovXG4gIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHRvIHVzZS4gRGVmYXVsdDogQ0JDXG4gICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogUGtjczdcbiAgICAgKi9cbiAgICBjZmc6IENpcGhlci5jZmcuZXh0ZW5kKHtcbiAgICAgIG1vZGU6IENCQyxcbiAgICAgIHBhZGRpbmc6IFBrY3M3XG4gICAgfSksXG5cbiAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gUmVzZXQgY2lwaGVyXG4gICAgICBDaXBoZXIucmVzZXQuY2FsbCh0aGlzKTtcblxuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XG4gICAgICB2YXIgaXYgPSBjZmcuaXY7XG4gICAgICB2YXIgbW9kZSA9IGNmZy5tb2RlO1xuXG4gICAgICAvLyBSZXNldCBibG9jayBtb2RlXG4gICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XG4gICAgICAgIHZhciBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRW5jcnlwdG9yO1xuICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcbiAgICAgICAgdmFyIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVEZWNyeXB0b3I7XG5cbiAgICAgICAgLy8gS2VlcCBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gdGhlIGJ1ZmZlciBmb3IgdW5wYWRkaW5nXG4gICAgICAgIHRoaXMuX21pbkJ1ZmZlclNpemUgPSAxO1xuICAgICAgfVxuICAgICAgdGhpcy5fbW9kZSA9IG1vZGVDcmVhdG9yLmNhbGwobW9kZSwgdGhpcywgaXYgJiYgaXYud29yZHMpO1xuICAgIH0sXG5cbiAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG4gICAgICB0aGlzLl9tb2RlLnByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KTtcbiAgICB9LFxuXG4gICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFNob3J0Y3V0XG4gICAgICB2YXIgcGFkZGluZyA9IHRoaXMuY2ZnLnBhZGRpbmc7XG5cbiAgICAgIC8vIEZpbmFsaXplXG4gICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XG4gICAgICAgIC8vIFBhZCBkYXRhXG4gICAgICAgIHBhZGRpbmcucGFkKHRoaXMuX2RhdGEsIHRoaXMuYmxvY2tTaXplKTtcblxuICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG4gICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cbiAgICAgICAgLy8gVW5wYWQgZGF0YVxuICAgICAgICBwYWRkaW5nLnVucGFkKGZpbmFsUHJvY2Vzc2VkQmxvY2tzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuICAgIH0sXG5cbiAgICBibG9ja1NpemU6IDEyOC8zMlxuICB9KTtcblxuICAvKipcbiAgICogQSBjb2xsZWN0aW9uIG9mIGNpcGhlciBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gY2lwaGVydGV4dCBUaGUgcmF3IGNpcGhlcnRleHQuXG4gICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBrZXkgVGhlIGtleSB0byB0aGlzIGNpcGhlcnRleHQuXG4gICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cbiAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IHNhbHQgVGhlIHNhbHQgdXNlZCB3aXRoIGEga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG4gICAqIEBwcm9wZXJ0eSB7Q2lwaGVyfSBhbGdvcml0aG0gVGhlIGNpcGhlciBhbGdvcml0aG0uXG4gICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc2NoZW1lIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIGJsb2NrIHNpemUgb2YgdGhlIGNpcGhlci5cbiAgICogQHByb3BlcnR5IHtGb3JtYXR9IGZvcm1hdHRlciBUaGUgZGVmYXVsdCBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cbiAgICovXG4gIHZhciBDaXBoZXJQYXJhbXMgPSBDX2xpYi5DaXBoZXJQYXJhbXMgPSBCYXNlLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNpcGhlclBhcmFtcyBBbiBvYmplY3Qgd2l0aCBhbnkgb2YgdGhlIHBvc3NpYmxlIGNpcGhlciBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMubGliLkNpcGhlclBhcmFtcy5jcmVhdGUoe1xuICAgICAgICAgKiAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHRXb3JkQXJyYXksXG4gICAgICAgICAqICAgICAgICAga2V5OiBrZXlXb3JkQXJyYXksXG4gICAgICAgICAqICAgICAgICAgaXY6IGl2V29yZEFycmF5LFxuICAgICAgICAgKiAgICAgICAgIHNhbHQ6IHNhbHRXb3JkQXJyYXksXG4gICAgICAgICAqICAgICAgICAgYWxnb3JpdGhtOiBDcnlwdG9KUy5hbGdvLkFFUyxcbiAgICAgICAgICogICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcbiAgICAgICAgICogICAgICAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuUEtDUzcsXG4gICAgICAgICAqICAgICAgICAgYmxvY2tTaXplOiA0LFxuICAgICAgICAgKiAgICAgICAgIGZvcm1hdHRlcjogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0xcbiAgICAgICAgICogICAgIH0pO1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcbiAgICAgIHRoaXMubWl4SW4oY2lwaGVyUGFyYW1zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Rm9ybWF0fSBmb3JtYXR0ZXIgKE9wdGlvbmFsKSBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCBjaXBoZXIgcGFyYW1zLlxuICAgICAqXG4gICAgICogQHRocm93cyBFcnJvciBJZiBuZWl0aGVyIHRoZSBmb3JtYXR0ZXIgbm9yIHRoZSBkZWZhdWx0IGZvcm1hdHRlciBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMgKyAnJztcbiAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZygpO1xuICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMKTtcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKGZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIChmb3JtYXR0ZXIgfHwgdGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBGb3JtYXQgbmFtZXNwYWNlLlxuICAgKi9cbiAgdmFyIENfZm9ybWF0ID0gQy5mb3JtYXQgPSB7fTtcblxuICAvKipcbiAgICogT3BlblNTTCBmb3JtYXR0aW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgdmFyIE9wZW5TU0xGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5PcGVuU1NMID0ge1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIG9wZW5TU0xTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcbiAgICAgKi9cbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcbiAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgdmFyIGNpcGhlcnRleHQgPSBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dDtcbiAgICAgIHZhciBzYWx0ID0gY2lwaGVyUGFyYW1zLnNhbHQ7XG5cbiAgICAgIC8vIEZvcm1hdFxuICAgICAgaWYgKHNhbHQpIHtcbiAgICAgICAgdmFyIHdvcmRBcnJheSA9IFdvcmRBcnJheS5jcmVhdGUoWzB4NTM2MTZjNzQsIDB4NjU2NDVmNWZdKS5jb25jYXQoc2FsdCkuY29uY2F0KGNpcGhlcnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHdvcmRBcnJheSA9IGNpcGhlcnRleHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3b3JkQXJyYXkudG9TdHJpbmcoQmFzZTY0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZW5TU0xTdHIgVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnBhcnNlKG9wZW5TU0xTdHJpbmcpO1xuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbiAob3BlblNTTFN0cikge1xuICAgICAgLy8gUGFyc2UgYmFzZTY0XG4gICAgICB2YXIgY2lwaGVydGV4dCA9IEJhc2U2NC5wYXJzZShvcGVuU1NMU3RyKTtcblxuICAgICAgLy8gU2hvcnRjdXRcbiAgICAgIHZhciBjaXBoZXJ0ZXh0V29yZHMgPSBjaXBoZXJ0ZXh0LndvcmRzO1xuXG4gICAgICAvLyBUZXN0IGZvciBzYWx0XG4gICAgICBpZiAoY2lwaGVydGV4dFdvcmRzWzBdID09IDB4NTM2MTZjNzQgJiYgY2lwaGVydGV4dFdvcmRzWzFdID09IDB4NjU2NDVmNWYpIHtcbiAgICAgICAgLy8gRXh0cmFjdCBzYWx0XG4gICAgICAgIHZhciBzYWx0ID0gV29yZEFycmF5LmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMiwgNCkpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBzYWx0IGZyb20gY2lwaGVydGV4dFxuICAgICAgICBjaXBoZXJ0ZXh0V29yZHMuc3BsaWNlKDAsIDQpO1xuICAgICAgICBjaXBoZXJ0ZXh0LnNpZ0J5dGVzIC09IDE2O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsIHNhbHQ6IHNhbHQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBIGNpcGhlciB3cmFwcGVyIHRoYXQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgKi9cbiAgdmFyIFNlcmlhbGl6YWJsZUNpcGhlciA9IENfbGliLlNlcmlhbGl6YWJsZUNpcGhlciA9IEJhc2UuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgY2lwaGVyIHBhcmFtIG9iamVjdHMgdG8gYW5kIGZyb20gYSBzdHJpbmcuIERlZmF1bHQ6IE9wZW5TU0xcbiAgICAgKi9cbiAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcbiAgICAgIGZvcm1hdDogT3BlblNTTEZvcm1hdHRlclxuICAgIH0pLFxuXG4gICAgLyoqXG4gICAgICogRW5jcnlwdHMgYSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG4gICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG4gICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXkpO1xuICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiB9KTtcbiAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG4gICAgICovXG4gICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpIHtcbiAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cbiAgICAgIC8vIEVuY3J5cHRcbiAgICAgIHZhciBlbmNyeXB0b3IgPSBjaXBoZXIuY3JlYXRlRW5jcnlwdG9yKGtleSwgY2ZnKTtcbiAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gZW5jcnlwdG9yLmZpbmFsaXplKG1lc3NhZ2UpO1xuXG4gICAgICAvLyBTaG9ydGN1dFxuICAgICAgdmFyIGNpcGhlckNmZyA9IGVuY3J5cHRvci5jZmc7XG5cbiAgICAgIC8vIENyZWF0ZSBhbmQgcmV0dXJuIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zXG4gICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG4gICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBpdjogY2lwaGVyQ2ZnLml2LFxuICAgICAgICBhbGdvcml0aG06IGNpcGhlcixcbiAgICAgICAgbW9kZTogY2lwaGVyQ2ZnLm1vZGUsXG4gICAgICAgIHBhZGRpbmc6IGNpcGhlckNmZy5wYWRkaW5nLFxuICAgICAgICBibG9ja1NpemU6IGNpcGhlci5ibG9ja1NpemUsXG4gICAgICAgIGZvcm1hdHRlcjogY2ZnLmZvcm1hdFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuICAgICAqL1xuICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG4gICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcbiAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG4gICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcbiAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuICAgICAgLy8gRGVjcnlwdFxuICAgICAgdmFyIHBsYWludGV4dCA9IGNpcGhlci5jcmVhdGVEZWNyeXB0b3Ioa2V5LCBjZmcpLmZpbmFsaXplKGNpcGhlcnRleHQuY2lwaGVydGV4dCk7XG5cbiAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB0byBDaXBoZXJQYXJhbXMsXG4gICAgICogZWxzZSBhc3N1bWVkIENpcGhlclBhcmFtcyBhbHJlYWR5IGFuZCByZXR1cm5zIGNpcGhlcnRleHQgdW5jaGFuZ2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0LlxuICAgICAqIEBwYXJhbSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlIHRvIHBhcnNlIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIHVuc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuX3BhcnNlKGNpcGhlcnRleHRTdHJpbmdPclBhcmFtcywgZm9ybWF0KTtcbiAgICAgKi9cbiAgICBfcGFyc2U6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBmb3JtYXQpIHtcbiAgICAgIGlmICh0eXBlb2YgY2lwaGVydGV4dCA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZm9ybWF0LnBhcnNlKGNpcGhlcnRleHQsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogS2V5IGRlcml2YXRpb24gZnVuY3Rpb24gbmFtZXNwYWNlLlxuICAgKi9cbiAgdmFyIENfa2RmID0gQy5rZGYgPSB7fTtcblxuICAvKipcbiAgICogT3BlblNTTCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cbiAgICovXG4gIHZhciBPcGVuU1NMS2RmID0gQ19rZGYuT3BlblNTTCA9IHtcbiAgICAvKipcbiAgICAgKiBEZXJpdmVzIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHRvIGRlcml2ZSBmcm9tLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrZXlTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBrZXkgdG8gZ2VuZXJhdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGl2U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUgSVYgdG8gZ2VuZXJhdGUuXG4gICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IChPcHRpb25hbCkgQSA2NC1iaXQgc2FsdCB0byB1c2UuIElmIG9taXR0ZWQsIGEgc2FsdCB3aWxsIGJlIGdlbmVyYXRlZCByYW5kb21seS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdCB3aXRoIHRoZSBrZXksIElWLCBhbmQgc2FsdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyKTtcbiAgICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyLCAnc2FsdHNhbHQnKTtcbiAgICAgKi9cbiAgICBleGVjdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIGtleVNpemUsIGl2U2l6ZSwgc2FsdCkge1xuICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIHNhbHRcbiAgICAgIGlmICghc2FsdCkge1xuICAgICAgICBzYWx0ID0gV29yZEFycmF5LnJhbmRvbSg2NC84KTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVyaXZlIGtleSBhbmQgSVZcbiAgICAgIHZhciBrZXkgPSBFdnBLREYuY3JlYXRlKHsga2V5U2l6ZToga2V5U2l6ZSArIGl2U2l6ZSB9KS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblxuICAgICAgLy8gU2VwYXJhdGUga2V5IGFuZCBJVlxuICAgICAgdmFyIGl2ID0gV29yZEFycmF5LmNyZWF0ZShrZXkud29yZHMuc2xpY2Uoa2V5U2l6ZSksIGl2U2l6ZSAqIDQpO1xuICAgICAga2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cbiAgICAgIC8vIFJldHVybiBwYXJhbXNcbiAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsga2V5OiBrZXksIGl2OiBpdiwgc2FsdDogc2FsdCB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgc2VyaWFsaXphYmxlIGNpcGhlciB3cmFwcGVyIHRoYXQgZGVyaXZlcyB0aGUga2V5IGZyb20gYSBwYXNzd29yZCxcbiAgICogYW5kIHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAgICovXG4gIHZhciBQYXNzd29yZEJhc2VkQ2lwaGVyID0gQ19saWIuUGFzc3dvcmRCYXNlZENpcGhlciA9IFNlcmlhbGl6YWJsZUNpcGhlci5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7S0RGfSBrZGYgVGhlIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSB0byBnZW5lcmF0ZSBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLiBEZWZhdWx0OiBPcGVuU1NMXG4gICAgICovXG4gICAgY2ZnOiBTZXJpYWxpemFibGVDaXBoZXIuY2ZnLmV4dGVuZCh7XG4gICAgICBrZGY6IE9wZW5TU0xLZGZcbiAgICB9KSxcblxuICAgIC8qKlxuICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZSB1c2luZyBhIHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG4gICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcpO1xuICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcbiAgICAgKi9cbiAgICBlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBwYXNzd29yZCwgY2ZnKSB7XG4gICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcbiAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG4gICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcbiAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSk7XG5cbiAgICAgIC8vIEFkZCBJViB0byBjb25maWdcbiAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cbiAgICAgIC8vIEVuY3J5cHRcbiAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIG1lc3NhZ2UsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xuXG4gICAgICAvLyBNaXggaW4gZGVyaXZlZCBwYXJhbXNcbiAgICAgIGNpcGhlcnRleHQubWl4SW4oZGVyaXZlZFBhcmFtcyk7XG5cbiAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdXNpbmcgYSBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcbiAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcbiAgICAgKi9cbiAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBwYXNzd29yZCwgY2ZnKSB7XG4gICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcbiAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG4gICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcbiAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG4gICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IGNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUsIGNpcGhlcnRleHQuc2FsdCk7XG5cbiAgICAgIC8vIEFkZCBJViB0byBjb25maWdcbiAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cbiAgICAgIC8vIERlY3J5cHRcbiAgICAgIHZhciBwbGFpbnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgY2lwaGVydGV4dCwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cbiAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgfVxuICB9KTtcbn0oKSk7XG4vKlxuIENyeXB0b0pTIHYzLjEuMlxuIGFlcy5qc1xuIGNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuIChjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuIGNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgLy8gU2hvcnRjdXRzXG4gIHZhciBDID0gQ3J5cHRvSlM7XG4gIHZhciBDX2xpYiA9IEMubGliO1xuICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlcjtcbiAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuICAvLyBMb29rdXAgdGFibGVzXG4gIHZhciBTQk9YID0gW107XG4gIHZhciBJTlZfU0JPWCA9IFtdO1xuICB2YXIgU1VCX01JWF8wID0gW107XG4gIHZhciBTVUJfTUlYXzEgPSBbXTtcbiAgdmFyIFNVQl9NSVhfMiA9IFtdO1xuICB2YXIgU1VCX01JWF8zID0gW107XG4gIHZhciBJTlZfU1VCX01JWF8wID0gW107XG4gIHZhciBJTlZfU1VCX01JWF8xID0gW107XG4gIHZhciBJTlZfU1VCX01JWF8yID0gW107XG4gIHZhciBJTlZfU1VCX01JWF8zID0gW107XG5cbiAgLy8gQ29tcHV0ZSBsb29rdXAgdGFibGVzXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ29tcHV0ZSBkb3VibGUgdGFibGVcbiAgICB2YXIgZCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgIGRbaV0gPSBpIDw8IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXYWxrIEdGKDJeOClcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHhpID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAvLyBDb21wdXRlIHNib3hcbiAgICAgIHZhciBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpO1xuICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuICAgICAgU0JPWFt4XSA9IHN4O1xuICAgICAgSU5WX1NCT1hbc3hdID0geDtcblxuICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuICAgICAgdmFyIHgyID0gZFt4XTtcbiAgICAgIHZhciB4NCA9IGRbeDJdO1xuICAgICAgdmFyIHg4ID0gZFt4NF07XG5cbiAgICAgIC8vIENvbXB1dGUgc3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcbiAgICAgIHZhciB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKTtcbiAgICAgIFNVQl9NSVhfMFt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcbiAgICAgIFNVQl9NSVhfMVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG4gICAgICBTVUJfTUlYXzJbeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xuICAgICAgU1VCX01JWF8zW3hdID0gdDtcblxuICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICB2YXIgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKTtcbiAgICAgIElOVl9TVUJfTUlYXzBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuICAgICAgSU5WX1NVQl9NSVhfMVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuICAgICAgSU5WX1NVQl9NSVhfMltzeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xuICAgICAgSU5WX1NVQl9NSVhfM1tzeF0gPSB0O1xuXG4gICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuICAgICAgaWYgKCF4KSB7XG4gICAgICAgIHggPSB4aSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xuICAgICAgICB4aSBePSBkW2RbeGldXTtcbiAgICAgIH1cbiAgICB9XG4gIH0oKSk7XG5cbiAgLy8gUHJlY29tcHV0ZWQgUmNvbiBsb29rdXBcbiAgdmFyIFJDT04gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG5cbiAgLyoqXG4gICAqIEFFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuICAgKi9cbiAgdmFyIEFFUyA9IENfYWxnby5BRVMgPSBCbG9ja0NpcGhlci5leHRlbmQoe1xuICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBTaG9ydGN1dHNcbiAgICAgIHZhciBrZXkgPSB0aGlzLl9rZXk7XG4gICAgICB2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XG4gICAgICB2YXIga2V5U2l6ZSA9IGtleS5zaWdCeXRlcyAvIDQ7XG5cbiAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIHJvdW5kc1xuICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDZcblxuICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Yga2V5IHNjaGVkdWxlIHJvd3NcbiAgICAgIHZhciBrc1Jvd3MgPSAoblJvdW5kcyArIDEpICogNDtcblxuICAgICAgLy8gQ29tcHV0ZSBrZXkgc2NoZWR1bGVcbiAgICAgIHZhciBrZXlTY2hlZHVsZSA9IHRoaXMuX2tleVNjaGVkdWxlID0gW107XG4gICAgICBmb3IgKHZhciBrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG4gICAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcbiAgICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlXb3Jkc1trc1Jvd107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDFdO1xuXG4gICAgICAgICAgaWYgKCEoa3NSb3cgJSBrZXlTaXplKSkge1xuICAgICAgICAgICAgLy8gUm90IHdvcmRcbiAgICAgICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG5cbiAgICAgICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuXG4gICAgICAgICAgICAvLyBNaXggUmNvblxuICAgICAgICAgICAgdCBePSBSQ09OWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT0gNCkge1xuICAgICAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ29tcHV0ZSBpbnYga2V5IHNjaGVkdWxlXG4gICAgICB2YXIgaW52S2V5U2NoZWR1bGUgPSB0aGlzLl9pbnZLZXlTY2hlZHVsZSA9IFtdO1xuICAgICAgZm9yICh2YXIgaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgICAgICB2YXIga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcblxuICAgICAgICBpZiAoaW52S3NSb3cgJSA0KSB7XG4gICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG4gICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBJTlZfU1VCX01JWF8wW1NCT1hbdCA+Pj4gMjRdXSBeIElOVl9TVUJfTUlYXzFbU0JPWFsodCA+Pj4gMTYpICYgMHhmZl1dIF5cbiAgICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdXSBeIElOVl9TVUJfTUlYXzNbU0JPWFt0ICYgMHhmZl1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5fa2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCk7XG4gICAgfSxcblxuICAgIGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuICAgICAgLy8gU3dhcCAybmQgYW5kIDR0aCByb3dzXG4gICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG4gICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcbiAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuXG4gICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgSU5WX1NVQl9NSVhfMCwgSU5WX1NVQl9NSVhfMSwgSU5WX1NVQl9NSVhfMiwgSU5WX1NVQl9NSVhfMywgSU5WX1NCT1gpO1xuXG4gICAgICAvLyBJbnYgc3dhcCAybmQgYW5kIDR0aCByb3dzXG4gICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG4gICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcbiAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuICAgIH0sXG5cbiAgICBfZG9DcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0LCBrZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKSB7XG4gICAgICAvLyBTaG9ydGN1dFxuICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzO1xuXG4gICAgICAvLyBHZXQgaW5wdXQsIGFkZCByb3VuZCBrZXlcbiAgICAgIHZhciBzMCA9IE1bb2Zmc2V0XSAgICAgXiBrZXlTY2hlZHVsZVswXTtcbiAgICAgIHZhciBzMSA9IE1bb2Zmc2V0ICsgMV0gXiBrZXlTY2hlZHVsZVsxXTtcbiAgICAgIHZhciBzMiA9IE1bb2Zmc2V0ICsgMl0gXiBrZXlTY2hlZHVsZVsyXTtcbiAgICAgIHZhciBzMyA9IE1bb2Zmc2V0ICsgM10gXiBrZXlTY2hlZHVsZVszXTtcblxuICAgICAgLy8gS2V5IHNjaGVkdWxlIHJvdyBjb3VudGVyXG4gICAgICB2YXIga3NSb3cgPSA0O1xuXG4gICAgICAvLyBSb3VuZHNcbiAgICAgIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCBuUm91bmRzOyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgbWl4IGNvbHVtbnMsIGFkZCByb3VuZCBrZXlcbiAgICAgICAgdmFyIHQwID0gU1VCX01JWF8wW3MwID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMxID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuICAgICAgICB2YXIgdDEgPSBTVUJfTUlYXzBbczEgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczIgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMCAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG4gICAgICAgIHZhciB0MiA9IFNVQl9NSVhfMFtzMiA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMwID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcbiAgICAgICAgdmFyIHQzID0gU1VCX01JWF8wW3MzID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMwID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgICAgICBzMCA9IHQwO1xuICAgICAgICBzMSA9IHQxO1xuICAgICAgICBzMiA9IHQyO1xuICAgICAgICBzMyA9IHQzO1xuICAgICAgfVxuXG4gICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcbiAgICAgIHZhciB0MCA9ICgoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuICAgICAgdmFyIHQxID0gKChTQk9YW3MxID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MwICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG4gICAgICB2YXIgdDIgPSAoKFNCT1hbczIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcbiAgICAgIHZhciB0MyA9ICgoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXG4gICAgICAvLyBTZXQgb3V0cHV0XG4gICAgICBNW29mZnNldF0gICAgID0gdDA7XG4gICAgICBNW29mZnNldCArIDFdID0gdDE7XG4gICAgICBNW29mZnNldCArIDJdID0gdDI7XG4gICAgICBNW29mZnNldCArIDNdID0gdDM7XG4gICAgfSxcblxuICAgIGtleVNpemU6IDI1Ni8zMlxuICB9KTtcblxuICAvKipcbiAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG4gICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcbiAgICovXG4gIEMuQUVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihBRVMpO1xufSgpKTtcbi8qXG4gQ3J5cHRvSlMgdjMuMS4yXG4gbWQ1LmpzXG4gY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG4gKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuICovXG4oZnVuY3Rpb24gKE1hdGgpIHtcbiAgLy8gU2hvcnRjdXRzXG4gIHZhciBDID0gQ3J5cHRvSlM7XG4gIHZhciBDX2xpYiA9IEMubGliO1xuICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG4gIC8vIENvbnN0YW50cyB0YWJsZVxuICB2YXIgVCA9IFtdO1xuXG4gIC8vIENvbXB1dGUgY29uc3RhbnRzXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICBUW2ldID0gKE1hdGguYWJzKE1hdGguc2luKGkgKyAxKSkgKiAweDEwMDAwMDAwMCkgfCAwO1xuICAgIH1cbiAgfSgpKTtcblxuICAvKipcbiAgICogTUQ1IGhhc2ggYWxnb3JpdGhtLlxuICAgKi9cbiAgdmFyIE1ENSA9IENfYWxnby5NRDUgPSBIYXNoZXIuZXh0ZW5kKHtcbiAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG4gICAgICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksXG4gICAgICAgIDB4OThiYWRjZmUsIDB4MTAzMjU0NzZcbiAgICAgIF0pO1xuICAgIH0sXG5cbiAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcbiAgICAgIC8vIFN3YXAgZW5kaWFuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgIHZhciBvZmZzZXRfaSA9IG9mZnNldCArIGk7XG4gICAgICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV07XG5cbiAgICAgICAgTVtvZmZzZXRfaV0gPSAoXG4gICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDgpICB8IChNX29mZnNldF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuICAgICAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cbiAgICAgIHZhciBNX29mZnNldF8wICA9IE1bb2Zmc2V0ICsgMF07XG4gICAgICB2YXIgTV9vZmZzZXRfMSAgPSBNW29mZnNldCArIDFdO1xuICAgICAgdmFyIE1fb2Zmc2V0XzIgID0gTVtvZmZzZXQgKyAyXTtcbiAgICAgIHZhciBNX29mZnNldF8zICA9IE1bb2Zmc2V0ICsgM107XG4gICAgICB2YXIgTV9vZmZzZXRfNCAgPSBNW29mZnNldCArIDRdO1xuICAgICAgdmFyIE1fb2Zmc2V0XzUgID0gTVtvZmZzZXQgKyA1XTtcbiAgICAgIHZhciBNX29mZnNldF82ICA9IE1bb2Zmc2V0ICsgNl07XG4gICAgICB2YXIgTV9vZmZzZXRfNyAgPSBNW29mZnNldCArIDddO1xuICAgICAgdmFyIE1fb2Zmc2V0XzggID0gTVtvZmZzZXQgKyA4XTtcbiAgICAgIHZhciBNX29mZnNldF85ICA9IE1bb2Zmc2V0ICsgOV07XG4gICAgICB2YXIgTV9vZmZzZXRfMTAgPSBNW29mZnNldCArIDEwXTtcbiAgICAgIHZhciBNX29mZnNldF8xMSA9IE1bb2Zmc2V0ICsgMTFdO1xuICAgICAgdmFyIE1fb2Zmc2V0XzEyID0gTVtvZmZzZXQgKyAxMl07XG4gICAgICB2YXIgTV9vZmZzZXRfMTMgPSBNW29mZnNldCArIDEzXTtcbiAgICAgIHZhciBNX29mZnNldF8xNCA9IE1bb2Zmc2V0ICsgMTRdO1xuICAgICAgdmFyIE1fb2Zmc2V0XzE1ID0gTVtvZmZzZXQgKyAxNV07XG5cbiAgICAgIC8vIFdvcmtpbmcgdmFyaWFsYmVzXG4gICAgICB2YXIgYSA9IEhbMF07XG4gICAgICB2YXIgYiA9IEhbMV07XG4gICAgICB2YXIgYyA9IEhbMl07XG4gICAgICB2YXIgZCA9IEhbM107XG5cbiAgICAgIC8vIENvbXB1dGF0aW9uXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDcsICBUWzBdKTtcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xLCAgMTIsIFRbMV0pO1xuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNywgVFsyXSk7XG4gICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMywgIDIyLCBUWzNdKTtcbiAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNywgIFRbNF0pO1xuICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzUsICAxMiwgVFs1XSk7XG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE3LCBUWzZdKTtcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF83LCAgMjIsIFRbN10pO1xuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA3LCAgVFs4XSk7XG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfOSwgIDEyLCBUWzldKTtcbiAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTcsIFRbMTBdKTtcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xMSwgMjIsIFRbMTFdKTtcbiAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNywgIFRbMTJdKTtcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xMywgMTIsIFRbMTNdKTtcbiAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xNSwgMjIsIFRbMTVdKTtcblxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsICA1LCAgVFsxNl0pO1xuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzYsICA5LCAgVFsxN10pO1xuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNCwgVFsxOF0pO1xuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzAsICAyMCwgVFsxOV0pO1xuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA1LCAgVFsyMF0pO1xuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEwLCA5LCAgVFsyMV0pO1xuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNCwgVFsyMl0pO1xuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzQsICAyMCwgVFsyM10pO1xuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA1LCAgVFsyNF0pO1xuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE0LCA5LCAgVFsyNV0pO1xuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNCwgVFsyNl0pO1xuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzgsICAyMCwgVFsyN10pO1xuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA1LCAgVFsyOF0pO1xuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzIsICA5LCAgVFsyOV0pO1xuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNCwgVFszMF0pO1xuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEyLCAyMCwgVFszMV0pO1xuXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDQsICBUWzMyXSk7XG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfOCwgIDExLCBUWzMzXSk7XG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE2LCBUWzM0XSk7XG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDQsICBUWzM2XSk7XG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfNCwgIDExLCBUWzM3XSk7XG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE2LCBUWzM4XSk7XG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTAsIDIzLCBUWzM5XSk7XG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDQsICBUWzQwXSk7XG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgIDExLCBUWzQxXSk7XG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgIDE2LCBUWzQyXSk7XG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfNiwgIDIzLCBUWzQzXSk7XG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDQsICBUWzQ0XSk7XG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTIsIDExLCBUWzQ1XSk7XG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE2LCBUWzQ2XSk7XG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMiwgIDIzLCBUWzQ3XSk7XG5cbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNiwgIFRbNDhdKTtcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF83LCAgMTAsIFRbNDldKTtcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTUsIFRbNTBdKTtcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF81LCAgMjEsIFRbNTFdKTtcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNiwgIFRbNTJdKTtcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8zLCAgMTAsIFRbNTNdKTtcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTUsIFRbNTRdKTtcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xLCAgMjEsIFRbNTVdKTtcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNiwgIFRbNTZdKTtcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xNSwgMTAsIFRbNTddKTtcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTUsIFRbNThdKTtcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNiwgIFRbNjBdKTtcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xMSwgMTAsIFRbNjFdKTtcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTUsIFRbNjJdKTtcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF85LCAgMjEsIFRbNjNdKTtcblxuICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcbiAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcbiAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcbiAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcbiAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcbiAgICB9LFxuXG4gICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cbiAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG4gICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cbiAgICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblxuICAgICAgdmFyIG5CaXRzVG90YWxIID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuICAgICAgdmFyIG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcbiAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gKFxuICAgICAgICAgICgoKG5CaXRzVG90YWxIIDw8IDgpICB8IChuQml0c1RvdGFsSCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgMjQpIHwgKG5CaXRzVG90YWxIID4+PiA4KSkgICYgMHhmZjAwZmYwMClcbiAgICAgICAgICApO1xuICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSAoXG4gICAgICAgICAgKCgobkJpdHNUb3RhbEwgPDwgOCkgIHwgKG5CaXRzVG90YWxMID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCAyNCkgfCAobkJpdHNUb3RhbEwgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuICAgICAgICAgICk7XG5cbiAgICAgIGRhdGEuc2lnQnl0ZXMgPSAoZGF0YVdvcmRzLmxlbmd0aCArIDEpICogNDtcblxuICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3NcbiAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICB2YXIgaGFzaCA9IHRoaXMuX2hhc2g7XG4gICAgICB2YXIgSCA9IGhhc2gud29yZHM7XG5cbiAgICAgIC8vIFN3YXAgZW5kaWFuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAvLyBTaG9ydGN1dFxuICAgICAgICB2YXIgSF9pID0gSFtpXTtcblxuICAgICAgICBIW2ldID0gKCgoSF9pIDw8IDgpICB8IChIX2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG4gICAgICAgICAgICAoKChIX2kgPDwgMjQpIHwgKEhfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBGRihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgdmFyIG4gPSBhICsgKChiICYgYykgfCAofmIgJiBkKSkgKyB4ICsgdDtcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuICB9XG5cbiAgZnVuY3Rpb24gR0coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgIHZhciBuID0gYSArICgoYiAmIGQpIHwgKGMgJiB+ZCkpICsgeCArIHQ7XG4gICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcbiAgfVxuXG4gIGZ1bmN0aW9uIEhIKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArIHggKyB0O1xuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG4gIH1cblxuICBmdW5jdGlvbiBJSShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgdmFyIG4gPSBhICsgKGMgXiAoYiB8IH5kKSkgKyB4ICsgdDtcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUoJ21lc3NhZ2UnKTtcbiAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KHdvcmRBcnJheSk7XG4gICAqL1xuICBDLk1ENSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKE1ENSk7XG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcbiAgICovXG4gIEMuSG1hY01ENSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihNRDUpO1xufShNYXRoKSk7XG4vKlxuIENyeXB0b0pTIHYzLjEuMlxuIHNoYTEuanNcbiBjb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbiAoYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiBjb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gIC8vIFNob3J0Y3V0c1xuICB2YXIgQyA9IENyeXB0b0pTO1xuICB2YXIgQ19saWIgPSBDLmxpYjtcbiAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcbiAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcbiAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuICAvLyBSZXVzYWJsZSBvYmplY3RcbiAgdmFyIFcgPSBbXTtcblxuICAvKipcbiAgICogU0hBLTEgaGFzaCBhbGdvcml0aG0uXG4gICAqL1xuICB2YXIgU0hBMSA9IENfYWxnby5TSEExID0gSGFzaGVyLmV4dGVuZCh7XG4gICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuICAgICAgICAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LFxuICAgICAgICAweGMzZDJlMWYwXG4gICAgICBdKTtcbiAgICB9LFxuXG4gICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG4gICAgICAvLyBTaG9ydGN1dFxuICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG4gICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuICAgICAgdmFyIGEgPSBIWzBdO1xuICAgICAgdmFyIGIgPSBIWzFdO1xuICAgICAgdmFyIGMgPSBIWzJdO1xuICAgICAgdmFyIGQgPSBIWzNdO1xuICAgICAgdmFyIGUgPSBIWzRdO1xuXG4gICAgICAvLyBDb21wdXRhdGlvblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgMTYpIHtcbiAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG4gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xuICAgICAgICAgIFdbaV0gPSAobiA8PCAxKSB8IChuID4+PiAzMSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZSArIFdbaV07XG4gICAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKH5iICYgZCkpICsgMHg1YTgyNzk5OTtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgNDApIHtcbiAgICAgICAgICB0ICs9IChiIF4gYyBeIGQpICsgMHg2ZWQ5ZWJhMTtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgNjApIHtcbiAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCkpIC0gMHg3MGU0NDMyNDtcbiAgICAgICAgfSBlbHNlIC8qIGlmIChpIDwgODApICovIHtcbiAgICAgICAgICB0ICs9IChiIF4gYyBeIGQpIC0gMHgzNTlkM2UyYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUgPSBkO1xuICAgICAgICBkID0gYztcbiAgICAgICAgYyA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcbiAgICAgICAgYiA9IGE7XG4gICAgICAgIGEgPSB0O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuICAgIH0sXG5cbiAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcbiAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuICAgICAgLy8gQWRkIHBhZGRpbmdcbiAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG4gICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG4gICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cbiAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG4gICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cbiAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG4gICAgICByZXR1cm4gdGhpcy5faGFzaDtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMSgnbWVzc2FnZScpO1xuICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKHdvcmRBcnJheSk7XG4gICAqL1xuICBDLlNIQTEgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEExKTtcblxuICAvKipcbiAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTEobWVzc2FnZSwga2V5KTtcbiAgICovXG4gIEMuSG1hY1NIQTEgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMSk7XG59KCkpO1xuLypcbiBDcnlwdG9KUyB2My4xLjJcbiB4NjQtY29yZS5qc1xuIGNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuIChjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuIGNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcbiAgLy8gU2hvcnRjdXRzXG4gIHZhciBDID0gQ3J5cHRvSlM7XG4gIHZhciBDX2xpYiA9IEMubGliO1xuICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG4gIHZhciBYMzJXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cbiAgLyoqXG4gICAqIHg2NCBuYW1lc3BhY2UuXG4gICAqL1xuICB2YXIgQ194NjQgPSBDLng2NCA9IHt9O1xuXG4gIC8qKlxuICAgKiBBIDY0LWJpdCB3b3JkLlxuICAgKi9cbiAgdmFyIFg2NFdvcmQgPSBDX3g2NC5Xb3JkID0gQmFzZS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCA2NC1iaXQgd29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIDMyIGJpdHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IDMyIGJpdHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciB4NjRXb3JkID0gQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MDAwMTAyMDMsIDB4MDQwNTA2MDcpO1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uIChoaWdoLCBsb3cpIHtcbiAgICAgIHRoaXMuaGlnaCA9IGhpZ2g7XG4gICAgICB0aGlzLmxvdyA9IGxvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaXR3aXNlIE5PVHMgdGhpcyB3b3JkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIG5lZ2F0aW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgbmVnYXRlZCA9IHg2NFdvcmQubm90KCk7XG4gICAgICovXG4gICAgLy8gbm90OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdmFyIGhpZ2ggPSB+dGhpcy5oaWdoO1xuICAgIC8vIHZhciBsb3cgPSB+dGhpcy5sb3c7XG5cbiAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcbiAgICAvLyB9LFxuXG4gICAgLyoqXG4gICAgICogQml0d2lzZSBBTkRzIHRoaXMgd29yZCB3aXRoIHRoZSBwYXNzZWQgd29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7WDY0V29yZH0gd29yZCBUaGUgeDY0LVdvcmQgdG8gQU5EIHdpdGggdGhpcyB3b3JkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIEFORGluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGFuZGVkID0geDY0V29yZC5hbmQoYW5vdGhlclg2NFdvcmQpO1xuICAgICAqL1xuICAgIC8vIGFuZDogZnVuY3Rpb24gKHdvcmQpIHtcbiAgICAvLyB2YXIgaGlnaCA9IHRoaXMuaGlnaCAmIHdvcmQuaGlnaDtcbiAgICAvLyB2YXIgbG93ID0gdGhpcy5sb3cgJiB3b3JkLmxvdztcblxuICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuICAgIC8vIH0sXG5cbiAgICAvKipcbiAgICAgKiBCaXR3aXNlIE9ScyB0aGlzIHdvcmQgd2l0aCB0aGUgcGFzc2VkIHdvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1g2NFdvcmR9IHdvcmQgVGhlIHg2NC1Xb3JkIHRvIE9SIHdpdGggdGhpcyB3b3JkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIE9SaW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgb3JlZCA9IHg2NFdvcmQub3IoYW5vdGhlclg2NFdvcmQpO1xuICAgICAqL1xuICAgIC8vIG9yOiBmdW5jdGlvbiAod29yZCkge1xuICAgIC8vIHZhciBoaWdoID0gdGhpcy5oaWdoIHwgd29yZC5oaWdoO1xuICAgIC8vIHZhciBsb3cgPSB0aGlzLmxvdyB8IHdvcmQubG93O1xuXG4gICAgLy8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XG4gICAgLy8gfSxcblxuICAgIC8qKlxuICAgICAqIEJpdHdpc2UgWE9ScyB0aGlzIHdvcmQgd2l0aCB0aGUgcGFzc2VkIHdvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1g2NFdvcmR9IHdvcmQgVGhlIHg2NC1Xb3JkIHRvIFhPUiB3aXRoIHRoaXMgd29yZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBYT1JpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciB4b3JlZCA9IHg2NFdvcmQueG9yKGFub3RoZXJYNjRXb3JkKTtcbiAgICAgKi9cbiAgICAvLyB4b3I6IGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgLy8gdmFyIGhpZ2ggPSB0aGlzLmhpZ2ggXiB3b3JkLmhpZ2g7XG4gICAgLy8gdmFyIGxvdyA9IHRoaXMubG93IF4gd29yZC5sb3c7XG5cbiAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcbiAgICAvLyB9LFxuXG4gICAgLyoqXG4gICAgICogU2hpZnRzIHRoaXMgd29yZCBuIGJpdHMgdG8gdGhlIGxlZnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgc2hpZnRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBzaGlmdGVkID0geDY0V29yZC5zaGlmdEwoMjUpO1xuICAgICAqL1xuICAgIC8vIHNoaWZ0TDogZnVuY3Rpb24gKG4pIHtcbiAgICAvLyBpZiAobiA8IDMyKSB7XG4gICAgLy8gdmFyIGhpZ2ggPSAodGhpcy5oaWdoIDw8IG4pIHwgKHRoaXMubG93ID4+PiAoMzIgLSBuKSk7XG4gICAgLy8gdmFyIGxvdyA9IHRoaXMubG93IDw8IG47XG4gICAgLy8gfSBlbHNlIHtcbiAgICAvLyB2YXIgaGlnaCA9IHRoaXMubG93IDw8IChuIC0gMzIpO1xuICAgIC8vIHZhciBsb3cgPSAwO1xuICAgIC8vIH1cblxuICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuICAgIC8vIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaGlmdHMgdGhpcyB3b3JkIG4gYml0cyB0byB0aGUgcmlnaHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgc2hpZnRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBzaGlmdGVkID0geDY0V29yZC5zaGlmdFIoNyk7XG4gICAgICovXG4gICAgLy8gc2hpZnRSOiBmdW5jdGlvbiAobikge1xuICAgIC8vIGlmIChuIDwgMzIpIHtcbiAgICAvLyB2YXIgbG93ID0gKHRoaXMubG93ID4+PiBuKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbikpO1xuICAgIC8vIHZhciBoaWdoID0gdGhpcy5oaWdoID4+PiBuO1xuICAgIC8vIH0gZWxzZSB7XG4gICAgLy8gdmFyIGxvdyA9IHRoaXMuaGlnaCA+Pj4gKG4gLSAzMik7XG4gICAgLy8gdmFyIGhpZ2ggPSAwO1xuICAgIC8vIH1cblxuICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuICAgIC8vIH0sXG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoaXMgd29yZCBuIGJpdHMgdG8gdGhlIGxlZnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gcm90YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIHJvdGF0aW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgcm90YXRlZCA9IHg2NFdvcmQucm90TCgyNSk7XG4gICAgICovXG4gICAgLy8gcm90TDogZnVuY3Rpb24gKG4pIHtcbiAgICAvLyByZXR1cm4gdGhpcy5zaGlmdEwobikub3IodGhpcy5zaGlmdFIoNjQgLSBuKSk7XG4gICAgLy8gfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhpcyB3b3JkIG4gYml0cyB0byB0aGUgcmlnaHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gcm90YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIHJvdGF0aW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgcm90YXRlZCA9IHg2NFdvcmQucm90Uig3KTtcbiAgICAgKi9cbiAgICAvLyByb3RSOiBmdW5jdGlvbiAobikge1xuICAgIC8vIHJldHVybiB0aGlzLnNoaWZ0UihuKS5vcih0aGlzLnNoaWZ0TCg2NCAtIG4pKTtcbiAgICAvLyB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGlzIHdvcmQgd2l0aCB0aGUgcGFzc2VkIHdvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1g2NFdvcmR9IHdvcmQgVGhlIHg2NC1Xb3JkIHRvIGFkZCB3aXRoIHRoaXMgd29yZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBhZGRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBhZGRlZCA9IHg2NFdvcmQuYWRkKGFub3RoZXJYNjRXb3JkKTtcbiAgICAgKi9cbiAgICAvLyBhZGQ6IGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgLy8gdmFyIGxvdyA9ICh0aGlzLmxvdyArIHdvcmQubG93KSB8IDA7XG4gICAgLy8gdmFyIGNhcnJ5ID0gKGxvdyA+Pj4gMCkgPCAodGhpcy5sb3cgPj4+IDApID8gMSA6IDA7XG4gICAgLy8gdmFyIGhpZ2ggPSAodGhpcy5oaWdoICsgd29yZC5oaWdoICsgY2FycnkpIHwgMDtcblxuICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuICAgIC8vIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIDY0LWJpdCB3b3Jkcy5cbiAgICpcbiAgICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIENyeXB0b0pTLng2NC5Xb3JkIG9iamVjdHMuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWdCeXRlcyBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoaXMgd29yZCBhcnJheS5cbiAgICovXG4gIHZhciBYNjRXb3JkQXJyYXkgPSBDX3g2NC5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIENyeXB0b0pTLng2NC5Xb3JkIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy54NjQuV29yZEFycmF5LmNyZWF0ZSgpO1xuICAgICAqXG4gICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy54NjQuV29yZEFycmF5LmNyZWF0ZShbXG4gICAgICogICAgICAgICBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgwMDAxMDIwMywgMHgwNDA1MDYwNyksXG4gICAgICogICAgICAgICBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgxODE5MWExYiwgMHgxYzFkMWUxZilcbiAgICAgKiAgICAgXSk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLng2NC5Xb3JkQXJyYXkuY3JlYXRlKFtcbiAgICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDAwMDEwMjAzLCAweDA0MDUwNjA3KSxcbiAgICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDE4MTkxYTFiLCAweDFjMWQxZTFmKVxuICAgICAqICAgICBdLCAxMCk7XG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24gKHdvcmRzLCBzaWdCeXRlcykge1xuICAgICAgd29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XG5cbiAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHNpZ0J5dGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgNjQtYml0IHdvcmQgYXJyYXkgdG8gYSAzMi1iaXQgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0NyeXB0b0pTLmxpYi5Xb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheSdzIGRhdGEgYXMgYSAzMi1iaXQgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIHgzMldvcmRBcnJheSA9IHg2NFdvcmRBcnJheS50b1gzMigpO1xuICAgICAqL1xuICAgIHRvWDMyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBTaG9ydGN1dHNcbiAgICAgIHZhciB4NjRXb3JkcyA9IHRoaXMud29yZHM7XG4gICAgICB2YXIgeDY0V29yZHNMZW5ndGggPSB4NjRXb3Jkcy5sZW5ndGg7XG5cbiAgICAgIC8vIENvbnZlcnRcbiAgICAgIHZhciB4MzJXb3JkcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4NjRXb3Jkc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB4NjRXb3JkID0geDY0V29yZHNbaV07XG4gICAgICAgIHgzMldvcmRzLnB1c2goeDY0V29yZC5oaWdoKTtcbiAgICAgICAgeDMyV29yZHMucHVzaCh4NjRXb3JkLmxvdyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBYMzJXb3JkQXJyYXkuY3JlYXRlKHgzMldvcmRzLCB0aGlzLnNpZ0J5dGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7WDY0V29yZEFycmF5fSBUaGUgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBjbG9uZSA9IHg2NFdvcmRBcnJheS5jbG9uZSgpO1xuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cbiAgICAgIC8vIENsb25lIFwid29yZHNcIiBhcnJheVxuICAgICAgdmFyIHdvcmRzID0gY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xuXG4gICAgICAvLyBDbG9uZSBlYWNoIFg2NFdvcmQgb2JqZWN0XG4gICAgICB2YXIgd29yZHNMZW5ndGggPSB3b3Jkcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd29yZHNbaV0gPSB3b3Jkc1tpXS5jbG9uZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICB9KTtcbn0oKSk7XG4vKlxuIENyeXB0b0pTIHYzLjEuMlxuIHNoYTI1Ni5qc1xuIGNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuIChjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuIGNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uIChNYXRoKSB7XG4gIC8vIFNob3J0Y3V0c1xuICB2YXIgQyA9IENyeXB0b0pTO1xuICB2YXIgQ19saWIgPSBDLmxpYjtcbiAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcbiAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcbiAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuICAvLyBJbml0aWFsaXphdGlvbiBhbmQgcm91bmQgY29uc3RhbnRzIHRhYmxlc1xuICB2YXIgSCA9IFtdO1xuICB2YXIgSyA9IFtdO1xuXG4gIC8vIENvbXB1dGUgY29uc3RhbnRzXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gaXNQcmltZShuKSB7XG4gICAgICB2YXIgc3FydE4gPSBNYXRoLnNxcnQobik7XG4gICAgICBmb3IgKHZhciBmYWN0b3IgPSAyOyBmYWN0b3IgPD0gc3FydE47IGZhY3RvcisrKSB7XG4gICAgICAgIGlmICghKG4gJSBmYWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEZyYWN0aW9uYWxCaXRzKG4pIHtcbiAgICAgIHJldHVybiAoKG4gLSAobiB8IDApKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG4gICAgfVxuXG4gICAgdmFyIG4gPSAyO1xuICAgIHZhciBuUHJpbWUgPSAwO1xuICAgIHdoaWxlIChuUHJpbWUgPCA2NCkge1xuICAgICAgaWYgKGlzUHJpbWUobikpIHtcbiAgICAgICAgaWYgKG5QcmltZSA8IDgpIHtcbiAgICAgICAgICBIW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMikpO1xuICAgICAgICB9XG4gICAgICAgIEtbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAzKSk7XG5cbiAgICAgICAgblByaW1lKys7XG4gICAgICB9XG5cbiAgICAgIG4rKztcbiAgICB9XG4gIH0oKSk7XG5cbiAgLy8gUmV1c2FibGUgb2JqZWN0XG4gIHZhciBXID0gW107XG5cbiAgLyoqXG4gICAqIFNIQS0yNTYgaGFzaCBhbGdvcml0aG0uXG4gICAqL1xuICB2YXIgU0hBMjU2ID0gQ19hbGdvLlNIQTI1NiA9IEhhc2hlci5leHRlbmQoe1xuICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KEguc2xpY2UoMCkpO1xuICAgIH0sXG5cbiAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcbiAgICAgIC8vIFNob3J0Y3V0XG4gICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cbiAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG4gICAgICB2YXIgYSA9IEhbMF07XG4gICAgICB2YXIgYiA9IEhbMV07XG4gICAgICB2YXIgYyA9IEhbMl07XG4gICAgICB2YXIgZCA9IEhbM107XG4gICAgICB2YXIgZSA9IEhbNF07XG4gICAgICB2YXIgZiA9IEhbNV07XG4gICAgICB2YXIgZyA9IEhbNl07XG4gICAgICB2YXIgaCA9IEhbN107XG5cbiAgICAgIC8vIENvbXB1dGF0aW9uXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgaWYgKGkgPCAxNikge1xuICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZ2FtbWEweCA9IFdbaSAtIDE1XTtcbiAgICAgICAgICB2YXIgZ2FtbWEwICA9ICgoZ2FtbWEweCA8PCAyNSkgfCAoZ2FtbWEweCA+Pj4gNykpICBeXG4gICAgICAgICAgICAgICgoZ2FtbWEweCA8PCAxNCkgfCAoZ2FtbWEweCA+Pj4gMTgpKSBeXG4gICAgICAgICAgICAgIChnYW1tYTB4ID4+PiAzKTtcblxuICAgICAgICAgIHZhciBnYW1tYTF4ID0gV1tpIC0gMl07XG4gICAgICAgICAgdmFyIGdhbW1hMSAgPSAoKGdhbW1hMXggPDwgMTUpIHwgKGdhbW1hMXggPj4+IDE3KSkgXlxuICAgICAgICAgICAgICAoKGdhbW1hMXggPDwgMTMpIHwgKGdhbW1hMXggPj4+IDE5KSkgXlxuICAgICAgICAgICAgICAoZ2FtbWExeCA+Pj4gMTApO1xuXG4gICAgICAgICAgV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoICA9IChlICYgZikgXiAofmUgJiBnKTtcbiAgICAgICAgdmFyIG1haiA9IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcblxuICAgICAgICB2YXIgc2lnbWEwID0gKChhIDw8IDMwKSB8IChhID4+PiAyKSkgXiAoKGEgPDwgMTkpIHwgKGEgPj4+IDEzKSkgXiAoKGEgPDwgMTApIHwgKGEgPj4+IDIyKSk7XG4gICAgICAgIHZhciBzaWdtYTEgPSAoKGUgPDwgMjYpIHwgKGUgPj4+IDYpKSBeICgoZSA8PCAyMSkgfCAoZSA+Pj4gMTEpKSBeICgoZSA8PCA3KSAgfCAoZSA+Pj4gMjUpKTtcblxuICAgICAgICB2YXIgdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2ldICsgV1tpXTtcbiAgICAgICAgdmFyIHQyID0gc2lnbWEwICsgbWFqO1xuXG4gICAgICAgIGggPSBnO1xuICAgICAgICBnID0gZjtcbiAgICAgICAgZiA9IGU7XG4gICAgICAgIGUgPSAoZCArIHQxKSB8IDA7XG4gICAgICAgIGQgPSBjO1xuICAgICAgICBjID0gYjtcbiAgICAgICAgYiA9IGE7XG4gICAgICAgIGEgPSAodDEgKyB0MikgfCAwO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuICAgICAgSFs1XSA9IChIWzVdICsgZikgfCAwO1xuICAgICAgSFs2XSA9IChIWzZdICsgZykgfCAwO1xuICAgICAgSFs3XSA9IChIWzddICsgaCkgfCAwO1xuICAgIH0sXG5cbiAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcbiAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuICAgICAgLy8gQWRkIHBhZGRpbmdcbiAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG4gICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG4gICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cbiAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG4gICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cbiAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG4gICAgICByZXR1cm4gdGhpcy5faGFzaDtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KCdtZXNzYWdlJyk7XG4gICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTI1Nih3b3JkQXJyYXkpO1xuICAgKi9cbiAgQy5TSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEEyNTYpO1xuXG4gIC8qKlxuICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMjU2KG1lc3NhZ2UsIGtleSk7XG4gICAqL1xuICBDLkhtYWNTSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMjU2KTtcbn0oTWF0aCkpO1xuLypcbiBDcnlwdG9KUyB2My4xLjJcbiBzaGE1MTIuanNcbiBjb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbiAoYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiBjb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gIC8vIFNob3J0Y3V0c1xuICB2YXIgQyA9IENyeXB0b0pTO1xuICB2YXIgQ19saWIgPSBDLmxpYjtcbiAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcbiAgdmFyIENfeDY0ID0gQy54NjQ7XG4gIHZhciBYNjRXb3JkID0gQ194NjQuV29yZDtcbiAgdmFyIFg2NFdvcmRBcnJheSA9IENfeDY0LldvcmRBcnJheTtcbiAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuICBmdW5jdGlvbiBYNjRXb3JkX2NyZWF0ZSgpIHtcbiAgICByZXR1cm4gWDY0V29yZC5jcmVhdGUuYXBwbHkoWDY0V29yZCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8vIENvbnN0YW50c1xuICB2YXIgSyA9IFtcbiAgICBYNjRXb3JkX2NyZWF0ZSgweDQyOGEyZjk4LCAweGQ3MjhhZTIyKSwgWDY0V29yZF9jcmVhdGUoMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCksXG4gICAgWDY0V29yZF9jcmVhdGUoMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiksIFg2NFdvcmRfY3JlYXRlKDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMpLFxuICAgIFg2NFdvcmRfY3JlYXRlKDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgpLCBYNjRXb3JkX2NyZWF0ZSgweDU5ZjExMWYxLCAweGI2MDVkMDE5KSxcbiAgICBYNjRXb3JkX2NyZWF0ZSgweDkyM2Y4MmE0LCAweGFmMTk0ZjliKSwgWDY0V29yZF9jcmVhdGUoMHhhYjFjNWVkNSwgMHhkYTZkODExOCksXG4gICAgWDY0V29yZF9jcmVhdGUoMHhkODA3YWE5OCwgMHhhMzAzMDI0MiksIFg2NFdvcmRfY3JlYXRlKDB4MTI4MzViMDEsIDB4NDU3MDZmYmUpLFxuICAgIFg2NFdvcmRfY3JlYXRlKDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMpLCBYNjRXb3JkX2NyZWF0ZSgweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyKSxcbiAgICBYNjRXb3JkX2NyZWF0ZSgweDcyYmU1ZDc0LCAweGYyN2I4OTZmKSwgWDY0V29yZF9jcmVhdGUoMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSksXG4gICAgWDY0V29yZF9jcmVhdGUoMHg5YmRjMDZhNywgMHgyNWM3MTIzNSksIFg2NFdvcmRfY3JlYXRlKDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQpLFxuICAgIFg2NFdvcmRfY3JlYXRlKDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIpLCBYNjRXb3JkX2NyZWF0ZSgweGVmYmU0Nzg2LCAweDM4NGYyNWUzKSxcbiAgICBYNjRXb3JkX2NyZWF0ZSgweDBmYzE5ZGM2LCAweDhiOGNkNWI1KSwgWDY0V29yZF9jcmVhdGUoMHgyNDBjYTFjYywgMHg3N2FjOWM2NSksXG4gICAgWDY0V29yZF9jcmVhdGUoMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSksIFg2NFdvcmRfY3JlYXRlKDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMpLFxuICAgIFg2NFdvcmRfY3JlYXRlKDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQpLCBYNjRXb3JkX2NyZWF0ZSgweDc2Zjk4OGRhLCAweDgzMTE1M2I1KSxcbiAgICBYNjRXb3JkX2NyZWF0ZSgweDk4M2U1MTUyLCAweGVlNjZkZmFiKSwgWDY0V29yZF9jcmVhdGUoMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCksXG4gICAgWDY0V29yZF9jcmVhdGUoMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiksIFg2NFdvcmRfY3JlYXRlKDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQpLFxuICAgIFg2NFdvcmRfY3JlYXRlKDB4YzZlMDBiZjMsIDB4M2RhODhmYzIpLCBYNjRXb3JkX2NyZWF0ZSgweGQ1YTc5MTQ3LCAweDkzMGFhNzI1KSxcbiAgICBYNjRXb3JkX2NyZWF0ZSgweDA2Y2E2MzUxLCAweGUwMDM4MjZmKSwgWDY0V29yZF9jcmVhdGUoMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCksXG4gICAgWDY0V29yZF9jcmVhdGUoMHgyN2I3MGE4NSwgMHg0NmQyMmZmYyksIFg2NFdvcmRfY3JlYXRlKDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYpLFxuICAgIFg2NFdvcmRfY3JlYXRlKDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQpLCBYNjRXb3JkX2NyZWF0ZSgweDUzMzgwZDEzLCAweDlkOTViM2RmKSxcbiAgICBYNjRXb3JkX2NyZWF0ZSgweDY1MGE3MzU0LCAweDhiYWY2M2RlKSwgWDY0V29yZF9jcmVhdGUoMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCksXG4gICAgWDY0V29yZF9jcmVhdGUoMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiksIFg2NFdvcmRfY3JlYXRlKDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IpLFxuICAgIFg2NFdvcmRfY3JlYXRlKDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQpLCBYNjRXb3JkX2NyZWF0ZSgweGE4MWE2NjRiLCAweGJjNDIzMDAxKSxcbiAgICBYNjRXb3JkX2NyZWF0ZSgweGMyNGI4YjcwLCAweGQwZjg5NzkxKSwgWDY0V29yZF9jcmVhdGUoMHhjNzZjNTFhMywgMHgwNjU0YmUzMCksXG4gICAgWDY0V29yZF9jcmVhdGUoMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCksIFg2NFdvcmRfY3JlYXRlKDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTApLFxuICAgIFg2NFdvcmRfY3JlYXRlKDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEpLCBYNjRXb3JkX2NyZWF0ZSgweDEwNmFhMDcwLCAweDMyYmJkMWI4KSxcbiAgICBYNjRXb3JkX2NyZWF0ZSgweDE5YTRjMTE2LCAweGI4ZDJkMGM4KSwgWDY0V29yZF9jcmVhdGUoMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyksXG4gICAgWDY0V29yZF9jcmVhdGUoMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSksIFg2NFdvcmRfY3JlYXRlKDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgpLFxuICAgIFg2NFdvcmRfY3JlYXRlKDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMpLCBYNjRXb3JkX2NyZWF0ZSgweDRlZDhhYTRhLCAweGUzNDE4YWNiKSxcbiAgICBYNjRXb3JkX2NyZWF0ZSgweDViOWNjYTRmLCAweDc3NjNlMzczKSwgWDY0V29yZF9jcmVhdGUoMHg2ODJlNmZmMywgMHhkNmIyYjhhMyksXG4gICAgWDY0V29yZF9jcmVhdGUoMHg3NDhmODJlZSwgMHg1ZGVmYjJmYyksIFg2NFdvcmRfY3JlYXRlKDB4NzhhNTYzNmYsIDB4NDMxNzJmNjApLFxuICAgIFg2NFdvcmRfY3JlYXRlKDB4ODRjODc4MTQsIDB4YTFmMGFiNzIpLCBYNjRXb3JkX2NyZWF0ZSgweDhjYzcwMjA4LCAweDFhNjQzOWVjKSxcbiAgICBYNjRXb3JkX2NyZWF0ZSgweDkwYmVmZmZhLCAweDIzNjMxZTI4KSwgWDY0V29yZF9jcmVhdGUoMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSksXG4gICAgWDY0V29yZF9jcmVhdGUoMHhiZWY5YTNmNywgMHhiMmM2NzkxNSksIFg2NFdvcmRfY3JlYXRlKDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIpLFxuICAgIFg2NFdvcmRfY3JlYXRlKDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMpLCBYNjRXb3JkX2NyZWF0ZSgweGQxODZiOGM3LCAweDIxYzBjMjA3KSxcbiAgICBYNjRXb3JkX2NyZWF0ZSgweGVhZGE3ZGQ2LCAweGNkZTBlYjFlKSwgWDY0V29yZF9jcmVhdGUoMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCksXG4gICAgWDY0V29yZF9jcmVhdGUoMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSksIFg2NFdvcmRfY3JlYXRlKDB4MGE2MzdkYzUsIDB4YTJjODk4YTYpLFxuICAgIFg2NFdvcmRfY3JlYXRlKDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUpLCBYNjRXb3JkX2NyZWF0ZSgweDFiNzEwYjM1LCAweDEzMWM0NzFiKSxcbiAgICBYNjRXb3JkX2NyZWF0ZSgweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0KSwgWDY0V29yZF9jcmVhdGUoMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyksXG4gICAgWDY0V29yZF9jcmVhdGUoMHgzYzllYmUwYSwgMHgxNWM5YmViYyksIFg2NFdvcmRfY3JlYXRlKDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMpLFxuICAgIFg2NFdvcmRfY3JlYXRlKDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYpLCBYNjRXb3JkX2NyZWF0ZSgweDU5N2YyOTljLCAweGZjNjU3ZTJhKSxcbiAgICBYNjRXb3JkX2NyZWF0ZSgweDVmY2I2ZmFiLCAweDNhZDZmYWVjKSwgWDY0V29yZF9jcmVhdGUoMHg2YzQ0MTk4YywgMHg0YTQ3NTgxNylcbiAgXTtcblxuICAvLyBSZXVzYWJsZSBvYmplY3RzXG4gIHZhciBXID0gW107XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICBXW2ldID0gWDY0V29yZF9jcmVhdGUoKTtcbiAgICB9XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIFNIQS01MTIgaGFzaCBhbGdvcml0aG0uXG4gICAqL1xuICB2YXIgU0hBNTEyID0gQ19hbGdvLlNIQTUxMiA9IEhhc2hlci5leHRlbmQoe1xuICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9oYXNoID0gbmV3IFg2NFdvcmRBcnJheS5pbml0KFtcbiAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDZhMDllNjY3LCAweGYzYmNjOTA4KSwgbmV3IFg2NFdvcmQuaW5pdCgweGJiNjdhZTg1LCAweDg0Y2FhNzNiKSxcbiAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDNjNmVmMzcyLCAweGZlOTRmODJiKSwgbmV3IFg2NFdvcmQuaW5pdCgweGE1NGZmNTNhLCAweDVmMWQzNmYxKSxcbiAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDUxMGU1MjdmLCAweGFkZTY4MmQxKSwgbmV3IFg2NFdvcmQuaW5pdCgweDliMDU2ODhjLCAweDJiM2U2YzFmKSxcbiAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDFmODNkOWFiLCAweGZiNDFiZDZiKSwgbmV3IFg2NFdvcmQuaW5pdCgweDViZTBjZDE5LCAweDEzN2UyMTc5KVxuICAgICAgXSk7XG4gICAgfSxcblxuICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cbiAgICAgIHZhciBIMCA9IEhbMF07XG4gICAgICB2YXIgSDEgPSBIWzFdO1xuICAgICAgdmFyIEgyID0gSFsyXTtcbiAgICAgIHZhciBIMyA9IEhbM107XG4gICAgICB2YXIgSDQgPSBIWzRdO1xuICAgICAgdmFyIEg1ID0gSFs1XTtcbiAgICAgIHZhciBINiA9IEhbNl07XG4gICAgICB2YXIgSDcgPSBIWzddO1xuXG4gICAgICB2YXIgSDBoID0gSDAuaGlnaDtcbiAgICAgIHZhciBIMGwgPSBIMC5sb3c7XG4gICAgICB2YXIgSDFoID0gSDEuaGlnaDtcbiAgICAgIHZhciBIMWwgPSBIMS5sb3c7XG4gICAgICB2YXIgSDJoID0gSDIuaGlnaDtcbiAgICAgIHZhciBIMmwgPSBIMi5sb3c7XG4gICAgICB2YXIgSDNoID0gSDMuaGlnaDtcbiAgICAgIHZhciBIM2wgPSBIMy5sb3c7XG4gICAgICB2YXIgSDRoID0gSDQuaGlnaDtcbiAgICAgIHZhciBINGwgPSBINC5sb3c7XG4gICAgICB2YXIgSDVoID0gSDUuaGlnaDtcbiAgICAgIHZhciBINWwgPSBINS5sb3c7XG4gICAgICB2YXIgSDZoID0gSDYuaGlnaDtcbiAgICAgIHZhciBINmwgPSBINi5sb3c7XG4gICAgICB2YXIgSDdoID0gSDcuaGlnaDtcbiAgICAgIHZhciBIN2wgPSBINy5sb3c7XG5cbiAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG4gICAgICB2YXIgYWggPSBIMGg7XG4gICAgICB2YXIgYWwgPSBIMGw7XG4gICAgICB2YXIgYmggPSBIMWg7XG4gICAgICB2YXIgYmwgPSBIMWw7XG4gICAgICB2YXIgY2ggPSBIMmg7XG4gICAgICB2YXIgY2wgPSBIMmw7XG4gICAgICB2YXIgZGggPSBIM2g7XG4gICAgICB2YXIgZGwgPSBIM2w7XG4gICAgICB2YXIgZWggPSBINGg7XG4gICAgICB2YXIgZWwgPSBINGw7XG4gICAgICB2YXIgZmggPSBINWg7XG4gICAgICB2YXIgZmwgPSBINWw7XG4gICAgICB2YXIgZ2ggPSBINmg7XG4gICAgICB2YXIgZ2wgPSBINmw7XG4gICAgICB2YXIgaGggPSBIN2g7XG4gICAgICB2YXIgaGwgPSBIN2w7XG5cbiAgICAgIC8vIFJvdW5kc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgIC8vIFNob3J0Y3V0XG4gICAgICAgIHZhciBXaSA9IFdbaV07XG5cbiAgICAgICAgLy8gRXh0ZW5kIG1lc3NhZ2VcbiAgICAgICAgaWYgKGkgPCAxNikge1xuICAgICAgICAgIHZhciBXaWggPSBXaS5oaWdoID0gTVtvZmZzZXQgKyBpICogMl0gICAgIHwgMDtcbiAgICAgICAgICB2YXIgV2lsID0gV2kubG93ICA9IE1bb2Zmc2V0ICsgaSAqIDIgKyAxXSB8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gR2FtbWEwXG4gICAgICAgICAgdmFyIGdhbW1hMHggID0gV1tpIC0gMTVdO1xuICAgICAgICAgIHZhciBnYW1tYTB4aCA9IGdhbW1hMHguaGlnaDtcbiAgICAgICAgICB2YXIgZ2FtbWEweGwgPSBnYW1tYTB4LmxvdztcbiAgICAgICAgICB2YXIgZ2FtbWEwaCAgPSAoKGdhbW1hMHhoID4+PiAxKSB8IChnYW1tYTB4bCA8PCAzMSkpIF4gKChnYW1tYTB4aCA+Pj4gOCkgfCAoZ2FtbWEweGwgPDwgMjQpKSBeIChnYW1tYTB4aCA+Pj4gNyk7XG4gICAgICAgICAgdmFyIGdhbW1hMGwgID0gKChnYW1tYTB4bCA+Pj4gMSkgfCAoZ2FtbWEweGggPDwgMzEpKSBeICgoZ2FtbWEweGwgPj4+IDgpIHwgKGdhbW1hMHhoIDw8IDI0KSkgXiAoKGdhbW1hMHhsID4+PiA3KSB8IChnYW1tYTB4aCA8PCAyNSkpO1xuXG4gICAgICAgICAgLy8gR2FtbWExXG4gICAgICAgICAgdmFyIGdhbW1hMXggID0gV1tpIC0gMl07XG4gICAgICAgICAgdmFyIGdhbW1hMXhoID0gZ2FtbWExeC5oaWdoO1xuICAgICAgICAgIHZhciBnYW1tYTF4bCA9IGdhbW1hMXgubG93O1xuICAgICAgICAgIHZhciBnYW1tYTFoICA9ICgoZ2FtbWExeGggPj4+IDE5KSB8IChnYW1tYTF4bCA8PCAxMykpIF4gKChnYW1tYTF4aCA8PCAzKSB8IChnYW1tYTF4bCA+Pj4gMjkpKSBeIChnYW1tYTF4aCA+Pj4gNik7XG4gICAgICAgICAgdmFyIGdhbW1hMWwgID0gKChnYW1tYTF4bCA+Pj4gMTkpIHwgKGdhbW1hMXhoIDw8IDEzKSkgXiAoKGdhbW1hMXhsIDw8IDMpIHwgKGdhbW1hMXhoID4+PiAyOSkpIF4gKChnYW1tYTF4bCA+Pj4gNikgfCAoZ2FtbWExeGggPDwgMjYpKTtcblxuICAgICAgICAgIC8vIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XVxuICAgICAgICAgIHZhciBXaTcgID0gV1tpIC0gN107XG4gICAgICAgICAgdmFyIFdpN2ggPSBXaTcuaGlnaDtcbiAgICAgICAgICB2YXIgV2k3bCA9IFdpNy5sb3c7XG5cbiAgICAgICAgICB2YXIgV2kxNiAgPSBXW2kgLSAxNl07XG4gICAgICAgICAgdmFyIFdpMTZoID0gV2kxNi5oaWdoO1xuICAgICAgICAgIHZhciBXaTE2bCA9IFdpMTYubG93O1xuXG4gICAgICAgICAgdmFyIFdpbCA9IGdhbW1hMGwgKyBXaTdsO1xuICAgICAgICAgIHZhciBXaWggPSBnYW1tYTBoICsgV2k3aCArICgoV2lsID4+PiAwKSA8IChnYW1tYTBsID4+PiAwKSA/IDEgOiAwKTtcbiAgICAgICAgICB2YXIgV2lsID0gV2lsICsgZ2FtbWExbDtcbiAgICAgICAgICB2YXIgV2loID0gV2loICsgZ2FtbWExaCArICgoV2lsID4+PiAwKSA8IChnYW1tYTFsID4+PiAwKSA/IDEgOiAwKTtcbiAgICAgICAgICB2YXIgV2lsID0gV2lsICsgV2kxNmw7XG4gICAgICAgICAgdmFyIFdpaCA9IFdpaCArIFdpMTZoICsgKChXaWwgPj4+IDApIDwgKFdpMTZsID4+PiAwKSA/IDEgOiAwKTtcblxuICAgICAgICAgIFdpLmhpZ2ggPSBXaWg7XG4gICAgICAgICAgV2kubG93ICA9IFdpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGggID0gKGVoICYgZmgpIF4gKH5laCAmIGdoKTtcbiAgICAgICAgdmFyIGNobCAgPSAoZWwgJiBmbCkgXiAofmVsICYgZ2wpO1xuICAgICAgICB2YXIgbWFqaCA9IChhaCAmIGJoKSBeIChhaCAmIGNoKSBeIChiaCAmIGNoKTtcbiAgICAgICAgdmFyIG1hamwgPSAoYWwgJiBibCkgXiAoYWwgJiBjbCkgXiAoYmwgJiBjbCk7XG5cbiAgICAgICAgdmFyIHNpZ21hMGggPSAoKGFoID4+PiAyOCkgfCAoYWwgPDwgNCkpICBeICgoYWggPDwgMzApICB8IChhbCA+Pj4gMikpIF4gKChhaCA8PCAyNSkgfCAoYWwgPj4+IDcpKTtcbiAgICAgICAgdmFyIHNpZ21hMGwgPSAoKGFsID4+PiAyOCkgfCAoYWggPDwgNCkpICBeICgoYWwgPDwgMzApICB8IChhaCA+Pj4gMikpIF4gKChhbCA8PCAyNSkgfCAoYWggPj4+IDcpKTtcbiAgICAgICAgdmFyIHNpZ21hMWggPSAoKGVoID4+PiAxNCkgfCAoZWwgPDwgMTgpKSBeICgoZWggPj4+IDE4KSB8IChlbCA8PCAxNCkpIF4gKChlaCA8PCAyMykgfCAoZWwgPj4+IDkpKTtcbiAgICAgICAgdmFyIHNpZ21hMWwgPSAoKGVsID4+PiAxNCkgfCAoZWggPDwgMTgpKSBeICgoZWwgPj4+IDE4KSB8IChlaCA8PCAxNCkpIF4gKChlbCA8PCAyMykgfCAoZWggPj4+IDkpKTtcblxuICAgICAgICAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldXG4gICAgICAgIHZhciBLaSAgPSBLW2ldO1xuICAgICAgICB2YXIgS2loID0gS2kuaGlnaDtcbiAgICAgICAgdmFyIEtpbCA9IEtpLmxvdztcblxuICAgICAgICB2YXIgdDFsID0gaGwgKyBzaWdtYTFsO1xuICAgICAgICB2YXIgdDFoID0gaGggKyBzaWdtYTFoICsgKCh0MWwgPj4+IDApIDwgKGhsID4+PiAwKSA/IDEgOiAwKTtcbiAgICAgICAgdmFyIHQxbCA9IHQxbCArIGNobDtcbiAgICAgICAgdmFyIHQxaCA9IHQxaCArIGNoaCArICgodDFsID4+PiAwKSA8IChjaGwgPj4+IDApID8gMSA6IDApO1xuICAgICAgICB2YXIgdDFsID0gdDFsICsgS2lsO1xuICAgICAgICB2YXIgdDFoID0gdDFoICsgS2loICsgKCh0MWwgPj4+IDApIDwgKEtpbCA+Pj4gMCkgPyAxIDogMCk7XG4gICAgICAgIHZhciB0MWwgPSB0MWwgKyBXaWw7XG4gICAgICAgIHZhciB0MWggPSB0MWggKyBXaWggKyAoKHQxbCA+Pj4gMCkgPCAoV2lsID4+PiAwKSA/IDEgOiAwKTtcblxuICAgICAgICAvLyB0MiA9IHNpZ21hMCArIG1halxuICAgICAgICB2YXIgdDJsID0gc2lnbWEwbCArIG1hamw7XG4gICAgICAgIHZhciB0MmggPSBzaWdtYTBoICsgbWFqaCArICgodDJsID4+PiAwKSA8IChzaWdtYTBsID4+PiAwKSA/IDEgOiAwKTtcblxuICAgICAgICAvLyBVcGRhdGUgd29ya2luZyB2YXJpYWJsZXNcbiAgICAgICAgaGggPSBnaDtcbiAgICAgICAgaGwgPSBnbDtcbiAgICAgICAgZ2ggPSBmaDtcbiAgICAgICAgZ2wgPSBmbDtcbiAgICAgICAgZmggPSBlaDtcbiAgICAgICAgZmwgPSBlbDtcbiAgICAgICAgZWwgPSAoZGwgKyB0MWwpIHwgMDtcbiAgICAgICAgZWggPSAoZGggKyB0MWggKyAoKGVsID4+PiAwKSA8IChkbCA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcbiAgICAgICAgZGggPSBjaDtcbiAgICAgICAgZGwgPSBjbDtcbiAgICAgICAgY2ggPSBiaDtcbiAgICAgICAgY2wgPSBibDtcbiAgICAgICAgYmggPSBhaDtcbiAgICAgICAgYmwgPSBhbDtcbiAgICAgICAgYWwgPSAodDFsICsgdDJsKSB8IDA7XG4gICAgICAgIGFoID0gKHQxaCArIHQyaCArICgoYWwgPj4+IDApIDwgKHQxbCA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcbiAgICAgIEgwbCA9IEgwLmxvdyAgPSAoSDBsICsgYWwpO1xuICAgICAgSDAuaGlnaCA9IChIMGggKyBhaCArICgoSDBsID4+PiAwKSA8IChhbCA+Pj4gMCkgPyAxIDogMCkpO1xuICAgICAgSDFsID0gSDEubG93ICA9IChIMWwgKyBibCk7XG4gICAgICBIMS5oaWdoID0gKEgxaCArIGJoICsgKChIMWwgPj4+IDApIDwgKGJsID4+PiAwKSA/IDEgOiAwKSk7XG4gICAgICBIMmwgPSBIMi5sb3cgID0gKEgybCArIGNsKTtcbiAgICAgIEgyLmhpZ2ggPSAoSDJoICsgY2ggKyAoKEgybCA+Pj4gMCkgPCAoY2wgPj4+IDApID8gMSA6IDApKTtcbiAgICAgIEgzbCA9IEgzLmxvdyAgPSAoSDNsICsgZGwpO1xuICAgICAgSDMuaGlnaCA9IChIM2ggKyBkaCArICgoSDNsID4+PiAwKSA8IChkbCA+Pj4gMCkgPyAxIDogMCkpO1xuICAgICAgSDRsID0gSDQubG93ICA9IChINGwgKyBlbCk7XG4gICAgICBINC5oaWdoID0gKEg0aCArIGVoICsgKChINGwgPj4+IDApIDwgKGVsID4+PiAwKSA/IDEgOiAwKSk7XG4gICAgICBINWwgPSBINS5sb3cgID0gKEg1bCArIGZsKTtcbiAgICAgIEg1LmhpZ2ggPSAoSDVoICsgZmggKyAoKEg1bCA+Pj4gMCkgPCAoZmwgPj4+IDApID8gMSA6IDApKTtcbiAgICAgIEg2bCA9IEg2LmxvdyAgPSAoSDZsICsgZ2wpO1xuICAgICAgSDYuaGlnaCA9IChINmggKyBnaCArICgoSDZsID4+PiAwKSA8IChnbCA+Pj4gMCkgPyAxIDogMCkpO1xuICAgICAgSDdsID0gSDcubG93ICA9IChIN2wgKyBobCk7XG4gICAgICBINy5oaWdoID0gKEg3aCArIGhoICsgKChIN2wgPj4+IDApIDwgKGhsID4+PiAwKSA/IDEgOiAwKSk7XG4gICAgfSxcblxuICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBTaG9ydGN1dHNcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG4gICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG4gICAgICAvLyBBZGQgcGFkZGluZ1xuICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG4gICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgMTI4KSA+Pj4gMTApIDw8IDUpICsgMzBdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDEyOCkgPj4+IDEwKSA8PCA1KSArIDMxXSA9IG5CaXRzVG90YWw7XG4gICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cbiAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG4gICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cbiAgICAgIC8vIENvbnZlcnQgaGFzaCB0byAzMi1iaXQgd29yZCBhcnJheSBiZWZvcmUgcmV0dXJuaW5nXG4gICAgICB2YXIgaGFzaCA9IHRoaXMuX2hhc2gudG9YMzIoKTtcblxuICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG4gICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH0sXG5cbiAgICBibG9ja1NpemU6IDEwMjQvMzJcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEE1MTIoJ21lc3NhZ2UnKTtcbiAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBNTEyKHdvcmRBcnJheSk7XG4gICAqL1xuICBDLlNIQTUxMiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTUxMik7XG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEE1MTIobWVzc2FnZSwga2V5KTtcbiAgICovXG4gIEMuSG1hY1NIQTUxMiA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEE1MTIpO1xufSgpKTtcbi8qXG4gQ3J5cHRvSlMgdjMuMS4yXG4gc2hhMy5qc1xuIGNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuIChjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuIGNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uIChNYXRoKSB7XG4gIC8vIFNob3J0Y3V0c1xuICB2YXIgQyA9IENyeXB0b0pTO1xuICB2YXIgQ19saWIgPSBDLmxpYjtcbiAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcbiAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcbiAgdmFyIENfeDY0ID0gQy54NjQ7XG4gIHZhciBYNjRXb3JkID0gQ194NjQuV29yZDtcbiAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuICAvLyBDb25zdGFudHMgdGFibGVzXG4gIHZhciBSSE9fT0ZGU0VUUyA9IFtdO1xuICB2YXIgUElfSU5ERVhFUyAgPSBbXTtcbiAgdmFyIFJPVU5EX0NPTlNUQU5UUyA9IFtdO1xuXG4gIC8vIENvbXB1dGUgQ29uc3RhbnRzXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ29tcHV0ZSByaG8gb2Zmc2V0IGNvbnN0YW50c1xuICAgIHZhciB4ID0gMSwgeSA9IDA7XG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICBSSE9fT0ZGU0VUU1t4ICsgNSAqIHldID0gKCh0ICsgMSkgKiAodCArIDIpIC8gMikgJSA2NDtcblxuICAgICAgdmFyIG5ld1ggPSB5ICUgNTtcbiAgICAgIHZhciBuZXdZID0gKDIgKiB4ICsgMyAqIHkpICUgNTtcbiAgICAgIHggPSBuZXdYO1xuICAgICAgeSA9IG5ld1k7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBwaSBpbmRleCBjb25zdGFudHNcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDU7IHgrKykge1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCA1OyB5KyspIHtcbiAgICAgICAgUElfSU5ERVhFU1t4ICsgNSAqIHldID0geSArICgoMiAqIHggKyAzICogeSkgJSA1KSAqIDU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSByb3VuZCBjb25zdGFudHNcbiAgICB2YXIgTEZTUiA9IDB4MDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICB2YXIgcm91bmRDb25zdGFudE1zdyA9IDA7XG4gICAgICB2YXIgcm91bmRDb25zdGFudExzdyA9IDA7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgIGlmIChMRlNSICYgMHgwMSkge1xuICAgICAgICAgIHZhciBiaXRQb3NpdGlvbiA9ICgxIDw8IGopIC0gMTtcbiAgICAgICAgICBpZiAoYml0UG9zaXRpb24gPCAzMikge1xuICAgICAgICAgICAgcm91bmRDb25zdGFudExzdyBePSAxIDw8IGJpdFBvc2l0aW9uO1xuICAgICAgICAgIH0gZWxzZSAvKiBpZiAoYml0UG9zaXRpb24gPj0gMzIpICovIHtcbiAgICAgICAgICAgIHJvdW5kQ29uc3RhbnRNc3cgXj0gMSA8PCAoYml0UG9zaXRpb24gLSAzMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IExGU1JcbiAgICAgICAgaWYgKExGU1IgJiAweDgwKSB7XG4gICAgICAgICAgLy8gUHJpbWl0aXZlIHBvbHlub21pYWwgb3ZlciBHRigyKTogeF44ICsgeF42ICsgeF41ICsgeF40ICsgMVxuICAgICAgICAgIExGU1IgPSAoTEZTUiA8PCAxKSBeIDB4NzE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgTEZTUiA8PD0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBST1VORF9DT05TVEFOVFNbaV0gPSBYNjRXb3JkLmNyZWF0ZShyb3VuZENvbnN0YW50TXN3LCByb3VuZENvbnN0YW50THN3KTtcbiAgICB9XG4gIH0oKSk7XG5cbiAgLy8gUmV1c2FibGUgb2JqZWN0cyBmb3IgdGVtcG9yYXJ5IHZhbHVlc1xuICB2YXIgVCA9IFtdO1xuICAoZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU7IGkrKykge1xuICAgICAgVFtpXSA9IFg2NFdvcmQuY3JlYXRlKCk7XG4gICAgfVxuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBTSEEtMyBoYXNoIGFsZ29yaXRobS5cbiAgICovXG4gIHZhciBTSEEzID0gQ19hbGdvLlNIQTMgPSBIYXNoZXIuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gb3V0cHV0TGVuZ3RoXG4gICAgICogICBUaGUgZGVzaXJlZCBudW1iZXIgb2YgYml0cyBpbiB0aGUgb3V0cHV0IGhhc2guXG4gICAgICogICBPbmx5IHZhbHVlcyBwZXJtaXR0ZWQgYXJlOiAyMjQsIDI1NiwgMzg0LCA1MTIuXG4gICAgICogICBEZWZhdWx0OiA1MTJcbiAgICAgKi9cbiAgICBjZmc6IEhhc2hlci5jZmcuZXh0ZW5kKHtcbiAgICAgIG91dHB1dExlbmd0aDogNTEyXG4gICAgfSksXG5cbiAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGUgPSBbXVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTsgaSsrKSB7XG4gICAgICAgIHN0YXRlW2ldID0gbmV3IFg2NFdvcmQuaW5pdCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJsb2NrU2l6ZSA9ICgxNjAwIC0gMiAqIHRoaXMuY2ZnLm91dHB1dExlbmd0aCkgLyAzMjtcbiAgICB9LFxuXG4gICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG4gICAgICAvLyBTaG9ydGN1dHNcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgdmFyIG5CbG9ja1NpemVMYW5lcyA9IHRoaXMuYmxvY2tTaXplIC8gMjtcblxuICAgICAgLy8gQWJzb3JiXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5CbG9ja1NpemVMYW5lczsgaSsrKSB7XG4gICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICB2YXIgTTJpICA9IE1bb2Zmc2V0ICsgMiAqIGldO1xuICAgICAgICB2YXIgTTJpMSA9IE1bb2Zmc2V0ICsgMiAqIGkgKyAxXTtcblxuICAgICAgICAvLyBTd2FwIGVuZGlhblxuICAgICAgICBNMmkgPSAoXG4gICAgICAgICAgICAoKChNMmkgPDwgOCkgIHwgKE0yaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAgICAgICAgICAgICAoKChNMmkgPDwgMjQpIHwgKE0yaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG4gICAgICAgICAgICApO1xuICAgICAgICBNMmkxID0gKFxuICAgICAgICAgICAgKCgoTTJpMSA8PCA4KSAgfCAoTTJpMSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAgICAgICAgICAgICAoKChNMmkxIDw8IDI0KSB8IChNMmkxID4+PiA4KSkgICYgMHhmZjAwZmYwMClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgLy8gQWJzb3JiIG1lc3NhZ2UgaW50byBzdGF0ZVxuICAgICAgICB2YXIgbGFuZSA9IHN0YXRlW2ldO1xuICAgICAgICBsYW5lLmhpZ2ggXj0gTTJpMTtcbiAgICAgICAgbGFuZS5sb3cgIF49IE0yaTtcbiAgICAgIH1cblxuICAgICAgLy8gUm91bmRzXG4gICAgICBmb3IgKHZhciByb3VuZCA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAgICAgLy8gVGhldGFcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA1OyB4KyspIHtcbiAgICAgICAgICAvLyBNaXggY29sdW1uIGxhbmVzXG4gICAgICAgICAgdmFyIHRNc3cgPSAwLCB0THN3ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDU7IHkrKykge1xuICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVt4ICsgNSAqIHldO1xuICAgICAgICAgICAgdE1zdyBePSBsYW5lLmhpZ2g7XG4gICAgICAgICAgICB0THN3IF49IGxhbmUubG93O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRlbXBvcmFyeSB2YWx1ZXNcbiAgICAgICAgICB2YXIgVHggPSBUW3hdO1xuICAgICAgICAgIFR4LmhpZ2ggPSB0TXN3O1xuICAgICAgICAgIFR4LmxvdyAgPSB0THN3O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNTsgeCsrKSB7XG4gICAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgICAgdmFyIFR4NCA9IFRbKHggKyA0KSAlIDVdO1xuICAgICAgICAgIHZhciBUeDEgPSBUWyh4ICsgMSkgJSA1XTtcbiAgICAgICAgICB2YXIgVHgxTXN3ID0gVHgxLmhpZ2g7XG4gICAgICAgICAgdmFyIFR4MUxzdyA9IFR4MS5sb3c7XG5cbiAgICAgICAgICAvLyBNaXggc3Vycm91bmRpbmcgY29sdW1uc1xuICAgICAgICAgIHZhciB0TXN3ID0gVHg0LmhpZ2ggXiAoKFR4MU1zdyA8PCAxKSB8IChUeDFMc3cgPj4+IDMxKSk7XG4gICAgICAgICAgdmFyIHRMc3cgPSBUeDQubG93ICBeICgoVHgxTHN3IDw8IDEpIHwgKFR4MU1zdyA+Pj4gMzEpKTtcbiAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDU7IHkrKykge1xuICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVt4ICsgNSAqIHldO1xuICAgICAgICAgICAgbGFuZS5oaWdoIF49IHRNc3c7XG4gICAgICAgICAgICBsYW5lLmxvdyAgXj0gdExzdztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSaG8gUGlcbiAgICAgICAgZm9yICh2YXIgbGFuZUluZGV4ID0gMTsgbGFuZUluZGV4IDwgMjU7IGxhbmVJbmRleCsrKSB7XG4gICAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVtsYW5lSW5kZXhdO1xuICAgICAgICAgIHZhciBsYW5lTXN3ID0gbGFuZS5oaWdoO1xuICAgICAgICAgIHZhciBsYW5lTHN3ID0gbGFuZS5sb3c7XG4gICAgICAgICAgdmFyIHJob09mZnNldCA9IFJIT19PRkZTRVRTW2xhbmVJbmRleF07XG5cbiAgICAgICAgICAvLyBSb3RhdGUgbGFuZXNcbiAgICAgICAgICBpZiAocmhvT2Zmc2V0IDwgMzIpIHtcbiAgICAgICAgICAgIHZhciB0TXN3ID0gKGxhbmVNc3cgPDwgcmhvT2Zmc2V0KSB8IChsYW5lTHN3ID4+PiAoMzIgLSByaG9PZmZzZXQpKTtcbiAgICAgICAgICAgIHZhciB0THN3ID0gKGxhbmVMc3cgPDwgcmhvT2Zmc2V0KSB8IChsYW5lTXN3ID4+PiAoMzIgLSByaG9PZmZzZXQpKTtcbiAgICAgICAgICB9IGVsc2UgLyogaWYgKHJob09mZnNldCA+PSAzMikgKi8ge1xuICAgICAgICAgICAgdmFyIHRNc3cgPSAobGFuZUxzdyA8PCAocmhvT2Zmc2V0IC0gMzIpKSB8IChsYW5lTXN3ID4+PiAoNjQgLSByaG9PZmZzZXQpKTtcbiAgICAgICAgICAgIHZhciB0THN3ID0gKGxhbmVNc3cgPDwgKHJob09mZnNldCAtIDMyKSkgfCAobGFuZUxzdyA+Pj4gKDY0IC0gcmhvT2Zmc2V0KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVHJhbnNwb3NlIGxhbmVzXG4gICAgICAgICAgdmFyIFRQaUxhbmUgPSBUW1BJX0lOREVYRVNbbGFuZUluZGV4XV07XG4gICAgICAgICAgVFBpTGFuZS5oaWdoID0gdE1zdztcbiAgICAgICAgICBUUGlMYW5lLmxvdyAgPSB0THN3O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmhvIHBpIGF0IHggPSB5ID0gMFxuICAgICAgICB2YXIgVDAgPSBUWzBdO1xuICAgICAgICB2YXIgc3RhdGUwID0gc3RhdGVbMF07XG4gICAgICAgIFQwLmhpZ2ggPSBzdGF0ZTAuaGlnaDtcbiAgICAgICAgVDAubG93ICA9IHN0YXRlMC5sb3c7XG5cbiAgICAgICAgLy8gQ2hpXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNTsgeCsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCA1OyB5KyspIHtcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICAgICAgdmFyIGxhbmVJbmRleCA9IHggKyA1ICogeTtcbiAgICAgICAgICAgIHZhciBsYW5lID0gc3RhdGVbbGFuZUluZGV4XTtcbiAgICAgICAgICAgIHZhciBUTGFuZSA9IFRbbGFuZUluZGV4XTtcbiAgICAgICAgICAgIHZhciBUeDFMYW5lID0gVFsoKHggKyAxKSAlIDUpICsgNSAqIHldO1xuICAgICAgICAgICAgdmFyIFR4MkxhbmUgPSBUWygoeCArIDIpICUgNSkgKyA1ICogeV07XG5cbiAgICAgICAgICAgIC8vIE1peCByb3dzXG4gICAgICAgICAgICBsYW5lLmhpZ2ggPSBUTGFuZS5oaWdoIF4gKH5UeDFMYW5lLmhpZ2ggJiBUeDJMYW5lLmhpZ2gpO1xuICAgICAgICAgICAgbGFuZS5sb3cgID0gVExhbmUubG93ICBeICh+VHgxTGFuZS5sb3cgICYgVHgyTGFuZS5sb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElvdGFcbiAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVswXTtcbiAgICAgICAgdmFyIHJvdW5kQ29uc3RhbnQgPSBST1VORF9DT05TVEFOVFNbcm91bmRdO1xuICAgICAgICBsYW5lLmhpZ2ggXj0gcm91bmRDb25zdGFudC5oaWdoO1xuICAgICAgICBsYW5lLmxvdyAgXj0gcm91bmRDb25zdGFudC5sb3c7O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcbiAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG4gICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG4gICAgICB2YXIgYmxvY2tTaXplQml0cyA9IHRoaXMuYmxvY2tTaXplICogMzI7XG5cbiAgICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDEgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuICAgICAgZGF0YVdvcmRzWygoTWF0aC5jZWlsKChuQml0c0xlZnQgKyAxKSAvIGJsb2NrU2l6ZUJpdHMpICogYmxvY2tTaXplQml0cykgPj4+IDUpIC0gMV0gfD0gMHg4MDtcbiAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3NcbiAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgIHZhciBvdXRwdXRMZW5ndGhCeXRlcyA9IHRoaXMuY2ZnLm91dHB1dExlbmd0aCAvIDg7XG4gICAgICB2YXIgb3V0cHV0TGVuZ3RoTGFuZXMgPSBvdXRwdXRMZW5ndGhCeXRlcyAvIDg7XG5cbiAgICAgIC8vIFNxdWVlemVcbiAgICAgIHZhciBoYXNoV29yZHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0TGVuZ3RoTGFuZXM7IGkrKykge1xuICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVtpXTtcbiAgICAgICAgdmFyIGxhbmVNc3cgPSBsYW5lLmhpZ2g7XG4gICAgICAgIHZhciBsYW5lTHN3ID0gbGFuZS5sb3c7XG5cbiAgICAgICAgLy8gU3dhcCBlbmRpYW5cbiAgICAgICAgbGFuZU1zdyA9IChcbiAgICAgICAgICAgICgoKGxhbmVNc3cgPDwgOCkgIHwgKGxhbmVNc3cgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG4gICAgICAgICAgICAgICAgKCgobGFuZU1zdyA8PCAyNCkgfCAobGFuZU1zdyA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG4gICAgICAgICAgICApO1xuICAgICAgICBsYW5lTHN3ID0gKFxuICAgICAgICAgICAgKCgobGFuZUxzdyA8PCA4KSAgfCAobGFuZUxzdyA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAgICAgICAgICAgICAoKChsYW5lTHN3IDw8IDI0KSB8IChsYW5lTHN3ID4+PiA4KSkgICYgMHhmZjAwZmYwMClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgLy8gU3F1ZWV6ZSBzdGF0ZSB0byByZXRyaWV2ZSBoYXNoXG4gICAgICAgIGhhc2hXb3Jkcy5wdXNoKGxhbmVMc3cpO1xuICAgICAgICBoYXNoV29yZHMucHVzaChsYW5lTXN3KTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcbiAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQoaGFzaFdvcmRzLCBvdXRwdXRMZW5ndGhCeXRlcyk7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblxuICAgICAgdmFyIHN0YXRlID0gY2xvbmUuX3N0YXRlID0gdGhpcy5fc3RhdGUuc2xpY2UoMCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgc3RhdGVbaV0gPSBzdGF0ZVtpXS5jbG9uZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTMoJ21lc3NhZ2UnKTtcbiAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMyh3b3JkQXJyYXkpO1xuICAgKi9cbiAgQy5TSEEzID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMyk7XG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEzKG1lc3NhZ2UsIGtleSk7XG4gICAqL1xuICBDLkhtYWNTSEEzID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTMpO1xufShNYXRoKSk7XG5cbjsgYnJvd3NlcmlmeV9zaGltX19kZWZpbmVfX21vZHVsZV9fZXhwb3J0X18odHlwZW9mIENyeXB0b0pTICE9IFwidW5kZWZpbmVkXCIgPyBDcnlwdG9KUyA6IHdpbmRvdy5DcnlwdG9KUyk7XG5cbn0pLmNhbGwoZ2xvYmFsLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZ1bmN0aW9uIGRlZmluZUV4cG9ydChleCkgeyBtb2R1bGUuZXhwb3J0cyA9IGV4OyB9KTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG47X19icm93c2VyaWZ5X3NoaW1fcmVxdWlyZV9fPXJlcXVpcmU7KGZ1bmN0aW9uIGJyb3dzZXJpZnlTaGltKG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSwgZGVmaW5lLCBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXykge1xuLyoqXG4gKiBMYXduY2hhaXIhXG4gKiAtLS1cbiAqIGNsaWVudHNpZGUganNvbiBzdG9yZVxuICpcbiAqL1xudmFyIExhd25jaGFpciA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyBlbnN1cmUgTGF3bmNoYWlyIHdhcyBjYWxsZWQgYXMgYSBjb25zdHJ1Y3RvclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGF3bmNoYWlyKSkgcmV0dXJuIG5ldyBMYXduY2hhaXIob3B0aW9ucywgY2FsbGJhY2spO1xuXG4gIC8vIGxhd25jaGFpciByZXF1aXJlcyBqc29uXG4gIGlmICghSlNPTikgdGhyb3cgJ0pTT04gdW5hdmFpbGFibGUhIEluY2x1ZGUgaHR0cDovL3d3dy5qc29uLm9yZy9qc29uMi5qcyB0byBmaXguJ1xuICAvLyBvcHRpb25zIGFyZSBvcHRpb25hbDsgY2FsbGJhY2sgaXMgbm90XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDIgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBjYWxsYmFjayA9ICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSA/IGFyZ3VtZW50c1swXSA6IGFyZ3VtZW50c1sxXTtcbiAgICBvcHRpb25zICA9ICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSA/IHt9IDogYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIHRocm93ICdJbmNvcnJlY3QgIyBvZiBjdG9yIGFyZ3MhJ1xuICB9XG4gIC8vIFRPRE8gcGVyaGFwcyBhbGxvdyBmb3IgcHViL3N1YiBpbnN0ZWFkP1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB0aHJvdyAnTm8gY2FsbGJhY2sgd2FzIHByb3ZpZGVkJztcblxuICAvLyBkZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAgdGhpcy5yZWNvcmQgPSBvcHRpb25zLnJlY29yZCB8fCAncmVjb3JkJyAgLy8gZGVmYXVsdCBmb3IgcmVjb3Jkc1xuICB0aGlzLm5hbWUgICA9IG9wdGlvbnMubmFtZSAgIHx8ICdyZWNvcmRzJyAvLyBkZWZhdWx0IG5hbWUgZm9yIHVuZGVybHlpbmcgc3RvcmVcblxuICAvLyBtaXhpbiBmaXJzdCB2YWxpZCAgYWRhcHRlclxuICB2YXIgYWRhcHRlclxuICAvLyBpZiB0aGUgYWRhcHRlciBpcyBwYXNzZWQgaW4gd2UgdHJ5IHRvIGxvYWQgdGhhdCBvbmx5XG4gIGlmIChvcHRpb25zLmFkYXB0ZXIpIHtcblxuICAgIC8vIHRoZSBhcmd1bWVudCBwYXNzZWQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHByZWZlcmVkIGFkYXB0ZXJzXG4gICAgLy8gaWYgaXQgaXMgbm90LCB3ZSBjb252ZXJ0IGl0XG4gICAgaWYodHlwZW9mKG9wdGlvbnMuYWRhcHRlcikgPT09ICdzdHJpbmcnKXtcbiAgICAgIG9wdGlvbnMuYWRhcHRlciA9IFtvcHRpb25zLmFkYXB0ZXJdO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGVzIG92ZXIgdGhlIGFycmF5IG9mIHBhc3NlZCBhZGFwdGVyc1xuICAgIGZvcih2YXIgaiA9IDAsIGsgPSBvcHRpb25zLmFkYXB0ZXIubGVuZ3RoOyBqIDwgazsgaisrKXtcblxuICAgICAgLy8gaXRpcmF0ZXMgb3ZlciB0aGUgYXJyYXkgb2YgYXZhaWxhYmxlIGFkYXB0ZXJzXG4gICAgICBmb3IgKHZhciBpID0gTGF3bmNoYWlyLmFkYXB0ZXJzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoTGF3bmNoYWlyLmFkYXB0ZXJzW2ldLmFkYXB0ZXIgPT09IG9wdGlvbnMuYWRhcHRlcltqXSkge1xuICAgICAgICAgIGFkYXB0ZXIgPSBMYXduY2hhaXIuYWRhcHRlcnNbaV0udmFsaWQoKSA/IExhd25jaGFpci5hZGFwdGVyc1tpXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoYWRhcHRlcikgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFkYXB0ZXIpIGJyZWFrXG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGZpbmQgdGhlIGZpcnN0IHZhbGlkIGFkYXB0ZXIgZm9yIHRoaXMgZW52XG4gIH1cbiAgZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBMYXduY2hhaXIuYWRhcHRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhZGFwdGVyID0gTGF3bmNoYWlyLmFkYXB0ZXJzW2ldLnZhbGlkKCkgPyBMYXduY2hhaXIuYWRhcHRlcnNbaV0gOiB1bmRlZmluZWRcbiAgICAgIGlmIChhZGFwdGVyKSBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIHdlIGhhdmUgZmFpbGVkXG4gIGlmICghYWRhcHRlcikgdGhyb3cgJ05vIHZhbGlkIGFkYXB0ZXIuJ1xuXG4gIC8vIHlheSEgbWl4aW4gdGhlIGFkYXB0ZXJcbiAgZm9yICh2YXIgaiBpbiBhZGFwdGVyKVxuICAgIHRoaXNbal0gPSBhZGFwdGVyW2pdXG5cbiAgLy8gY2FsbCBpbml0IGZvciBlYWNoIG1peGVkIGluIHBsdWdpblxuICBmb3IgKHZhciBpID0gMCwgbCA9IExhd25jaGFpci5wbHVnaW5zLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICBMYXduY2hhaXIucGx1Z2luc1tpXS5jYWxsKHRoaXMpXG5cbiAgLy8gaW5pdCB0aGUgYWRhcHRlclxuICB0aGlzLmluaXQob3B0aW9ucywgY2FsbGJhY2spXG59XG5cbkxhd25jaGFpci5hZGFwdGVycyA9IFtdXG5cbi8qKlxuICogcXVldWVzIGFuIGFkYXB0ZXIgZm9yIG1peGluXG4gKiA9PT1cbiAqIC0gZW5zdXJlcyBhbiBhZGFwdGVyIGNvbmZvcm1zIHRvIGEgc3BlY2lmaWMgaW50ZXJmYWNlXG4gKlxuICovXG5MYXduY2hhaXIuYWRhcHRlciA9IGZ1bmN0aW9uIChpZCwgb2JqKSB7XG4gIC8vIGFkZCB0aGUgYWRhcHRlciBpZCB0byB0aGUgYWRhcHRlciBvYmpcbiAgLy8gdWdseSBoZXJlIGZvciBhICBjbGVhbmVyIGRzbCBmb3IgaW1wbGVtZW50aW5nIGFkYXB0ZXJzXG4gIG9ialsnYWRhcHRlciddID0gaWRcbiAgLy8gbWV0aG9kcyByZXF1aXJlZCB0byBpbXBsZW1lbnQgYSBsYXduY2hhaXIgYWRhcHRlclxuICB2YXIgaW1wbGVtZW50aW5nID0gJ2FkYXB0ZXIgdmFsaWQgaW5pdCBrZXlzIHNhdmUgYmF0Y2ggZ2V0IGV4aXN0cyBhbGwgcmVtb3ZlIG51a2UnLnNwbGl0KCcgJylcbiAgICAsICAgaW5kZXhPZiA9IHRoaXMucHJvdG90eXBlLmluZGV4T2ZcbiAgLy8gbWl4IGluIHRoZSBhZGFwdGVyXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGluZGV4T2YoaW1wbGVtZW50aW5nLCBpKSA9PT0gLTEpIHRocm93ICdJbnZhbGlkIGFkYXB0ZXIhIE5vbnN0YW5kYXJkIG1ldGhvZDogJyArIGlcbiAgfVxuICAvLyBpZiB3ZSBtYWRlIGl0IHRoaXMgZmFyIHRoZSBhZGFwdGVyIGludGVyZmFjZSBpcyB2YWxpZFxuICAvLyBpbnNlcnQgdGhlIG5ldyBhZGFwdGVyIGFzIHRoZSBwcmVmZXJyZWQgYWRhcHRlclxuICBMYXduY2hhaXIuYWRhcHRlcnMuc3BsaWNlKDAsMCxvYmopXG59XG5cbkxhd25jaGFpci5wbHVnaW5zID0gW11cblxuLyoqXG4gKiBnZW5lcmljIHNoYWxsb3cgZXh0ZW5zaW9uIGZvciBwbHVnaW5zXG4gKiA9PT1cbiAqIC0gaWYgYW4gaW5pdCBtZXRob2QgaXMgZm91bmQgaXQgcmVnaXN0ZXJzIGl0IHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBsYXduY2hhaXIgaXMgaW5pdGVkXG4gKiAtIHllcyB3ZSBjb3VsZCB1c2UgaGFzT3duUHJvcCBidXQgbm9ib2R5IGhlcmUgaXMgYW4gYXNzaG9sZVxuICovXG5MYXduY2hhaXIucGx1Z2luID0gZnVuY3Rpb24gKG9iaikge1xuICBmb3IgKHZhciBpIGluIG9iailcbiAgICBpID09PSAnaW5pdCcgPyBMYXduY2hhaXIucGx1Z2lucy5wdXNoKG9ialtpXSkgOiB0aGlzLnByb3RvdHlwZVtpXSA9IG9ialtpXVxufVxuXG4vKipcbiAqIGhlbHBlcnNcbiAqXG4gKi9cbkxhd25jaGFpci5wcm90b3R5cGUgPSB7XG5cbiAgaXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IEFycmF5XScgfSxcblxuICAvKipcbiAgICogdGhpcyBjb2RlIGV4aXN0cyBmb3IgaWU4Li4uIGZvciBtb3JlIGJhY2tncm91bmQgc2VlOlxuICAgKiBodHRwOi8vd3d3LmZsaWNrci5jb20vcGhvdG9zL3dlc3Rjb2FzdGxvZ2ljLzU5NTUzNjU3NDIvaW4vcGhvdG9zdHJlYW1cbiAgICovXG4gIGluZGV4T2Y6IGZ1bmN0aW9uKGFyeSwgaXRlbSwgaSwgbCkge1xuICAgIGlmIChhcnkuaW5kZXhPZikgcmV0dXJuIGFyeS5pbmRleE9mKGl0ZW0pXG4gICAgZm9yIChpID0gMCwgbCA9IGFyeS5sZW5ndGg7IGkgPCBsOyBpKyspIGlmIChhcnlbaV0gPT09IGl0ZW0pIHJldHVybiBpXG4gICAgcmV0dXJuIC0xXG4gIH0sXG5cbiAgLy8gYXdlc29tZSBzaG9ydGhhbmQgY2FsbGJhY2tzIGFzIHN0cmluZ3MuIHRoaXMgaXMgc2hhbWVsZXNzIHRoZWZ0IGZyb20gZG9qby5cbiAgbGFtYmRhOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5mbih0aGlzLnJlY29yZCwgY2FsbGJhY2spXG4gIH0sXG5cbiAgLy8gZmlyc3Qgc3RhYiBhdCBuYW1lZCBwYXJhbWV0ZXJzIGZvciB0ZXJzZSBjYWxsYmFja3M7IGRvam86IGZpcnN0ICE9IGJlc3QgLy8gO0RcbiAgZm46IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0eXBlb2YgY2FsbGJhY2sgPT0gJ3N0cmluZycgPyBuZXcgRnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIDogY2FsbGJhY2tcbiAgfSxcblxuICAvLyByZXR1cm5zIGEgdW5pcXVlIGlkZW50aWZpZXIgKGJ5IHdheSBvZiBCYWNrYm9uZS5sb2NhbFN0b3JhZ2UuanMpXG4gIC8vIFRPRE8gaW52ZXN0aWdhdGUgc21hbGxlciBVVUlEcyB0byBjdXQgb24gc3RvcmFnZSBjb3N0XG4gIHV1aWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgUzQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKCgoMStNYXRoLnJhbmRvbSgpKSoweDEwMDAwKXwwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICByZXR1cm4gKFM0KCkrUzQoKStcIi1cIitTNCgpK1wiLVwiK1M0KCkrXCItXCIrUzQoKStcIi1cIitTNCgpK1M0KCkrUzQoKSk7XG4gIH0sXG5cbiAgLy8gYSBjbGFzc2ljIGl0ZXJhdG9yXG4gIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBjYiA9IHRoaXMubGFtYmRhKGNhbGxiYWNrKVxuICAgIC8vIGl0ZXJhdGUgZnJvbSBjaGFpblxuICAgIGlmICh0aGlzLl9fcmVzdWx0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9fcmVzdWx0cy5sZW5ndGg7IGkgPCBsOyBpKyspIGNiLmNhbGwodGhpcywgdGhpcy5fX3Jlc3VsdHNbaV0sIGkpXG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSBpdGVyYXRlIHRoZSBlbnRpcmUgY29sbGVjdGlvblxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5hbGwoZnVuY3Rpb24ocikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHIubGVuZ3RoOyBpIDwgbDsgaSsrKSBjYi5jYWxsKHRoaXMsIHJbaV0sIGkpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG4vLyAtLVxufTtcbi8vIHdpbmRvdy5uYW1lIGNvZGUgY291cnRlc3kgUmVteSBTaGFycDogaHR0cDovLzI0d2F5cy5vcmcvMjAwOS9icmVha2luZy1vdXQtdGhlLWVkZ2VzLW9mLXRoZS1icm93c2VyXG5MYXduY2hhaXIuYWRhcHRlcignd2luZG93LW5hbWUnLCAoZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93PT09J3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cgPSB7IHRvcDogeyB9IH07IC8vIG5vZGUvb3B0aW1pemVyIGNvbXBhdGliaWxpdHlcbiAgfVxuXG4gIC8vIGVkaXRlZCBmcm9tIHRoZSBvcmlnaW5hbCBoZXJlIGJ5IGVsc2lnaFxuICAvLyBTb21lIHNpdGVzIHN0b3JlIEpTT04gZGF0YSBpbiB3aW5kb3cudG9wLm5hbWUsIGJ1dCBzb21lIGZvbGtzICh0d2l0dGVyIG9uIGlQYWQpXG4gIC8vIHB1dCBzaW1wbGUgc3RyaW5ncyBpbiB0aGVyZSAtIHdlIHNob3VsZCBtYWtlIHN1cmUgbm90IHRvIGNhdXNlIGEgU3ludGF4RXJyb3IuXG4gIHZhciBkYXRhID0ge31cbiAgdHJ5IHtcbiAgICBkYXRhID0gSlNPTi5wYXJzZSh3aW5kb3cudG9wLm5hbWUpXG4gIH0gY2F0Y2ggKGUpIHt9XG5cblxuICByZXR1cm4ge1xuXG4gICAgdmFsaWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygd2luZG93LnRvcC5uYW1lICE9ICd1bmRlZmluZWQnXG4gICAgfSxcblxuICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgZGF0YVt0aGlzLm5hbWVdID0gZGF0YVt0aGlzLm5hbWVdIHx8IHtpbmRleDpbXSxzdG9yZTp7fX1cbiAgICAgIHRoaXMuaW5kZXggPSBkYXRhW3RoaXMubmFtZV0uaW5kZXhcbiAgICAgIHRoaXMuc3RvcmUgPSBkYXRhW3RoaXMubmFtZV0uc3RvcmVcbiAgICAgIHRoaXMuZm4odGhpcy5uYW1lLCBjYWxsYmFjaykuY2FsbCh0aGlzLCB0aGlzKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAga2V5czogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmZuKCdrZXlzJywgY2FsbGJhY2spLmNhbGwodGhpcywgdGhpcy5pbmRleClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIHNhdmU6IGZ1bmN0aW9uIChvYmosIGNiKSB7XG4gICAgICAvLyBkYXRhW2tleV0gPSB2YWx1ZSArICcnOyAvLyBmb3JjZSB0byBzdHJpbmdcbiAgICAgIC8vIHdpbmRvdy50b3AubmFtZSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgdmFyIGtleSA9IG9iai5rZXkgfHwgdGhpcy51dWlkKClcbiAgICAgIHRoaXMuZXhpc3RzKGtleSwgZnVuY3Rpb24oZXhpc3RzKSB7XG4gICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgaWYgKG9iai5rZXkpIGRlbGV0ZSBvYmoua2V5XG4gICAgICAgICAgdGhpcy5pbmRleC5wdXNoKGtleSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JlW2tleV0gPSBvYmpcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHdpbmRvdy50b3AubmFtZSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpIC8vIFRPRE8gd293LCB0aGlzIGlzIHRoZSBvbmx5IGRpZmYgZnJvbSB0aGUgbWVtb3J5IGFkYXB0ZXJcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgLy8gcmVzdG9yZSBpbmRleC9zdG9yZSB0byBwcmV2aW91cyB2YWx1ZSBiZWZvcmUgSlNPTiBleGNlcHRpb25cbiAgICAgICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0b3JlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBvYmoua2V5ID0ga2V5XG4gICAgICAgICAgdGhpcy5sYW1iZGEoY2IpLmNhbGwodGhpcywgb2JqKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgYmF0Y2g6IGZ1bmN0aW9uIChvYmpzLCBjYikge1xuICAgICAgdmFyIHIgPSBbXVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmpzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLnNhdmUob2Jqc1tpXSwgZnVuY3Rpb24ocmVjb3JkKSB7XG4gICAgICAgICAgci5wdXNoKHJlY29yZClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGlmIChjYikgdGhpcy5sYW1iZGEoY2IpLmNhbGwodGhpcywgcilcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gKGtleU9yQXJyYXksIGNiKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIGlmICh0aGlzLmlzQXJyYXkoa2V5T3JBcnJheSkpIHtcbiAgICAgICAgciA9IFtdXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5T3JBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICByLnB1c2godGhpcy5zdG9yZVtrZXlPckFycmF5W2ldXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciA9IHRoaXMuc3RvcmVba2V5T3JBcnJheV1cbiAgICAgICAgaWYgKHIpIHIua2V5ID0ga2V5T3JBcnJheVxuICAgICAgfVxuICAgICAgaWYgKGNiKSB0aGlzLmxhbWJkYShjYikuY2FsbCh0aGlzLCByKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgZXhpc3RzOiBmdW5jdGlvbiAoa2V5LCBjYikge1xuICAgICAgdGhpcy5sYW1iZGEoY2IpLmNhbGwodGhpcywgISEodGhpcy5zdG9yZVtrZXldKSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGFsbDogZnVuY3Rpb24gKGNiKSB7XG4gICAgICB2YXIgciA9IFtdXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuaW5kZXgubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLnN0b3JlW3RoaXMuaW5kZXhbaV1dXG4gICAgICAgIG9iai5rZXkgPSB0aGlzLmluZGV4W2ldXG4gICAgICAgIHIucHVzaChvYmopXG4gICAgICB9XG4gICAgICB0aGlzLmZuKHRoaXMubmFtZSwgY2IpLmNhbGwodGhpcywgcilcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGtleU9yQXJyYXksIGNiKSB7XG4gICAgICB2YXIgZGVsID0gdGhpcy5pc0FycmF5KGtleU9yQXJyYXkpID8ga2V5T3JBcnJheSA6IFtrZXlPckFycmF5XVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkZWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBkZWxbaV0ua2V5ID8gZGVsW2ldLmtleSA6IGRlbFtpXVxuICAgICAgICB2YXIgd2hlcmUgPSB0aGlzLmluZGV4T2YodGhpcy5pbmRleCwga2V5KVxuICAgICAgICBpZiAod2hlcmUgPCAwKSBjb250aW51ZSAvKiBrZXkgbm90IHByZXNlbnQgKi9cbiAgICAgICAgZGVsZXRlIHRoaXMuc3RvcmVba2V5XVxuICAgICAgICB0aGlzLmluZGV4LnNwbGljZSh3aGVyZSwgMSlcbiAgICAgIH1cbiAgICAgIHdpbmRvdy50b3AubmFtZSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgICBpZiAoY2IpIHRoaXMubGFtYmRhKGNiKS5jYWxsKHRoaXMpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBudWtlOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHRoaXMuc3RvcmUgPSBkYXRhW3RoaXMubmFtZV0uc3RvcmUgPSB7fVxuICAgICAgdGhpcy5pbmRleCA9IGRhdGFbdGhpcy5uYW1lXS5pbmRleCA9IFtdXG4gICAgICB3aW5kb3cudG9wLm5hbWUgPSBKU09OLnN0cmluZ2lmeShkYXRhKVxuICAgICAgaWYgKGNiKSB0aGlzLmxhbWJkYShjYikuY2FsbCh0aGlzKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cbi8vLy8vXG59KSgpKVxuLyoqXG4gKiBkb20gc3RvcmFnZSBhZGFwdGVyXG4gKiA9PT1cbiAqIC0gb3JpZ2luYWxseSBhdXRob3JlZCBieSBKb3NlcGggUGVjb3Jhcm9cbiAqXG4gKi9cbi8vXG4vLyBUT0RPIGRvZXMgaXQgbWFrZSBzZW5zZSB0byBiZSBjaGFpbmFibGUgYWxsIG92ZXIgdGhlIHBsYWNlP1xuLy8gY2hhaW5hYmxlOiBudWtlLCByZW1vdmUsIGFsbCwgZ2V0LCBzYXZlLCBhbGwgICAgXG4vLyBub3QgY2hhaW5hYmxlOiB2YWxpZCwga2V5c1xuLy9cbkxhd25jaGFpci5hZGFwdGVyKCdkb20nLCAoZnVuY3Rpb24oKSB7XG4gIHZhciBzdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZVxuICAvLyB0aGUgaW5kZXhlciBpcyBhbiBlbmNhcHN1bGF0aW9uIG9mIHRoZSBoZWxwZXJzIG5lZWRlZCB0byBrZWVwIGFuIG9yZGVyZWQgaW5kZXggb2YgdGhlIGtleXNcbiAgdmFyIGluZGV4ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIHRoZSBrZXlcbiAgICAgIGtleTogbmFtZSArICcuX2luZGV4XycsXG4gICAgICAvLyByZXR1cm5zIHRoZSBpbmRleFxuICAgICAgYWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgID0gc3RvcmFnZS5nZXRJdGVtKHRoaXMua2V5KVxuICAgICAgICBpZiAoYSkge1xuICAgICAgICAgIGEgPSBKU09OLnBhcnNlKGEpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgPT09IG51bGwpIHN0b3JhZ2Uuc2V0SXRlbSh0aGlzLmtleSwgSlNPTi5zdHJpbmdpZnkoW10pKSAvLyBsYXp5IGluaXRcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RvcmFnZS5nZXRJdGVtKHRoaXMua2V5KSlcbiAgICAgIH0sXG4gICAgICAvLyBhZGRzIGEga2V5IHRvIHRoZSBpbmRleFxuICAgICAgYWRkOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5hbGwoKVxuICAgICAgICBhLnB1c2goa2V5KVxuICAgICAgICBzdG9yYWdlLnNldEl0ZW0odGhpcy5rZXksIEpTT04uc3RyaW5naWZ5KGEpKVxuICAgICAgfSxcbiAgICAgIC8vIGRlbGV0ZXMgYSBrZXkgZnJvbSB0aGUgaW5kZXhcbiAgICAgIGRlbDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuYWxsKCksIHIgPSBbXVxuICAgICAgICAvLyBGSVhNRSB0aGlzIGlzIGNyYXp5IGluZWZmaWNpZW50IGJ1dCBJJ20gaW4gYSBzdHJhdGEgbWVldGluZyBhbmQgaGFsZiBjb25jZW50cmF0aW5nXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoYVtpXSAhPSBrZXkpIHIucHVzaChhW2ldKVxuICAgICAgICB9XG4gICAgICAgIHN0b3JhZ2Uuc2V0SXRlbSh0aGlzLmtleSwgSlNPTi5zdHJpbmdpZnkocikpXG4gICAgICB9LFxuICAgICAgLy8gcmV0dXJucyBpbmRleCBmb3IgYSBrZXlcbiAgICAgIGZpbmQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmFsbCgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSBhW2ldKSByZXR1cm4gaVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkYXB0ZXIgYXBpXG4gIHJldHVybiB7XG5cbiAgICAvLyBlbnN1cmUgd2UgYXJlIGluIGFuIGVudiB3aXRoIGxvY2FsU3RvcmFnZVxuICAgIHZhbGlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISFzdG9yYWdlICYmIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBpbiBtb2JpbGUgc2FmYXJpIGlmIHNhZmUgYnJvd3NpbmcgaXMgZW5hYmxlZCwgd2luZG93LnN0b3JhZ2VcbiAgICAgICAgLy8gaXMgZGVmaW5lZCBidXQgc2V0SXRlbSBjYWxscyB0aHJvdyBleGNlcHRpb25zLlxuICAgICAgICB2YXIgc3VjY2VzcyA9IHRydWVcbiAgICAgICAgdmFyIHZhbHVlID0gTWF0aC5yYW5kb20oKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbSh2YWx1ZSwgdmFsdWUpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzdWNjZXNzID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0odmFsdWUpXG4gICAgICAgIHJldHVybiBzdWNjZXNzXG4gICAgICB9KClcbiAgICB9LFxuXG4gICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmluZGV4ZXIgPSBpbmRleGVyKHRoaXMubmFtZSlcbiAgICAgIGlmIChjYWxsYmFjaykgdGhpcy5mbih0aGlzLm5hbWUsIGNhbGxiYWNrKS5jYWxsKHRoaXMsIHRoaXMpXG4gICAgfSxcblxuICAgIHNhdmU6IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XG4gICAgICB2YXIga2V5ID0gb2JqLmtleSA/IHRoaXMubmFtZSArICcuJyArIG9iai5rZXkgOiB0aGlzLm5hbWUgKyAnLicgKyB0aGlzLnV1aWQoKVxuICAgICAgLy8gbm93IHdlIGtpbCB0aGUga2V5IGFuZCB1c2UgaXQgaW4gdGhlIHN0b3JlIGNvbGxlY2l0b25cbiAgICAgIGRlbGV0ZSBvYmoua2V5O1xuICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkob2JqKSlcbiAgICAgIC8vIGlmIHRoZSBrZXkgaXMgbm90IGluIHRoZSBpbmRleCBwdXNoIGl0IG9uXG4gICAgICBpZiAodGhpcy5pbmRleGVyLmZpbmQoa2V5KSA9PT0gZmFsc2UpIHRoaXMuaW5kZXhlci5hZGQoa2V5KVxuICAgICAgb2JqLmtleSA9IGtleS5zbGljZSh0aGlzLm5hbWUubGVuZ3RoICsgMSlcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmxhbWJkYShjYWxsYmFjaykuY2FsbCh0aGlzLCBvYmopXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBiYXRjaDogZnVuY3Rpb24gKGFyeSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBzYXZlZCA9IFtdXG4gICAgICAvLyBub3QgcGFydGljdWxhcmlseSBlZmZpY2llbnQgYnV0IHRoaXMgaXMgbW9yZSBmb3Igc3FsaXRlIHNpdHVhdGlvbnNcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJ5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLnNhdmUoYXJ5W2ldLCBmdW5jdGlvbihyKXtcbiAgICAgICAgICBzYXZlZC5wdXNoKHIpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2spIHRoaXMubGFtYmRhKGNhbGxiYWNrKS5jYWxsKHRoaXMsIHNhdmVkKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgLy8gYWNjZXB0cyBbb3B0aW9uc10sIGNhbGxiYWNrXG4gICAga2V5czogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZVxuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kZXhlci5hbGwoKTtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgLy9DaGVja2luZyBmb3IgdGhlIHN1cHBvcnQgb2YgbWFwLlxuICAgICAgICBpZihBcnJheS5wcm90b3R5cGUubWFwKSB7XG4gICAgICAgICAga2V5cyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKHIpeyByZXR1cm4gci5yZXBsYWNlKG5hbWUgKyAnLicsICcnKSB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpbmRpY2VzKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5LnJlcGxhY2UobmFtZSArICcuJywgJycpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbigna2V5cycsIGNhbGxiYWNrKS5jYWxsKHRoaXMsIGtleXMpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcyAvLyBUT0RPIG9wdGlvbnMgZm9yIGxpbWl0L29mZnNldCwgcmV0dXJuIHByb21pc2VcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbiAoa2V5LCBjYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMuaXNBcnJheShrZXkpKSB7XG4gICAgICAgIHZhciByID0gW11cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGsgPSB0aGlzLm5hbWUgKyAnLicgKyBrZXlbaV1cbiAgICAgICAgICB2YXIgb2JqID0gc3RvcmFnZS5nZXRJdGVtKGspXG4gICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgb2JqID0gSlNPTi5wYXJzZShvYmopXG4gICAgICAgICAgICBvYmoua2V5ID0ga2V5W2ldXG4gICAgICAgICAgfVxuICAgICAgICAgIHIucHVzaChvYmopXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB0aGlzLmxhbWJkYShjYWxsYmFjaykuY2FsbCh0aGlzLCByKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGsgPSB0aGlzLm5hbWUgKyAnLicgKyBrZXlcbiAgICAgICAgdmFyICBvYmogPSBzdG9yYWdlLmdldEl0ZW0oaylcbiAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgIG9iaiA9IEpTT04ucGFyc2Uob2JqKVxuICAgICAgICAgIG9iai5rZXkgPSBrZXlcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHRoaXMubGFtYmRhKGNhbGxiYWNrKS5jYWxsKHRoaXMsIG9iailcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGV4aXN0czogZnVuY3Rpb24gKGtleSwgY2IpIHtcbiAgICAgIHZhciBleGlzdHMgPSB0aGlzLmluZGV4ZXIuZmluZCh0aGlzLm5hbWUrJy4nK2tleSkgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlIDtcbiAgICAgIHRoaXMubGFtYmRhKGNiKS5jYWxsKHRoaXMsIGV4aXN0cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIE5PVEUgYWRhcHRlcnMgY2Fubm90IHNldCB0aGlzLl9fcmVzdWx0cyBidXQgcGx1Z2lucyBkb1xuICAgIC8vIHRoaXMgcHJvYmFibHkgc2hvdWxkIGJlIHJldmlld2VkXG4gICAgYWxsOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBpZHggPSB0aGlzLmluZGV4ZXIuYWxsKClcbiAgICAgICAgLCAgIHIgICA9IFtdXG4gICAgICAgICwgICBvXG4gICAgICAgICwgICBrXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGlkeC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgayAgICAgPSBpZHhbaV0gLy92XG4gICAgICAgIG8gICAgID0gSlNPTi5wYXJzZShzdG9yYWdlLmdldEl0ZW0oaykpXG4gICAgICAgIG8ua2V5ID0gay5yZXBsYWNlKHRoaXMubmFtZSArICcuJywgJycpXG4gICAgICAgIHIucHVzaChvKVxuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKSB0aGlzLmZuKHRoaXMubmFtZSwgY2FsbGJhY2spLmNhbGwodGhpcywgcilcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGtleU9yQXJyYXksIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5pc0FycmF5KGtleU9yQXJyYXkpKSB7XG4gICAgICAgIC8vIGJhdGNoIHJlbW92ZVxuICAgICAgICB2YXIgaSwgZG9uZSA9IGtleU9yQXJyYXkubGVuZ3RoO1xuICAgICAgICB2YXIgcmVtb3ZlT25lID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHNlbGYucmVtb3ZlKGtleU9yQXJyYXlbaV0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCgtLWRvbmUpID4gMCkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBzZWxmLmxhbWJkYShjYWxsYmFjaykuY2FsbChzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChpPTA7IGkgPCBrZXlPckFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHJlbW92ZU9uZShpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdGhpcy5uYW1lICsgJy4nICtcbiAgICAgICAgKChrZXlPckFycmF5LmtleSkgPyBrZXlPckFycmF5LmtleSA6IGtleU9yQXJyYXkpXG4gICAgICB0aGlzLmluZGV4ZXIuZGVsKGtleSlcbiAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG4gICAgICBpZiAoY2FsbGJhY2spIHRoaXMubGFtYmRhKGNhbGxiYWNrKS5jYWxsKHRoaXMpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBudWtlOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuYWxsKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSByLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMucmVtb3ZlKHJbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykgdGhpcy5sYW1iZGEoY2FsbGJhY2spLmNhbGwodGhpcylcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfX0pKCkpO1xuTGF3bmNoYWlyLmFkYXB0ZXIoJ3dlYmtpdC1zcWxpdGUnLCAoZnVuY3Rpb24oKSB7XG4gIC8vIHByaXZhdGUgbWV0aG9kc1xuICB2YXIgZmFpbCA9IGZ1bmN0aW9uKGUsIGkpIHtcbiAgICBpZiAoY29uc29sZSkge1xuICAgICAgY29uc29sZS5sb2coJ2Vycm9yIGluIHNxbGl0ZSBhZGFwdG9yIScsIGUsIGkpXG4gICAgfVxuICB9LCBub3cgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpXG4gICAgfSAvLyBGSVhNRSBuZWVkIHRvIHVzZSBiZXR0ZXIgZGF0ZSBmblxuICAgIC8vIG5vdCBlbnRpcmVseSBzdXJlIGlmIHRoaXMgaXMgbmVlZGVkLi4uXG5cbiAgLy8gcHVibGljIG1ldGhvZHNcbiAgcmV0dXJuIHtcblxuICAgIHZhbGlkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhISh3aW5kb3cub3BlbkRhdGFiYXNlKVxuICAgIH0sXG5cbiAgICBpbml0OiBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICBjYiA9IHRoYXQuZm4odGhhdC5uYW1lLCBjYWxsYmFjayksXG4gICAgICAgIGNyZWF0ZSA9IFwiQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgXCIgKyB0aGlzLnJlY29yZCArIFwiIChpZCBOVkFSQ0hBUigzMikgVU5JUVVFIFBSSU1BUlkgS0VZLCB2YWx1ZSBURVhULCB0aW1lc3RhbXAgUkVBTClcIixcbiAgICAgICAgd2luID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGNiLmNhbGwodGhhdCwgdGhhdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3BlbiBhIGNvbm5lY3Rpb24gYW5kIGNyZWF0ZSB0aGUgZGIgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgICAvL0ZFRURIRU5SWSBDSEFOR0UgVE8gQUxMT1cgRVJST1IgQ0FMTEJBQ0tcbiAgICAgIGlmIChvcHRpb25zICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRpb25zLmZhaWwpIGZhaWwgPSBvcHRpb25zLmZhaWxcbiAgICAgICAgLy9FTkQgQ0hBTkdFXG4gICAgICB0aGlzLmRiID0gb3BlbkRhdGFiYXNlKHRoaXMubmFtZSwgJzEuMC4wJywgdGhpcy5uYW1lLCA2NTUzNilcbiAgICAgIHRoaXMuZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24odCkge1xuICAgICAgICB0LmV4ZWN1dGVTcWwoY3JlYXRlLCBbXSwgd2luLCBmYWlsKVxuICAgICAgfSlcbiAgICB9LFxuXG4gICAga2V5czogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHZhciBjYiA9IHRoaXMubGFtYmRhKGNhbGxiYWNrKSxcbiAgICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICAgIGtleXMgPSBcIlNFTEVDVCBpZCBGUk9NIFwiICsgdGhpcy5yZWNvcmQgKyBcIiBPUkRFUiBCWSB0aW1lc3RhbXAgREVTQ1wiXG5cbiAgICAgIHRoaXMuZGIucmVhZFRyYW5zYWN0aW9uKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHdpbiA9IGZ1bmN0aW9uKHh4eCwgcmVzdWx0cykge1xuICAgICAgICAgIGlmIChyZXN1bHRzLnJvd3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGNiLmNhbGwodGhhdCwgW10pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlc3VsdHMucm93cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgci5wdXNoKHJlc3VsdHMucm93cy5pdGVtKGkpLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiLmNhbGwodGhhdCwgcilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdC5leGVjdXRlU3FsKGtleXMsIFtdLCB3aW4sIGZhaWwpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIC8vIHlvdSB0aGluayB0aGF0cyBhaXIgeW91J3JlIGJyZWF0aGluZyBub3c/XG4gICAgc2F2ZTogZnVuY3Rpb24ob2JqLCBjYWxsYmFjaywgZXJyb3IpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgb2JqcyA9ICh0aGlzLmlzQXJyYXkob2JqKSA/IG9iaiA6IFtvYmpdKS5tYXAoZnVuY3Rpb24obykge1xuICAgICAgICBpZiAoIW8ua2V5KSB7XG4gICAgICAgICAgby5rZXkgPSB0aGF0LnV1aWQoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvXG4gICAgICB9KSxcbiAgICAgICAgaW5zID0gXCJJTlNFUlQgT1IgUkVQTEFDRSBJTlRPIFwiICsgdGhpcy5yZWNvcmQgKyBcIiAodmFsdWUsIHRpbWVzdGFtcCwgaWQpIFZBTFVFUyAoPyw/LD8pXCIsXG4gICAgICAgIHdpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhhdC5sYW1iZGEoY2FsbGJhY2spLmNhbGwodGhhdCwgdGhhdC5pc0FycmF5KG9iaikgPyBvYmpzIDogb2Jqc1swXSlcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGVycm9yID0gZXJyb3IgfHwgZnVuY3Rpb24oKSB7fSwgaW5zdmFscyA9IFtdLFxuICAgICAgICB0cyA9IG5vdygpXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9ianMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpbnN2YWxzW2ldID0gW0pTT04uc3RyaW5naWZ5KG9ianNbaV0pLCB0cywgb2Jqc1tpXS5rZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGZhaWwoZSlcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG5cbiAgICAgIHRoYXQuZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9ianMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIHQuZXhlY3V0ZVNxbChpbnMsIGluc3ZhbHNbaV0pXG4gICAgICB9LCBmdW5jdGlvbihlLCBpKSB7XG4gICAgICAgIGZhaWwoZSwgaSlcbiAgICAgIH0sIHdpbilcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG5cbiAgICBiYXRjaDogZnVuY3Rpb24ob2JqcywgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnNhdmUob2JqcywgY2FsbGJhY2spXG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24oa2V5T3JBcnJheSwgY2IpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgc3FsID0gJycsXG4gICAgICAgIGFyZ3MgPSB0aGlzLmlzQXJyYXkoa2V5T3JBcnJheSkgPyBrZXlPckFycmF5IDogW2tleU9yQXJyYXldO1xuICAgICAgLy8gYmF0Y2ggc2VsZWN0cyBzdXBwb3J0XG4gICAgICBzcWwgPSAnU0VMRUNUIGlkLCB2YWx1ZSBGUk9NICcgKyB0aGlzLnJlY29yZCArIFwiIFdIRVJFIGlkIElOIChcIiArXG4gICAgICAgIGFyZ3MubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJz8nXG4gICAgICB9KS5qb2luKFwiLFwiKSArIFwiKVwiXG4gICAgICAvLyBGSVhNRVxuICAgICAgLy8gd2lsbCBhbHdheXMgbG9vcCB0aGUgcmVzdWx0cyBidXQgY2xlYW5zIGl0IHVwIGlmIG5vdCBhIGJhdGNoIHJldHVybiBhdCB0aGUgZW5kLi5cbiAgICAgIC8vIGluIG90aGVyIHdvcmRzLCB0aGlzIGNvdWxkIGJlIGZhc3RlclxuICAgICAgdmFyIHdpbiA9IGZ1bmN0aW9uKHh4eCwgcmVzdWx0cykge1xuICAgICAgICB2YXIgbywgciwgbG9va3VwID0ge31cbiAgICAgICAgICAvLyBtYXAgZnJvbSByZXN1bHRzIHRvIGtleXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSByZXN1bHRzLnJvd3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbyA9IEpTT04ucGFyc2UocmVzdWx0cy5yb3dzLml0ZW0oaSkudmFsdWUpXG4gICAgICAgICAgby5rZXkgPSByZXN1bHRzLnJvd3MuaXRlbShpKS5pZFxuICAgICAgICAgIGxvb2t1cFtvLmtleV0gPSBvO1xuICAgICAgICB9XG4gICAgICAgIHIgPSBhcmdzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICByZXR1cm4gbG9va3VwW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoYXQuaXNBcnJheShrZXlPckFycmF5KSkgciA9IHIubGVuZ3RoID8gclswXSA6IG51bGxcbiAgICAgICAgaWYgKGNiKSB0aGF0LmxhbWJkYShjYikuY2FsbCh0aGF0LCByKVxuICAgICAgfVxuICAgICAgdGhpcy5kYi5yZWFkVHJhbnNhY3Rpb24oZnVuY3Rpb24odCkge1xuICAgICAgICB0LmV4ZWN1dGVTcWwoc3FsLCBhcmdzLCB3aW4sIGZhaWwpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgZXhpc3RzOiBmdW5jdGlvbihrZXksIGNiKSB7XG4gICAgICB2YXIgaXMgPSBcIlNFTEVDVCAqIEZST00gXCIgKyB0aGlzLnJlY29yZCArIFwiIFdIRVJFIGlkID0gP1wiLFxuICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgd2luID0gZnVuY3Rpb24oeHh4LCByZXN1bHRzKSB7XG4gICAgICAgICAgaWYgKGNiKSB0aGF0LmZuKCdleGlzdHMnLCBjYikuY2FsbCh0aGF0LCAocmVzdWx0cy5yb3dzLmxlbmd0aCA+IDApKVxuICAgICAgICB9XG4gICAgICB0aGlzLmRiLnJlYWRUcmFuc2FjdGlvbihmdW5jdGlvbih0KSB7XG4gICAgICAgIHQuZXhlY3V0ZVNxbChpcywgW2tleV0sIHdpbiwgZmFpbClcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBhbGw6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIGFsbCA9IFwiU0VMRUNUICogRlJPTSBcIiArIHRoaXMucmVjb3JkLFxuICAgICAgICByID0gW10sXG4gICAgICAgIGNiID0gdGhpcy5mbih0aGlzLm5hbWUsIGNhbGxiYWNrKSB8fCB1bmRlZmluZWQsXG4gICAgICAgIHdpbiA9IGZ1bmN0aW9uKHh4eCwgcmVzdWx0cykge1xuICAgICAgICAgIGlmIChyZXN1bHRzLnJvd3MubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVzdWx0cy5yb3dzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgb2JqID0gSlNPTi5wYXJzZShyZXN1bHRzLnJvd3MuaXRlbShpKS52YWx1ZSlcbiAgICAgICAgICAgICAgb2JqLmtleSA9IHJlc3VsdHMucm93cy5pdGVtKGkpLmlkXG4gICAgICAgICAgICAgIHIucHVzaChvYmopXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYikgY2IuY2FsbCh0aGF0LCByKVxuICAgICAgICB9XG5cbiAgICAgIHRoaXMuZGIucmVhZFRyYW5zYWN0aW9uKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdC5leGVjdXRlU3FsKGFsbCwgW10sIHdpbiwgZmFpbClcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKGtleU9yQXJyYXksIGNiKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIGFyZ3MsIHNxbCA9IFwiREVMRVRFIEZST00gXCIgKyB0aGlzLnJlY29yZCArIFwiIFdIRVJFIGlkIFwiLFxuICAgICAgICB3aW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoY2IpIHRoYXQubGFtYmRhKGNiKS5jYWxsKHRoYXQpXG4gICAgICAgIH1cbiAgICAgIGlmICghdGhpcy5pc0FycmF5KGtleU9yQXJyYXkpKSB7XG4gICAgICAgIHNxbCArPSAnPSA/JztcbiAgICAgICAgYXJncyA9IFtrZXlPckFycmF5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MgPSBrZXlPckFycmF5O1xuICAgICAgICBzcWwgKz0gXCJJTiAoXCIgK1xuICAgICAgICAgIGFyZ3MubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAnPydcbiAgICAgICAgfSkuam9pbignLCcpICtcbiAgICAgICAgICBcIilcIjtcbiAgICAgIH1cbiAgICAgIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iai5rZXkgPyBvYmoua2V5IDogb2JqO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24odCkge1xuICAgICAgICB0LmV4ZWN1dGVTcWwoc3FsLCBhcmdzLCB3aW4sIGZhaWwpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBudWtlOiBmdW5jdGlvbihjYikge1xuICAgICAgdmFyIG51a2UgPSBcIkRFTEVURSBGUk9NIFwiICsgdGhpcy5yZWNvcmQsXG4gICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICB3aW4gPSBjYiA/IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0LmxhbWJkYShjYikuY2FsbCh0aGF0KVxuICAgICAgfSA6IGZ1bmN0aW9uKCkge31cbiAgICAgIHRoaXMuZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24odCkge1xuICAgICAgICB0LmV4ZWN1dGVTcWwobnVrZSwgW10sIHdpbiwgZmFpbClcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxufSkoKSk7XG5MYXduY2hhaXIuYWRhcHRlcignaHRtbDUtZmlsZXN5c3RlbScsIChmdW5jdGlvbihnbG9iYWwpe1xuXG4gIHZhciBGaWxlRXJyb3IgPSBnbG9iYWwuRmlsZUVycm9yO1xuXG4gIHZhciBmYWlsID0gZnVuY3Rpb24oIGUgKSB7XG4gICAgdmFyIG1zZztcbiAgICB2YXIgc2hvdyA9IHRydWU7XG4gICAgc3dpdGNoIChlLmNvZGUpIHtcbiAgICAgIGNhc2UgRmlsZUVycm9yLlFVT1RBX0VYQ0VFREVEX0VSUjpcbiAgICAgICAgbXNnID0gJ1FVT1RBX0VYQ0VFREVEX0VSUic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGaWxlRXJyb3IuTk9UX0ZPVU5EX0VSUjpcbiAgICAgICAgbXNnID0gJ05PVF9GT1VORF9FUlInO1xuICAgICAgICBzaG93ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGaWxlRXJyb3IuU0VDVVJJVFlfRVJSOlxuICAgICAgICBtc2cgPSAnU0VDVVJJVFlfRVJSJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZpbGVFcnJvci5JTlZBTElEX01PRElGSUNBVElPTl9FUlI6XG4gICAgICAgIG1zZyA9ICdJTlZBTElEX01PRElGSUNBVElPTl9FUlInO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRmlsZUVycm9yLklOVkFMSURfU1RBVEVfRVJSOlxuICAgICAgICBtc2cgPSAnSU5WQUxJRF9TVEFURV9FUlInO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG1zZyA9ICdVbmtub3duIEVycm9yJztcbiAgICAgICAgYnJlYWs7XG4gICAgfTtcbiAgICBpZiAoIGNvbnNvbGUgJiYgc2hvdyApIGNvbnNvbGUuZXJyb3IoIGUsIG1zZyApO1xuICB9O1xuXG4gIHZhciBscyA9IGZ1bmN0aW9uKCByZWFkZXIsIGNhbGxiYWNrLCBlbnRyaWVzICkge1xuICAgIHZhciByZXN1bHQgPSBlbnRyaWVzIHx8IFtdO1xuICAgIHJlYWRlci5yZWFkRW50cmllcyhmdW5jdGlvbiggcmVzdWx0cyApIHtcbiAgICAgIGlmICggIXJlc3VsdHMubGVuZ3RoICkge1xuICAgICAgICBpZiAoIGNhbGxiYWNrICkgY2FsbGJhY2soIHJlc3VsdC5tYXAoZnVuY3Rpb24oZW50cnkpIHsgcmV0dXJuIGVudHJ5Lm5hbWU7IH0pICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBscyggcmVhZGVyLCBjYWxsYmFjaywgcmVzdWx0LmNvbmNhdCggQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIHJlc3VsdHMgKSApICk7XG4gICAgICB9XG4gICAgfSwgZmFpbCApO1xuICB9O1xuXG4gIHZhciBmaWxlc3lzdGVtcyA9IHt9O1xuXG4gIHZhciByb290ID0gZnVuY3Rpb24oIHN0b3JlLCBjYWxsYmFjayApIHtcbiAgICB2YXIgZGlyZWN0b3J5ID0gZmlsZXN5c3RlbXNbc3RvcmUubmFtZV07XG4gICAgaWYgKCBkaXJlY3RvcnkgKSB7XG4gICAgICBjYWxsYmFjayggZGlyZWN0b3J5ICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJvb3QoIHN0b3JlLCBjYWxsYmFjayApO1xuICAgICAgfSwgMTAgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzUGhvbmVHYXAgPSBmdW5jdGlvbigpIHtcbiAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTAzNDc1MzkvZGV0ZWN0LWJldHdlZW4tYS1tb2JpbGUtYnJvd3Nlci1vci1hLXBob25lZ2FwLWFwcGxpY2F0aW9uXG4gICAgLy9tYXkgYnJlYWsuXG4gICAgdmFyIGFwcCA9IGRvY3VtZW50LlVSTC5pbmRleE9mKCdodHRwOi8vJykgPT09IC0xICYmIGRvY3VtZW50LlVSTC5pbmRleE9mKCdodHRwczovLycpID09PSAtMTtcbiAgICBpZiAoYXBwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjcmVhdGVCbG9iT3JTdHJpbmcgPSBmdW5jdGlvbihjb250ZW50c3RyKSB7XG4gICAgdmFyIHJldFZhbDtcbiAgICBpZiAoaXNQaG9uZUdhcCgpKSB7ICAvLyBwaG9uZWdhcCBmaWxld3JpdGVyIHdvcmtzIHdpdGggc3RyaW5ncywgbGF0ZXIgdmVyc2lvbnMgYWxzbyB3b3JrIHdpdGggYmluYXJ5IGFycmF5cywgYW5kIGlmIHBhc3NlZCBhIGJsb2Igd2lsbCBqdXN0IGNvbnZlcnQgdG8gYmluYXJ5IGFycmF5IGFueXdheVxuICAgICAgcmV0VmFsID0gY29udGVudHN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhcmdldENvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0VmFsID0gbmV3IEJsb2IoIFtjb250ZW50c3RyXSwgeyB0eXBlOiB0YXJnZXRDb250ZW50VHlwZSB9KTsgIC8vIEJsb2IgZG9lc24ndCBleGlzdCBvbiBhbGwgYW5kcm9pZHNcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKXtcbiAgICAgICAgLy8gVHlwZUVycm9yIG9sZCBjaHJvbWUgYW5kIEZGXG4gICAgICAgIHZhciBibG9iQnVpbGRlciA9IHdpbmRvdy5CbG9iQnVpbGRlciB8fFxuICAgICAgICAgIHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fFxuICAgICAgICAgIHdpbmRvdy5Nb3pCbG9iQnVpbGRlciB8fFxuICAgICAgICAgIHdpbmRvdy5NU0Jsb2JCdWlsZGVyO1xuICAgICAgICBpZiAoZS5uYW1lID09ICdUeXBlRXJyb3InICYmIGJsb2JCdWlsZGVyKSB7XG4gICAgICAgICAgdmFyIGJiID0gbmV3IGJsb2JCdWlsZGVyKCk7XG4gICAgICAgICAgYmIuYXBwZW5kKFtjb250ZW50c3RyLmJ1ZmZlcl0pO1xuICAgICAgICAgIHJldFZhbCA9IGJiLmdldEJsb2IodGFyZ2V0Q29udGVudFR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdlIGNhbid0IG1ha2UgYSBCbG9iLCBzbyBqdXN0IHJldHVybiB0aGUgc3RyaW5naWZpZWQgY29udGVudFxuICAgICAgICAgIHJldFZhbCA9IGNvbnRlbnRzdHI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldFZhbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gYm9vbGVhbjsgdHJ1ZSBpZiB0aGUgYWRhcHRlciBpcyB2YWxpZCBmb3IgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnRcbiAgICB2YWxpZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZnMgPSBnbG9iYWwucmVxdWVzdEZpbGVTeXN0ZW0gfHwgZ2xvYmFsLndlYmtpdFJlcXVlc3RGaWxlU3lzdGVtIHx8IGdsb2JhbC5tb3pfcmVxdWVzdEZpbGVTeXN0ZW07XG4gICAgICByZXR1cm4gISFmcztcbiAgICB9LFxuXG4gICAgLy8gY29uc3RydWN0b3IgY2FsbCBhbmQgY2FsbGJhY2suICduYW1lJyBpcyB0aGUgbW9zdCBjb21tb24gb3B0aW9uXG4gICAgaW5pdDogZnVuY3Rpb24oIG9wdGlvbnMsIGNhbGxiYWNrICkge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uKGUpIHsgZmFpbChlKTsgaWYgKCBjYWxsYmFjayApIG1lLmZuKCBtZS5uYW1lLCBjYWxsYmFjayApLmNhbGwoIG1lLCBtZSApOyB9O1xuICAgICAgdmFyIHNpemUgPSBvcHRpb25zLnNpemUgfHwgMTAwKjEwMjQqMTAyNDtcbiAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgICBmdW5jdGlvbiByZXF1ZXN0RmlsZVN5c3RlbShhbW91bnQpIHtcbi8vICAgICAgICBjb25zb2xlLmxvZygnaW4gcmVxdWVzdEZpbGVTeXN0ZW0nKTtcbiAgICAgICAgdmFyIGZzID0gZ2xvYmFsLnJlcXVlc3RGaWxlU3lzdGVtIHx8IGdsb2JhbC53ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbSB8fCBnbG9iYWwubW96X3JlcXVlc3RGaWxlU3lzdGVtO1xuICAgICAgICB2YXIgbW9kZSA9IHdpbmRvdy5QRVJTSVNURU5UO1xuICAgICAgICBpZih0eXBlb2YgTG9jYWxGaWxlU3lzdGVtICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBMb2NhbEZpbGVTeXN0ZW0uUEVSU0lTVEVOVCAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgbW9kZSA9IExvY2FsRmlsZVN5c3RlbS5QRVJTSVNURU5UO1xuICAgICAgICB9ICAgICAgXG4gICAgICAgIGZzKG1vZGUsIGFtb3VudCwgZnVuY3Rpb24oZnMpIHtcbi8vICAgICAgICAgIGNvbnNvbGUubG9nKCdnb3QgRlMgJywgZnMpO1xuICAgICAgICAgIGZzLnJvb3QuZ2V0RGlyZWN0b3J5KCBuYW1lLCB7Y3JlYXRlOnRydWV9LCBmdW5jdGlvbiggZGlyZWN0b3J5ICkge1xuLy8gICAgICAgICAgICBjb25zb2xlLmxvZygnZ290IERJUiAnLCBkaXJlY3RvcnkpO1xuICAgICAgICAgICAgZmlsZXN5c3RlbXNbbmFtZV0gPSBkaXJlY3Rvcnk7XG4gICAgICAgICAgICBpZiAoIGNhbGxiYWNrICkgbWUuZm4oIG1lLm5hbWUsIGNhbGxiYWNrICkuY2FsbCggbWUsIG1lICk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oIGUgKSB7XG4vLyAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlcnJvciBnZXR0aW5nIGRpciA6OiAnLCBlKTtcbiAgICAgICAgICAgIGVycm9yKGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiggZSApIHtcbi8vICAgICAgICAgIGNvbnNvbGUubG9nKCdlcnJvciBnZXR0aW5nIEZTIDo6ICcsIGUpO1xuICAgICAgICAgIGVycm9yKGUpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFdoZW4gaW4gdGhlIGJyb3dzZXIgd2UgbmVlZCB0byB1c2UgdGhlIGh0bWw1IGZpbGUgc3lzdGVtIHJhdGhlciB0aGFuXG4gICAgICAvLyB0aGUgb25lIGNvcmRvdmEgc3VwcGxpZXMsIGJ1dCBpdCBuZWVkcyB0byByZXF1ZXN0IGEgcXVvdGEgZmlyc3QuXG4gICAgICBpZiAodHlwZW9mIG5hdmlnYXRvci53ZWJraXRQZXJzaXN0ZW50U3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbmF2aWdhdG9yLndlYmtpdFBlcnNpc3RlbnRTdG9yYWdlLnJlcXVlc3RRdW90YShzaXplLCByZXF1ZXN0RmlsZVN5c3RlbSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ1VzZXIgZGVjbGluZWQgZmlsZSBzdG9yYWdlJyk7XG4gICAgICAgICAgZXJyb3IoJ1VzZXIgZGVjbGluZWQgZmlsZSBzdG9yYWdlJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQW1vdW50IGlzIDAgYmVjYXVzZSB3ZSBwcmV0dHkgbXVjaCBoYXZlIGZyZWUgcmVpZ24gb3ZlciB0aGVcbiAgICAgICAgLy8gYW1vdW50IG9mIHN0b3JhZ2Ugd2UgdXNlIG9uIGFuIGFuZHJvaWQgZGV2aWNlLlxuICAgICAgICByZXF1ZXN0RmlsZVN5c3RlbSgwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gcmV0dXJucyBhbGwgdGhlIGtleXMgaW4gdGhlIHN0b3JlXG4gICAga2V5czogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHJvb3QoIHRoaXMsIGZ1bmN0aW9uKCBzdG9yZSApIHtcbiAgICAgICAgbHMoIHN0b3JlLmNyZWF0ZVJlYWRlcigpLCBmdW5jdGlvbiggZW50cmllcyApIHtcbiAgICAgICAgICBpZiAoIGNhbGxiYWNrICkgbWUuZm4oICdrZXlzJywgY2FsbGJhY2sgKS5jYWxsKCBtZSwgZW50cmllcyApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIHNhdmUgYW4gb2JqZWN0XG4gICAgc2F2ZTogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIGtleSA9IG9iai5rZXkgfHwgdGhpcy51dWlkKCk7XG4gICAgICBvYmoua2V5ID0ga2V5O1xuICAgICAgdmFyIGVycm9yID0gZnVuY3Rpb24oZSkgeyBmYWlsKGUpOyBpZiAoIGNhbGxiYWNrICkgbWUubGFtYmRhKCBjYWxsYmFjayApLmNhbGwoIG1lICk7IH07XG4gICAgICByb290KCB0aGlzLCBmdW5jdGlvbiggc3RvcmUgKSB7XG4gICAgICAgIHN0b3JlLmdldEZpbGUoIGtleSwge2NyZWF0ZTp0cnVlfSwgZnVuY3Rpb24oIGZpbGUgKSB7XG4gICAgICAgICAgZmlsZS5jcmVhdGVXcml0ZXIoZnVuY3Rpb24oIHdyaXRlciApIHtcbiAgICAgICAgICAgIHdyaXRlci5vbmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICB3cml0ZXIub253cml0ZWVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgb25Xcml0ZUVuZCBoYW5kbGVyIHNvIHRoZSB0cnVuY2F0ZSBkb2VzIG5vdCBjYWxsIGl0IGFuZCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgIHRoaXMub253cml0ZWVuZCA9IG51bGw7XG4gICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRoZSBmaWxlIGF0IHRoZSBlbmQgb2YgdGhlIHdyaXR0ZW4gY29udGVudHMuIFRoaXMgZW5zdXJlcyB0aGF0IGlmIHdlIGFyZSB1cGRhdGluZyBcbiAgICAgICAgICAgICAgLy8gYSBmaWxlIHdoaWNoIHdhcyBwcmV2aW91c2x5IGxvbmdlciwgd2Ugd2lsbCBub3QgYmUgbGVmdCB3aXRoIG9sZCBjb250ZW50cyBiZXlvbmQgdGhlIGVuZCBvZiBcbiAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgYnVmZmVyLlxuICAgICAgICAgICAgICB0aGlzLnRydW5jYXRlKHRoaXMucG9zaXRpb24pO1xuICAgICAgICAgICAgICBpZiAoIGNhbGxiYWNrICkgbWUubGFtYmRhKCBjYWxsYmFjayApLmNhbGwoIG1lLCBvYmogKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY29udGVudFN0ciA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG5cbiAgICAgICAgICAgIHZhciB3cml0ZXJDb250ZW50ID0gY3JlYXRlQmxvYk9yU3RyaW5nKGNvbnRlbnRTdHIpO1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlKHdyaXRlckNvbnRlbnQpO1xuICAgICAgICAgIH0sIGVycm9yICk7XG4gICAgICAgIH0sIGVycm9yICk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBiYXRjaCBzYXZlIGFycmF5IG9mIG9ianNcbiAgICBiYXRjaDogZnVuY3Rpb24oIG9ianMsIGNhbGxiYWNrICkge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBzYXZlZCA9IFtdO1xuICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG9ianMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcbiAgICAgICAgbWUuc2F2ZSggb2Jqc1tpXSwgZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICBzYXZlZC5wdXNoKCBvYmogKTtcbiAgICAgICAgICBpZiAoIHNhdmVkLmxlbmd0aCA9PT0gaWwgJiYgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICBtZS5sYW1iZGEoIGNhbGxiYWNrICkuY2FsbCggbWUsIHNhdmVkICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyByZXRyaWV2ZSBvYmogKG9yIGFycmF5IG9mIG9ianMpIGFuZCBhcHBseSBjYWxsYmFjayB0byBlYWNoXG4gICAgZ2V0OiBmdW5jdGlvbigga2V5IC8qIG9yIGFycmF5ICovLCBjYWxsYmFjayApIHtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICBpZiAoIHRoaXMuaXNBcnJheSgga2V5ICkgKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGtleS5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuICAgICAgICAgIG1lLmdldCgga2V5W2ldLCBmdW5jdGlvbiggcmVzdWx0ICkge1xuICAgICAgICAgICAgaWYgKCByZXN1bHQgKSB2YWx1ZXMucHVzaCggcmVzdWx0ICk7XG4gICAgICAgICAgICBpZiAoIHZhbHVlcy5sZW5ndGggPT09IGlsICYmIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICBtZS5sYW1iZGEoIGNhbGxiYWNrICkuY2FsbCggbWUsIHZhbHVlcyApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZmFpbCggZSApO1xuICAgICAgICAgIGlmICggY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICBtZS5sYW1iZGEoIGNhbGxiYWNrICkuY2FsbCggbWUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJvb3QoIHRoaXMsIGZ1bmN0aW9uKCBzdG9yZSApIHtcbiAgICAgICAgICBzdG9yZS5nZXRGaWxlKCBrZXksIHtjcmVhdGU6ZmFsc2V9LCBmdW5jdGlvbiggZW50cnkgKSB7XG4gICAgICAgICAgICBlbnRyeS5maWxlKGZ1bmN0aW9uKCBmaWxlICkge1xuICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGVycm9yO1xuXG4gICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICByZXMgPSBKU09OLnBhcnNlKCBlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgcmVzLmtleSA9IGtleTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICByZXMgPSB7a2V5OmtleX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2sgKSBtZS5sYW1iZGEoIGNhbGxiYWNrICkuY2FsbCggbWUsIHJlcyApO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KCBmaWxlICk7XG4gICAgICAgICAgICB9LCBlcnJvciApO1xuICAgICAgICAgIH0sIGVycm9yICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIGNoZWNrIGlmIGFuIG9iaiBleGlzdHMgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICBleGlzdHM6IGZ1bmN0aW9uKCBrZXksIGNhbGxiYWNrICkge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHJvb3QoIHRoaXMsIGZ1bmN0aW9uKCBzdG9yZSApIHtcbiAgICAgICAgc3RvcmUuZ2V0RmlsZSgga2V5LCB7Y3JlYXRlOmZhbHNlfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCBjYWxsYmFjayApIG1lLmxhbWJkYSggY2FsbGJhY2sgKS5jYWxsKCBtZSwgdHJ1ZSApO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIGNhbGxiYWNrICkgbWUubGFtYmRhKCBjYWxsYmFjayApLmNhbGwoIG1lLCBmYWxzZSApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIHJldHVybnMgYWxsIHRoZSBvYmpzIHRvIHRoZSBjYWxsYmFjayBhcyBhbiBhcnJheVxuICAgIGFsbDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIGlmICggY2FsbGJhY2sgKSB7XG4gICAgICAgIHRoaXMua2V5cyhmdW5jdGlvbigga2V5cyApIHtcbiAgICAgICAgICBpZiAoICFrZXlzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIG1lLmZuKCBtZS5uYW1lLCBjYWxsYmFjayApLmNhbGwoIG1lLCBbXSApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5nZXQoIGtleXMsIGZ1bmN0aW9uKCB2YWx1ZXMgKSB7XG4gICAgICAgICAgICAgIG1lLmZuKCBtZS5uYW1lLCBjYWxsYmFjayApLmNhbGwoIG1lLCB2YWx1ZXMgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gcmVtb3ZlIGEgZG9jIG9yIGNvbGxlY3Rpb24gb2YgZW1cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCBrZXkgLyogb3Igb2JqZWN0ICovLCBjYWxsYmFjayApIHtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgZXJyb3IgPSBmdW5jdGlvbihlKSB7IGZhaWwoIGUgKTsgaWYgKCBjYWxsYmFjayApIG1lLmxhbWJkYSggY2FsbGJhY2sgKS5jYWxsKCBtZSApOyB9O1xuICAgICAgcm9vdCggdGhpcywgZnVuY3Rpb24oIHN0b3JlICkge1xuICAgICAgICBzdG9yZS5nZXRGaWxlKCAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgPyBrZXkgOiBrZXkua2V5ICksIHtjcmVhdGU6ZmFsc2V9LCBmdW5jdGlvbiggZmlsZSApIHtcbiAgICAgICAgICBmaWxlLnJlbW92ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICggY2FsbGJhY2sgKSBtZS5sYW1iZGEoIGNhbGxiYWNrICkuY2FsbCggbWUgKTtcbiAgICAgICAgICB9LCBlcnJvciApO1xuICAgICAgICB9LCBlcnJvciApO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gZGVzdHJveSBldmVyeXRoaW5nXG4gICAgbnVrZTogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICB0aGlzLmtleXMoZnVuY3Rpb24oIGtleXMgKSB7XG4gICAgICAgIGlmICggIWtleXMubGVuZ3RoICkge1xuICAgICAgICAgIGlmICggY2FsbGJhY2sgKSBtZS5sYW1iZGEoIGNhbGxiYWNrICkuY2FsbCggbWUgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuICAgICAgICAgICAgbWUucmVtb3ZlKCBrZXlzW2ldLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgaWYgKCBjb3VudCA9PT0gaWwgJiYgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgbWUubGFtYmRhKCBjYWxsYmFjayApLmNhbGwoIG1lICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KHRoaXMpKSk7XG5MYXduY2hhaXIuYWRhcHRlcignbWVtb3J5JywgKGZ1bmN0aW9uKCl7XG5cbiAgICB2YXIgZGF0YSA9IHt9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZDogZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlIH0sXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBkYXRhW3RoaXMubmFtZV0gPSBkYXRhW3RoaXMubmFtZV0gfHwge2luZGV4OltdLHN0b3JlOnt9fVxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGRhdGFbdGhpcy5uYW1lXS5pbmRleFxuICAgICAgICAgICAgdGhpcy5zdG9yZSA9IGRhdGFbdGhpcy5uYW1lXS5zdG9yZVxuICAgICAgICAgICAgdmFyIGNiID0gdGhpcy5mbih0aGlzLm5hbWUsIGNhbGxiYWNrKVxuICAgICAgICAgICAgaWYgKGNiKSBjYi5jYWxsKHRoaXMsIHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9LFxuXG4gICAgICAgIGtleXM6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5mbigna2V5cycsIGNhbGxiYWNrKS5jYWxsKHRoaXMsIHRoaXMuaW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmU6IGZ1bmN0aW9uKG9iaiwgY2IpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBvYmoua2V5IHx8IHRoaXMudXVpZCgpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZXhpc3RzKGtleSwgZnVuY3Rpb24oZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5rZXkpIGRlbGV0ZSBvYmoua2V5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaChrZXkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZVtrZXldID0gb2JqXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5rZXkgPSBrZXlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYW1iZGEoY2IpLmNhbGwodGhpcywgb2JqKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0sXG5cbiAgICAgICAgYmF0Y2g6IGZ1bmN0aW9uIChvYmpzLCBjYikge1xuICAgICAgICAgICAgdmFyIHIgPSBbXVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmpzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2F2ZShvYmpzW2ldLCBmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgci5wdXNoKHJlY29yZClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNiKSB0aGlzLmxhbWJkYShjYikuY2FsbCh0aGlzLCByKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXlPckFycmF5LCBjYikge1xuICAgICAgICAgICAgdmFyIHI7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FycmF5KGtleU9yQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgciA9IFtdXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlPckFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByLnB1c2godGhpcy5zdG9yZVtrZXlPckFycmF5W2ldXSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHIgPSB0aGlzLnN0b3JlW2tleU9yQXJyYXldXG4gICAgICAgICAgICAgICAgaWYgKHIpIHIua2V5ID0ga2V5T3JBcnJheVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNiKSB0aGlzLmxhbWJkYShjYikuY2FsbCh0aGlzLCByKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMgXG4gICAgICAgIH0sXG5cbiAgICAgICAgZXhpc3RzOiBmdW5jdGlvbiAoa2V5LCBjYikge1xuICAgICAgICAgICAgdGhpcy5sYW1iZGEoY2IpLmNhbGwodGhpcywgISEodGhpcy5zdG9yZVtrZXldKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWxsOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHZhciByID0gW11cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5pbmRleC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5zdG9yZVt0aGlzLmluZGV4W2ldXVxuICAgICAgICAgICAgICAgIG9iai5rZXkgPSB0aGlzLmluZGV4W2ldXG4gICAgICAgICAgICAgICAgci5wdXNoKG9iailcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm4odGhpcy5uYW1lLCBjYikuY2FsbCh0aGlzLCByKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChrZXlPckFycmF5LCBjYikge1xuICAgICAgICAgICAgdmFyIGRlbCA9IHRoaXMuaXNBcnJheShrZXlPckFycmF5KSA/IGtleU9yQXJyYXkgOiBba2V5T3JBcnJheV1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGVsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBkZWxbaV0ua2V5ID8gZGVsW2ldLmtleSA6IGRlbFtpXVxuICAgICAgICAgICAgICAgIHZhciB3aGVyZSA9IHRoaXMuaW5kZXhPZih0aGlzLmluZGV4LCBrZXkpXG4gICAgICAgICAgICAgICAgaWYgKHdoZXJlIDwgMCkgY29udGludWUgLyoga2V5IG5vdCBwcmVzZW50ICovXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3RvcmVba2V5XVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXguc3BsaWNlKHdoZXJlLCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNiKSB0aGlzLmxhbWJkYShjYikuY2FsbCh0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSxcblxuICAgICAgICBudWtlOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUgPSBkYXRhW3RoaXMubmFtZV0uc3RvcmUgPSB7fVxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGRhdGFbdGhpcy5uYW1lXS5pbmRleCA9IFtdXG4gICAgICAgICAgICBpZiAoY2IpIHRoaXMubGFtYmRhKGNiKS5jYWxsKHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgfVxuLy8vLy9cbn0pKCkpO1xuOyBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXyh0eXBlb2YgTGF3bmNoYWlyICE9IFwidW5kZWZpbmVkXCIgPyBMYXduY2hhaXIgOiB3aW5kb3cuTGF3bmNoYWlyKTtcblxufSkuY2FsbChnbG9iYWwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZnVuY3Rpb24gZGVmaW5lRXhwb3J0KGV4KSB7IG1vZHVsZS5leHBvcnRzID0gZXg7IH0pO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbjtfX2Jyb3dzZXJpZnlfc2hpbV9yZXF1aXJlX189cmVxdWlyZTsoZnVuY3Rpb24gYnJvd3NlcmlmeVNoaW0obW9kdWxlLCBleHBvcnRzLCByZXF1aXJlLCBkZWZpbmUsIGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKSB7XG4vKlxuIGpzb24yLmpzXG4gMjAxMS0xMC0xOVxuXG4gUHVibGljIERvbWFpbi5cblxuIE5PIFdBUlJBTlRZIEVYUFJFU1NFRCBPUiBJTVBMSUVELiBVU0UgQVQgWU9VUiBPV04gUklTSy5cblxuIFNlZSBodHRwOi8vd3d3LkpTT04ub3JnL2pzLmh0bWxcblxuXG4gVGhpcyBjb2RlIHNob3VsZCBiZSBtaW5pZmllZCBiZWZvcmUgZGVwbG95bWVudC5cbiBTZWUgaHR0cDovL2phdmFzY3JpcHQuY3JvY2tmb3JkLmNvbS9qc21pbi5odG1sXG5cbiBVU0UgWU9VUiBPV04gQ09QWS4gSVQgSVMgRVhUUkVNRUxZIFVOV0lTRSBUTyBMT0FEIENPREUgRlJPTSBTRVJWRVJTIFlPVSBET1xuIE5PVCBDT05UUk9MLlxuXG5cbiBUaGlzIGZpbGUgY3JlYXRlcyBhIGdsb2JhbCBKU09OIG9iamVjdCBjb250YWluaW5nIHR3byBtZXRob2RzOiBzdHJpbmdpZnlcbiBhbmQgcGFyc2UuXG5cbiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKVxuIHZhbHVlICAgICAgIGFueSBKYXZhU2NyaXB0IHZhbHVlLCB1c3VhbGx5IGFuIG9iamVjdCBvciBhcnJheS5cblxuIHJlcGxhY2VyICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IGRldGVybWluZXMgaG93IG9iamVjdFxuIHZhbHVlcyBhcmUgc3RyaW5naWZpZWQgZm9yIG9iamVjdHMuIEl0IGNhbiBiZSBhXG4gZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cblxuIHNwYWNlICAgICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiBvZiBuZXN0ZWQgc3RydWN0dXJlcy4gSWYgaXQgaXMgb21pdHRlZCwgdGhlIHRleHQgd2lsbFxuIGJlIHBhY2tlZCB3aXRob3V0IGV4dHJhIHdoaXRlc3BhY2UuIElmIGl0IGlzIGEgbnVtYmVyLFxuIGl0IHdpbGwgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHNwYWNlcyB0byBpbmRlbnQgYXQgZWFjaFxuIGxldmVsLiBJZiBpdCBpcyBhIHN0cmluZyAoc3VjaCBhcyAnXFx0JyBvciAnJm5ic3A7JyksXG4gaXQgY29udGFpbnMgdGhlIGNoYXJhY3RlcnMgdXNlZCB0byBpbmRlbnQgYXQgZWFjaCBsZXZlbC5cblxuIFRoaXMgbWV0aG9kIHByb2R1Y2VzIGEgSlNPTiB0ZXh0IGZyb20gYSBKYXZhU2NyaXB0IHZhbHVlLlxuXG4gV2hlbiBhbiBvYmplY3QgdmFsdWUgaXMgZm91bmQsIGlmIHRoZSBvYmplY3QgY29udGFpbnMgYSB0b0pTT05cbiBtZXRob2QsIGl0cyB0b0pTT04gbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFuZCB0aGUgcmVzdWx0IHdpbGwgYmVcbiBzdHJpbmdpZmllZC4gQSB0b0pTT04gbWV0aG9kIGRvZXMgbm90IHNlcmlhbGl6ZTogaXQgcmV0dXJucyB0aGVcbiB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgbmFtZS92YWx1ZSBwYWlyIHRoYXQgc2hvdWxkIGJlIHNlcmlhbGl6ZWQsXG4gb3IgdW5kZWZpbmVkIGlmIG5vdGhpbmcgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSB0b0pTT04gbWV0aG9kXG4gd2lsbCBiZSBwYXNzZWQgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHZhbHVlLCBhbmQgdGhpcyB3aWxsIGJlXG4gYm91bmQgdG8gdGhlIHZhbHVlXG5cbiBGb3IgZXhhbXBsZSwgdGhpcyB3b3VsZCBzZXJpYWxpemUgRGF0ZXMgYXMgSVNPIHN0cmluZ3MuXG5cbiBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG4gZnVuY3Rpb24gZihuKSB7XG4gLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiByZXR1cm4gbiA8IDEwID8gJzAnICsgbiA6IG47XG4gfVxuXG4gcmV0dXJuIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSAgICsgJy0nICtcbiBmKHRoaXMuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICtcbiBmKHRoaXMuZ2V0VVRDRGF0ZSgpKSAgICAgICsgJ1QnICtcbiBmKHRoaXMuZ2V0VVRDSG91cnMoKSkgICAgICsgJzonICtcbiBmKHRoaXMuZ2V0VVRDTWludXRlcygpKSAgICsgJzonICtcbiBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSAgICsgJ1onO1xuIH07XG5cbiBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWwgcmVwbGFjZXIgbWV0aG9kLiBJdCB3aWxsIGJlIHBhc3NlZCB0aGVcbiBrZXkgYW5kIHZhbHVlIG9mIGVhY2ggbWVtYmVyLCB3aXRoIHRoaXMgYm91bmQgdG8gdGhlIGNvbnRhaW5pbmdcbiBvYmplY3QuIFRoZSB2YWx1ZSB0aGF0IGlzIHJldHVybmVkIGZyb20geW91ciBtZXRob2Qgd2lsbCBiZVxuIHNlcmlhbGl6ZWQuIElmIHlvdXIgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLCB0aGVuIHRoZSBtZW1iZXIgd2lsbFxuIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHNlcmlhbGl6YXRpb24uXG5cbiBJZiB0aGUgcmVwbGFjZXIgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIHRoZW4gaXQgd2lsbCBiZVxuIHVzZWQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlIHNlcmlhbGl6ZWQuIEl0IGZpbHRlcnMgdGhlIHJlc3VsdHNcbiBzdWNoIHRoYXQgb25seSBtZW1iZXJzIHdpdGgga2V5cyBsaXN0ZWQgaW4gdGhlIHJlcGxhY2VyIGFycmF5IGFyZVxuIHN0cmluZ2lmaWVkLlxuXG4gVmFsdWVzIHRoYXQgZG8gbm90IGhhdmUgSlNPTiByZXByZXNlbnRhdGlvbnMsIHN1Y2ggYXMgdW5kZWZpbmVkIG9yXG4gZnVuY3Rpb25zLCB3aWxsIG5vdCBiZSBzZXJpYWxpemVkLiBTdWNoIHZhbHVlcyBpbiBvYmplY3RzIHdpbGwgYmVcbiBkcm9wcGVkOyBpbiBhcnJheXMgdGhleSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggbnVsbC4gWW91IGNhbiB1c2VcbiBhIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIHJlcGxhY2UgdGhvc2Ugd2l0aCBKU09OIHZhbHVlcy5cbiBKU09OLnN0cmluZ2lmeSh1bmRlZmluZWQpIHJldHVybnMgdW5kZWZpbmVkLlxuXG4gVGhlIG9wdGlvbmFsIHNwYWNlIHBhcmFtZXRlciBwcm9kdWNlcyBhIHN0cmluZ2lmaWNhdGlvbiBvZiB0aGVcbiB2YWx1ZSB0aGF0IGlzIGZpbGxlZCB3aXRoIGxpbmUgYnJlYWtzIGFuZCBpbmRlbnRhdGlvbiB0byBtYWtlIGl0XG4gZWFzaWVyIHRvIHJlYWQuXG5cbiBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbm9uLWVtcHR5IHN0cmluZywgdGhlbiB0aGF0IHN0cmluZyB3aWxsXG4gYmUgdXNlZCBmb3IgaW5kZW50YXRpb24uIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIHRoZW5cbiB0aGUgaW5kZW50YXRpb24gd2lsbCBiZSB0aGF0IG1hbnkgc3BhY2VzLlxuXG4gRXhhbXBsZTpcblxuIHRleHQgPSBKU09OLnN0cmluZ2lmeShbJ2UnLCB7cGx1cmlidXM6ICd1bnVtJ31dKTtcbiAvLyB0ZXh0IGlzICdbXCJlXCIse1wicGx1cmlidXNcIjpcInVudW1cIn1dJ1xuXG5cbiB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoWydlJywge3BsdXJpYnVzOiAndW51bSd9XSwgbnVsbCwgJ1xcdCcpO1xuIC8vIHRleHQgaXMgJ1tcXG5cXHRcImVcIixcXG5cXHR7XFxuXFx0XFx0XCJwbHVyaWJ1c1wiOiBcInVudW1cIlxcblxcdH1cXG5dJ1xuXG4gdGV4dCA9IEpTT04uc3RyaW5naWZ5KFtuZXcgRGF0ZSgpXSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiByZXR1cm4gdGhpc1trZXldIGluc3RhbmNlb2YgRGF0ZSA/XG4gJ0RhdGUoJyArIHRoaXNba2V5XSArICcpJyA6IHZhbHVlO1xuIH0pO1xuIC8vIHRleHQgaXMgJ1tcIkRhdGUoLS0tY3VycmVudCB0aW1lLS0tKVwiXSdcblxuXG4gSlNPTi5wYXJzZSh0ZXh0LCByZXZpdmVyKVxuIFRoaXMgbWV0aG9kIHBhcnNlcyBhIEpTT04gdGV4dCB0byBwcm9kdWNlIGFuIG9iamVjdCBvciBhcnJheS5cbiBJdCBjYW4gdGhyb3cgYSBTeW50YXhFcnJvciBleGNlcHRpb24uXG5cbiBUaGUgb3B0aW9uYWwgcmV2aXZlciBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBmaWx0ZXIgYW5kXG4gdHJhbnNmb3JtIHRoZSByZXN1bHRzLiBJdCByZWNlaXZlcyBlYWNoIG9mIHRoZSBrZXlzIGFuZCB2YWx1ZXMsXG4gYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiBJZiBpdCByZXR1cm5zIHdoYXQgaXQgcmVjZWl2ZWQsIHRoZW4gdGhlIHN0cnVjdHVyZSBpcyBub3QgbW9kaWZpZWQuXG4gSWYgaXQgcmV0dXJucyB1bmRlZmluZWQgdGhlbiB0aGUgbWVtYmVyIGlzIGRlbGV0ZWQuXG5cbiBFeGFtcGxlOlxuXG4gLy8gUGFyc2UgdGhlIHRleHQuIFZhbHVlcyB0aGF0IGxvb2sgbGlrZSBJU08gZGF0ZSBzdHJpbmdzIHdpbGxcbiAvLyBiZSBjb252ZXJ0ZWQgdG8gRGF0ZSBvYmplY3RzLlxuXG4gbXlEYXRhID0gSlNPTi5wYXJzZSh0ZXh0LCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuIHZhciBhO1xuIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gYSA9XG4gL14oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KVQoXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KD86XFwuXFxkKik/KVokLy5leGVjKHZhbHVlKTtcbiBpZiAoYSkge1xuIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygrYVsxXSwgK2FbMl0gLSAxLCArYVszXSwgK2FbNF0sXG4gK2FbNV0sICthWzZdKSk7XG4gfVxuIH1cbiByZXR1cm4gdmFsdWU7XG4gfSk7XG5cbiBteURhdGEgPSBKU09OLnBhcnNlKCdbXCJEYXRlKDA5LzA5LzIwMDEpXCJdJywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiB2YXIgZDtcbiBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuIHZhbHVlLnNsaWNlKDAsIDUpID09PSAnRGF0ZSgnICYmXG4gdmFsdWUuc2xpY2UoLTEpID09PSAnKScpIHtcbiBkID0gbmV3IERhdGUodmFsdWUuc2xpY2UoNSwgLTEpKTtcbiBpZiAoZCkge1xuIHJldHVybiBkO1xuIH1cbiB9XG4gcmV0dXJuIHZhbHVlO1xuIH0pO1xuXG5cbiBUaGlzIGlzIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLiBZb3UgYXJlIGZyZWUgdG8gY29weSwgbW9kaWZ5LCBvclxuIHJlZGlzdHJpYnV0ZS5cbiAqL1xuXG4vKmpzbGludCBldmlsOiB0cnVlLCByZWdleHA6IHRydWUgKi9cblxuLyptZW1iZXJzIFwiXCIsIFwiXFxiXCIsIFwiXFx0XCIsIFwiXFxuXCIsIFwiXFxmXCIsIFwiXFxyXCIsIFwiXFxcIlwiLCBKU09OLCBcIlxcXFxcIiwgYXBwbHksXG4gY2FsbCwgY2hhckNvZGVBdCwgZ2V0VVRDRGF0ZSwgZ2V0VVRDRnVsbFllYXIsIGdldFVUQ0hvdXJzLFxuIGdldFVUQ01pbnV0ZXMsIGdldFVUQ01vbnRoLCBnZXRVVENTZWNvbmRzLCBoYXNPd25Qcm9wZXJ0eSwgam9pbixcbiBsYXN0SW5kZXgsIGxlbmd0aCwgcGFyc2UsIHByb3RvdHlwZSwgcHVzaCwgcmVwbGFjZSwgc2xpY2UsIHN0cmluZ2lmeSxcbiB0ZXN0LCB0b0pTT04sIHRvU3RyaW5nLCB2YWx1ZU9mXG4gKi9cblxuXG4vLyBDcmVhdGUgYSBKU09OIG9iamVjdCBvbmx5IGlmIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LiBXZSBjcmVhdGUgdGhlXG4vLyBtZXRob2RzIGluIGEgY2xvc3VyZSB0byBhdm9pZCBjcmVhdGluZyBnbG9iYWwgdmFyaWFibGVzLlxuXG52YXIgSlNPTjtcbmlmICghSlNPTikge1xuICBKU09OID0ge307XG59XG5cbihmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBmKG4pIHtcbiAgICAvLyBGb3JtYXQgaW50ZWdlcnMgdG8gaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuIDogbjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgRGF0ZS5wcm90b3R5cGUudG9KU09OICE9PSAnZnVuY3Rpb24nKSB7XG5cbiAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG5cbiAgICAgIHJldHVybiBpc0Zpbml0ZSh0aGlzLnZhbHVlT2YoKSlcbiAgICAgICAgPyB0aGlzLmdldFVUQ0Z1bGxZZWFyKCkgICAgICsgJy0nICtcbiAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArXG4gICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICAgICAgKyAnVCcgK1xuICAgICAgICBmKHRoaXMuZ2V0VVRDSG91cnMoKSkgICAgICsgJzonICtcbiAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgICArICc6JyArXG4gICAgICAgIGYodGhpcy5nZXRVVENTZWNvbmRzKCkpICAgKyAnWidcbiAgICAgICAgOiBudWxsO1xuICAgIH07XG5cbiAgICBTdHJpbmcucHJvdG90eXBlLnRvSlNPTiAgICAgID1cbiAgICAgIE51bWJlci5wcm90b3R5cGUudG9KU09OICA9XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gICAgICAgIH07XG4gIH1cblxuICB2YXIgY3ggPSAvW1xcdTAwMDBcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGdhcCxcbiAgICBpbmRlbnQsXG4gICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICB9LFxuICAgIHJlcDtcblxuXG4gIGZ1bmN0aW9uIHF1b3RlKHN0cmluZykge1xuXG4vLyBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG5vIGNvbnRyb2wgY2hhcmFjdGVycywgbm8gcXVvdGUgY2hhcmFjdGVycywgYW5kIG5vXG4vLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG4vLyBzZXF1ZW5jZXMuXG5cbiAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/ICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnXG4gICAgICAgID8gY1xuICAgICAgICA6ICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgIH0pICsgJ1wiJyA6ICdcIicgKyBzdHJpbmcgKyAnXCInO1xuICB9XG5cblxuICBmdW5jdGlvbiBzdHIoa2V5LCBob2xkZXIpIHtcblxuLy8gUHJvZHVjZSBhIHN0cmluZyBmcm9tIGhvbGRlcltrZXldLlxuXG4gICAgdmFyIGksICAgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICBrLCAgICAgICAgICAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgIHYsICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICBsZW5ndGgsXG4gICAgICBtaW5kID0gZ2FwLFxuICAgICAgcGFydGlhbCxcbiAgICAgIHZhbHVlID0gaG9sZGVyW2tleV07XG5cbi8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgfVxuXG4vLyBJZiB3ZSB3ZXJlIGNhbGxlZCB3aXRoIGEgcmVwbGFjZXIgZnVuY3Rpb24sIHRoZW4gY2FsbCB0aGUgcmVwbGFjZXIgdG9cbi8vIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuXG4gICAgaWYgKHR5cGVvZiByZXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICB9XG5cbi8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cblxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuXG4gICAgICBjYXNlICdudW1iZXInOlxuXG4vLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cblxuICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6ICdudWxsJztcblxuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdudWxsJzpcblxuLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbi8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG5cbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cbi8vIElmIHRoZSB0eXBlIGlzICdvYmplY3QnLCB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggYW4gb2JqZWN0IG9yIGFuIGFycmF5IG9yXG4vLyBudWxsLlxuXG4gICAgICBjYXNlICdvYmplY3QnOlxuXG4vLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgJ29iamVjdCcsXG4vLyBzbyB3YXRjaCBvdXQgZm9yIHRoYXQgY2FzZS5cblxuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgfVxuXG4vLyBNYWtlIGFuIGFycmF5IHRvIGhvbGQgdGhlIHBhcnRpYWwgcmVzdWx0cyBvZiBzdHJpbmdpZnlpbmcgdGhpcyBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgcGFydGlhbCA9IFtdO1xuXG4vLyBJcyB0aGUgdmFsdWUgYW4gYXJyYXk/XG5cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG5cbi8vIFRoZSB2YWx1ZSBpcyBhbiBhcnJheS4gU3RyaW5naWZ5IGV2ZXJ5IGVsZW1lbnQuIFVzZSBudWxsIGFzIGEgcGxhY2Vob2xkZXJcbi8vIGZvciBub24tSlNPTiB2YWx1ZXMuXG5cbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCAnbnVsbCc7XG4gICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kIHdyYXAgdGhlbSBpblxuLy8gYnJhY2tldHMuXG5cbiAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDBcbiAgICAgICAgICAgID8gJ1tdJ1xuICAgICAgICAgICAgOiBnYXBcbiAgICAgICAgICAgID8gJ1tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnXSdcbiAgICAgICAgICAgIDogJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuXG4vLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgaWYgKHJlcCAmJiB0eXBlb2YgcmVwID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGxlbmd0aCA9IHJlcC5sZW5ndGg7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcFtpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgayA9IHJlcFtpXTtcbiAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbi8vIE90aGVyd2lzZSwgaXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUga2V5cyBpbiB0aGUgb2JqZWN0LlxuXG4gICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4vLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDBcbiAgICAgICAgICA/ICd7fSdcbiAgICAgICAgICA6IGdhcFxuICAgICAgICAgID8gJ3tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnfSdcbiAgICAgICAgICA6ICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJ30nO1xuICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gIH1cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgc3RyaW5naWZ5IG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgaWYgKHR5cGVvZiBKU09OLnN0cmluZ2lmeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIEpTT04uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcblxuLy8gVGhlIHN0cmluZ2lmeSBtZXRob2QgdGFrZXMgYSB2YWx1ZSBhbmQgYW4gb3B0aW9uYWwgcmVwbGFjZXIsIGFuZCBhbiBvcHRpb25hbFxuLy8gc3BhY2UgcGFyYW1ldGVyLCBhbmQgcmV0dXJucyBhIEpTT04gdGV4dC4gVGhlIHJlcGxhY2VyIGNhbiBiZSBhIGZ1bmN0aW9uXG4vLyB0aGF0IGNhbiByZXBsYWNlIHZhbHVlcywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgc2VsZWN0IHRoZSBrZXlzLlxuLy8gQSBkZWZhdWx0IHJlcGxhY2VyIG1ldGhvZCBjYW4gYmUgcHJvdmlkZWQuIFVzZSBvZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGNhblxuLy8gcHJvZHVjZSB0ZXh0IHRoYXQgaXMgbW9yZSBlYXNpbHkgcmVhZGFibGUuXG5cbiAgICAgIHZhciBpO1xuICAgICAgZ2FwID0gJyc7XG4gICAgICBpbmRlbnQgPSAnJztcblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgbWFrZSBhbiBpbmRlbnQgc3RyaW5nIGNvbnRhaW5pbmcgdGhhdFxuLy8gbWFueSBzcGFjZXMuXG5cbiAgICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFjZTsgaSArPSAxKSB7XG4gICAgICAgICAgaW5kZW50ICs9ICcgJztcbiAgICAgICAgfVxuXG4vLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG5cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbmRlbnQgPSBzcGFjZTtcbiAgICAgIH1cblxuLy8gSWYgdGhlcmUgaXMgYSByZXBsYWNlciwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5LlxuLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvci5cblxuICAgICAgcmVwID0gcmVwbGFjZXI7XG4gICAgICBpZiAocmVwbGFjZXIgJiYgdHlwZW9mIHJlcGxhY2VyICE9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICh0eXBlb2YgcmVwbGFjZXIgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTi5zdHJpbmdpZnknKTtcbiAgICAgIH1cblxuLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiAnJy5cbi8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG5cbiAgICAgIHJldHVybiBzdHIoJycsIHsnJzogdmFsdWV9KTtcbiAgICB9O1xuICB9XG5cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgcGFyc2UgbWV0aG9kLCBnaXZlIGl0IG9uZS5cblxuICBpZiAodHlwZW9mIEpTT04ucGFyc2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICBKU09OLnBhcnNlID0gZnVuY3Rpb24gKHRleHQsIHJldml2ZXIpIHtcblxuLy8gVGhlIHBhcnNlIG1ldGhvZCB0YWtlcyBhIHRleHQgYW5kIGFuIG9wdGlvbmFsIHJldml2ZXIgZnVuY3Rpb24sIGFuZCByZXR1cm5zXG4vLyBhIEphdmFTY3JpcHQgdmFsdWUgaWYgdGhlIHRleHQgaXMgYSB2YWxpZCBKU09OIHRleHQuXG5cbiAgICAgIHZhciBqO1xuXG4gICAgICBmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG5cbi8vIFRoZSB3YWxrIG1ldGhvZCBpcyB1c2VkIHRvIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIHJlc3VsdGluZyBzdHJ1Y3R1cmUgc29cbi8vIHRoYXQgbW9kaWZpY2F0aW9ucyBjYW4gYmUgbWFkZS5cblxuICAgICAgICB2YXIgaywgdiwgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuXG5cbi8vIFBhcnNpbmcgaGFwcGVucyBpbiBmb3VyIHN0YWdlcy4gSW4gdGhlIGZpcnN0IHN0YWdlLCB3ZSByZXBsYWNlIGNlcnRhaW5cbi8vIFVuaWNvZGUgY2hhcmFjdGVycyB3aXRoIGVzY2FwZSBzZXF1ZW5jZXMuIEphdmFTY3JpcHQgaGFuZGxlcyBtYW55IGNoYXJhY3RlcnNcbi8vIGluY29ycmVjdGx5LCBlaXRoZXIgc2lsZW50bHkgZGVsZXRpbmcgdGhlbSwgb3IgdHJlYXRpbmcgdGhlbSBhcyBsaW5lIGVuZGluZ3MuXG5cbiAgICAgIHRleHQgPSBTdHJpbmcodGV4dCk7XG4gICAgICBjeC5sYXN0SW5kZXggPSAwO1xuICAgICAgaWYgKGN4LnRlc3QodGV4dCkpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShjeCwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArXG4gICAgICAgICAgICAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuLy8gSW4gdGhlIHNlY29uZCBzdGFnZSwgd2UgcnVuIHRoZSB0ZXh0IGFnYWluc3QgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IGxvb2tcbi8vIGZvciBub24tSlNPTiBwYXR0ZXJucy4gV2UgYXJlIGVzcGVjaWFsbHkgY29uY2VybmVkIHdpdGggJygpJyBhbmQgJ25ldydcbi8vIGJlY2F1c2UgdGhleSBjYW4gY2F1c2UgaW52b2NhdGlvbiwgYW5kICc9JyBiZWNhdXNlIGl0IGNhbiBjYXVzZSBtdXRhdGlvbi5cbi8vIEJ1dCBqdXN0IHRvIGJlIHNhZmUsIHdlIHdhbnQgdG8gcmVqZWN0IGFsbCB1bmV4cGVjdGVkIGZvcm1zLlxuXG4vLyBXZSBzcGxpdCB0aGUgc2Vjb25kIHN0YWdlIGludG8gNCByZWdleHAgb3BlcmF0aW9ucyBpbiBvcmRlciB0byB3b3JrIGFyb3VuZFxuLy8gY3JpcHBsaW5nIGluZWZmaWNpZW5jaWVzIGluIElFJ3MgYW5kIFNhZmFyaSdzIHJlZ2V4cCBlbmdpbmVzLiBGaXJzdCB3ZVxuLy8gcmVwbGFjZSB0aGUgSlNPTiBiYWNrc2xhc2ggcGFpcnMgd2l0aCAnQCcgKGEgbm9uLUpTT04gY2hhcmFjdGVyKS4gU2Vjb25kLCB3ZVxuLy8gcmVwbGFjZSBhbGwgc2ltcGxlIHZhbHVlIHRva2VucyB3aXRoICddJyBjaGFyYWN0ZXJzLiBUaGlyZCwgd2UgZGVsZXRlIGFsbFxuLy8gb3BlbiBicmFja2V0cyB0aGF0IGZvbGxvdyBhIGNvbG9uIG9yIGNvbW1hIG9yIHRoYXQgYmVnaW4gdGhlIHRleHQuIEZpbmFsbHksXG4vLyB3ZSBsb29rIHRvIHNlZSB0aGF0IHRoZSByZW1haW5pbmcgY2hhcmFjdGVycyBhcmUgb25seSB3aGl0ZXNwYWNlIG9yICddJyBvclxuLy8gJywnIG9yICc6JyBvciAneycgb3IgJ30nLiBJZiB0aGF0IGlzIHNvLCB0aGVuIHRoZSB0ZXh0IGlzIHNhZmUgZm9yIGV2YWwuXG5cbiAgICAgIGlmICgvXltcXF0sOnt9XFxzXSokL1xuICAgICAgICAudGVzdCh0ZXh0LnJlcGxhY2UoL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZywgJ0AnKVxuICAgICAgICAucmVwbGFjZSgvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csICddJylcbiAgICAgICAgLnJlcGxhY2UoLyg/Ol58OnwsKSg/OlxccypcXFspKy9nLCAnJykpKSB7XG5cbi8vIEluIHRoZSB0aGlyZCBzdGFnZSB3ZSB1c2UgdGhlIGV2YWwgZnVuY3Rpb24gdG8gY29tcGlsZSB0aGUgdGV4dCBpbnRvIGFcbi8vIEphdmFTY3JpcHQgc3RydWN0dXJlLiBUaGUgJ3snIG9wZXJhdG9yIGlzIHN1YmplY3QgdG8gYSBzeW50YWN0aWMgYW1iaWd1aXR5XG4vLyBpbiBKYXZhU2NyaXB0OiBpdCBjYW4gYmVnaW4gYSBibG9jayBvciBhbiBvYmplY3QgbGl0ZXJhbC4gV2Ugd3JhcCB0aGUgdGV4dFxuLy8gaW4gcGFyZW5zIHRvIGVsaW1pbmF0ZSB0aGUgYW1iaWd1aXR5LlxuXG4gICAgICAgIGogPSBldmFsKCcoJyArIHRleHQgKyAnKScpO1xuXG4vLyBJbiB0aGUgb3B0aW9uYWwgZm91cnRoIHN0YWdlLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLCBwYXNzaW5nXG4vLyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byBhIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlIHRyYW5zZm9ybWF0aW9uLlxuXG4gICAgICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gd2Fsayh7Jyc6IGp9LCAnJylcbiAgICAgICAgICA6IGo7XG4gICAgICB9XG5cbi8vIElmIHRoZSB0ZXh0IGlzIG5vdCBKU09OIHBhcnNlYWJsZSwgdGhlbiBhIFN5bnRheEVycm9yIGlzIHRocm93bi5cblxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdKU09OLnBhcnNlJyk7XG4gICAgfTtcbiAgfVxufSgpKTtcbjsgYnJvd3NlcmlmeV9zaGltX19kZWZpbmVfX21vZHVsZV9fZXhwb3J0X18odHlwZW9mIEpTT04gIT0gXCJ1bmRlZmluZWRcIiA/IEpTT04gOiB3aW5kb3cuSlNPTik7XG5cbn0pLmNhbGwoZ2xvYmFsLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZ1bmN0aW9uIGRlZmluZUV4cG9ydChleCkgeyBtb2R1bGUuZXhwb3J0cyA9IGV4OyB9KTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIvLyBDb3B5cmlnaHQgKGMpIDIwMDUgIFRvbSBXdVxuLy8gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlscy5cblxuLy8gQmFzaWMgSmF2YVNjcmlwdCBCTiBsaWJyYXJ5IC0gc3Vic2V0IHVzZWZ1bCBmb3IgUlNBIGVuY3J5cHRpb24uXG5cbi8vIEJpdHMgcGVyIGRpZ2l0XG52YXIgZGJpdHM7XG5cbi8vIEphdmFTY3JpcHQgZW5naW5lIGFuYWx5c2lzXG52YXIgY2FuYXJ5ID0gMHhkZWFkYmVlZmNhZmU7XG52YXIgal9sbSA9ICgoY2FuYXJ5JjB4ZmZmZmZmKT09MHhlZmNhZmUpO1xuXG4vLyAocHVibGljKSBDb25zdHJ1Y3RvclxuZnVuY3Rpb24gQmlnSW50ZWdlcihhLGIsYykge1xuICBpZihhICE9IG51bGwpXG4gICAgaWYoXCJudW1iZXJcIiA9PSB0eXBlb2YgYSkgdGhpcy5mcm9tTnVtYmVyKGEsYixjKTtcbiAgICBlbHNlIGlmKGIgPT0gbnVsbCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBhKSB0aGlzLmZyb21TdHJpbmcoYSwyNTYpO1xuICAgIGVsc2UgdGhpcy5mcm9tU3RyaW5nKGEsYik7XG59XG5cbi8vIHJldHVybiBuZXcsIHVuc2V0IEJpZ0ludGVnZXJcbmZ1bmN0aW9uIG5iaSgpIHsgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG51bGwpOyB9XG5cbi8vIGFtOiBDb21wdXRlIHdfaiArPSAoeCp0aGlzX2kpLCBwcm9wYWdhdGUgY2Fycmllcyxcbi8vIGMgaXMgaW5pdGlhbCBjYXJyeSwgcmV0dXJucyBmaW5hbCBjYXJyeS5cbi8vIGMgPCAzKmR2YWx1ZSwgeCA8IDIqZHZhbHVlLCB0aGlzX2kgPCBkdmFsdWVcbi8vIFdlIG5lZWQgdG8gc2VsZWN0IHRoZSBmYXN0ZXN0IG9uZSB0aGF0IHdvcmtzIGluIHRoaXMgZW52aXJvbm1lbnQuXG5cbi8vIGFtMTogdXNlIGEgc2luZ2xlIG11bHQgYW5kIGRpdmlkZSB0byBnZXQgdGhlIGhpZ2ggYml0cyxcbi8vIG1heCBkaWdpdCBiaXRzIHNob3VsZCBiZSAyNiBiZWNhdXNlXG4vLyBtYXggaW50ZXJuYWwgdmFsdWUgPSAyKmR2YWx1ZV4yLTIqZHZhbHVlICg8IDJeNTMpXG5mdW5jdGlvbiBhbTEoaSx4LHcsaixjLG4pIHtcbiAgd2hpbGUoLS1uID49IDApIHtcbiAgICB2YXIgdiA9IHgqdGhpc1tpKytdK3dbal0rYztcbiAgICBjID0gTWF0aC5mbG9vcih2LzB4NDAwMDAwMCk7XG4gICAgd1tqKytdID0gdiYweDNmZmZmZmY7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG4vLyBhbTIgYXZvaWRzIGEgYmlnIG11bHQtYW5kLWV4dHJhY3QgY29tcGxldGVseS5cbi8vIE1heCBkaWdpdCBiaXRzIHNob3VsZCBiZSA8PSAzMCBiZWNhdXNlIHdlIGRvIGJpdHdpc2Ugb3BzXG4vLyBvbiB2YWx1ZXMgdXAgdG8gMipoZHZhbHVlXjItaGR2YWx1ZS0xICg8IDJeMzEpXG5mdW5jdGlvbiBhbTIoaSx4LHcsaixjLG4pIHtcbiAgdmFyIHhsID0geCYweDdmZmYsIHhoID0geD4+MTU7XG4gIHdoaWxlKC0tbiA+PSAwKSB7XG4gICAgdmFyIGwgPSB0aGlzW2ldJjB4N2ZmZjtcbiAgICB2YXIgaCA9IHRoaXNbaSsrXT4+MTU7XG4gICAgdmFyIG0gPSB4aCpsK2gqeGw7XG4gICAgbCA9IHhsKmwrKChtJjB4N2ZmZik8PDE1KSt3W2pdKyhjJjB4M2ZmZmZmZmYpO1xuICAgIGMgPSAobD4+PjMwKSsobT4+PjE1KSt4aCpoKyhjPj4+MzApO1xuICAgIHdbaisrXSA9IGwmMHgzZmZmZmZmZjtcbiAgfVxuICByZXR1cm4gYztcbn1cbi8vIEFsdGVybmF0ZWx5LCBzZXQgbWF4IGRpZ2l0IGJpdHMgdG8gMjggc2luY2Ugc29tZVxuLy8gYnJvd3NlcnMgc2xvdyBkb3duIHdoZW4gZGVhbGluZyB3aXRoIDMyLWJpdCBudW1iZXJzLlxuZnVuY3Rpb24gYW0zKGkseCx3LGosYyxuKSB7XG4gIHZhciB4bCA9IHgmMHgzZmZmLCB4aCA9IHg+PjE0O1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpc1tpXSYweDNmZmY7XG4gICAgdmFyIGggPSB0aGlzW2krK10+PjE0O1xuICAgIHZhciBtID0geGgqbCtoKnhsO1xuICAgIGwgPSB4bCpsKygobSYweDNmZmYpPDwxNCkrd1tqXStjO1xuICAgIGMgPSAobD4+MjgpKyhtPj4xNCkreGgqaDtcbiAgICB3W2orK10gPSBsJjB4ZmZmZmZmZjtcbiAgfVxuICByZXR1cm4gYztcbn1cbmlmKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lID09IFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCIpKSB7XG4gIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0yO1xuICBkYml0cyA9IDMwO1xufVxuZWxzZSBpZihqX2xtICYmIChuYXZpZ2F0b3IuYXBwTmFtZSAhPSBcIk5ldHNjYXBlXCIpKSB7XG4gIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0xO1xuICBkYml0cyA9IDI2O1xufVxuZWxzZSB7IC8vIE1vemlsbGEvTmV0c2NhcGUgc2VlbXMgdG8gcHJlZmVyIGFtM1xuICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGFtMztcbiAgZGJpdHMgPSAyODtcbn1cblxuQmlnSW50ZWdlci5wcm90b3R5cGUuREIgPSBkYml0cztcbkJpZ0ludGVnZXIucHJvdG90eXBlLkRNID0gKCgxPDxkYml0cyktMSk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5EViA9ICgxPDxkYml0cyk7XG5cbnZhciBCSV9GUCA9IDUyO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRlYgPSBNYXRoLnBvdygyLEJJX0ZQKTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLkYxID0gQklfRlAtZGJpdHM7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GMiA9IDIqZGJpdHMtQklfRlA7XG5cbi8vIERpZ2l0IGNvbnZlcnNpb25zXG52YXIgQklfUk0gPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xudmFyIEJJX1JDID0gbmV3IEFycmF5KCk7XG52YXIgcnIsdnY7XG5yciA9IFwiMFwiLmNoYXJDb2RlQXQoMCk7XG5mb3IodnYgPSAwOyB2diA8PSA5OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2O1xucnIgPSBcImFcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIEJJX1JDW3JyKytdID0gdnY7XG5yciA9IFwiQVwiLmNoYXJDb2RlQXQoMCk7XG5mb3IodnYgPSAxMDsgdnYgPCAzNjsgKyt2dikgQklfUkNbcnIrK10gPSB2djtcblxuZnVuY3Rpb24gaW50MmNoYXIobikgeyByZXR1cm4gQklfUk0uY2hhckF0KG4pOyB9XG5mdW5jdGlvbiBpbnRBdChzLGkpIHtcbiAgdmFyIGMgPSBCSV9SQ1tzLmNoYXJDb2RlQXQoaSldO1xuICByZXR1cm4gKGM9PW51bGwpPy0xOmM7XG59XG5cbi8vIChwcm90ZWN0ZWQpIGNvcHkgdGhpcyB0byByXG5mdW5jdGlvbiBibnBDb3B5VG8ocikge1xuICBmb3IodmFyIGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHJbaV0gPSB0aGlzW2ldO1xuICByLnQgPSB0aGlzLnQ7XG4gIHIucyA9IHRoaXMucztcbn1cblxuLy8gKHByb3RlY3RlZCkgc2V0IGZyb20gaW50ZWdlciB2YWx1ZSB4LCAtRFYgPD0geCA8IERWXG5mdW5jdGlvbiBibnBGcm9tSW50KHgpIHtcbiAgdGhpcy50ID0gMTtcbiAgdGhpcy5zID0gKHg8MCk/LTE6MDtcbiAgaWYoeCA+IDApIHRoaXNbMF0gPSB4O1xuICBlbHNlIGlmKHggPCAtMSkgdGhpc1swXSA9IHgrRFY7XG4gIGVsc2UgdGhpcy50ID0gMDtcbn1cblxuLy8gcmV0dXJuIGJpZ2ludCBpbml0aWFsaXplZCB0byB2YWx1ZVxuZnVuY3Rpb24gbmJ2KGkpIHsgdmFyIHIgPSBuYmkoKTsgci5mcm9tSW50KGkpOyByZXR1cm4gcjsgfVxuXG4vLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBzdHJpbmcgYW5kIHJhZGl4XG5mdW5jdGlvbiBibnBGcm9tU3RyaW5nKHMsYikge1xuICB2YXIgaztcbiAgaWYoYiA9PSAxNikgayA9IDQ7XG4gIGVsc2UgaWYoYiA9PSA4KSBrID0gMztcbiAgZWxzZSBpZihiID09IDI1NikgayA9IDg7IC8vIGJ5dGUgYXJyYXlcbiAgZWxzZSBpZihiID09IDIpIGsgPSAxO1xuICBlbHNlIGlmKGIgPT0gMzIpIGsgPSA1O1xuICBlbHNlIGlmKGIgPT0gNCkgayA9IDI7XG4gIGVsc2UgeyB0aGlzLmZyb21SYWRpeChzLGIpOyByZXR1cm47IH1cbiAgdGhpcy50ID0gMDtcbiAgdGhpcy5zID0gMDtcbiAgdmFyIGkgPSBzLmxlbmd0aCwgbWkgPSBmYWxzZSwgc2ggPSAwO1xuICB3aGlsZSgtLWkgPj0gMCkge1xuICAgIHZhciB4ID0gKGs9PTgpP3NbaV0mMHhmZjppbnRBdChzLGkpO1xuICAgIGlmKHggPCAwKSB7XG4gICAgICBpZihzLmNoYXJBdChpKSA9PSBcIi1cIikgbWkgPSB0cnVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG1pID0gZmFsc2U7XG4gICAgaWYoc2ggPT0gMClcbiAgICAgIHRoaXNbdGhpcy50KytdID0geDtcbiAgICBlbHNlIGlmKHNoK2sgPiB0aGlzLkRCKSB7XG4gICAgICB0aGlzW3RoaXMudC0xXSB8PSAoeCYoKDE8PCh0aGlzLkRCLXNoKSktMSkpPDxzaDtcbiAgICAgIHRoaXNbdGhpcy50KytdID0gKHg+Pih0aGlzLkRCLXNoKSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgIHRoaXNbdGhpcy50LTFdIHw9IHg8PHNoO1xuICAgIHNoICs9IGs7XG4gICAgaWYoc2ggPj0gdGhpcy5EQikgc2ggLT0gdGhpcy5EQjtcbiAgfVxuICBpZihrID09IDggJiYgKHNbMF0mMHg4MCkgIT0gMCkge1xuICAgIHRoaXMucyA9IC0xO1xuICAgIGlmKHNoID4gMCkgdGhpc1t0aGlzLnQtMV0gfD0gKCgxPDwodGhpcy5EQi1zaCkpLTEpPDxzaDtcbiAgfVxuICB0aGlzLmNsYW1wKCk7XG4gIGlmKG1pKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcyx0aGlzKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgY2xhbXAgb2ZmIGV4Y2VzcyBoaWdoIHdvcmRzXG5mdW5jdGlvbiBibnBDbGFtcCgpIHtcbiAgdmFyIGMgPSB0aGlzLnMmdGhpcy5ETTtcbiAgd2hpbGUodGhpcy50ID4gMCAmJiB0aGlzW3RoaXMudC0xXSA9PSBjKSAtLXRoaXMudDtcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxuZnVuY3Rpb24gYm5Ub1N0cmluZyhiKSB7XG4gIGlmKHRoaXMucyA8IDApIHJldHVybiBcIi1cIit0aGlzLm5lZ2F0ZSgpLnRvU3RyaW5nKGIpO1xuICB2YXIgaztcbiAgaWYoYiA9PSAxNikgayA9IDQ7XG4gIGVsc2UgaWYoYiA9PSA4KSBrID0gMztcbiAgZWxzZSBpZihiID09IDIpIGsgPSAxO1xuICBlbHNlIGlmKGIgPT0gMzIpIGsgPSA1O1xuICBlbHNlIGlmKGIgPT0gNCkgayA9IDI7XG4gIGVsc2UgcmV0dXJuIHRoaXMudG9SYWRpeChiKTtcbiAgdmFyIGttID0gKDE8PGspLTEsIGQsIG0gPSBmYWxzZSwgciA9IFwiXCIsIGkgPSB0aGlzLnQ7XG4gIHZhciBwID0gdGhpcy5EQi0oaSp0aGlzLkRCKSVrO1xuICBpZihpLS0gPiAwKSB7XG4gICAgaWYocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzW2ldPj5wKSA+IDApIHsgbSA9IHRydWU7IHIgPSBpbnQyY2hhcihkKTsgfVxuICAgIHdoaWxlKGkgPj0gMCkge1xuICAgICAgaWYocCA8IGspIHtcbiAgICAgICAgZCA9ICh0aGlzW2ldJigoMTw8cCktMSkpPDwoay1wKTtcbiAgICAgICAgZCB8PSB0aGlzWy0taV0+PihwKz10aGlzLkRCLWspO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGQgPSAodGhpc1tpXT4+KHAtPWspKSZrbTtcbiAgICAgICAgaWYocCA8PSAwKSB7IHAgKz0gdGhpcy5EQjsgLS1pOyB9XG4gICAgICB9XG4gICAgICBpZihkID4gMCkgbSA9IHRydWU7XG4gICAgICBpZihtKSByICs9IGludDJjaGFyKGQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbT9yOlwiMFwiO1xufVxuXG4vLyAocHVibGljKSAtdGhpc1xuZnVuY3Rpb24gYm5OZWdhdGUoKSB7IHZhciByID0gbmJpKCk7IEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLHIpOyByZXR1cm4gcjsgfVxuXG4vLyAocHVibGljKSB8dGhpc3xcbmZ1bmN0aW9uIGJuQWJzKCkgeyByZXR1cm4gKHRoaXMuczwwKT90aGlzLm5lZ2F0ZSgpOnRoaXM7IH1cblxuLy8gKHB1YmxpYykgcmV0dXJuICsgaWYgdGhpcyA+IGEsIC0gaWYgdGhpcyA8IGEsIDAgaWYgZXF1YWxcbmZ1bmN0aW9uIGJuQ29tcGFyZVRvKGEpIHtcbiAgdmFyIHIgPSB0aGlzLnMtYS5zO1xuICBpZihyICE9IDApIHJldHVybiByO1xuICB2YXIgaSA9IHRoaXMudDtcbiAgciA9IGktYS50O1xuICBpZihyICE9IDApIHJldHVybiAodGhpcy5zPDApPy1yOnI7XG4gIHdoaWxlKC0taSA+PSAwKSBpZigocj10aGlzW2ldLWFbaV0pICE9IDApIHJldHVybiByO1xuICByZXR1cm4gMDtcbn1cblxuLy8gcmV0dXJucyBiaXQgbGVuZ3RoIG9mIHRoZSBpbnRlZ2VyIHhcbmZ1bmN0aW9uIG5iaXRzKHgpIHtcbiAgdmFyIHIgPSAxLCB0O1xuICBpZigodD14Pj4+MTYpICE9IDApIHsgeCA9IHQ7IHIgKz0gMTY7IH1cbiAgaWYoKHQ9eD4+OCkgIT0gMCkgeyB4ID0gdDsgciArPSA4OyB9XG4gIGlmKCh0PXg+PjQpICE9IDApIHsgeCA9IHQ7IHIgKz0gNDsgfVxuICBpZigodD14Pj4yKSAhPSAwKSB7IHggPSB0OyByICs9IDI7IH1cbiAgaWYoKHQ9eD4+MSkgIT0gMCkgeyB4ID0gdDsgciArPSAxOyB9XG4gIHJldHVybiByO1xufVxuXG4vLyAocHVibGljKSByZXR1cm4gdGhlIG51bWJlciBvZiBiaXRzIGluIFwidGhpc1wiXG5mdW5jdGlvbiBibkJpdExlbmd0aCgpIHtcbiAgaWYodGhpcy50IDw9IDApIHJldHVybiAwO1xuICByZXR1cm4gdGhpcy5EQioodGhpcy50LTEpK25iaXRzKHRoaXNbdGhpcy50LTFdXih0aGlzLnMmdGhpcy5ETSkpO1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyA8PCBuKkRCXG5mdW5jdGlvbiBibnBETFNoaWZ0VG8obixyKSB7XG4gIHZhciBpO1xuICBmb3IoaSA9IHRoaXMudC0xOyBpID49IDA7IC0taSkgcltpK25dID0gdGhpc1tpXTtcbiAgZm9yKGkgPSBuLTE7IGkgPj0gMDsgLS1pKSByW2ldID0gMDtcbiAgci50ID0gdGhpcy50K247XG4gIHIucyA9IHRoaXMucztcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gbipEQlxuZnVuY3Rpb24gYm5wRFJTaGlmdFRvKG4scikge1xuICBmb3IodmFyIGkgPSBuOyBpIDwgdGhpcy50OyArK2kpIHJbaS1uXSA9IHRoaXNbaV07XG4gIHIudCA9IE1hdGgubWF4KHRoaXMudC1uLDApO1xuICByLnMgPSB0aGlzLnM7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIDw8IG5cbmZ1bmN0aW9uIGJucExTaGlmdFRvKG4scikge1xuICB2YXIgYnMgPSBuJXRoaXMuREI7XG4gIHZhciBjYnMgPSB0aGlzLkRCLWJzO1xuICB2YXIgYm0gPSAoMTw8Y2JzKS0xO1xuICB2YXIgZHMgPSBNYXRoLmZsb29yKG4vdGhpcy5EQiksIGMgPSAodGhpcy5zPDxicykmdGhpcy5ETSwgaTtcbiAgZm9yKGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHtcbiAgICByW2krZHMrMV0gPSAodGhpc1tpXT4+Y2JzKXxjO1xuICAgIGMgPSAodGhpc1tpXSZibSk8PGJzO1xuICB9XG4gIGZvcihpID0gZHMtMTsgaSA+PSAwOyAtLWkpIHJbaV0gPSAwO1xuICByW2RzXSA9IGM7XG4gIHIudCA9IHRoaXMudCtkcysxO1xuICByLnMgPSB0aGlzLnM7XG4gIHIuY2xhbXAoKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gblxuZnVuY3Rpb24gYm5wUlNoaWZ0VG8obixyKSB7XG4gIHIucyA9IHRoaXMucztcbiAgdmFyIGRzID0gTWF0aC5mbG9vcihuL3RoaXMuREIpO1xuICBpZihkcyA+PSB0aGlzLnQpIHsgci50ID0gMDsgcmV0dXJuOyB9XG4gIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gIHZhciBibSA9ICgxPDxicyktMTtcbiAgclswXSA9IHRoaXNbZHNdPj5icztcbiAgZm9yKHZhciBpID0gZHMrMTsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgcltpLWRzLTFdIHw9ICh0aGlzW2ldJmJtKTw8Y2JzO1xuICAgIHJbaS1kc10gPSB0aGlzW2ldPj5icztcbiAgfVxuICBpZihicyA+IDApIHJbdGhpcy50LWRzLTFdIHw9ICh0aGlzLnMmYm0pPDxjYnM7XG4gIHIudCA9IHRoaXMudC1kcztcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyAtIGFcbmZ1bmN0aW9uIGJucFN1YlRvKGEscikge1xuICB2YXIgaSA9IDAsIGMgPSAwLCBtID0gTWF0aC5taW4oYS50LHRoaXMudCk7XG4gIHdoaWxlKGkgPCBtKSB7XG4gICAgYyArPSB0aGlzW2ldLWFbaV07XG4gICAgcltpKytdID0gYyZ0aGlzLkRNO1xuICAgIGMgPj49IHRoaXMuREI7XG4gIH1cbiAgaWYoYS50IDwgdGhpcy50KSB7XG4gICAgYyAtPSBhLnM7XG4gICAgd2hpbGUoaSA8IHRoaXMudCkge1xuICAgICAgYyArPSB0aGlzW2ldO1xuICAgICAgcltpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICB9XG4gICAgYyArPSB0aGlzLnM7XG4gIH1cbiAgZWxzZSB7XG4gICAgYyArPSB0aGlzLnM7XG4gICAgd2hpbGUoaSA8IGEudCkge1xuICAgICAgYyAtPSBhW2ldO1xuICAgICAgcltpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICB9XG4gICAgYyAtPSBhLnM7XG4gIH1cbiAgci5zID0gKGM8MCk/LTE6MDtcbiAgaWYoYyA8IC0xKSByW2krK10gPSB0aGlzLkRWK2M7XG4gIGVsc2UgaWYoYyA+IDApIHJbaSsrXSA9IGM7XG4gIHIudCA9IGk7XG4gIHIuY2xhbXAoKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgKiBhLCByICE9IHRoaXMsYSAoSEFDIDE0LjEyKVxuLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuZnVuY3Rpb24gYm5wTXVsdGlwbHlUbyhhLHIpIHtcbiAgdmFyIHggPSB0aGlzLmFicygpLCB5ID0gYS5hYnMoKTtcbiAgdmFyIGkgPSB4LnQ7XG4gIHIudCA9IGkreS50O1xuICB3aGlsZSgtLWkgPj0gMCkgcltpXSA9IDA7XG4gIGZvcihpID0gMDsgaSA8IHkudDsgKytpKSByW2kreC50XSA9IHguYW0oMCx5W2ldLHIsaSwwLHgudCk7XG4gIHIucyA9IDA7XG4gIHIuY2xhbXAoKTtcbiAgaWYodGhpcy5zICE9IGEucykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIscik7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzXjIsIHIgIT0gdGhpcyAoSEFDIDE0LjE2KVxuZnVuY3Rpb24gYm5wU3F1YXJlVG8ocikge1xuICB2YXIgeCA9IHRoaXMuYWJzKCk7XG4gIHZhciBpID0gci50ID0gMip4LnQ7XG4gIHdoaWxlKC0taSA+PSAwKSByW2ldID0gMDtcbiAgZm9yKGkgPSAwOyBpIDwgeC50LTE7ICsraSkge1xuICAgIHZhciBjID0geC5hbShpLHhbaV0sciwyKmksMCwxKTtcbiAgICBpZigocltpK3gudF0rPXguYW0oaSsxLDIqeFtpXSxyLDIqaSsxLGMseC50LWktMSkpID49IHguRFYpIHtcbiAgICAgIHJbaSt4LnRdIC09IHguRFY7XG4gICAgICByW2kreC50KzFdID0gMTtcbiAgICB9XG4gIH1cbiAgaWYoci50ID4gMCkgcltyLnQtMV0gKz0geC5hbShpLHhbaV0sciwyKmksMCwxKTtcbiAgci5zID0gMDtcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSBkaXZpZGUgdGhpcyBieSBtLCBxdW90aWVudCBhbmQgcmVtYWluZGVyIHRvIHEsIHIgKEhBQyAxNC4yMClcbi8vIHIgIT0gcSwgdGhpcyAhPSBtLiAgcSBvciByIG1heSBiZSBudWxsLlxuZnVuY3Rpb24gYm5wRGl2UmVtVG8obSxxLHIpIHtcbiAgdmFyIHBtID0gbS5hYnMoKTtcbiAgaWYocG0udCA8PSAwKSByZXR1cm47XG4gIHZhciBwdCA9IHRoaXMuYWJzKCk7XG4gIGlmKHB0LnQgPCBwbS50KSB7XG4gICAgaWYocSAhPSBudWxsKSBxLmZyb21JbnQoMCk7XG4gICAgaWYociAhPSBudWxsKSB0aGlzLmNvcHlUbyhyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYociA9PSBudWxsKSByID0gbmJpKCk7XG4gIHZhciB5ID0gbmJpKCksIHRzID0gdGhpcy5zLCBtcyA9IG0ucztcbiAgdmFyIG5zaCA9IHRoaXMuREItbmJpdHMocG1bcG0udC0xXSk7ICAvLyBub3JtYWxpemUgbW9kdWx1c1xuICBpZihuc2ggPiAwKSB7IHBtLmxTaGlmdFRvKG5zaCx5KTsgcHQubFNoaWZ0VG8obnNoLHIpOyB9XG4gIGVsc2UgeyBwbS5jb3B5VG8oeSk7IHB0LmNvcHlUbyhyKTsgfVxuICB2YXIgeXMgPSB5LnQ7XG4gIHZhciB5MCA9IHlbeXMtMV07XG4gIGlmKHkwID09IDApIHJldHVybjtcbiAgdmFyIHl0ID0geTAqKDE8PHRoaXMuRjEpKygoeXM+MSk/eVt5cy0yXT4+dGhpcy5GMjowKTtcbiAgdmFyIGQxID0gdGhpcy5GVi95dCwgZDIgPSAoMTw8dGhpcy5GMSkveXQsIGUgPSAxPDx0aGlzLkYyO1xuICB2YXIgaSA9IHIudCwgaiA9IGkteXMsIHQgPSAocT09bnVsbCk/bmJpKCk6cTtcbiAgeS5kbFNoaWZ0VG8oaix0KTtcbiAgaWYoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgIHJbci50KytdID0gMTtcbiAgICByLnN1YlRvKHQscik7XG4gIH1cbiAgQmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKHlzLHQpO1xuICB0LnN1YlRvKHkseSk7IC8vIFwibmVnYXRpdmVcIiB5IHNvIHdlIGNhbiByZXBsYWNlIHN1YiB3aXRoIGFtIGxhdGVyXG4gIHdoaWxlKHkudCA8IHlzKSB5W3kudCsrXSA9IDA7XG4gIHdoaWxlKC0taiA+PSAwKSB7XG4gICAgLy8gRXN0aW1hdGUgcXVvdGllbnQgZGlnaXRcbiAgICB2YXIgcWQgPSAoclstLWldPT15MCk/dGhpcy5ETTpNYXRoLmZsb29yKHJbaV0qZDErKHJbaS0xXStlKSpkMik7XG4gICAgaWYoKHJbaV0rPXkuYW0oMCxxZCxyLGosMCx5cykpIDwgcWQpIHsgIC8vIFRyeSBpdCBvdXRcbiAgICAgIHkuZGxTaGlmdFRvKGosdCk7XG4gICAgICByLnN1YlRvKHQscik7XG4gICAgICB3aGlsZShyW2ldIDwgLS1xZCkgci5zdWJUbyh0LHIpO1xuICAgIH1cbiAgfVxuICBpZihxICE9IG51bGwpIHtcbiAgICByLmRyU2hpZnRUbyh5cyxxKTtcbiAgICBpZih0cyAhPSBtcykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEscSk7XG4gIH1cbiAgci50ID0geXM7XG4gIHIuY2xhbXAoKTtcbiAgaWYobnNoID4gMCkgci5yU2hpZnRUbyhuc2gscik7ICAvLyBEZW5vcm1hbGl6ZSByZW1haW5kZXJcbiAgaWYodHMgPCAwKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbn1cblxuLy8gKHB1YmxpYykgdGhpcyBtb2QgYVxuZnVuY3Rpb24gYm5Nb2QoYSkge1xuICB2YXIgciA9IG5iaSgpO1xuICB0aGlzLmFicygpLmRpdlJlbVRvKGEsbnVsbCxyKTtcbiAgaWYodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgYS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gTW9kdWxhciByZWR1Y3Rpb24gdXNpbmcgXCJjbGFzc2ljXCIgYWxnb3JpdGhtXG5mdW5jdGlvbiBDbGFzc2ljKG0pIHsgdGhpcy5tID0gbTsgfVxuZnVuY3Rpb24gY0NvbnZlcnQoeCkge1xuICBpZih4LnMgPCAwIHx8IHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG4gIGVsc2UgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBjUmV2ZXJ0KHgpIHsgcmV0dXJuIHg7IH1cbmZ1bmN0aW9uIGNSZWR1Y2UoeCkgeyB4LmRpdlJlbVRvKHRoaXMubSxudWxsLHgpOyB9XG5mdW5jdGlvbiBjTXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IHRoaXMucmVkdWNlKHIpOyB9XG5mdW5jdGlvbiBjU3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbkNsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBjQ29udmVydDtcbkNsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGNSZXZlcnQ7XG5DbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBjUmVkdWNlO1xuQ2xhc3NpYy5wcm90b3R5cGUubXVsVG8gPSBjTXVsVG87XG5DbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGNTcXJUbztcblxuLy8gKHByb3RlY3RlZCkgcmV0dXJuIFwiLTEvdGhpcyAlIDJeREJcIjsgdXNlZnVsIGZvciBNb250LiByZWR1Y3Rpb25cbi8vIGp1c3RpZmljYXRpb246XG4vLyAgICAgICAgIHh5ID09IDEgKG1vZCBtKVxuLy8gICAgICAgICB4eSA9ICAxK2ttXG4vLyAgIHh5KDIteHkpID0gKDEra20pKDEta20pXG4vLyB4W3koMi14eSldID0gMS1rXjJtXjJcbi8vIHhbeSgyLXh5KV0gPT0gMSAobW9kIG1eMilcbi8vIGlmIHkgaXMgMS94IG1vZCBtLCB0aGVuIHkoMi14eSkgaXMgMS94IG1vZCBtXjJcbi8vIHNob3VsZCByZWR1Y2UgeCBhbmQgeSgyLXh5KSBieSBtXjIgYXQgZWFjaCBzdGVwIHRvIGtlZXAgc2l6ZSBib3VuZGVkLlxuLy8gSlMgbXVsdGlwbHkgXCJvdmVyZmxvd3NcIiBkaWZmZXJlbnRseSBmcm9tIEMvQysrLCBzbyBjYXJlIGlzIG5lZWRlZCBoZXJlLlxuZnVuY3Rpb24gYm5wSW52RGlnaXQoKSB7XG4gIGlmKHRoaXMudCA8IDEpIHJldHVybiAwO1xuICB2YXIgeCA9IHRoaXNbMF07XG4gIGlmKCh4JjEpID09IDApIHJldHVybiAwO1xuICB2YXIgeSA9IHgmMzsgICAgLy8geSA9PSAxL3ggbW9kIDJeMlxuICB5ID0gKHkqKDItKHgmMHhmKSp5KSkmMHhmOyAgLy8geSA9PSAxL3ggbW9kIDJeNFxuICB5ID0gKHkqKDItKHgmMHhmZikqeSkpJjB4ZmY7ICAvLyB5ID09IDEveCBtb2QgMl44XG4gIHkgPSAoeSooMi0oKCh4JjB4ZmZmZikqeSkmMHhmZmZmKSkpJjB4ZmZmZjsgLy8geSA9PSAxL3ggbW9kIDJeMTZcbiAgLy8gbGFzdCBzdGVwIC0gY2FsY3VsYXRlIGludmVyc2UgbW9kIERWIGRpcmVjdGx5O1xuICAvLyBhc3N1bWVzIDE2IDwgREIgPD0gMzIgYW5kIGFzc3VtZXMgYWJpbGl0eSB0byBoYW5kbGUgNDgtYml0IGludHNcbiAgeSA9ICh5KigyLXgqeSV0aGlzLkRWKSkldGhpcy5EVjsgICAgLy8geSA9PSAxL3ggbW9kIDJeZGJpdHNcbiAgLy8gd2UgcmVhbGx5IHdhbnQgdGhlIG5lZ2F0aXZlIGludmVyc2UsIGFuZCAtRFYgPCB5IDwgRFZcbiAgcmV0dXJuICh5PjApP3RoaXMuRFYteToteTtcbn1cblxuLy8gTW9udGdvbWVyeSByZWR1Y3Rpb25cbmZ1bmN0aW9uIE1vbnRnb21lcnkobSkge1xuICB0aGlzLm0gPSBtO1xuICB0aGlzLm1wID0gbS5pbnZEaWdpdCgpO1xuICB0aGlzLm1wbCA9IHRoaXMubXAmMHg3ZmZmO1xuICB0aGlzLm1waCA9IHRoaXMubXA+PjE1O1xuICB0aGlzLnVtID0gKDE8PChtLkRCLTE1KSktMTtcbiAgdGhpcy5tdDIgPSAyKm0udDtcbn1cblxuLy8geFIgbW9kIG1cbmZ1bmN0aW9uIG1vbnRDb252ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5hYnMoKS5kbFNoaWZ0VG8odGhpcy5tLnQscik7XG4gIHIuZGl2UmVtVG8odGhpcy5tLG51bGwscik7XG4gIGlmKHgucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIHRoaXMubS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geC9SIG1vZCBtXG5mdW5jdGlvbiBtb250UmV2ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5jb3B5VG8ocik7XG4gIHRoaXMucmVkdWNlKHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geCA9IHgvUiBtb2QgbSAoSEFDIDE0LjMyKVxuZnVuY3Rpb24gbW9udFJlZHVjZSh4KSB7XG4gIHdoaWxlKHgudCA8PSB0aGlzLm10MikgIC8vIHBhZCB4IHNvIGFtIGhhcyBlbm91Z2ggcm9vbSBsYXRlclxuICAgIHhbeC50KytdID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubS50OyArK2kpIHtcbiAgICAvLyBmYXN0ZXIgd2F5IG9mIGNhbGN1bGF0aW5nIHUwID0geFtpXSptcCBtb2QgRFZcbiAgICB2YXIgaiA9IHhbaV0mMHg3ZmZmO1xuICAgIHZhciB1MCA9IChqKnRoaXMubXBsKygoKGoqdGhpcy5tcGgrKHhbaV0+PjE1KSp0aGlzLm1wbCkmdGhpcy51bSk8PDE1KSkmeC5ETTtcbiAgICAvLyB1c2UgYW0gdG8gY29tYmluZSB0aGUgbXVsdGlwbHktc2hpZnQtYWRkIGludG8gb25lIGNhbGxcbiAgICBqID0gaSt0aGlzLm0udDtcbiAgICB4W2pdICs9IHRoaXMubS5hbSgwLHUwLHgsaSwwLHRoaXMubS50KTtcbiAgICAvLyBwcm9wYWdhdGUgY2FycnlcbiAgICB3aGlsZSh4W2pdID49IHguRFYpIHsgeFtqXSAtPSB4LkRWOyB4Wysral0rKzsgfVxuICB9XG4gIHguY2xhbXAoKTtcbiAgeC5kclNoaWZ0VG8odGhpcy5tLnQseCk7XG4gIGlmKHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgeC5zdWJUbyh0aGlzLm0seCk7XG59XG5cbi8vIHIgPSBcInheMi9SIG1vZCBtXCI7IHggIT0gclxuZnVuY3Rpb24gbW9udFNxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG4vLyByID0gXCJ4eS9SIG1vZCBtXCI7IHgseSAhPSByXG5mdW5jdGlvbiBtb250TXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbk1vbnRnb21lcnkucHJvdG90eXBlLmNvbnZlcnQgPSBtb250Q29udmVydDtcbk1vbnRnb21lcnkucHJvdG90eXBlLnJldmVydCA9IG1vbnRSZXZlcnQ7XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5yZWR1Y2UgPSBtb250UmVkdWNlO1xuTW9udGdvbWVyeS5wcm90b3R5cGUubXVsVG8gPSBtb250TXVsVG87XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5zcXJUbyA9IG1vbnRTcXJUbztcblxuLy8gKHByb3RlY3RlZCkgdHJ1ZSBpZmYgdGhpcyBpcyBldmVuXG5mdW5jdGlvbiBibnBJc0V2ZW4oKSB7IHJldHVybiAoKHRoaXMudD4wKT8odGhpc1swXSYxKTp0aGlzLnMpID09IDA7IH1cblxuLy8gKHByb3RlY3RlZCkgdGhpc15lLCBlIDwgMl4zMiwgZG9pbmcgc3FyIGFuZCBtdWwgd2l0aCBcInJcIiAoSEFDIDE0Ljc5KVxuZnVuY3Rpb24gYm5wRXhwKGUseikge1xuICBpZihlID4gMHhmZmZmZmZmZiB8fCBlIDwgMSkgcmV0dXJuIEJpZ0ludGVnZXIuT05FO1xuICB2YXIgciA9IG5iaSgpLCByMiA9IG5iaSgpLCBnID0gei5jb252ZXJ0KHRoaXMpLCBpID0gbmJpdHMoZSktMTtcbiAgZy5jb3B5VG8ocik7XG4gIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgei5zcXJUbyhyLHIyKTtcbiAgICBpZigoZSYoMTw8aSkpID4gMCkgei5tdWxUbyhyMixnLHIpO1xuICAgIGVsc2UgeyB2YXIgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gIH1cbiAgcmV0dXJuIHoucmV2ZXJ0KHIpO1xufVxuXG4vLyAocHVibGljKSB0aGlzXmUgJSBtLCAwIDw9IGUgPCAyXjMyXG5mdW5jdGlvbiBibk1vZFBvd0ludChlLG0pIHtcbiAgdmFyIHo7XG4gIGlmKGUgPCAyNTYgfHwgbS5pc0V2ZW4oKSkgeiA9IG5ldyBDbGFzc2ljKG0pOyBlbHNlIHogPSBuZXcgTW9udGdvbWVyeShtKTtcbiAgcmV0dXJuIHRoaXMuZXhwKGUseik7XG59XG5cbi8vIHByb3RlY3RlZFxuQmlnSW50ZWdlci5wcm90b3R5cGUuY29weVRvID0gYm5wQ29weVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbUludCA9IGJucEZyb21JbnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gYm5wRnJvbVN0cmluZztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNsYW1wID0gYm5wQ2xhbXA7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kbFNoaWZ0VG8gPSBibnBETFNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kclNoaWZ0VG8gPSBibnBEUlNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5sU2hpZnRUbyA9IGJucExTaGlmdFRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuclNoaWZ0VG8gPSBibnBSU2hpZnRUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnN1YlRvID0gYm5wU3ViVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVRvID0gYm5wTXVsdGlwbHlUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZVRvID0gYm5wU3F1YXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZSZW1UbyA9IGJucERpdlJlbVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBibnBJbnZEaWdpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGJucElzRXZlbjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmV4cCA9IGJucEV4cDtcblxuLy8gcHVibGljXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGJuVG9TdHJpbmc7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBibk5lZ2F0ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGJuQWJzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gYm5Db21wYXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBibkJpdExlbmd0aDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGJuTW9kO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93SW50ID0gYm5Nb2RQb3dJbnQ7XG5cbi8vIFwiY29uc3RhbnRzXCJcbkJpZ0ludGVnZXIuWkVSTyA9IG5idigwKTtcbkJpZ0ludGVnZXIuT05FID0gbmJ2KDEpO1xuXG4vLyBwcm5nNC5qcyAtIHVzZXMgQXJjZm91ciBhcyBhIFBSTkdcblxuZnVuY3Rpb24gQXJjZm91cigpIHtcbiAgdGhpcy5pID0gMDtcbiAgdGhpcy5qID0gMDtcbiAgdGhpcy5TID0gbmV3IEFycmF5KCk7XG59XG5cbi8vIEluaXRpYWxpemUgYXJjZm91ciBjb250ZXh0IGZyb20ga2V5LCBhbiBhcnJheSBvZiBpbnRzLCBlYWNoIGZyb20gWzAuLjI1NV1cbmZ1bmN0aW9uIEFSQzRpbml0KGtleSkge1xuICB2YXIgaSwgaiwgdDtcbiAgZm9yKGkgPSAwOyBpIDwgMjU2OyArK2kpXG4gICAgdGhpcy5TW2ldID0gaTtcbiAgaiA9IDA7XG4gIGZvcihpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgaiA9IChqICsgdGhpcy5TW2ldICsga2V5W2kgJSBrZXkubGVuZ3RoXSkgJiAyNTU7XG4gICAgdCA9IHRoaXMuU1tpXTtcbiAgICB0aGlzLlNbaV0gPSB0aGlzLlNbal07XG4gICAgdGhpcy5TW2pdID0gdDtcbiAgfVxuICB0aGlzLmkgPSAwO1xuICB0aGlzLmogPSAwO1xufVxuXG5mdW5jdGlvbiBBUkM0bmV4dCgpIHtcbiAgdmFyIHQ7XG4gIHRoaXMuaSA9ICh0aGlzLmkgKyAxKSAmIDI1NTtcbiAgdGhpcy5qID0gKHRoaXMuaiArIHRoaXMuU1t0aGlzLmldKSAmIDI1NTtcbiAgdCA9IHRoaXMuU1t0aGlzLmldO1xuICB0aGlzLlNbdGhpcy5pXSA9IHRoaXMuU1t0aGlzLmpdO1xuICB0aGlzLlNbdGhpcy5qXSA9IHQ7XG4gIHJldHVybiB0aGlzLlNbKHQgKyB0aGlzLlNbdGhpcy5pXSkgJiAyNTVdO1xufVxuXG5BcmNmb3VyLnByb3RvdHlwZS5pbml0ID0gQVJDNGluaXQ7XG5BcmNmb3VyLnByb3RvdHlwZS5uZXh0ID0gQVJDNG5leHQ7XG5cbi8vIFBsdWcgaW4geW91ciBSTkcgY29uc3RydWN0b3IgaGVyZVxuZnVuY3Rpb24gcHJuZ19uZXdzdGF0ZSgpIHtcbiAgcmV0dXJuIG5ldyBBcmNmb3VyKCk7XG59XG5cbi8vIFBvb2wgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCBhbmQgZ3JlYXRlciB0aGFuIDMyLlxuLy8gQW4gYXJyYXkgb2YgYnl0ZXMgdGhlIHNpemUgb2YgdGhlIHBvb2wgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpXG52YXIgcm5nX3BzaXplID0gMjU2O1xuLy8gUmFuZG9tIG51bWJlciBnZW5lcmF0b3IgLSByZXF1aXJlcyBhIFBSTkcgYmFja2VuZCwgZS5nLiBwcm5nNC5qc1xuXG4vLyBGb3IgYmVzdCByZXN1bHRzLCBwdXQgY29kZSBsaWtlXG4vLyA8Ym9keSBvbkNsaWNrPSdybmdfc2VlZF90aW1lKCk7JyBvbktleVByZXNzPSdybmdfc2VlZF90aW1lKCk7Jz5cbi8vIGluIHlvdXIgbWFpbiBIVE1MIGRvY3VtZW50LlxuXG52YXIgcm5nX3N0YXRlO1xudmFyIHJuZ19wb29sO1xudmFyIHJuZ19wcHRyO1xuXG4vLyBNaXggaW4gYSAzMi1iaXQgaW50ZWdlciBpbnRvIHRoZSBwb29sXG5mdW5jdGlvbiBybmdfc2VlZF9pbnQoeCkge1xuICBybmdfcG9vbFtybmdfcHB0cisrXSBePSB4ICYgMjU1O1xuICBybmdfcG9vbFtybmdfcHB0cisrXSBePSAoeCA+PiA4KSAmIDI1NTtcbiAgcm5nX3Bvb2xbcm5nX3BwdHIrK10gXj0gKHggPj4gMTYpICYgMjU1O1xuICBybmdfcG9vbFtybmdfcHB0cisrXSBePSAoeCA+PiAyNCkgJiAyNTU7XG4gIGlmKHJuZ19wcHRyID49IHJuZ19wc2l6ZSkgcm5nX3BwdHIgLT0gcm5nX3BzaXplO1xufVxuXG4vLyBNaXggaW4gdGhlIGN1cnJlbnQgdGltZSAody9taWxsaXNlY29uZHMpIGludG8gdGhlIHBvb2xcbmZ1bmN0aW9uIHJuZ19zZWVkX3RpbWUoKSB7XG4gIHJuZ19zZWVkX2ludChuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG59XG5cbi8vIEluaXRpYWxpemUgdGhlIHBvb2wgd2l0aCBqdW5rIGlmIG5lZWRlZC5cbmlmKHJuZ19wb29sID09IG51bGwpIHtcbiAgcm5nX3Bvb2wgPSBuZXcgQXJyYXkoKTtcbiAgcm5nX3BwdHIgPSAwO1xuICB2YXIgdDtcbiAgaWYobmF2aWdhdG9yLmFwcE5hbWUgPT0gXCJOZXRzY2FwZVwiICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uIDwgXCI1XCIgJiYgd2luZG93LmNyeXB0bykge1xuICAgIC8vIEV4dHJhY3QgZW50cm9weSAoMjU2IGJpdHMpIGZyb20gTlM0IFJORyBpZiBhdmFpbGFibGVcbiAgICB2YXIgeiA9IHdpbmRvdy5jcnlwdG8ucmFuZG9tKDMyKTtcbiAgICBmb3IodCA9IDA7IHQgPCB6Lmxlbmd0aDsgKyt0KVxuICAgICAgcm5nX3Bvb2xbcm5nX3BwdHIrK10gPSB6LmNoYXJDb2RlQXQodCkgJiAyNTU7XG4gIH1cbiAgd2hpbGUocm5nX3BwdHIgPCBybmdfcHNpemUpIHsgIC8vIGV4dHJhY3Qgc29tZSByYW5kb21uZXNzIGZyb20gTWF0aC5yYW5kb20oKVxuICAgIHQgPSBNYXRoLmZsb29yKDY1NTM2ICogTWF0aC5yYW5kb20oKSk7XG4gICAgcm5nX3Bvb2xbcm5nX3BwdHIrK10gPSB0ID4+PiA4O1xuICAgIHJuZ19wb29sW3JuZ19wcHRyKytdID0gdCAmIDI1NTtcbiAgfVxuICBybmdfcHB0ciA9IDA7XG4gIHJuZ19zZWVkX3RpbWUoKTtcbiAgLy9ybmdfc2VlZF9pbnQod2luZG93LnNjcmVlblgpO1xuICAvL3JuZ19zZWVkX2ludCh3aW5kb3cuc2NyZWVuWSk7XG59XG5cbmZ1bmN0aW9uIHJuZ19nZXRfYnl0ZSgpIHtcbiAgaWYocm5nX3N0YXRlID09IG51bGwpIHtcbiAgICBybmdfc2VlZF90aW1lKCk7XG4gICAgcm5nX3N0YXRlID0gcHJuZ19uZXdzdGF0ZSgpO1xuICAgIHJuZ19zdGF0ZS5pbml0KHJuZ19wb29sKTtcbiAgICBmb3Iocm5nX3BwdHIgPSAwOyBybmdfcHB0ciA8IHJuZ19wb29sLmxlbmd0aDsgKytybmdfcHB0cilcbiAgICAgIHJuZ19wb29sW3JuZ19wcHRyXSA9IDA7XG4gICAgcm5nX3BwdHIgPSAwO1xuICAgIC8vcm5nX3Bvb2wgPSBudWxsO1xuICB9XG4gIC8vIFRPRE86IGFsbG93IHJlc2VlZGluZyBhZnRlciBmaXJzdCByZXF1ZXN0XG4gIHJldHVybiBybmdfc3RhdGUubmV4dCgpO1xufVxuXG5mdW5jdGlvbiBybmdfZ2V0X2J5dGVzKGJhKSB7XG4gIHZhciBpO1xuICBmb3IoaSA9IDA7IGkgPCBiYS5sZW5ndGg7ICsraSkgYmFbaV0gPSBybmdfZ2V0X2J5dGUoKTtcbn1cblxuZnVuY3Rpb24gU2VjdXJlUmFuZG9tKCkge31cblxuU2VjdXJlUmFuZG9tLnByb3RvdHlwZS5uZXh0Qnl0ZXMgPSBybmdfZ2V0X2J5dGVzO1xuXG4vL0RlcGVuZHMgb24ganNibi5qcyBhbmQgcm5nLmpzXG5cbi8vVmVyc2lvbiAxLjE6IHN1cHBvcnQgdXRmLTggZW5jb2RpbmcgaW4gcGtjczFwYWQyXG5cbi8vY29udmVydCBhIChoZXgpIHN0cmluZyB0byBhIGJpZ251bSBvYmplY3RcbmZ1bmN0aW9uIHBhcnNlQmlnSW50KHN0cixyKSB7XG4gIHJldHVybiBuZXcgQmlnSW50ZWdlcihzdHIscik7XG59XG5cbmZ1bmN0aW9uIGxpbmVicmsocyxuKSB7XG4gIHZhciByZXQgPSBcIlwiO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlKGkgKyBuIDwgcy5sZW5ndGgpIHtcbiAgICByZXQgKz0gcy5zdWJzdHJpbmcoaSxpK24pICsgXCJcXG5cIjtcbiAgICBpICs9IG47XG4gIH1cbiAgcmV0dXJuIHJldCArIHMuc3Vic3RyaW5nKGkscy5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBieXRlMkhleChiKSB7XG4gIGlmKGIgPCAweDEwKVxuICAgIHJldHVybiBcIjBcIiArIGIudG9TdHJpbmcoMTYpO1xuICBlbHNlXG4gICAgcmV0dXJuIGIudG9TdHJpbmcoMTYpO1xufVxuXG4vL1BLQ1MjMSAodHlwZSAyLCByYW5kb20pIHBhZCBpbnB1dCBzdHJpbmcgcyB0byBuIGJ5dGVzLCBhbmQgcmV0dXJuIGEgYmlnaW50XG5mdW5jdGlvbiBwa2NzMXBhZDIocyxuKSB7XG4gIGlmKG4gPCBzLmxlbmd0aCArIDExKSB7IC8vIFRPRE86IGZpeCBmb3IgdXRmLThcbiAgICBhbGVydChcIk1lc3NhZ2UgdG9vIGxvbmcgZm9yIFJTQVwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgYmEgPSBuZXcgQXJyYXkoKTtcbiAgdmFyIGkgPSBzLmxlbmd0aCAtIDE7XG4gIHdoaWxlKGkgPj0gMCAmJiBuID4gMCkge1xuICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGktLSk7XG4gICAgaWYoYyA8IDEyOCkgeyAvLyBlbmNvZGUgdXNpbmcgdXRmLThcbiAgICAgIGJhWy0tbl0gPSBjO1xuICAgIH1cbiAgICBlbHNlIGlmKChjID4gMTI3KSAmJiAoYyA8IDIwNDgpKSB7XG4gICAgICBiYVstLW5dID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICBiYVstLW5dID0gKGMgPj4gNikgfCAxOTI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYmFbLS1uXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgYmFbLS1uXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgIGJhWy0tbl0gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgfVxuICB9XG4gIGJhWy0tbl0gPSAwO1xuICB2YXIgcm5nID0gbmV3IFNlY3VyZVJhbmRvbSgpO1xuICB2YXIgeCA9IG5ldyBBcnJheSgpO1xuICB3aGlsZShuID4gMikgeyAvLyByYW5kb20gbm9uLXplcm8gcGFkXG4gICAgeFswXSA9IDA7XG4gICAgd2hpbGUoeFswXSA9PSAwKSBybmcubmV4dEJ5dGVzKHgpO1xuICAgIGJhWy0tbl0gPSB4WzBdO1xuICB9XG4gIGJhWy0tbl0gPSAyO1xuICBiYVstLW5dID0gMDtcbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGJhKTtcbn1cblxuLy9cImVtcHR5XCIgUlNBIGtleSBjb25zdHJ1Y3RvclxuZnVuY3Rpb24gUlNBS2V5KCkge1xuICB0aGlzLm4gPSBudWxsO1xuICB0aGlzLmUgPSAwO1xuICB0aGlzLmQgPSBudWxsO1xuICB0aGlzLnAgPSBudWxsO1xuICB0aGlzLnEgPSBudWxsO1xuICB0aGlzLmRtcDEgPSBudWxsO1xuICB0aGlzLmRtcTEgPSBudWxsO1xuICB0aGlzLmNvZWZmID0gbnVsbDtcbn1cblxuLy9TZXQgdGhlIHB1YmxpYyBrZXkgZmllbGRzIE4gYW5kIGUgZnJvbSBoZXggc3RyaW5nc1xuZnVuY3Rpb24gUlNBU2V0UHVibGljKE4sRSkge1xuICBpZihOICE9IG51bGwgJiYgRSAhPSBudWxsICYmIE4ubGVuZ3RoID4gMCAmJiBFLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLm4gPSBwYXJzZUJpZ0ludChOLDE2KTtcbiAgICB0aGlzLmUgPSBwYXJzZUludChFLDE2KTtcbiAgfVxuICBlbHNlXG4gICAgYWxlcnQoXCJJbnZhbGlkIFJTQSBwdWJsaWMga2V5XCIpO1xufVxuXG4vL1BlcmZvcm0gcmF3IHB1YmxpYyBvcGVyYXRpb24gb24gXCJ4XCI6IHJldHVybiB4XmUgKG1vZCBuKVxuZnVuY3Rpb24gUlNBRG9QdWJsaWMoeCkge1xuICByZXR1cm4geC5tb2RQb3dJbnQodGhpcy5lLCB0aGlzLm4pO1xufVxuXG4vL1JldHVybiB0aGUgUEtDUyMxIFJTQSBlbmNyeXB0aW9uIG9mIFwidGV4dFwiIGFzIGFuIGV2ZW4tbGVuZ3RoIGhleCBzdHJpbmdcbmZ1bmN0aW9uIFJTQUVuY3J5cHQodGV4dCkge1xuICB2YXIgbSA9IHBrY3MxcGFkMih0ZXh0LCh0aGlzLm4uYml0TGVuZ3RoKCkrNyk+PjMpO1xuICBpZihtID09IG51bGwpIHJldHVybiBudWxsO1xuICB2YXIgYyA9IHRoaXMuZG9QdWJsaWMobSk7XG4gIGlmKGMgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHZhciBoID0gYy50b1N0cmluZygxNik7XG4gIGlmKChoLmxlbmd0aCAmIDEpID09IDApIHJldHVybiBoOyBlbHNlIHJldHVybiBcIjBcIiArIGg7XG59XG5cbi8vUmV0dXJuIHRoZSBQS0NTIzEgUlNBIGVuY3J5cHRpb24gb2YgXCJ0ZXh0XCIgYXMgYSBCYXNlNjQtZW5jb2RlZCBzdHJpbmdcbi8vZnVuY3Rpb24gUlNBRW5jcnlwdEI2NCh0ZXh0KSB7XG4vL3ZhciBoID0gdGhpcy5lbmNyeXB0KHRleHQpO1xuLy9pZihoKSByZXR1cm4gaGV4MmI2NChoKTsgZWxzZSByZXR1cm4gbnVsbDtcbi8vfVxuXG4vL3Byb3RlY3RlZFxuUlNBS2V5LnByb3RvdHlwZS5kb1B1YmxpYyA9IFJTQURvUHVibGljO1xuXG4vL3B1YmxpY1xuUlNBS2V5LnByb3RvdHlwZS5zZXRQdWJsaWMgPSBSU0FTZXRQdWJsaWM7XG5SU0FLZXkucHJvdG90eXBlLmVuY3J5cHQgPSBSU0FFbmNyeXB0O1xuLy9SU0FLZXkucHJvdG90eXBlLmVuY3J5cHRfYjY0ID0gUlNBRW5jcnlwdEI2NDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFNlY3VyZVJhbmRvbTogU2VjdXJlUmFuZG9tLFxuICBieXRlMkhleDogYnl0ZTJIZXgsXG4gIFJTQUtleTogUlNBS2V5XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9jaGFpJyk7XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgdXNlZCA9IFtdXG4gICwgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qIVxuICogQ2hhaSB2ZXJzaW9uXG4gKi9cblxuZXhwb3J0cy52ZXJzaW9uID0gJzEuOC4xJztcblxuLyohXG4gKiBBc3NlcnRpb24gRXJyb3JcbiAqL1xuXG5leHBvcnRzLkFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnYXNzZXJ0aW9uLWVycm9yJyk7XG5cbi8qIVxuICogVXRpbHMgZm9yIHBsdWdpbnMgKG5vdCBleHBvcnRlZClcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vY2hhaS91dGlscycpO1xuXG4vKipcbiAqICMgLnVzZShmdW5jdGlvbilcbiAqXG4gKiBQcm92aWRlcyBhIHdheSB0byBleHRlbmQgdGhlIGludGVybmFscyBvZiBDaGFpXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEByZXR1cm5zIHt0aGlzfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy51c2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgaWYgKCF+dXNlZC5pbmRleE9mKGZuKSkge1xuICAgIGZuKHRoaXMsIHV0aWwpO1xuICAgIHVzZWQucHVzaChmbik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogUHJpbWFyeSBgQXNzZXJ0aW9uYCBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXNzZXJ0aW9uID0gcmVxdWlyZSgnLi9jaGFpL2Fzc2VydGlvbicpO1xuZXhwb3J0cy51c2UoYXNzZXJ0aW9uKTtcblxuLyohXG4gKiBDb3JlIEFzc2VydGlvbnNcbiAqL1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJy4vY2hhaS9jb3JlL2Fzc2VydGlvbnMnKTtcbmV4cG9ydHMudXNlKGNvcmUpO1xuXG4vKiFcbiAqIEV4cGVjdCBpbnRlcmZhY2VcbiAqL1xuXG52YXIgZXhwZWN0ID0gcmVxdWlyZSgnLi9jaGFpL2ludGVyZmFjZS9leHBlY3QnKTtcbmV4cG9ydHMudXNlKGV4cGVjdCk7XG5cbi8qIVxuICogU2hvdWxkIGludGVyZmFjZVxuICovXG5cbnZhciBzaG91bGQgPSByZXF1aXJlKCcuL2NoYWkvaW50ZXJmYWNlL3Nob3VsZCcpO1xuZXhwb3J0cy51c2Uoc2hvdWxkKTtcblxuLyohXG4gKiBBc3NlcnQgaW50ZXJmYWNlXG4gKi9cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJy4vY2hhaS9pbnRlcmZhY2UvYXNzZXJ0Jyk7XG5leHBvcnRzLnVzZShhc3NlcnQpO1xuIiwiLyohXG4gKiBjaGFpXG4gKiBodHRwOi8vY2hhaWpzLmNvbVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9jaGFpLCB1dGlsKSB7XG4gIC8qIVxuICAgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICAgKi9cblxuICB2YXIgQXNzZXJ0aW9uRXJyb3IgPSBfY2hhaS5Bc3NlcnRpb25FcnJvclxuICAgICwgZmxhZyA9IHV0aWwuZmxhZztcblxuICAvKiFcbiAgICogTW9kdWxlIGV4cG9ydC5cbiAgICovXG5cbiAgX2NoYWkuQXNzZXJ0aW9uID0gQXNzZXJ0aW9uO1xuXG4gIC8qIVxuICAgKiBBc3NlcnRpb24gQ29uc3RydWN0b3JcbiAgICpcbiAgICogQ3JlYXRlcyBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gQXNzZXJ0aW9uIChvYmosIG1zZywgc3RhY2spIHtcbiAgICBmbGFnKHRoaXMsICdzc2ZpJywgc3RhY2sgfHwgYXJndW1lbnRzLmNhbGxlZSk7XG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0Jywgb2JqKTtcbiAgICBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgfVxuXG4gIC8qIVxuICAgICogIyMjIEFzc2VydGlvbi5pbmNsdWRlU3RhY2tcbiAgICAqXG4gICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgaW5mbHVlbmNlcyB3aGV0aGVyIHN0YWNrIHRyYWNlXG4gICAgKiBpcyBpbmNsdWRlZCBpbiBBc3NlcnRpb24gZXJyb3IgbWVzc2FnZS4gRGVmYXVsdCBvZiBmYWxzZVxuICAgICogc3VwcHJlc3NlcyBzdGFjayB0cmFjZSBpbiB0aGUgZXJyb3IgbWVzc2FnZVxuICAgICpcbiAgICAqICAgICBBc3NlcnRpb24uaW5jbHVkZVN0YWNrID0gdHJ1ZTsgIC8vIGVuYWJsZSBzdGFjayBvbiBlcnJvclxuICAgICpcbiAgICAqIEBhcGkgcHVibGljXG4gICAgKi9cblxuICBBc3NlcnRpb24uaW5jbHVkZVN0YWNrID0gZmFsc2U7XG5cbiAgLyohXG4gICAqICMjIyBBc3NlcnRpb24uc2hvd0RpZmZcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIGluZmx1ZW5jZXMgd2hldGhlciBvciBub3RcbiAgICogdGhlIGBzaG93RGlmZmAgZmxhZyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHRocm93blxuICAgKiBBc3NlcnRpb25FcnJvcnMuIGBmYWxzZWAgd2lsbCBhbHdheXMgYmUgYGZhbHNlYDsgYHRydWVgXG4gICAqIHdpbGwgYmUgdHJ1ZSB3aGVuIHRoZSBhc3NlcnRpb24gaGFzIHJlcXVlc3RlZCBhIGRpZmZcbiAgICogYmUgc2hvd24uXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5zaG93RGlmZiA9IHRydWU7XG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5hZGRQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLmFkZE1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgICB1dGlsLmFkZENoYWluYWJsZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwub3ZlcndyaXRlUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKTtcbiAgfTtcblxuICAvKiFcbiAgICogIyMjIC5hc3NlcnQoZXhwcmVzc2lvbiwgbWVzc2FnZSwgbmVnYXRlTWVzc2FnZSwgZXhwZWN0ZWQsIGFjdHVhbClcbiAgICpcbiAgICogRXhlY3V0ZXMgYW4gZXhwcmVzc2lvbiBhbmQgY2hlY2sgZXhwZWN0YXRpb25zLiBUaHJvd3MgQXNzZXJ0aW9uRXJyb3IgZm9yIHJlcG9ydGluZyBpZiB0ZXN0IGRvZXNuJ3QgcGFzcy5cbiAgICpcbiAgICogQG5hbWUgYXNzZXJ0XG4gICAqIEBwYXJhbSB7UGhpbG9zb3BoaWNhbH0gZXhwcmVzc2lvbiB0byBiZSB0ZXN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgdG8gZGlzcGxheSBpZiBmYWlsc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbmVnYXRlZE1lc3NhZ2UgdG8gZGlzcGxheSBpZiBuZWdhdGVkIGV4cHJlc3Npb24gZmFpbHNcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWQgdmFsdWUgKHJlbWVtYmVyIHRvIGNoZWNrIGZvciBuZWdhdGlvbilcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsIChvcHRpb25hbCkgd2lsbCBkZWZhdWx0IHRvIGB0aGlzLm9iamBcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIEFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0ID0gZnVuY3Rpb24gKGV4cHIsIG1zZywgbmVnYXRlTXNnLCBleHBlY3RlZCwgX2FjdHVhbCwgc2hvd0RpZmYpIHtcbiAgICB2YXIgb2sgPSB1dGlsLnRlc3QodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodHJ1ZSAhPT0gc2hvd0RpZmYpIHNob3dEaWZmID0gZmFsc2U7XG4gICAgaWYgKHRydWUgIT09IEFzc2VydGlvbi5zaG93RGlmZikgc2hvd0RpZmYgPSBmYWxzZTtcblxuICAgIGlmICghb2spIHtcbiAgICAgIHZhciBtc2cgPSB1dGlsLmdldE1lc3NhZ2UodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAsIGFjdHVhbCA9IHV0aWwuZ2V0QWN0dWFsKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobXNnLCB7XG4gICAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgLCBzaG93RGlmZjogc2hvd0RpZmZcbiAgICAgIH0sIChBc3NlcnRpb24uaW5jbHVkZVN0YWNrKSA/IHRoaXMuYXNzZXJ0IDogZmxhZyh0aGlzLCAnc3NmaScpKTtcbiAgICB9XG4gIH07XG5cbiAgLyohXG4gICAqICMjIyAuX29ialxuICAgKlxuICAgKiBRdWljayByZWZlcmVuY2UgdG8gc3RvcmVkIGBhY3R1YWxgIHZhbHVlIGZvciBwbHVnaW4gZGV2ZWxvcGVycy5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3NlcnRpb24ucHJvdG90eXBlLCAnX29iaicsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgICAgfVxuICAgICwgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIHZhbCk7XG4gICAgICB9XG4gIH0pO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogaHR0cDovL2NoYWlqcy5jb21cbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCBfKSB7XG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvblxuICAgICwgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgLCBmbGFnID0gXy5mbGFnO1xuXG4gIC8qKlxuICAgKiAjIyMgTGFuZ3VhZ2UgQ2hhaW5zXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgYXJlIHByb3ZpZGVkIGFzIGNoYWluYWJsZSBnZXR0ZXJzIHRvXG4gICAqIGltcHJvdmUgdGhlIHJlYWRhYmlsaXR5IG9mIHlvdXIgYXNzZXJ0aW9ucy4gVGhleVxuICAgKiBkbyBub3QgcHJvdmlkZSBhbiB0ZXN0aW5nIGNhcGFiaWxpdHkgdW5sZXNzIHRoZXlcbiAgICogaGF2ZSBiZWVuIG92ZXJ3cml0dGVuIGJ5IGEgcGx1Z2luLlxuICAgKlxuICAgKiAqKkNoYWlucyoqXG4gICAqXG4gICAqIC0gdG9cbiAgICogLSBiZVxuICAgKiAtIGJlZW5cbiAgICogLSBpc1xuICAgKiAtIHRoYXRcbiAgICogLSBhbmRcbiAgICogLSBoYXNcbiAgICogLSBoYXZlXG4gICAqIC0gd2l0aFxuICAgKiAtIGF0XG4gICAqIC0gb2ZcbiAgICogLSBzYW1lXG4gICAqXG4gICAqIEBuYW1lIGxhbmd1YWdlIGNoYWluc1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBbICd0bycsICdiZScsICdiZWVuJ1xuICAsICdpcycsICdhbmQnLCAnaGFzJywgJ2hhdmUnXG4gICwgJ3dpdGgnLCAndGhhdCcsICdhdCdcbiAgLCAnb2YnLCAnc2FtZScgXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIEFzc2VydGlvbi5hZGRQcm9wZXJ0eShjaGFpbiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFxuICAgKlxuICAgKiBOZWdhdGVzIGFueSBvZiBhc3NlcnRpb25zIGZvbGxvd2luZyBpbiB0aGUgY2hhaW4uXG4gICAqXG4gICAqICAgICBleHBlY3QoZm9vKS50by5ub3QuZXF1YWwoJ2JhcicpO1xuICAgKiAgICAgZXhwZWN0KGdvb2RGbikudG8ubm90LnRocm93KEVycm9yKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogJ2JheicgfSkudG8uaGF2ZS5wcm9wZXJ0eSgnZm9vJylcbiAgICogICAgICAgLmFuZC5ub3QuZXF1YWwoJ2JhcicpO1xuICAgKlxuICAgKiBAbmFtZSBub3RcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdub3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnbmVnYXRlJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBcbiAgICpcbiAgICogU2V0cyB0aGUgYGRlZXBgIGZsYWcsIGxhdGVyIHVzZWQgYnkgdGhlIGBlcXVhbGAgYW5kXG4gICAqIGBwcm9wZXJ0eWAgYXNzZXJ0aW9ucy5cbiAgICpcbiAgICogICAgIGV4cGVjdChmb28pLnRvLmRlZXAuZXF1YWwoeyBiYXI6ICdiYXonIH0pO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiB7IGJhcjogeyBiYXo6ICdxdXV4JyB9IH0gfSlcbiAgICogICAgICAgLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgnZm9vLmJhci5iYXonLCAncXV1eCcpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZGVlcCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdkZWVwJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmEodHlwZSlcbiAgICpcbiAgICogVGhlIGBhYCBhbmQgYGFuYCBhc3NlcnRpb25zIGFyZSBhbGlhc2VzIHRoYXQgY2FuIGJlXG4gICAqIHVzZWQgZWl0aGVyIGFzIGxhbmd1YWdlIGNoYWlucyBvciB0byBhc3NlcnQgYSB2YWx1ZSdzXG4gICAqIHR5cGUuXG4gICAqXG4gICAqICAgICAvLyB0eXBlb2ZcbiAgICogICAgIGV4cGVjdCgndGVzdCcpLnRvLmJlLmEoJ3N0cmluZycpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5iZS5hbignb2JqZWN0Jyk7XG4gICAqICAgICBleHBlY3QobnVsbCkudG8uYmUuYSgnbnVsbCcpO1xuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8uYmUuYW4oJ3VuZGVmaW5lZCcpO1xuICAgKlxuICAgKiAgICAgLy8gbGFuZ3VhZ2UgY2hhaW5cbiAgICogICAgIGV4cGVjdChmb28pLnRvLmJlLmFuLmluc3RhbmNlb2YoRm9vKTtcbiAgICpcbiAgICogQG5hbWUgYVxuICAgKiBAYWxpYXMgYW5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhbiAodHlwZSwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgYXJ0aWNsZSA9IH5bICdhJywgJ2UnLCAnaScsICdvJywgJ3UnIF0uaW5kZXhPZih0eXBlLmNoYXJBdCgwKSkgPyAnYW4gJyA6ICdhICc7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdHlwZSA9PT0gXy50eXBlKG9iailcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgJyArIGFydGljbGUgKyB0eXBlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSAnICsgYXJ0aWNsZSArIHR5cGVcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnYW4nLCBhbik7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2EnLCBhbik7XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZSh2YWx1ZSlcbiAgICpcbiAgICogVGhlIGBpbmNsdWRlYCBhbmQgYGNvbnRhaW5gIGFzc2VydGlvbnMgY2FuIGJlIHVzZWQgYXMgZWl0aGVyIHByb3BlcnR5XG4gICAqIGJhc2VkIGxhbmd1YWdlIGNoYWlucyBvciBhcyBtZXRob2RzIHRvIGFzc2VydCB0aGUgaW5jbHVzaW9uIG9mIGFuIG9iamVjdFxuICAgKiBpbiBhbiBhcnJheSBvciBhIHN1YnN0cmluZyBpbiBhIHN0cmluZy4gV2hlbiB1c2VkIGFzIGxhbmd1YWdlIGNoYWlucyxcbiAgICogdGhleSB0b2dnbGUgdGhlIGBjb250YWluYCBmbGFnIGZvciB0aGUgYGtleXNgIGFzc2VydGlvbi5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwyLDNdKS50by5pbmNsdWRlKDIpO1xuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5jb250YWluKCdmb28nKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogJ2JhcicsIGhlbGxvOiAndW5pdmVyc2UnIH0pLnRvLmluY2x1ZGUua2V5cygnZm9vJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVcbiAgICogQGFsaWFzIGNvbnRhaW5cbiAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfE51bWJlcn0gb2JqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IgKCkge1xuICAgIGZsYWcodGhpcywgJ2NvbnRhaW5zJywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmNsdWRlICh2YWwsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIGlmIChfLnR5cGUodmFsKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICghZmxhZyh0aGlzLCAnbmVnYXRlJykpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiB2YWwpIG5ldyBBc3NlcnRpb24ob2JqKS5wcm9wZXJ0eShrLCB2YWxba10pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc3Vic2V0ID0ge31cbiAgICAgIGZvciAodmFyIGsgaW4gdmFsKSBzdWJzZXRba10gPSBvYmpba11cbiAgICAgIHZhciBleHBlY3RlZCA9IF8uZXFsKHN1YnNldCwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV4cGVjdGVkID0gb2JqICYmIH5vYmouaW5kZXhPZih2YWwpXG4gICAgfVxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBleHBlY3RlZFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBpbmNsdWRlICcgKyBfLmluc3BlY3QodmFsKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaW5jbHVkZSAnICsgXy5pbnNwZWN0KHZhbCkpO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnaW5jbHVkZScsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnY29udGFpbicsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcblxuICAvKipcbiAgICogIyMjIC5va1xuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyB0cnV0aHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2V2ZXJ0aGluZycpLnRvLmJlLm9rO1xuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLm9rO1xuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5ub3QuYmUub2s7XG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5ub3QuYmUub2s7XG4gICAqICAgICBleHBlY3QobnVsbCkudG8ubm90LmJlLm9rO1xuICAgKlxuICAgKiBAbmFtZSBva1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ29rJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnV0aHknXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHN5Jyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnRydWVcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYHRydWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHRydWUpLnRvLmJlLnRydWU7XG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLnRydWU7XG4gICAqXG4gICAqIEBuYW1lIHRydWVcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCd0cnVlJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0cnVlID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnVlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmYWxzZSdcbiAgICAgICwgdGhpcy5uZWdhdGUgPyBmYWxzZSA6IHRydWVcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5mYWxzZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBgZmFsc2VgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5iZS5mYWxzZTtcbiAgICogICAgIGV4cGVjdCgwKS50by5ub3QuYmUuZmFsc2U7XG4gICAqXG4gICAqIEBuYW1lIGZhbHNlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZmFsc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZhbHNlID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmYWxzZSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdHJ1ZSdcbiAgICAgICwgdGhpcy5uZWdhdGUgPyB0cnVlIDogZmFsc2VcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5udWxsXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGBudWxsYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChudWxsKS50by5iZS5udWxsO1xuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkubm90LnRvLmJlLm51bGw7XG4gICAqXG4gICAqIEBuYW1lIG51bGxcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdudWxsJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBudWxsID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBudWxsJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgbnVsbCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC51bmRlZmluZWRcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5iZS51bmRlZmluZWQ7XG4gICAqICAgICBleHBlY3QobnVsbCkudG8ubm90LmJlLnVuZGVmaW5lZDtcbiAgICpcbiAgICogQG5hbWUgdW5kZWZpbmVkXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgndW5kZWZpbmVkJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB1bmRlZmluZWQgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHVuZGVmaW5lZCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIHVuZGVmaW5lZCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5leGlzdFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBuZWl0aGVyIGBudWxsYCBub3IgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgZm9vID0gJ2hpJ1xuICAgKiAgICAgICAsIGJhciA9IG51bGxcbiAgICogICAgICAgLCBiYXo7XG4gICAqXG4gICAqICAgICBleHBlY3QoZm9vKS50by5leGlzdDtcbiAgICogICAgIGV4cGVjdChiYXIpLnRvLm5vdC5leGlzdDtcbiAgICogICAgIGV4cGVjdChiYXopLnRvLm5vdC5leGlzdDtcbiAgICpcbiAgICogQG5hbWUgZXhpc3RcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdleGlzdCcsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbnVsbCAhPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBleGlzdCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGV4aXN0J1xuICAgICk7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqICMjIyAuZW1wdHlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQncyBsZW5ndGggaXMgYDBgLiBGb3IgYXJyYXlzLCBpdCBjaGVja3NcbiAgICogdGhlIGBsZW5ndGhgIHByb3BlcnR5LiBGb3Igb2JqZWN0cywgaXQgZ2V0cyB0aGUgY291bnQgb2ZcbiAgICogZW51bWVyYWJsZSBrZXlzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFtdKS50by5iZS5lbXB0eTtcbiAgICogICAgIGV4cGVjdCgnJykudG8uYmUuZW1wdHk7XG4gICAqICAgICBleHBlY3Qoe30pLnRvLmJlLmVtcHR5O1xuICAgKlxuICAgKiBAbmFtZSBlbXB0eVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2VtcHR5JywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBleHBlY3RlZCA9IG9iajtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikgfHwgJ3N0cmluZycgPT09IHR5cGVvZiBvYmplY3QpIHtcbiAgICAgIGV4cGVjdGVkID0gb2JqLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICBleHBlY3RlZCA9IE9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAhZXhwZWN0ZWRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZW1wdHknXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBlbXB0eSdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hcmd1bWVudHNcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYW4gYXJndW1lbnRzIG9iamVjdC5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIHRlc3QgKCkge1xuICAgKiAgICAgICBleHBlY3QoYXJndW1lbnRzKS50by5iZS5hcmd1bWVudHM7XG4gICAqICAgICB9XG4gICAqXG4gICAqIEBuYW1lIGFyZ3VtZW50c1xuICAgKiBAYWxpYXMgQXJndW1lbnRzXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNoZWNrQXJndW1lbnRzICgpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAnW29iamVjdCBBcmd1bWVudHNdJyA9PT0gdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhcmd1bWVudHMgYnV0IGdvdCAnICsgdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYXJndW1lbnRzJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2FyZ3VtZW50cycsIGNoZWNrQXJndW1lbnRzKTtcbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdBcmd1bWVudHMnLCBjaGVja0FyZ3VtZW50cyk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXF1YWwodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IGVxdWFsIChgPT09YCkgdG8gYHZhbHVlYC5cbiAgICogQWx0ZXJuYXRlbHksIGlmIHRoZSBgZGVlcGAgZmxhZyBpcyBzZXQsIGFzc2VydHMgdGhhdFxuICAgKiB0aGUgdGFyZ2V0IGlzIGRlZXBseSBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdoZWxsbycpLnRvLmVxdWFsKCdoZWxsbycpO1xuICAgKiAgICAgZXhwZWN0KDQyKS50by5lcXVhbCg0Mik7XG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmVxdWFsKHRydWUpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5ub3QuZXF1YWwoeyBmb286ICdiYXInIH0pO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5kZWVwLmVxdWFsKHsgZm9vOiAnYmFyJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZXF1YWxcbiAgICogQGFsaWFzIGVxdWFsc1xuICAgKiBAYWxpYXMgZXFcbiAgICogQGFsaWFzIGRlZXAuZXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRFcXVhbCAodmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RlZXAnKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZXFsKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHZhbCA9PT0gb2JqXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3tleHB9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlcXVhbCAje2V4cH0nXG4gICAgICAgICwgdmFsXG4gICAgICAgICwgdGhpcy5fb2JqXG4gICAgICAgICwgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcXVhbCcsIGFzc2VydEVxdWFsKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXF1YWxzJywgYXNzZXJ0RXF1YWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcScsIGFzc2VydEVxdWFsKTtcblxuICAvKipcbiAgICogIyMjIC5lcWwodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGRlZXBseSBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5lcWwoeyBmb286ICdiYXInIH0pO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5lcWwoWyAxLCAyLCAzIF0pO1xuICAgKlxuICAgKiBAbmFtZSBlcWxcbiAgICogQGFsaWFzIGVxbHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRFcWwob2JqLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgXy5lcWwob2JqLCBmbGFnKHRoaXMsICdvYmplY3QnKSlcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZGVlcGx5IGVxdWFsICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGRlZXBseSBlcXVhbCAje2V4cH0nXG4gICAgICAsIG9ialxuICAgICAgLCB0aGlzLl9vYmpcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcWwnLCBhc3NlcnRFcWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcWxzJywgYXNzZXJ0RXFsKTtcblxuICAvKipcbiAgICogIyMjIC5hYm92ZSh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZ3JlYXRlciB0aGFuIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMTApLnRvLmJlLmFib3ZlKDUpO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGxlbmd0aGAgdG9cbiAgICogYXNzZXJ0IGEgbWluaW11bSBsZW5ndGguIFRoZSBiZW5lZml0IGJlaW5nIGFcbiAgICogbW9yZSBpbmZvcm1hdGl2ZSBlcnJvciBtZXNzYWdlIHRoYW4gaWYgdGhlIGxlbmd0aFxuICAgKiB3YXMgc3VwcGxpZWQgZGlyZWN0bHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDIpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5hYm92ZSgyKTtcbiAgICpcbiAgICogQG5hbWUgYWJvdmVcbiAgICogQGFsaWFzIGd0XG4gICAqIEBhbGlhcyBncmVhdGVyVGhhblxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRBYm92ZSAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuID4gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgbGVuZ3RoIGFib3ZlICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICAgICwgbGVuXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPiBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYWJvdmUgJyArIG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBtb3N0ICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2Fib3ZlJywgYXNzZXJ0QWJvdmUpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdndCcsIGFzc2VydEFib3ZlKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3JlYXRlclRoYW4nLCBhc3NlcnRBYm92ZSk7XG5cbiAgLyoqXG4gICAqICMjIyAubGVhc3QodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEwKS50by5iZS5hdC5sZWFzdCgxMCk7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgbGVuZ3RoYCB0b1xuICAgKiBhc3NlcnQgYSBtaW5pbXVtIGxlbmd0aC4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGgub2YuYXQubGVhc3QoMik7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLm9mLmF0LmxlYXN0KDMpO1xuICAgKlxuICAgKiBAbmFtZSBsZWFzdFxuICAgKiBAYWxpYXMgZ3RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydExlYXN0IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPj0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYXQgbGVhc3QgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbGVhc3QgJyArIG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBiZWxvdyAnICsgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZWFzdCcsIGFzc2VydExlYXN0KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3RlJywgYXNzZXJ0TGVhc3QpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmJlbG93KHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBsZXNzIHRoYW4gYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg1KS50by5iZS5iZWxvdygxMCk7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgbGVuZ3RoYCB0b1xuICAgKiBhc3NlcnQgYSBtYXhpbXVtIGxlbmd0aC4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGguYmVsb3coNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLmJlbG93KDQpO1xuICAgKlxuICAgKiBAbmFtZSBiZWxvd1xuICAgKiBAYWxpYXMgbHRcbiAgICogQGFsaWFzIGxlc3NUaGFuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEJlbG93IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPCBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBiZWxvdyAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA8IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBiZWxvdyAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IGxlYXN0ICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2JlbG93JywgYXNzZXJ0QmVsb3cpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsdCcsIGFzc2VydEJlbG93KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbGVzc1RoYW4nLCBhc3NlcnRCZWxvdyk7XG5cbiAgLyoqXG4gICAqICMjIyAubW9zdCh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoNSkudG8uYmUuYXQubW9zdCg1KTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIG1heGltdW0gbGVuZ3RoLiBUaGUgYmVuZWZpdCBiZWluZyBhXG4gICAqIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSB0aGFuIGlmIHRoZSBsZW5ndGhcbiAgICogd2FzIHN1cHBsaWVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5vZi5hdC5tb3N0KDQpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5vZi5hdC5tb3N0KDMpO1xuICAgKlxuICAgKiBAbmFtZSBtb3N0XG4gICAqIEBhbGlhcyBsdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TW9zdCAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuIDw9IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIGF0IG1vc3QgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA8PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbW9zdCAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFib3ZlICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21vc3QnLCBhc3NlcnRNb3N0KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbHRlJywgYXNzZXJ0TW9zdCk7XG5cbiAgLyoqXG4gICAqICMjIyAud2l0aGluKHN0YXJ0LCBmaW5pc2gpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHdpdGhpbiBhIHJhbmdlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDcpLnRvLmJlLndpdGhpbig1LDEwKTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIGxlbmd0aCByYW5nZS4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGgud2l0aGluKDIsNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLndpdGhpbigyLDQpO1xuICAgKlxuICAgKiBAbmFtZSB3aXRoaW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IGxvd2VyYm91bmQgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmaW5pc2ggdXBwZXJib3VuZCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd3aXRoaW4nLCBmdW5jdGlvbiAoc3RhcnQsIGZpbmlzaCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHJhbmdlID0gc3RhcnQgKyAnLi4nICsgZmluaXNoO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuID49IHN0YXJ0ICYmIGxlbiA8PSBmaW5pc2hcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhIGxlbmd0aCB3aXRoaW4gJyArIHJhbmdlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPj0gc3RhcnQgJiYgb2JqIDw9IGZpbmlzaFxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgd2l0aGluICcgKyByYW5nZVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluc3RhbmNlb2YoY29uc3RydWN0b3IpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGFuIGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICB2YXIgVGVhID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5uYW1lID0gbmFtZTsgfVxuICAgKiAgICAgICAsIENoYWkgPSBuZXcgVGVhKCdjaGFpJyk7XG4gICAqXG4gICAqICAgICBleHBlY3QoQ2hhaSkudG8uYmUuYW4uaW5zdGFuY2VvZihUZWEpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5iZS5pbnN0YW5jZW9mKEFycmF5KTtcbiAgICpcbiAgICogQG5hbWUgaW5zdGFuY2VvZlxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhbGlhcyBpbnN0YW5jZU9mXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEluc3RhbmNlT2YgKGNvbnN0cnVjdG9yLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgbmFtZSA9IF8uZ2V0TmFtZShjb25zdHJ1Y3Rvcik7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcpIGluc3RhbmNlb2YgY29uc3RydWN0b3JcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJyArIG5hbWVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFuIGluc3RhbmNlIG9mICcgKyBuYW1lXG4gICAgKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbnN0YW5jZW9mJywgYXNzZXJ0SW5zdGFuY2VPZik7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2luc3RhbmNlT2YnLCBhc3NlcnRJbnN0YW5jZU9mKTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eShuYW1lLCBbdmFsdWVdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgYSBwcm9wZXJ0eSBgbmFtZWAsIG9wdGlvbmFsbHkgYXNzZXJ0aW5nIHRoYXRcbiAgICogdGhlIHZhbHVlIG9mIHRoYXQgcHJvcGVydHkgaXMgc3RyaWN0bHkgZXF1YWwgdG8gIGB2YWx1ZWAuXG4gICAqIElmIHRoZSBgZGVlcGAgZmxhZyBpcyBzZXQsIHlvdSBjYW4gdXNlIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXBcbiAgICogcmVmZXJlbmNlcyBpbnRvIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICpcbiAgICogICAgIC8vIHNpbXBsZSByZWZlcmVuY2luZ1xuICAgKiAgICAgdmFyIG9iaiA9IHsgZm9vOiAnYmFyJyB9O1xuICAgKiAgICAgZXhwZWN0KG9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZm9vJyk7XG4gICAqICAgICBleHBlY3Qob2JqKS50by5oYXZlLnByb3BlcnR5KCdmb28nLCAnYmFyJyk7XG4gICAqXG4gICAqICAgICAvLyBkZWVwIHJlZmVyZW5jaW5nXG4gICAqICAgICB2YXIgZGVlcE9iaiA9IHtcbiAgICogICAgICAgICBncmVlbjogeyB0ZWE6ICdtYXRjaGEnIH1cbiAgICogICAgICAgLCB0ZWFzOiBbICdjaGFpJywgJ21hdGNoYScsIHsgdGVhOiAna29uYWNoYScgfSBdXG4gICAqICAgICB9O1xuXG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCdncmVlbi50ZWEnLCAnbWF0Y2hhJyk7XG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCd0ZWFzWzFdJywgJ21hdGNoYScpO1xuICAgKiAgICAgZXhwZWN0KGRlZXBPYmopLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgndGVhc1syXS50ZWEnLCAna29uYWNoYScpO1xuICAgKlxuICAgKiBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IGFzIHRoZSBzdGFydGluZyBwb2ludCBvZiBhIGBkZWVwLnByb3BlcnR5YFxuICAgKiBhc3NlcnRpb24sIG9yIHRyYXZlcnNlIG5lc3RlZCBhcnJheXMuXG4gICAqXG4gICAqICAgICB2YXIgYXJyID0gW1xuICAgKiAgICAgICAgIFsgJ2NoYWknLCAnbWF0Y2hhJywgJ2tvbmFjaGEnIF1cbiAgICogICAgICAgLCBbIHsgdGVhOiAnY2hhaScgfVxuICAgKiAgICAgICAgICwgeyB0ZWE6ICdtYXRjaGEnIH1cbiAgICogICAgICAgICAsIHsgdGVhOiAna29uYWNoYScgfSBdXG4gICAqICAgICBdO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFycikudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCdbMF1bMV0nLCAnbWF0Y2hhJyk7XG4gICAqICAgICBleHBlY3QoYXJyKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ1sxXVsyXS50ZWEnLCAna29uYWNoYScpO1xuICAgKlxuICAgKiBGdXJ0aGVybW9yZSwgYHByb3BlcnR5YCBjaGFuZ2VzIHRoZSBzdWJqZWN0IG9mIHRoZSBhc3NlcnRpb25cbiAgICogdG8gYmUgdGhlIHZhbHVlIG9mIHRoYXQgcHJvcGVydHkgZnJvbSB0aGUgb3JpZ2luYWwgb2JqZWN0LiBUaGlzXG4gICAqIHBlcm1pdHMgZm9yIGZ1cnRoZXIgY2hhaW5hYmxlIGFzc2VydGlvbnMgb24gdGhhdCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIGV4cGVjdChvYmopLnRvLmhhdmUucHJvcGVydHkoJ2ZvbycpXG4gICAqICAgICAgIC50aGF0LmlzLmEoJ3N0cmluZycpO1xuICAgKiAgICAgZXhwZWN0KGRlZXBPYmopLnRvLmhhdmUucHJvcGVydHkoJ2dyZWVuJylcbiAgICogICAgICAgLnRoYXQuaXMuYW4oJ29iamVjdCcpXG4gICAqICAgICAgIC50aGF0LmRlZXAuZXF1YWxzKHsgdGVhOiAnbWF0Y2hhJyB9KTtcbiAgICogICAgIGV4cGVjdChkZWVwT2JqKS50by5oYXZlLnByb3BlcnR5KCd0ZWFzJylcbiAgICogICAgICAgLnRoYXQuaXMuYW4oJ2FycmF5JylcbiAgICogICAgICAgLndpdGguZGVlcC5wcm9wZXJ0eSgnWzJdJylcbiAgICogICAgICAgICAudGhhdC5kZWVwLmVxdWFscyh7IHRlYTogJ2tvbmFjaGEnIH0pO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVxuICAgKiBAYWxpYXMgZGVlcC5wcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQHJldHVybnMgdmFsdWUgb2YgcHJvcGVydHkgZm9yIGNoYWluaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Byb3BlcnR5JywgZnVuY3Rpb24gKG5hbWUsIHZhbCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG5cbiAgICB2YXIgZGVzY3JpcHRvciA9IGZsYWcodGhpcywgJ2RlZXAnKSA/ICdkZWVwIHByb3BlcnR5ICcgOiAncHJvcGVydHkgJ1xuICAgICAgLCBuZWdhdGUgPSBmbGFnKHRoaXMsICduZWdhdGUnKVxuICAgICAgLCBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCB2YWx1ZSA9IGZsYWcodGhpcywgJ2RlZXAnKVxuICAgICAgICA/IF8uZ2V0UGF0aFZhbHVlKG5hbWUsIG9iailcbiAgICAgICAgOiBvYmpbbmFtZV07XG5cbiAgICBpZiAobmVnYXRlICYmIHVuZGVmaW5lZCAhPT0gdmFsKSB7XG4gICAgICBpZiAodW5kZWZpbmVkID09PSB2YWx1ZSkge1xuICAgICAgICBtc2cgPSAobXNnICE9IG51bGwpID8gbXNnICsgJzogJyA6ICcnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnICsgXy5pbnNwZWN0KG9iaikgKyAnIGhhcyBubyAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHVuZGVmaW5lZCAhPT0gdmFsdWVcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKHVuZGVmaW5lZCAhPT0gdmFsKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICB2YWwgPT09IHZhbHVlXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpICsgJyBvZiAje2V4cH0sIGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9mICN7YWN0fSdcbiAgICAgICAgLCB2YWxcbiAgICAgICAgLCB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCB2YWx1ZSk7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqICMjIyAub3duUHJvcGVydHkobmFtZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaGFzIGFuIG93biBwcm9wZXJ0eSBgbmFtZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ3Rlc3QnKS50by5oYXZlLm93blByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICpcbiAgICogQG5hbWUgb3duUHJvcGVydHlcbiAgICogQGFsaWFzIGhhdmVPd25Qcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydE93blByb3BlcnR5IChuYW1lLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIG93biBwcm9wZXJ0eSAnICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIG93biBwcm9wZXJ0eSAnICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ293blByb3BlcnR5JywgYXNzZXJ0T3duUHJvcGVydHkpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdoYXZlT3duUHJvcGVydHknLCBhc3NlcnRPd25Qcm9wZXJ0eSk7XG5cbiAgLyoqXG4gICAqICMjIyAubGVuZ3RoKHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgIHByb3BlcnR5IGhhc1xuICAgKiB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGgoMyk7XG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmhhdmUubGVuZ3RoKDYpO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGFzIGEgY2hhaW4gcHJlY3Vyc29yIHRvIGEgdmFsdWVcbiAgICogY29tcGFyaXNvbiBmb3IgdGhlIGxlbmd0aCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGguYWJvdmUoMik7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDIpO1xuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5iZWxvdyg0KTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGguYmVsb3coNCk7XG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLndpdGhpbigyLDQpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC53aXRoaW4oMiw0KTtcbiAgICpcbiAgICogQG5hbWUgbGVuZ3RoXG4gICAqIEBhbGlhcyBsZW5ndGhPZlxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TGVuZ3RoQ2hhaW4gKCkge1xuICAgIGZsYWcodGhpcywgJ2RvTGVuZ3RoJywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRMZW5ndGggKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBsZW4gPT0gblxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIG9mICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggb2YgI3thY3R9J1xuICAgICAgLCBuXG4gICAgICAsIGxlblxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdsZW5ndGgnLCBhc3NlcnRMZW5ndGgsIGFzc2VydExlbmd0aENoYWluKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbGVuZ3RoT2YnLCBhc3NlcnRMZW5ndGgsIGFzc2VydExlbmd0aENoYWluKTtcblxuICAvKipcbiAgICogIyMjIC5tYXRjaChyZWdleHApXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IG1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLm1hdGNoKC9eZm9vLyk7XG4gICAqXG4gICAqIEBuYW1lIG1hdGNoXG4gICAqIEBwYXJhbSB7UmVnRXhwfSBSZWd1bGFyRXhwcmVzc2lvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21hdGNoJywgZnVuY3Rpb24gKHJlLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlLmV4ZWMob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBtYXRjaCAnICsgcmVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIG1hdGNoICcgKyByZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnN0cmluZyhzdHJpbmcpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgc3RyaW5nIHRhcmdldCBjb250YWlucyBhbm90aGVyIHN0cmluZy5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uaGF2ZS5zdHJpbmcoJ2JhcicpO1xuICAgKlxuICAgKiBAbmFtZSBzdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3N0cmluZycsIGZ1bmN0aW9uIChzdHIsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS5pcy5hKCdzdHJpbmcnKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB+b2JqLmluZGV4T2Yoc3RyKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBjb250YWluICcgKyBfLmluc3BlY3Qoc3RyKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgY29udGFpbiAnICsgXy5pbnNwZWN0KHN0cilcbiAgICApO1xuICB9KTtcblxuXG4gIC8qKlxuICAgKiAjIyMgLmtleXMoa2V5MSwgW2tleTJdLCBbLi4uXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaGFzIGV4YWN0bHkgdGhlIGdpdmVuIGtleXMsIG9yXG4gICAqIGFzc2VydHMgdGhlIGluY2x1c2lvbiBvZiBzb21lIGtleXMgd2hlbiB1c2luZyB0aGVcbiAgICogYGluY2x1ZGVgIG9yIGBjb250YWluYCBtb2RpZmllcnMuXG4gICAqXG4gICAqICAgICBleHBlY3QoeyBmb286IDEsIGJhcjogMiB9KS50by5oYXZlLmtleXMoWydmb28nLCAnYmFyJ10pO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAxLCBiYXI6IDIsIGJhejogMyB9KS50by5jb250YWluLmtleXMoJ2ZvbycsICdiYXInKTtcbiAgICpcbiAgICogQG5hbWUga2V5c1xuICAgKiBAYWxpYXMga2V5XG4gICAqIEBwYXJhbSB7U3RyaW5nLi4ufEFycmF5fSBrZXlzXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEtleXMgKGtleXMpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgc3RyXG4gICAgICAsIG9rID0gdHJ1ZTtcblxuICAgIGtleXMgPSBrZXlzIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgID8ga2V5c1xuICAgICAgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgaWYgKCFrZXlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdrZXlzIHJlcXVpcmVkJyk7XG5cbiAgICB2YXIgYWN0dWFsID0gT2JqZWN0LmtleXMob2JqKVxuICAgICAgLCBsZW4gPSBrZXlzLmxlbmd0aDtcblxuICAgIC8vIEluY2x1c2lvblxuICAgIG9rID0ga2V5cy5ldmVyeShmdW5jdGlvbihrZXkpe1xuICAgICAgcmV0dXJuIH5hY3R1YWwuaW5kZXhPZihrZXkpO1xuICAgIH0pO1xuXG4gICAgLy8gU3RyaWN0XG4gICAgaWYgKCFmbGFnKHRoaXMsICduZWdhdGUnKSAmJiAhZmxhZyh0aGlzLCAnY29udGFpbnMnKSkge1xuICAgICAgb2sgPSBvayAmJiBrZXlzLmxlbmd0aCA9PSBhY3R1YWwubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIEtleSBzdHJpbmdcbiAgICBpZiAobGVuID4gMSkge1xuICAgICAga2V5cyA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIHJldHVybiBfLmluc3BlY3Qoa2V5KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGxhc3QgPSBrZXlzLnBvcCgpO1xuICAgICAgc3RyID0ga2V5cy5qb2luKCcsICcpICsgJywgYW5kICcgKyBsYXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBfLmluc3BlY3Qoa2V5c1swXSk7XG4gICAgfVxuXG4gICAgLy8gRm9ybVxuICAgIHN0ciA9IChsZW4gPiAxID8gJ2tleXMgJyA6ICdrZXkgJykgKyBzdHI7XG5cbiAgICAvLyBIYXZlIC8gaW5jbHVkZVxuICAgIHN0ciA9IChmbGFnKHRoaXMsICdjb250YWlucycpID8gJ2NvbnRhaW4gJyA6ICdoYXZlICcpICsgc3RyO1xuXG4gICAgLy8gQXNzZXJ0aW9uXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG9rXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvICcgKyBzdHJcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90ICcgKyBzdHJcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgna2V5cycsIGFzc2VydEtleXMpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdrZXknLCBhc3NlcnRLZXlzKTtcblxuICAvKipcbiAgICogIyMjIC50aHJvdyhjb25zdHJ1Y3RvcilcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSBmdW5jdGlvbiB0YXJnZXQgd2lsbCB0aHJvdyBhIHNwZWNpZmljIGVycm9yLCBvciBzcGVjaWZpYyB0eXBlIG9mIGVycm9yXG4gICAqIChhcyBkZXRlcm1pbmVkIHVzaW5nIGBpbnN0YW5jZW9mYCksIG9wdGlvbmFsbHkgd2l0aCBhIFJlZ0V4cCBvciBzdHJpbmcgaW5jbHVzaW9uIHRlc3RcbiAgICogZm9yIHRoZSBlcnJvcidzIG1lc3NhZ2UuXG4gICAqXG4gICAqICAgICB2YXIgZXJyID0gbmV3IFJlZmVyZW5jZUVycm9yKCdUaGlzIGlzIGEgYmFkIGZ1bmN0aW9uLicpO1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH1cbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coUmVmZXJlbmNlRXJyb3IpO1xuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdyhFcnJvcik7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KC9iYWQgZnVuY3Rpb24vKTtcbiAgICogICAgIGV4cGVjdChmbikudG8ubm90LnRocm93KCdnb29kIGZ1bmN0aW9uJyk7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KFJlZmVyZW5jZUVycm9yLCAvYmFkIGZ1bmN0aW9uLyk7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KGVycik7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLm5vdC50aHJvdyhuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlLicpKTtcbiAgICpcbiAgICogUGxlYXNlIG5vdGUgdGhhdCB3aGVuIGEgdGhyb3cgZXhwZWN0YXRpb24gaXMgbmVnYXRlZCwgaXQgd2lsbCBjaGVjayBlYWNoXG4gICAqIHBhcmFtZXRlciBpbmRlcGVuZGVudGx5LCBzdGFydGluZyB3aXRoIGVycm9yIGNvbnN0cnVjdG9yIHR5cGUuIFRoZSBhcHByb3ByaWF0ZSB3YXlcbiAgICogdG8gY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYSB0eXBlIG9mIGVycm9yIGJ1dCBmb3IgYSBtZXNzYWdlIHRoYXQgZG9lcyBub3QgbWF0Y2hcbiAgICogaXMgdG8gdXNlIGBhbmRgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdyhSZWZlcmVuY2VFcnJvcilcbiAgICogICAgICAgIC5hbmQubm90LnRocm93KC9nb29kIGZ1bmN0aW9uLyk7XG4gICAqXG4gICAqIEBuYW1lIHRocm93XG4gICAqIEBhbGlhcyB0aHJvd3NcbiAgICogQGFsaWFzIFRocm93XG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBleHBlY3RlZCBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgKiBAcmV0dXJucyBlcnJvciBmb3IgY2hhaW5pbmcgKG51bGwgaWYgbm8gZXJyb3IpXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydFRocm93cyAoY29uc3RydWN0b3IsIGVyck1zZywgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLmlzLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICB2YXIgdGhyb3duID0gZmFsc2VcbiAgICAgICwgZGVzaXJlZEVycm9yID0gbnVsbFxuICAgICAgLCBuYW1lID0gbnVsbFxuICAgICAgLCB0aHJvd25FcnJvciA9IG51bGw7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZXJyTXNnID0gbnVsbDtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIFJlZ0V4cCB8fCAnc3RyaW5nJyA9PT0gdHlwZW9mIGNvbnN0cnVjdG9yKSkge1xuICAgICAgZXJyTXNnID0gY29uc3RydWN0b3I7XG4gICAgICBjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBkZXNpcmVkRXJyb3IgPSBjb25zdHJ1Y3RvcjtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgIGVyck1zZyA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5hbWUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGUubmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgaWYgKG5hbWUgPT09ICdFcnJvcicgJiYgY29uc3RydWN0b3IgIT09IEVycm9yKSB7XG4gICAgICAgIG5hbWUgPSAobmV3IGNvbnN0cnVjdG9yKCkpLm5hbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgb2JqKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBmaXJzdCwgY2hlY2sgZGVzaXJlZCBlcnJvclxuICAgICAgaWYgKGRlc2lyZWRFcnJvcikge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgIGVyciA9PT0gZGVzaXJlZEVycm9yXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICN7ZXhwfSdcbiAgICAgICAgICAsIChkZXNpcmVkRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGRlc2lyZWRFcnJvci50b1N0cmluZygpIDogZGVzaXJlZEVycm9yKVxuICAgICAgICAgICwgKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLnRvU3RyaW5nKCkgOiBlcnIpXG4gICAgICAgICk7XG5cbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIG5leHQsIGNoZWNrIGNvbnN0cnVjdG9yXG4gICAgICBpZiAoY29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvclxuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgI3tleHB9IGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAgICwgbmFtZVxuICAgICAgICAgICwgKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLnRvU3RyaW5nKCkgOiBlcnIpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFlcnJNc2cpIHtcbiAgICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBlcnIpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5leHQsIGNoZWNrIG1lc3NhZ2VcbiAgICAgIHZhciBtZXNzYWdlID0gJ29iamVjdCcgPT09IF8udHlwZShlcnIpICYmIFwibWVzc2FnZVwiIGluIGVyclxuICAgICAgICA/IGVyci5tZXNzYWdlXG4gICAgICAgIDogJycgKyBlcnI7XG5cbiAgICAgIGlmICgobWVzc2FnZSAhPSBudWxsKSAmJiBlcnJNc2cgJiYgZXJyTXNnIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgZXJyTXNnLmV4ZWMobWVzc2FnZSlcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yIG1hdGNoaW5nICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yIG5vdCBtYXRjaGluZyAje2V4cH0nXG4gICAgICAgICAgLCBlcnJNc2dcbiAgICAgICAgICAsIG1lc3NhZ2VcbiAgICAgICAgKTtcblxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAoKG1lc3NhZ2UgIT0gbnVsbCkgJiYgZXJyTXNnICYmICdzdHJpbmcnID09PSB0eXBlb2YgZXJyTXNnKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgfm1lc3NhZ2UuaW5kZXhPZihlcnJNc2cpXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyBlcnJvciBpbmNsdWRpbmcgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3Igbm90IGluY2x1ZGluZyAje2FjdH0nXG4gICAgICAgICAgLCBlcnJNc2dcbiAgICAgICAgICAsIG1lc3NhZ2VcbiAgICAgICAgKTtcblxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93biA9IHRydWU7XG4gICAgICAgIHRocm93bkVycm9yID0gZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhY3R1YWxseUdvdCA9ICcnXG4gICAgICAsIGV4cGVjdGVkVGhyb3duID0gbmFtZSAhPT0gbnVsbFxuICAgICAgICA/IG5hbWVcbiAgICAgICAgOiBkZXNpcmVkRXJyb3JcbiAgICAgICAgICA/ICcje2V4cH0nIC8vXy5pbnNwZWN0KGRlc2lyZWRFcnJvcilcbiAgICAgICAgICA6ICdhbiBlcnJvcic7XG5cbiAgICBpZiAodGhyb3duKSB7XG4gICAgICBhY3R1YWxseUdvdCA9ICcgYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0aHJvd24gPT09IHRydWVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgJyArIGV4cGVjdGVkVGhyb3duICsgYWN0dWFsbHlHb3RcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICcgKyBleHBlY3RlZFRocm93biArIGFjdHVhbGx5R290XG4gICAgICAsIChkZXNpcmVkRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGRlc2lyZWRFcnJvci50b1N0cmluZygpIDogZGVzaXJlZEVycm9yKVxuICAgICAgLCAodGhyb3duRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHRocm93bkVycm9yLnRvU3RyaW5nKCkgOiB0aHJvd25FcnJvcilcbiAgICApO1xuXG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgdGhyb3duRXJyb3IpO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Rocm93JywgYXNzZXJ0VGhyb3dzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGhyb3dzJywgYXNzZXJ0VGhyb3dzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnVGhyb3cnLCBhc3NlcnRUaHJvd3MpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnJlc3BvbmRUbyhtZXRob2QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgb2JqZWN0IG9yIGNsYXNzIHRhcmdldCB3aWxsIHJlc3BvbmQgdG8gYSBtZXRob2QuXG4gICAqXG4gICAqICAgICBLbGFzcy5wcm90b3R5cGUuYmFyID0gZnVuY3Rpb24oKXt9O1xuICAgKiAgICAgZXhwZWN0KEtsYXNzKS50by5yZXNwb25kVG8oJ2JhcicpO1xuICAgKiAgICAgZXhwZWN0KG9iaikudG8ucmVzcG9uZFRvKCdiYXInKTtcbiAgICpcbiAgICogVG8gY2hlY2sgaWYgYSBjb25zdHJ1Y3RvciB3aWxsIHJlc3BvbmQgdG8gYSBzdGF0aWMgZnVuY3Rpb24sXG4gICAqIHNldCB0aGUgYGl0c2VsZmAgZmxhZy5cbiAgICpcbiAgICogICAgIEtsYXNzLmJheiA9IGZ1bmN0aW9uKCl7fTtcbiAgICogICAgIGV4cGVjdChLbGFzcykuaXRzZWxmLnRvLnJlc3BvbmRUbygnYmF6Jyk7XG4gICAqXG4gICAqIEBuYW1lIHJlc3BvbmRUb1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncmVzcG9uZFRvJywgZnVuY3Rpb24gKG1ldGhvZCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGl0c2VsZiA9IGZsYWcodGhpcywgJ2l0c2VsZicpXG4gICAgICAsIGNvbnRleHQgPSAoJ2Z1bmN0aW9uJyA9PT0gXy50eXBlKG9iaikgJiYgIWl0c2VsZilcbiAgICAgICAgPyBvYmoucHJvdG90eXBlW21ldGhvZF1cbiAgICAgICAgOiBvYmpbbWV0aG9kXTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAnZnVuY3Rpb24nID09PSB0eXBlb2YgY29udGV4dFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byByZXNwb25kIHRvICcgKyBfLmluc3BlY3QobWV0aG9kKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgcmVzcG9uZCB0byAnICsgXy5pbnNwZWN0KG1ldGhvZClcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5pdHNlbGZcbiAgICpcbiAgICogU2V0cyB0aGUgYGl0c2VsZmAgZmxhZywgbGF0ZXIgdXNlZCBieSB0aGUgYHJlc3BvbmRUb2AgYXNzZXJ0aW9uLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gRm9vKCkge31cbiAgICogICAgIEZvby5iYXIgPSBmdW5jdGlvbigpIHt9XG4gICAqICAgICBGb28ucHJvdG90eXBlLmJheiA9IGZ1bmN0aW9uKCkge31cbiAgICpcbiAgICogICAgIGV4cGVjdChGb28pLml0c2VsZi50by5yZXNwb25kVG8oJ2JhcicpO1xuICAgKiAgICAgZXhwZWN0KEZvbykuaXRzZWxmLm5vdC50by5yZXNwb25kVG8oJ2JheicpO1xuICAgKlxuICAgKiBAbmFtZSBpdHNlbGZcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdpdHNlbGYnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnaXRzZWxmJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnNhdGlzZnkobWV0aG9kKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBwYXNzZXMgYSBnaXZlbiB0cnV0aCB0ZXN0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLnNhdGlzZnkoZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gPiAwOyB9KTtcbiAgICpcbiAgICogQG5hbWUgc2F0aXNmeVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtYXRjaGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc2F0aXNmeScsIGZ1bmN0aW9uIChtYXRjaGVyLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG1hdGNoZXIob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBzYXRpc2Z5ICcgKyBfLm9iakRpc3BsYXkobWF0Y2hlcilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHNhdGlzZnknICsgXy5vYmpEaXNwbGF5KG1hdGNoZXIpXG4gICAgICAsIHRoaXMubmVnYXRlID8gZmFsc2UgOiB0cnVlXG4gICAgICAsIG1hdGNoZXIob2JqKVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmNsb3NlVG8oZXhwZWN0ZWQsIGRlbHRhKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCBgZXhwZWN0ZWRgLCB0byB3aXRoaW4gYSArLy0gYGRlbHRhYCByYW5nZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmJlLmNsb3NlVG8oMSwgMC41KTtcbiAgICpcbiAgICogQG5hbWUgY2xvc2VUb1xuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnY2xvc2VUbycsIGZ1bmN0aW9uIChleHBlY3RlZCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgTWF0aC5hYnMob2JqIC0gZXhwZWN0ZWQpIDw9IGRlbHRhXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGNsb3NlIHRvICcgKyBleHBlY3RlZCArICcgKy8tICcgKyBkZWx0YVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgY2xvc2UgdG8gJyArIGV4cGVjdGVkICsgJyArLy0gJyArIGRlbHRhXG4gICAgKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gaXNTdWJzZXRPZihzdWJzZXQsIHN1cGVyc2V0KSB7XG4gICAgcmV0dXJuIHN1YnNldC5ldmVyeShmdW5jdGlvbihlbGVtKSB7XG4gICAgICByZXR1cm4gc3VwZXJzZXQuaW5kZXhPZihlbGVtKSAhPT0gLTE7XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm1lbWJlcnMoc2V0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIHN1cGVyc2V0IG9mIGBzZXRgLFxuICAgKiBvciB0aGF0IHRoZSB0YXJnZXQgYW5kIGBzZXRgIGhhdmUgdGhlIHNhbWUgbWVtYmVycy5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUubWVtYmVycyhbMywgMl0pO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8ubm90LmluY2x1ZGUubWVtYmVycyhbMywgMiwgOF0pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KFs0LCAyXSkudG8uaGF2ZS5tZW1iZXJzKFsyLCA0XSk7XG4gICAqICAgICBleHBlY3QoWzUsIDJdKS50by5ub3QuaGF2ZS5tZW1iZXJzKFs1LCAyLCAxXSk7XG4gICAqXG4gICAqIEBuYW1lIG1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbWVtYmVycycsIGZ1bmN0aW9uIChzdWJzZXQsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIG5ldyBBc3NlcnRpb24ob2JqKS50by5iZS5hbignYXJyYXknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1YnNldCkudG8uYmUuYW4oJ2FycmF5Jyk7XG5cbiAgICBpZiAoZmxhZyh0aGlzLCAnY29udGFpbnMnKSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGlzU3Vic2V0T2Yoc3Vic2V0LCBvYmopXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYSBzdXBlcnNldCBvZiAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGEgc3VwZXJzZXQgb2YgI3thY3R9J1xuICAgICAgICAsIG9ialxuICAgICAgICAsIHN1YnNldFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgaXNTdWJzZXRPZihvYmosIHN1YnNldCkgJiYgaXNTdWJzZXRPZihzdWJzZXQsIG9iailcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgYXMgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgYXMgI3thY3R9J1xuICAgICAgICAsIG9ialxuICAgICAgICAsIHN1YnNldFxuICAgICk7XG4gIH0pO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgdXRpbCkge1xuXG4gIC8qIVxuICAgKiBDaGFpIGRlcGVuZGVuY2llcy5cbiAgICovXG5cbiAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uXG4gICAgLCBmbGFnID0gdXRpbC5mbGFnO1xuXG4gIC8qIVxuICAgKiBNb2R1bGUgZXhwb3J0LlxuICAgKi9cblxuICAvKipcbiAgICogIyMjIGFzc2VydChleHByZXNzaW9uLCBtZXNzYWdlKVxuICAgKlxuICAgKiBXcml0ZSB5b3VyIG93biB0ZXN0IGV4cHJlc3Npb25zLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0KCdmb28nICE9PSAnYmFyJywgJ2ZvbyBpcyBub3QgYmFyJyk7XG4gICAqICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShbXSksICdlbXB0eSBhcnJheXMgYXJlIGFycmF5cycpO1xuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBleHByZXNzaW9uIHRvIHRlc3QgZm9yIHRydXRoaW5lc3NcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgdG8gZGlzcGxheSBvbiBlcnJvclxuICAgKiBAbmFtZSBhc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgdmFyIGFzc2VydCA9IGNoYWkuYXNzZXJ0ID0gZnVuY3Rpb24gKGV4cHJlc3MsIGVycm1zZykge1xuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihudWxsKTtcbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgZXhwcmVzc1xuICAgICAgLCBlcnJtc2dcbiAgICAgICwgJ1sgbmVnYXRpb24gbWVzc2FnZSB1bmF2YWlsYWJsZSBdJ1xuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0sIFtvcGVyYXRvcl0pXG4gICAqXG4gICAqIFRocm93IGEgZmFpbHVyZS4gTm9kZS5qcyBgYXNzZXJ0YCBtb2R1bGUtY29tcGF0aWJsZS5cbiAgICpcbiAgICogQG5hbWUgZmFpbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5mYWlsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ2Fzc2VydC5mYWlsKCknO1xuICAgIHRocm93IG5ldyBjaGFpLkFzc2VydGlvbkVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICwgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAsIG9wZXJhdG9yOiBvcGVyYXRvclxuICAgIH0sIGFzc2VydC5mYWlsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5vayhvYmplY3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIHRydXRoeS5cbiAgICpcbiAgICogICAgIGFzc2VydC5vaygnZXZlcnl0aGluZycsICdldmVyeXRoaW5nIGlzIG9rJyk7XG4gICAqICAgICBhc3NlcnQub2soZmFsc2UsICd0aGlzIHdpbGwgZmFpbCcpO1xuICAgKlxuICAgKiBAbmFtZSBva1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3QgdG8gdGVzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQub2sgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS5pcy5vaztcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RPayhvYmplY3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIGZhbHN5LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE9rKCdldmVyeXRoaW5nJywgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqICAgICBhc3NlcnQubm90T2soZmFsc2UsICd0aGlzIHdpbGwgcGFzcycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RPa1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3QgdG8gdGVzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90T2sgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS5pcy5ub3Qub2s7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIG5vbi1zdHJpY3QgZXF1YWxpdHkgKGA9PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmVxdWFsKDMsICczJywgJz09IGNvZXJjZXMgdmFsdWVzIHRvIHN0cmluZ3MnKTtcbiAgICpcbiAgICogQG5hbWUgZXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKTtcblxuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHAgPT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3thY3R9J1xuICAgICAgLCBleHBcbiAgICAgICwgYWN0XG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgbm9uLXN0cmljdCBpbmVxdWFsaXR5IChgIT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RFcXVhbCgzLCA0LCAndGhlc2UgbnVtYmVycyBhcmUgbm90IGVxdWFsJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihhY3QsIG1zZyk7XG5cbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgZXhwICE9IGZsYWcodGVzdCwgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlcXVhbCAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGVxdWFsICN7YWN0fSdcbiAgICAgICwgZXhwXG4gICAgICAsIGFjdFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHN0cmljdCBlcXVhbGl0eSAoYD09PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIHRydWUsICd0aGVzZSBib29sZWFucyBhcmUgc3RyaWN0bHkgZXF1YWwnKTtcbiAgICpcbiAgICogQG5hbWUgc3RyaWN0RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZykudG8uZXF1YWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgc3RyaWN0IGluZXF1YWxpdHkgKGAhPT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RTdHJpY3RFcXVhbCgzLCAnMycsICdubyBjb2VyY2lvbiBmb3Igc3RyaWN0IGVxdWFsaXR5Jyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFN0cmljdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLm5vdC5lcXVhbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgYWN0dWFsYCBpcyBkZWVwbHkgZXF1YWwgdG8gYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwRXF1YWwoeyB0ZWE6ICdncmVlbicgfSwgeyB0ZWE6ICdncmVlbicgfSk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZykudG8uZXFsKGV4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0IHRoYXQgYGFjdHVhbGAgaXMgbm90IGRlZXBseSBlcXVhbCB0byBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBFcXVhbCh7IHRlYTogJ2dyZWVuJyB9LCB7IHRlYTogJ2phc21pbmUnIH0pO1xuICAgKlxuICAgKiBAbmFtZSBub3REZWVwRXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLm5vdC5lcWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1RydWUodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgdHJ1ZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWFTZXJ2ZWQgPSB0cnVlO1xuICAgKiAgICAgYXNzZXJ0LmlzVHJ1ZSh0ZWFTZXJ2ZWQsICd0aGUgdGVhIGhhcyBiZWVuIHNlcnZlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc1RydWVcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzVHJ1ZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLmlzWyd0cnVlJ107XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNGYWxzZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBmYWxzZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWFTZXJ2ZWQgPSBmYWxzZTtcbiAgICogICAgIGFzc2VydC5pc0ZhbHNlKHRlYVNlcnZlZCwgJ25vIHRlYSB5ZXQ/IGhtbS4uLicpO1xuICAgKlxuICAgKiBAbmFtZSBpc0ZhbHNlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0ZhbHNlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykuaXNbJ2ZhbHNlJ107XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOdWxsKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG51bGwuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOdWxsKGVyciwgJ3RoZXJlIHdhcyBubyBlcnJvcicpO1xuICAgKlxuICAgKiBAbmFtZSBpc051bGxcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTnVsbCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmVxdWFsKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90TnVsbCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgbnVsbC5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAndGFzdHkgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3ROdWxsKHRlYSwgJ2dyZWF0LCB0aW1lIGZvciB0ZWEhJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90TnVsbFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3ROdWxsID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmVxdWFsKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzVW5kZWZpbmVkKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYTtcbiAgICogICAgIGFzc2VydC5pc1VuZGVmaW5lZCh0ZWEsICdubyB0ZWEgZGVmaW5lZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc1VuZGVmaW5lZFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNVbmRlZmluZWQgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5lcXVhbCh1bmRlZmluZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRGVmaW5lZCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ2N1cCBvZiBjaGFpJztcbiAgICogICAgIGFzc2VydC5pc0RlZmluZWQodGVhLCAndGVhIGhhcyBiZWVuIGRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNEZWZpbmVkXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0RlZmluZWQgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuZXF1YWwodW5kZWZpbmVkKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Z1bmN0aW9uKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBzZXJ2ZVRlYSgpIHsgcmV0dXJuICdjdXAgb2YgdGVhJzsgfTtcbiAgICogICAgIGFzc2VydC5pc0Z1bmN0aW9uKHNlcnZlVGVhLCAnZ3JlYXQsIHdlIGNhbiBoYXZlIHRlYSBub3cnKTtcbiAgICpcbiAgICogQG5hbWUgaXNGdW5jdGlvblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ2Z1bmN0aW9uJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RGdW5jdGlvbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgICAgdmFyIHNlcnZlVGVhID0gWyAnaGVhdCcsICdwb3VyJywgJ3NpcCcgXTtcbiAgICogICAgIGFzc2VydC5pc05vdEZ1bmN0aW9uKHNlcnZlVGVhLCAnZ3JlYXQsIHdlIGhhdmUgbGlzdGVkIHRoZSBzdGVwcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEoJ2Z1bmN0aW9uJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNPYmplY3QodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYW4gb2JqZWN0IChhcyByZXZlYWxlZCBieVxuICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2ApLlxuICAgKlxuICAgKiAgICAgdmFyIHNlbGVjdGlvbiA9IHsgbmFtZTogJ0NoYWknLCBzZXJ2ZTogJ3dpdGggc3BpY2VzJyB9O1xuICAgKiAgICAgYXNzZXJ0LmlzT2JqZWN0KHNlbGVjdGlvbiwgJ3RlYSBzZWxlY3Rpb24gaXMgYW4gb2JqZWN0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzT2JqZWN0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc09iamVjdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90T2JqZWN0KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGFuIG9iamVjdC5cbiAgICpcbiAgICogICAgIHZhciBzZWxlY3Rpb24gPSAnY2hhaSdcbiAgICogICAgIGFzc2VydC5pc09iamVjdChzZWxlY3Rpb24sICd0ZWEgc2VsZWN0aW9uIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICogICAgIGFzc2VydC5pc09iamVjdChudWxsLCAnbnVsbCBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90T2JqZWN0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE9iamVjdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0FycmF5KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGFuIGFycmF5LlxuICAgKlxuICAgKiAgICAgdmFyIG1lbnUgPSBbICdncmVlbicsICdjaGFpJywgJ29vbG9uZycgXTtcbiAgICogICAgIGFzc2VydC5pc0FycmF5KG1lbnUsICd3aGF0IGtpbmQgb2YgdGVhIGRvIHdlIHdhbnQ/Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQXJyYXlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQXJyYXkgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hbignYXJyYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEFycmF5KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGFuIGFycmF5LlxuICAgKlxuICAgKiAgICAgdmFyIG1lbnUgPSAnZ3JlZW58Y2hhaXxvb2xvbmcnO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90QXJyYXkobWVudSwgJ3doYXQga2luZCBvZiB0ZWEgZG8gd2Ugd2FudD8nKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RBcnJheVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RBcnJheSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hbignYXJyYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1N0cmluZyh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciB0ZWFPcmRlciA9ICdjaGFpJztcbiAgICogICAgIGFzc2VydC5pc1N0cmluZyh0ZWFPcmRlciwgJ29yZGVyIHBsYWNlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc1N0cmluZ1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdzdHJpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdFN0cmluZyh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciB0ZWFPcmRlciA9IDQ7XG4gICAqICAgICBhc3NlcnQuaXNOb3RTdHJpbmcodGVhT3JkZXIsICdvcmRlciBwbGFjZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RTdHJpbmdcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90U3RyaW5nID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEoJ3N0cmluZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTnVtYmVyKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgbnVtYmVyLlxuICAgKlxuICAgKiAgICAgdmFyIGN1cHMgPSAyO1xuICAgKiAgICAgYXNzZXJ0LmlzTnVtYmVyKGN1cHMsICdob3cgbWFueSBjdXBzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTnVtYmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOdW1iZXIgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdudW1iZXInKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE51bWJlcih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIG51bWJlci5cbiAgICpcbiAgICogICAgIHZhciBjdXBzID0gJzIgY3VwcyBwbGVhc2UnO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90TnVtYmVyKGN1cHMsICdob3cgbWFueSBjdXBzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90TnVtYmVyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE51bWJlciA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdudW1iZXInKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Jvb2xlYW4odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBib29sZWFuLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVJlYWR5ID0gdHJ1ZVxuICAgKiAgICAgICAsIHRlYVNlcnZlZCA9IGZhbHNlO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzQm9vbGVhbih0ZWFSZWFkeSwgJ2lzIHRoZSB0ZWEgcmVhZHknKTtcbiAgICogICAgIGFzc2VydC5pc0Jvb2xlYW4odGVhU2VydmVkLCAnaGFzIHRlYSBiZWVuIHNlcnZlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc0Jvb2xlYW5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ2Jvb2xlYW4nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEJvb2xlYW4odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBib29sZWFuLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVJlYWR5ID0gJ3llcCdcbiAgICogICAgICAgLCB0ZWFTZXJ2ZWQgPSAnbm9wZSc7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3RCb29sZWFuKHRlYVJlYWR5LCAnaXMgdGhlIHRlYSByZWFkeScpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90Qm9vbGVhbih0ZWFTZXJ2ZWQsICdoYXMgdGVhIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90Qm9vbGVhblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RCb29sZWFuID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEoJ2Jvb2xlYW4nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC50eXBlT2YodmFsdWUsIG5hbWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAncyB0eXBlIGlzIGBuYW1lYCwgYXMgZGV0ZXJtaW5lZCBieVxuICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAqXG4gICAqICAgICBhc3NlcnQudHlwZU9mKHsgdGVhOiAnY2hhaScgfSwgJ29iamVjdCcsICd3ZSBoYXZlIGFuIG9iamVjdCcpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZihbJ2NoYWknLCAnamFzbWluZSddLCAnYXJyYXknLCAnd2UgaGF2ZSBhbiBhcnJheScpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZigndGVhJywgJ3N0cmluZycsICd3ZSBoYXZlIGEgc3RyaW5nJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKC90ZWEvLCAncmVnZXhwJywgJ3dlIGhhdmUgYSByZWd1bGFyIGV4cHJlc3Npb24nKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YobnVsbCwgJ251bGwnLCAnd2UgaGF2ZSBhIG51bGwnKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YodW5kZWZpbmVkLCAndW5kZWZpbmVkJywgJ3dlIGhhdmUgYW4gdW5kZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIHR5cGVPZlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQudHlwZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYSh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RUeXBlT2YodmFsdWUsIG5hbWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAncyB0eXBlIGlzIF9ub3RfIGBuYW1lYCwgYXMgZGV0ZXJtaW5lZCBieVxuICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90VHlwZU9mKCd0ZWEnLCAnbnVtYmVyJywgJ3N0cmluZ3MgYXJlIG5vdCBudW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFR5cGVPZlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZW9mIG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFR5cGVPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmluc3RhbmNlT2Yob2JqZWN0LCBjb25zdHJ1Y3RvciwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgLlxuICAgKlxuICAgKiAgICAgdmFyIFRlYSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMubmFtZSA9IG5hbWU7IH1cbiAgICogICAgICAgLCBjaGFpID0gbmV3IFRlYSgnY2hhaScpO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmluc3RhbmNlT2YoY2hhaSwgVGVhLCAnY2hhaSBpcyBhbiBpbnN0YW5jZSBvZiB0ZWEnKTtcbiAgICpcbiAgICogQG5hbWUgaW5zdGFuY2VPZlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbnN0YW5jZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuaW5zdGFuY2VPZih0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RJbnN0YW5jZU9mKG9iamVjdCwgY29uc3RydWN0b3IsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBgdmFsdWVgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgLlxuICAgKlxuICAgKiAgICAgdmFyIFRlYSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMubmFtZSA9IG5hbWU7IH1cbiAgICogICAgICAgLCBjaGFpID0gbmV3IFN0cmluZygnY2hhaScpO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEluc3RhbmNlT2YoY2hhaSwgVGVhLCAnY2hhaSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgdGVhJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluc3RhbmNlT2ZcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5zdGFuY2VPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5pbnN0YW5jZU9mKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGhheXN0YWNrYCBpbmNsdWRlcyBgbmVlZGxlYC4gV29ya3NcbiAgICogZm9yIHN0cmluZ3MgYW5kIGFycmF5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKCdmb29iYXInLCAnYmFyJywgJ2Zvb2JhciBjb250YWlucyBzdHJpbmcgXCJiYXJcIicpO1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoWyAxLCAyLCAzIF0sIDMsICdhcnJheSBjb250YWlucyB2YWx1ZScpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2cpLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgZG9lcyBub3QgaW5jbHVkZSBgbmVlZGxlYC4gV29ya3NcbiAgICogZm9yIHN0cmluZ3MgYW5kIGFycmF5cy5cbiAgICppXG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZSgnZm9vYmFyJywgJ2JheicsICdzdHJpbmcgbm90IGluY2x1ZGUgc3Vic3RyaW5nJyk7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZShbIDEsIDIsIDMgXSwgNCwgJ2FycmF5IG5vdCBpbmNsdWRlIGNvbnRhaW4gdmFsdWUnKTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5jbHVkZVxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnKS5ub3QuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm1hdGNoKHZhbHVlLCByZWdleHAsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm1hdGNoKCdmb29iYXInLCAvXmZvby8sICdyZWdleHAgbWF0Y2hlcycpO1xuICAgKlxuICAgKiBAbmFtZSBtYXRjaFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5tYXRjaCA9IGZ1bmN0aW9uIChleHAsIHJlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnKS50by5tYXRjaChyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90TWF0Y2godmFsdWUsIHJlZ2V4cCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBkb2VzIG5vdCBtYXRjaCB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE1hdGNoKCdmb29iYXInLCAvXmZvby8sICdyZWdleHAgZG9lcyBub3QgbWF0Y2gnKTtcbiAgICpcbiAgICogQG5hbWUgbm90TWF0Y2hcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90TWF0Y2ggPSBmdW5jdGlvbiAoZXhwLCByZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZykudG8ubm90Lm1hdGNoKHJlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYScpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQucHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90UHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAnY29mZmVlJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLm5vdC5oYXZlLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCB3aGljaCBjYW4gYmUgYVxuICAgKiBzdHJpbmcgdXNpbmcgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgZGVlcCByZWZlcmVuY2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCwgd2hpY2hcbiAgICogY2FuIGJlIGEgc3RyaW5nIHVzaW5nIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXAgcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBQcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEub29sb25nJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBQcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQucHJvcGVydHlWYWwoeyB0ZWE6ICdpcyBnb29kJyB9LCAndGVhJywgJ2lzIGdvb2QnKTtcbiAgICpcbiAgICogQG5hbWUgcHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHlOb3RWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAsIGJ1dCB3aXRoIGEgdmFsdWVcbiAgICogZGlmZmVyZW50IGZyb20gdGhhdCBnaXZlbiBieSBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5Tm90VmFsKHsgdGVhOiAnaXMgZ29vZCcgfSwgJ3RlYScsICdpcyBiYWQnKTtcbiAgICpcbiAgICogQG5hbWUgcHJvcGVydHlOb3RWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnByb3BlcnR5Tm90VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5ub3QuaGF2ZS5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBkZWVwXG4gICAqIHJlZmVyZW5jZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLmdyZWVuJywgJ21hdGNoYScpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5kZWVwLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFByb3BlcnR5Tm90VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCBidXQgd2l0aCBhIHZhbHVlXG4gICAqIGRpZmZlcmVudCBmcm9tIHRoYXQgZ2l2ZW4gYnkgYHZhbHVlYC4gYHByb3BlcnR5YCBjYW4gdXNlIGRvdC0gYW5kXG4gICAqIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXAgcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBQcm9wZXJ0eU5vdFZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEuZ3JlZW4nLCAna29uYWNoYScpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlOb3RWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eU5vdFZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmxlbmd0aE9mKG9iamVjdCwgbGVuZ3RoLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBgbGVuZ3RoYCBwcm9wZXJ0eSB3aXRoIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZihbMSwyLDNdLCAzLCAnYXJyYXkgaGFzIGxlbmd0aCBvZiAzJyk7XG4gICAqICAgICBhc3NlcnQubGVuZ3RoT2YoJ2Zvb2JhcicsIDUsICdzdHJpbmcgaGFzIGxlbmd0aCBvZiA2Jyk7XG4gICAqXG4gICAqIEBuYW1lIGxlbmd0aE9mXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5sZW5ndGhPZiA9IGZ1bmN0aW9uIChleHAsIGxlbiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZykudG8uaGF2ZS5sZW5ndGgobGVuKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC50aHJvd3MoZnVuY3Rpb24sIFtjb25zdHJ1Y3Rvci9zdHJpbmcvcmVnZXhwXSwgW3N0cmluZy9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgKiBgY29uc3RydWN0b3JgLCBvciBhbHRlcm5hdGVseSB0aGF0IGl0IHdpbGwgdGhyb3cgYW4gZXJyb3Igd2l0aCBtZXNzYWdlXG4gICAqIG1hdGNoaW5nIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnRocm93KGZuLCAnZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yJyk7XG4gICAqICAgICBhc3NlcnQudGhyb3coZm4sIC9mdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3IvKTtcbiAgICogICAgIGFzc2VydC50aHJvdyhmbiwgUmVmZXJlbmNlRXJyb3IpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93KGZuLCBSZWZlcmVuY2VFcnJvciwgJ2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvcicpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93KGZuLCBSZWZlcmVuY2VFcnJvciwgL2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvci8pO1xuICAgKlxuICAgKiBAbmFtZSB0aHJvd3NcbiAgICogQGFsaWFzIHRocm93XG4gICAqIEBhbGlhcyBUaHJvd1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuVGhyb3cgPSBmdW5jdGlvbiAoZm4sIGVycnQsIGVycnMsIG1zZykge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGVycnQgfHwgZXJydCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgZXJycyA9IGVycnQ7XG4gICAgICBlcnJ0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYXNzZXJ0RXJyID0gbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by5UaHJvdyhlcnJ0LCBlcnJzKTtcbiAgICByZXR1cm4gZmxhZyhhc3NlcnRFcnIsICdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90VGhyb3coZnVuY3Rpb24sIFtjb25zdHJ1Y3Rvci9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgX25vdF8gdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgKiBgY29uc3RydWN0b3JgLCBvciBhbHRlcm5hdGVseSB0aGF0IGl0IHdpbGwgbm90IHRocm93IGFuIGVycm9yIHdpdGggbWVzc2FnZVxuICAgKiBtYXRjaGluZyBgcmVnZXhwYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIEVycm9yLCAnZnVuY3Rpb24gZG9lcyBub3QgdGhyb3cnKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdFRocm93XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbiAoZm4sIHR5cGUsIG1zZykge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHR5cGUpIHtcbiAgICAgIG1zZyA9IHR5cGU7XG4gICAgICB0eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLm5vdC5UaHJvdyh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5vcGVyYXRvcih2YWwxLCBvcGVyYXRvciwgdmFsMiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBDb21wYXJlcyB0d28gdmFsdWVzIHVzaW5nIGBvcGVyYXRvcmAuXG4gICAqXG4gICAqICAgICBhc3NlcnQub3BlcmF0b3IoMSwgJzwnLCAyLCAnZXZlcnl0aGluZyBpcyBvaycpO1xuICAgKiAgICAgYXNzZXJ0Lm9wZXJhdG9yKDEsICc+JywgMiwgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqXG4gICAqIEBuYW1lIG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbDFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm9wZXJhdG9yID0gZnVuY3Rpb24gKHZhbCwgb3BlcmF0b3IsIHZhbDIsIG1zZykge1xuICAgIGlmICghflsnPT0nLCAnPT09JywgJz4nLCAnPj0nLCAnPCcsICc8PScsICchPScsICchPT0nXS5pbmRleE9mKG9wZXJhdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wZXJhdG9yIFwiJyArIG9wZXJhdG9yICsgJ1wiJyk7XG4gICAgfVxuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihldmFsKHZhbCArIG9wZXJhdG9yICsgdmFsMiksIG1zZyk7XG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIHRydWUgPT09IGZsYWcodGVzdCwgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAnICsgdXRpbC5pbnNwZWN0KHZhbCkgKyAnIHRvIGJlICcgKyBvcGVyYXRvciArICcgJyArIHV0aWwuaW5zcGVjdCh2YWwyKVxuICAgICAgLCAnZXhwZWN0ZWQgJyArIHV0aWwuaW5zcGVjdCh2YWwpICsgJyB0byBub3QgYmUgJyArIG9wZXJhdG9yICsgJyAnICsgdXRpbC5pbnNwZWN0KHZhbDIpICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuY2xvc2VUbyhhY3R1YWwsIGV4cGVjdGVkLCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCBgZXhwZWN0ZWRgLCB0byB3aXRoaW4gYSArLy0gYGRlbHRhYCByYW5nZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5jbG9zZVRvKDEuNSwgMSwgMC41LCAnbnVtYmVycyBhcmUgY2xvc2UnKTtcbiAgICpcbiAgICogQG5hbWUgY2xvc2VUb1xuICAgKiBAcGFyYW0ge051bWJlcn0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNsb3NlVG8gPSBmdW5jdGlvbiAoYWN0LCBleHAsIGRlbHRhLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5iZS5jbG9zZVRvKGV4cCwgZGVsdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnNhbWVNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGhhdmUgdGhlIHNhbWUgbWVtYmVycy5cbiAgICogT3JkZXIgaXMgbm90IHRha2VuIGludG8gYWNjb3VudC5cbiAgICpcbiAgICogICAgIGFzc2VydC5zYW1lTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAxLCAzIF0sICdzYW1lIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgc2FtZU1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZykudG8uaGF2ZS5zYW1lLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpcyBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgLlxuICAgKiBPcmRlciBpcyBub3QgdGFrZW4gaW50byBhY2NvdW50LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDEgXSwgJ2luY2x1ZGUgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZykudG8uaW5jbHVkZS5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKiFcbiAgICogVW5kb2N1bWVudGVkIC8gdW50ZXN0ZWRcbiAgICovXG5cbiAgYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUub2s7XG4gIH07XG5cbiAgLyohXG4gICAqIEFsaWFzZXMuXG4gICAqL1xuXG4gIChmdW5jdGlvbiBhbGlhcyhuYW1lLCBhcyl7XG4gICAgYXNzZXJ0W2FzXSA9IGFzc2VydFtuYW1lXTtcbiAgICByZXR1cm4gYWxpYXM7XG4gIH0pXG4gICgnVGhyb3cnLCAndGhyb3cnKVxuICAoJ1Rocm93JywgJ3Rocm93cycpO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcbiAgY2hhaS5leHBlY3QgPSBmdW5jdGlvbiAodmFsLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBjaGFpLkFzc2VydGlvbih2YWwsIG1lc3NhZ2UpO1xuICB9O1xufTtcblxuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgdXRpbCkge1xuICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb247XG5cbiAgZnVuY3Rpb24gbG9hZFNob3VsZCAoKSB7XG4gICAgLy8gbW9kaWZ5IE9iamVjdC5wcm90b3R5cGUgdG8gaGF2ZSBgc2hvdWxkYFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCAnc2hvdWxkJyxcbiAgICAgIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9jaGFpL2lzc3Vlcy84NjogdGhpcyBtYWtlc1xuICAgICAgICAgIC8vIGB3aGF0ZXZlci5zaG91bGQgPSBzb21lVmFsdWVgIGFjdHVhbGx5IHNldCBgc29tZVZhbHVlYCwgd2hpY2ggaXNcbiAgICAgICAgICAvLyBlc3BlY2lhbGx5IHVzZWZ1bCBmb3IgYGdsb2JhbC5zaG91bGQgPSByZXF1aXJlKCdjaGFpJykuc2hvdWxkKClgLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGhhdmUgdG8gdXNlIFtbRGVmaW5lUHJvcGVydHldXSBpbnN0ZWFkIG9mIFtbUHV0XV1cbiAgICAgICAgICAvLyBzaW5jZSBvdGhlcndpc2Ugd2Ugd291bGQgdHJpZ2dlciB0aGlzIHZlcnkgc2V0dGVyIVxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2hvdWxkJywge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICwgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU3RyaW5nIHx8IHRoaXMgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHRoaXMuY29uc3RydWN0b3IodGhpcykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcyBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHRoaXMgPT0gdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdmFyIHNob3VsZCA9IHt9O1xuXG4gICAgc2hvdWxkLmVxdWFsID0gZnVuY3Rpb24gKHZhbDEsIHZhbDIsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwxLCBtc2cpLnRvLmVxdWFsKHZhbDIpO1xuICAgIH07XG5cbiAgICBzaG91bGQuVGhyb3cgPSBmdW5jdGlvbiAoZm4sIGVycnQsIGVycnMsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by5UaHJvdyhlcnJ0LCBlcnJzKTtcbiAgICB9O1xuXG4gICAgc2hvdWxkLmV4aXN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5leGlzdDtcbiAgICB9XG5cbiAgICAvLyBuZWdhdGlvblxuICAgIHNob3VsZC5ub3QgPSB7fVxuXG4gICAgc2hvdWxkLm5vdC5lcXVhbCA9IGZ1bmN0aW9uICh2YWwxLCB2YWwyLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsMSwgbXNnKS50by5ub3QuZXF1YWwodmFsMik7XG4gICAgfTtcblxuICAgIHNob3VsZC5ub3QuVGhyb3cgPSBmdW5jdGlvbiAoZm4sIGVycnQsIGVycnMsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by5ub3QuVGhyb3coZXJydCwgZXJycyk7XG4gICAgfTtcblxuICAgIHNob3VsZC5ub3QuZXhpc3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5leGlzdDtcbiAgICB9XG5cbiAgICBzaG91bGRbJ3Rocm93J10gPSBzaG91bGRbJ1Rocm93J107XG4gICAgc2hvdWxkLm5vdFsndGhyb3cnXSA9IHNob3VsZC5ub3RbJ1Rocm93J107XG5cbiAgICByZXR1cm4gc2hvdWxkO1xuICB9O1xuXG4gIGNoYWkuc2hvdWxkID0gbG9hZFNob3VsZDtcbiAgY2hhaS5TaG91bGQgPSBsb2FkU2hvdWxkO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGFkZENoYWluaW5nTWV0aG9kIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgdHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKiFcbiAqIE1vZHVsZSB2YXJpYWJsZXNcbiAqL1xuXG4vLyBDaGVjayB3aGV0aGVyIGBfX3Byb3RvX19gIGlzIHN1cHBvcnRlZFxudmFyIGhhc1Byb3RvU3VwcG9ydCA9ICdfX3Byb3RvX18nIGluIE9iamVjdDtcblxuLy8gV2l0aG91dCBgX19wcm90b19fYCBzdXBwb3J0LCB0aGlzIG1vZHVsZSB3aWxsIG5lZWQgdG8gYWRkIHByb3BlcnRpZXMgdG8gYSBmdW5jdGlvbi5cbi8vIEhvd2V2ZXIsIHNvbWUgRnVuY3Rpb24ucHJvdG90eXBlIG1ldGhvZHMgY2Fubm90IGJlIG92ZXJ3cml0dGVuLFxuLy8gYW5kIHRoZXJlIHNlZW1zIG5vIGVhc3kgY3Jvc3MtcGxhdGZvcm0gd2F5IHRvIGRldGVjdCB0aGVtIChAc2VlIGNoYWlqcy9jaGFpL2lzc3Vlcy82OSkuXG52YXIgZXhjbHVkZU5hbWVzID0gL14oPzpsZW5ndGh8bmFtZXxhcmd1bWVudHN8Y2FsbGVyKSQvO1xuXG4vLyBDYWNoZSBgRnVuY3Rpb25gIHByb3BlcnRpZXNcbnZhciBjYWxsICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLFxuICAgIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vKipcbiAqICMjIyBhZGRDaGFpbmFibGVNZXRob2QgKGN0eCwgbmFtZSwgbWV0aG9kLCBjaGFpbmluZ0JlaGF2aW9yKVxuICpcbiAqIEFkZHMgYSBtZXRob2QgdG8gYW4gb2JqZWN0LCBzdWNoIHRoYXQgdGhlIG1ldGhvZCBjYW4gYWxzbyBiZSBjaGFpbmVkLlxuICpcbiAqICAgICB1dGlscy5hZGRDaGFpbmFibGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZm9vJywgZnVuY3Rpb24gKHN0cikge1xuICogICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iaikudG8uYmUuZXF1YWwoc3RyKTtcbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnZm9vJywgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICpcbiAqIFRoZSByZXN1bHQgY2FuIHRoZW4gYmUgdXNlZCBhcyBib3RoIGEgbWV0aG9kIGFzc2VydGlvbiwgZXhlY3V0aW5nIGJvdGggYG1ldGhvZGAgYW5kXG4gKiBgY2hhaW5pbmdCZWhhdmlvcmAsIG9yIGFzIGEgbGFuZ3VhZ2UgY2hhaW4sIHdoaWNoIG9ubHkgZXhlY3V0ZXMgYGNoYWluaW5nQmVoYXZpb3JgLlxuICpcbiAqICAgICBleHBlY3QoZm9vU3RyKS50by5iZS5mb28oJ2JhcicpO1xuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvby5lcXVhbCgnZm9vJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIG1ldGhvZCBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIGBuYW1lYCwgd2hlbiBjYWxsZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoYWluaW5nQmVoYXZpb3IgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkXG4gKiBAbmFtZSBhZGRDaGFpbmFibGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgaWYgKHR5cGVvZiBjaGFpbmluZ0JlaGF2aW9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hhaW5pbmdCZWhhdmlvciA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgfVxuXG4gIHZhciBjaGFpbmFibGVCZWhhdmlvciA9IHtcbiAgICAgIG1ldGhvZDogbWV0aG9kXG4gICAgLCBjaGFpbmluZ0JlaGF2aW9yOiBjaGFpbmluZ0JlaGF2aW9yXG4gIH07XG5cbiAgLy8gc2F2ZSB0aGUgbWV0aG9kcyBzbyB3ZSBjYW4gb3ZlcndyaXRlIHRoZW0gbGF0ZXIsIGlmIHdlIG5lZWQgdG8uXG4gIGlmICghY3R4Ll9fbWV0aG9kcykge1xuICAgIGN0eC5fX21ldGhvZHMgPSB7fTtcbiAgfVxuICBjdHguX19tZXRob2RzW25hbWVdID0gY2hhaW5hYmxlQmVoYXZpb3I7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgbmFtZSxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdmFyIGFzc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVc2UgYF9fcHJvdG9fX2AgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChoYXNQcm90b1N1cHBvcnQpIHtcbiAgICAgICAgICAvLyBJbmhlcml0IGFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIG9iamVjdCBieSByZXBsYWNpbmcgdGhlIGBGdW5jdGlvbmAgcHJvdG90eXBlXG4gICAgICAgICAgdmFyIHByb3RvdHlwZSA9IGFzc2VydC5fX3Byb3RvX18gPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGBjYWxsYCBhbmQgYGFwcGx5YCBtZXRob2RzIGZyb20gYEZ1bmN0aW9uYFxuICAgICAgICAgIHByb3RvdHlwZS5jYWxsID0gY2FsbDtcbiAgICAgICAgICBwcm90b3R5cGUuYXBwbHkgPSBhcHBseTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHJlZGVmaW5lIGFsbCBwcm9wZXJ0aWVzIChzbG93ISlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGFzc2VydGVyTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjdHgpO1xuICAgICAgICAgIGFzc2VydGVyTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoYXNzZXJ0ZXJOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWV4Y2x1ZGVOYW1lcy50ZXN0KGFzc2VydGVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgdmFyIHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdHgsIGFzc2VydGVyTmFtZSk7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhc3NlcnQsIGFzc2VydGVyTmFtZSwgcGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNmZXJGbGFncyh0aGlzLCBhc3NlcnQpO1xuICAgICAgICByZXR1cm4gYXNzZXJ0O1xuICAgICAgfVxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGFkZE1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmFkZE1ldGhvZCAoY3R4LCBuYW1lLCBtZXRob2QpXG4gKlxuICogQWRkcyBhIG1ldGhvZCB0byB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmVxdWFsKHN0cik7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvbygnYmFyJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIG1ldGhvZCBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lIGFkZE1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIG1ldGhvZCkge1xuICBjdHhbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gIH07XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gYWRkUHJvcGVydHkgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIGFkZFByb3BlcnR5IChjdHgsIG5hbWUsIGdldHRlcilcbiAqXG4gKiBBZGRzIGEgcHJvcGVydHkgdG8gdGhlIHByb3RvdHlwZSBvZiBhbiBvYmplY3QuXG4gKlxuICogICAgIHV0aWxzLmFkZFByb3BlcnR5KGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmluc3RhbmNlb2YoRm9vKTtcbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmJlLmZvbztcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB0byB3aGljaCB0aGUgcHJvcGVydHkgaXMgYWRkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHByb3BlcnR5IHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lIGFkZFByb3BlcnR5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGN0eCwgbmFtZSwgZ2V0dGVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIG5hbWUsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGdldHRlci5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgfVxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGZsYWcgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIGZsYWcob2JqZWN0ICxrZXksIFt2YWx1ZV0pXG4gKlxuICogR2V0IG9yIHNldCBhIGZsYWcgdmFsdWUgb24gYW4gb2JqZWN0LiBJZiBhXG4gKiB2YWx1ZSBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHNldCwgZWxzZSBpdCB3aWxsXG4gKiByZXR1cm4gdGhlIGN1cnJlbnRseSBzZXQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgaWZcbiAqIHRoZSB2YWx1ZSBpcyBub3Qgc2V0LlxuICpcbiAqICAgICB1dGlscy5mbGFnKHRoaXMsICdmb28nLCAnYmFyJyk7IC8vIHNldHRlclxuICogICAgIHV0aWxzLmZsYWcodGhpcywgJ2ZvbycpOyAvLyBnZXR0ZXIsIHJldHVybnMgYGJhcmBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIChvcHRpb25hbClcbiAqIEBuYW1lIGZsYWdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICB2YXIgZmxhZ3MgPSBvYmouX19mbGFncyB8fCAob2JqLl9fZmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBmbGFnc1trZXldID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZsYWdzW2tleV07XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRBY3R1YWwgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyBnZXRBY3R1YWwob2JqZWN0LCBbYWN0dWFsXSlcbiAqXG4gKiBSZXR1cm5zIHRoZSBgYWN0dWFsYCB2YWx1ZSBmb3IgYW4gQXNzZXJ0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAoY29uc3RydWN0ZWQgQXNzZXJ0aW9uKVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgYXJndW1lbnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBhcmdzKSB7XG4gIHZhciBhY3R1YWwgPSBhcmdzWzRdO1xuICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBhY3R1YWwgPyBhY3R1YWwgOiBvYmouX29iajtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldEVudW1lcmFibGVQcm9wZXJ0aWVzKG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LFxuICogaW5oZXJpdGVkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAbmFtZSBnZXRFbnVtZXJhYmxlUHJvcGVydGllc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBtZXNzYWdlIGNvbXBvc2l0aW9uIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRhbmNpZXNcbiAqL1xuXG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpXG4gICwgZ2V0QWN0dWFsID0gcmVxdWlyZSgnLi9nZXRBY3R1YWwnKVxuICAsIGluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKVxuICAsIG9iakRpc3BsYXkgPSByZXF1aXJlKCcuL29iakRpc3BsYXknKTtcblxuLyoqXG4gKiAjIyMgLmdldE1lc3NhZ2Uob2JqZWN0LCBtZXNzYWdlLCBuZWdhdGVNZXNzYWdlKVxuICpcbiAqIENvbnN0cnVjdCB0aGUgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiBmbGFnc1xuICogYW5kIHRlbXBsYXRlIHRhZ3MuIFRlbXBsYXRlIHRhZ3Mgd2lsbCByZXR1cm5cbiAqIGEgc3RyaW5naWZpZWQgaW5zcGVjdGlvbiBvZiB0aGUgb2JqZWN0IHJlZmVyZW5jZWQuXG4gKlxuICogTWVzc2FnZSB0ZW1wbGF0ZSB0YWdzOlxuICogLSBgI3t0aGlzfWAgY3VycmVudCBhc3NlcnRlZCBvYmplY3RcbiAqIC0gYCN7YWN0fWAgYWN0dWFsIHZhbHVlXG4gKiAtIGAje2V4cH1gIGV4cGVjdGVkIHZhbHVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAoY29uc3RydWN0ZWQgQXNzZXJ0aW9uKVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgYXJndW1lbnRzXG4gKiBAbmFtZSBnZXRNZXNzYWdlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgYXJncykge1xuICB2YXIgbmVnYXRlID0gZmxhZyhvYmosICduZWdhdGUnKVxuICAgICwgdmFsID0gZmxhZyhvYmosICdvYmplY3QnKVxuICAgICwgZXhwZWN0ZWQgPSBhcmdzWzNdXG4gICAgLCBhY3R1YWwgPSBnZXRBY3R1YWwob2JqLCBhcmdzKVxuICAgICwgbXNnID0gbmVnYXRlID8gYXJnc1syXSA6IGFyZ3NbMV1cbiAgICAsIGZsYWdNc2cgPSBmbGFnKG9iaiwgJ21lc3NhZ2UnKTtcblxuICBtc2cgPSBtc2cgfHwgJyc7XG4gIG1zZyA9IG1zZ1xuICAgIC5yZXBsYWNlKC8je3RoaXN9L2csIG9iakRpc3BsYXkodmFsKSlcbiAgICAucmVwbGFjZSgvI3thY3R9L2csIG9iakRpc3BsYXkoYWN0dWFsKSlcbiAgICAucmVwbGFjZSgvI3tleHB9L2csIG9iakRpc3BsYXkoZXhwZWN0ZWQpKTtcblxuICByZXR1cm4gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnICsgbXNnIDogbXNnO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldE5hbWUgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyBnZXROYW1lKGZ1bmMpXG4gKlxuICogR2V0cyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uLCBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGEgZnVuY3Rpb24gKHVzdWFsbHkgYSBjb25zdHJ1Y3RvcilcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIGlmIChmdW5jLm5hbWUpIHJldHVybiBmdW5jLm5hbWU7XG5cbiAgdmFyIG1hdGNoID0gL15cXHM/ZnVuY3Rpb24gKFteKF0qKVxcKC8uZXhlYyhmdW5jKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdID8gbWF0Y2hbMV0gOiBcIlwiO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldFBhdGhWYWx1ZSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbG9naWNhbHBhcmFkb3gvZmlsdHJcbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRQYXRoVmFsdWUocGF0aCwgb2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgdmFsdWVzIGluIGFuXG4gKiBvYmplY3QgZ2l2ZW4gYSBzdHJpbmcgcGF0aC5cbiAqXG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgcHJvcDE6IHtcbiAqICAgICAgICAgICAgIGFycjogWydhJywgJ2InLCAnYyddXG4gKiAgICAgICAgICAgLCBzdHI6ICdIZWxsbydcbiAqICAgICAgICAgfVxuICogICAgICAgLCBwcm9wMjoge1xuICogICAgICAgICAgICAgYXJyOiBbIHsgbmVzdGVkOiAnVW5pdmVyc2UnIH0gXVxuICogICAgICAgICAgICwgc3RyOiAnSGVsbG8gYWdhaW4hJ1xuICogICAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgd291bGQgYmUgdGhlIHJlc3VsdHMuXG4gKlxuICogICAgIGdldFBhdGhWYWx1ZSgncHJvcDEuc3RyJywgb2JqKTsgLy8gSGVsbG9cbiAqICAgICBnZXRQYXRoVmFsdWUoJ3Byb3AxLmF0dFsyXScsIG9iaik7IC8vIGJcbiAqICAgICBnZXRQYXRoVmFsdWUoJ3Byb3AyLmFyclswXS5uZXN0ZWQnLCBvYmopOyAvLyBVbml2ZXJzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSB2YWx1ZSBvciBgdW5kZWZpbmVkYFxuICogQG5hbWUgZ2V0UGF0aFZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciBnZXRQYXRoVmFsdWUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXRoLCBvYmopIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aChwYXRoKTtcbiAgcmV0dXJuIF9nZXRQYXRoVmFsdWUocGFyc2VkLCBvYmopO1xufTtcblxuLyohXG4gKiAjIyBwYXJzZVBhdGgocGF0aClcbiAqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCB0byBwYXJzZSBzdHJpbmcgb2JqZWN0XG4gKiBwYXRocy4gVXNlIGluIGNvbmp1bmN0aW9uIHdpdGggYF9nZXRQYXRoVmFsdWVgLlxuICpcbiAqICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aCgnbXlvYmplY3QucHJvcGVydHkuc3VicHJvcCcpO1xuICpcbiAqICMjIyBQYXRoczpcbiAqXG4gKiAqIENhbiBiZSBhcyBuZWFyIGluZmluaXRlbHkgZGVlcCBhbmQgbmVzdGVkXG4gKiAqIEFycmF5cyBhcmUgYWxzbyB2YWxpZCB1c2luZyB0aGUgZm9ybWFsIGBteW9iamVjdC5kb2N1bWVudFszXS5wcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBhcnNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIHZhciBzdHIgPSBwYXRoLnJlcGxhY2UoL1xcWy9nLCAnLlsnKVxuICAgICwgcGFydHMgPSBzdHIubWF0Y2goLyhcXFxcXFwufFteLl0rPykrL2cpO1xuICByZXR1cm4gcGFydHMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByZSA9IC9cXFsoXFxkKylcXF0kL1xuICAgICAgLCBtQXJyID0gcmUuZXhlYyh2YWx1ZSlcbiAgICBpZiAobUFycikgcmV0dXJuIHsgaTogcGFyc2VGbG9hdChtQXJyWzFdKSB9O1xuICAgIGVsc2UgcmV0dXJuIHsgcDogdmFsdWUgfTtcbiAgfSk7XG59O1xuXG4vKiFcbiAqICMjIF9nZXRQYXRoVmFsdWUocGFyc2VkLCBvYmopXG4gKlxuICogSGVscGVyIGNvbXBhbmlvbiBmdW5jdGlvbiBmb3IgYC5wYXJzZVBhdGhgIHRoYXQgcmV0dXJuc1xuICogdGhlIHZhbHVlIGxvY2F0ZWQgYXQgdGhlIHBhcnNlZCBhZGRyZXNzLlxuICpcbiAqICAgICAgdmFyIHZhbHVlID0gZ2V0UGF0aFZhbHVlKHBhcnNlZCwgb2JqKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyc2VkIGRlZmluaXRpb24gZnJvbSBgcGFyc2VQYXRoYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gc2VhcmNoIGFnYWluc3RcbiAqIEByZXR1cm5zIHtPYmplY3R8VW5kZWZpbmVkfSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX2dldFBhdGhWYWx1ZSAocGFyc2VkLCBvYmopIHtcbiAgdmFyIHRtcCA9IG9ialxuICAgICwgcmVzO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnNlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtpXTtcbiAgICBpZiAodG1wKSB7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBwYXJ0LnApXG4gICAgICAgIHRtcCA9IHRtcFtwYXJ0LnBdO1xuICAgICAgZWxzZSBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBwYXJ0LmkpXG4gICAgICAgIHRtcCA9IHRtcFtwYXJ0LmldO1xuICAgICAgaWYgKGkgPT0gKGwgLSAxKSkgcmVzID0gdG1wO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0UHJvcGVydGllcyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldFByb3BlcnRpZXMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LCBlbnVtZXJhYmxlIG9yIG5vdCxcbiAqIGluaGVyaXRlZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge0FycmF5fVxuICogQG5hbWUgZ2V0UHJvcGVydGllc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFByb3BlcnRpZXMob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdWJqZWN0KTtcblxuICBmdW5jdGlvbiBhZGRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgIGlmIChyZXN1bHQuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xKSB7XG4gICAgICByZXN1bHQucHVzaChwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHN1YmplY3QpO1xuICB3aGlsZSAocHJvdG8gIT09IG51bGwpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZm9yRWFjaChhZGRQcm9wZXJ0eSk7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExIEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNYWluIGV4cG9ydHNcbiAqL1xuXG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qIVxuICogdGVzdCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50ZXN0ID0gcmVxdWlyZSgnLi90ZXN0Jyk7XG5cbi8qIVxuICogdHlwZSB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50eXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbi8qIVxuICogbWVzc2FnZSB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5nZXRNZXNzYWdlID0gcmVxdWlyZSgnLi9nZXRNZXNzYWdlJyk7XG5cbi8qIVxuICogYWN0dWFsIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmdldEFjdHVhbCA9IHJlcXVpcmUoJy4vZ2V0QWN0dWFsJyk7XG5cbi8qIVxuICogSW5zcGVjdCB1dGlsXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0ID0gcmVxdWlyZSgnLi9pbnNwZWN0Jyk7XG5cbi8qIVxuICogT2JqZWN0IERpc3BsYXkgdXRpbFxuICovXG5cbmV4cG9ydHMub2JqRGlzcGxheSA9IHJlcXVpcmUoJy4vb2JqRGlzcGxheScpO1xuXG4vKiFcbiAqIEZsYWcgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG4vKiFcbiAqIEZsYWcgdHJhbnNmZXJyaW5nIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLnRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyohXG4gKiBEZWVwIGVxdWFsIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmVxbCA9IHJlcXVpcmUoJ2RlZXAtZXFsJyk7XG5cbi8qIVxuICogRGVlcCBwYXRoIHZhbHVlXG4gKi9cblxuZXhwb3J0cy5nZXRQYXRoVmFsdWUgPSByZXF1aXJlKCcuL2dldFBhdGhWYWx1ZScpO1xuXG4vKiFcbiAqIEZ1bmN0aW9uIG5hbWVcbiAqL1xuXG5leHBvcnRzLmdldE5hbWUgPSByZXF1aXJlKCcuL2dldE5hbWUnKTtcblxuLyohXG4gKiBhZGQgUHJvcGVydHlcbiAqL1xuXG5leHBvcnRzLmFkZFByb3BlcnR5ID0gcmVxdWlyZSgnLi9hZGRQcm9wZXJ0eScpO1xuXG4vKiFcbiAqIGFkZCBNZXRob2RcbiAqL1xuXG5leHBvcnRzLmFkZE1ldGhvZCA9IHJlcXVpcmUoJy4vYWRkTWV0aG9kJyk7XG5cbi8qIVxuICogb3ZlcndyaXRlIFByb3BlcnR5XG4gKi9cblxuZXhwb3J0cy5vdmVyd3JpdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vb3ZlcndyaXRlUHJvcGVydHknKTtcblxuLyohXG4gKiBvdmVyd3JpdGUgTWV0aG9kXG4gKi9cblxuZXhwb3J0cy5vdmVyd3JpdGVNZXRob2QgPSByZXF1aXJlKCcuL292ZXJ3cml0ZU1ldGhvZCcpO1xuXG4vKiFcbiAqIEFkZCBhIGNoYWluYWJsZSBtZXRob2RcbiAqL1xuXG5leHBvcnRzLmFkZENoYWluYWJsZU1ldGhvZCA9IHJlcXVpcmUoJy4vYWRkQ2hhaW5hYmxlTWV0aG9kJyk7XG5cbi8qIVxuICogT3ZlcndyaXRlIGNoYWluYWJsZSBtZXRob2RcbiAqL1xuXG5leHBvcnRzLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCA9IHJlcXVpcmUoJy4vb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kJyk7XG5cbiIsIi8vIFRoaXMgaXMgKGFsbW9zdCkgZGlyZWN0bHkgZnJvbSBOb2RlLmpzIHV0aWxzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvYmxvYi9mOGMzMzVkMGNhZjQ3ZjE2ZDMxNDEzZjg5YWEyOGVkYTM4NzhlM2FhL2xpYi91dGlsLmpzXG5cbnZhciBnZXROYW1lID0gcmVxdWlyZSgnLi9nZXROYW1lJyk7XG52YXIgZ2V0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZ2V0UHJvcGVydGllcycpO1xudmFyIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9nZXRFbnVtZXJhYmxlUHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluc3BlY3Q7XG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvd0hpZGRlbiBGbGFnIHRoYXQgc2hvd3MgaGlkZGVuIChub3QgZW51bWVyYWJsZSlcbiAqICAgIHByb3BlcnRpZXMgb2Ygb2JqZWN0cy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aCBEZXB0aCBpbiB3aGljaCB0byBkZXNjZW5kIGluIG9iamVjdC4gRGVmYXVsdCBpcyAyLlxuICogQHBhcmFtIHtCb29sZWFufSBjb2xvcnMgRmxhZyB0byB0dXJuIG9uIEFOU0kgZXNjYXBlIGNvZGVzIHRvIGNvbG9yIHRoZVxuICogICAgb3V0cHV0LiBEZWZhdWx0IGlzIGZhbHNlIChubyBjb2xvcmluZykuXG4gKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKSB7XG4gIHZhciBjdHggPSB7XG4gICAgc2hvd0hpZGRlbjogc2hvd0hpZGRlbixcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHI7IH1cbiAgfTtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCAodHlwZW9mIGRlcHRoID09PSAndW5kZWZpbmVkJyA/IDIgOiBkZXB0aCkpO1xufVxuXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDQ0MTI4L1xudmFyIGdldE91dGVySFRNTCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgaWYgKCdvdXRlckhUTUwnIGluIGVsZW1lbnQpIHJldHVybiBlbGVtZW50Lm91dGVySFRNTDtcbiAgdmFyIG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG4gIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdfJyk7XG4gIHZhciBlbGVtUHJvdG8gPSAod2luZG93LkhUTUxFbGVtZW50IHx8IHdpbmRvdy5FbGVtZW50KS5wcm90b3R5cGU7XG4gIHZhciB4bWxTZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcbiAgdmFyIGh0bWw7XG4gIGlmIChkb2N1bWVudC54bWxWZXJzaW9uKSB7XG4gICAgcmV0dXJuIHhtbFNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQuY2xvbmVOb2RlKGZhbHNlKSk7XG4gICAgaHRtbCA9IGNvbnRhaW5lci5pbm5lckhUTUwucmVwbGFjZSgnPjwnLCAnPicgKyBlbGVtZW50LmlubmVySFRNTCArICc8Jyk7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgIHJldHVybiBodG1sO1xuICB9XG59O1xuXG4vLyBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGEgRE9NIGVsZW1lbnQuXG52YXIgaXNET01FbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqZWN0ICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0Lm5vZGVUeXBlID09PSAxICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJztcbiAgfVxufTtcblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcyk7XG4gICAgaWYgKHR5cGVvZiByZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gSWYgaXQncyBET00gZWxlbSwgZ2V0IG91dGVyIEhUTUwuXG4gIGlmIChpc0RPTUVsZW1lbnQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGdldE91dGVySFRNTCh2YWx1ZSk7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciB2aXNpYmxlS2V5cyA9IGdldEVudW1lcmFibGVQcm9wZXJ0aWVzKHZhbHVlKTtcbiAgdmFyIGtleXMgPSBjdHguc2hvd0hpZGRlbiA/IGdldFByb3BlcnRpZXModmFsdWUpIDogdmlzaWJsZUtleXM7XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICAvLyBJbiBJRSwgZXJyb3JzIGhhdmUgYSBzaW5nbGUgYHN0YWNrYCBwcm9wZXJ0eSwgb3IgaWYgdGhleSBhcmUgdmFuaWxsYSBgRXJyb3JgLFxuICAvLyBhIGBzdGFja2AgcGx1cyBgZGVzY3JpcHRpb25gIHByb3BlcnR5OyBpZ25vcmUgdGhvc2UgZm9yIGNvbnNpc3RlbmN5LlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgfHwgKGlzRXJyb3IodmFsdWUpICYmIChcbiAgICAgIChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSAnc3RhY2snKSB8fFxuICAgICAgKGtleXMubGVuZ3RoID09PSAyICYmIGtleXNbMF0gPT09ICdkZXNjcmlwdGlvbicgJiYga2V5c1sxXSA9PT0gJ3N0YWNrJylcbiAgICAgKSkpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldE5hbWUodmFsdWUpO1xuICAgICAgdmFyIG5hbWVTdWZmaXggPSBuYW1lID8gJzogJyArIG5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWVTdWZmaXggKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBuYW1lID0gZ2V0TmFtZSh2YWx1ZSk7XG4gICAgdmFyIG5hbWVTdWZmaXggPSBuYW1lID8gJzogJyArIG5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbmFtZVN1ZmZpeCArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICB9XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyO1xuICBpZiAodmFsdWUuX19sb29rdXBHZXR0ZXJfXykge1xuICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKGtleSkpIHtcbiAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2aXNpYmxlS2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKHZhbHVlW2tleV0pIDwgMCkge1xuICAgICAgaWYgKHJlY3Vyc2VUaW1lcyA9PT0gbnVsbCkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlW2tleV0sIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKSB8fFxuICAgICAgICAgKHR5cGVvZiBhciA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcoYXIpID09PSAnW29iamVjdCBBcnJheV0nKTtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIHR5cGVvZiByZSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIHR5cGVvZiBkID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJztcbn1cblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLyohXG4gKiBDaGFpIC0gZmxhZyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kYW5jaWVzXG4gKi9cblxudmFyIGluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKTtcblxuLyoqXG4gKiAjIyMgLm9iakRpc3BsYXkgKG9iamVjdClcbiAqXG4gKiBEZXRlcm1pbmVzIGlmIGFuIG9iamVjdCBvciBhbiBhcnJheSBtYXRjaGVzXG4gKiBjcml0ZXJpYSB0byBiZSBpbnNwZWN0ZWQgaW4tbGluZSBmb3IgZXJyb3JcbiAqIG1lc3NhZ2VzIG9yIHNob3VsZCBiZSB0cnVuY2F0ZWQuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gamF2YXNjcmlwdCBvYmplY3QgdG8gaW5zcGVjdFxuICogQG5hbWUgb2JqRGlzcGxheVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHN0ciA9IGluc3BlY3Qob2JqKVxuICAgICwgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuXG4gIGlmIChzdHIubGVuZ3RoID49IDQwKSB7XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgIHJldHVybiAhb2JqLm5hbWUgfHwgb2JqLm5hbWUgPT09ICcnXG4gICAgICAgID8gJ1tGdW5jdGlvbl0nXG4gICAgICAgIDogJ1tGdW5jdGlvbjogJyArIG9iai5uYW1lICsgJ10nO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuICdbIEFycmF5KCcgKyBvYmoubGVuZ3RoICsgJykgXSc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gICAgICAgICwga3N0ciA9IGtleXMubGVuZ3RoID4gMlxuICAgICAgICAgID8ga2V5cy5zcGxpY2UoMCwgMikuam9pbignLCAnKSArICcsIC4uLidcbiAgICAgICAgICA6IGtleXMuam9pbignLCAnKTtcbiAgICAgIHJldHVybiAneyBPYmplY3QgKCcgKyBrc3RyICsgJykgfSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCAoY3R4LCBuYW1lLCBmbilcbiAqXG4gKiBPdmVyd2l0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBjaGFpbmFibGUgbWV0aG9kXG4gKiBhbmQgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBwcmV2aW91cyBmdW5jdGlvbiBvclxuICogcHJvcGVydHkuICBNdXN0IHJldHVybiBmdW5jdGlvbnMgdG8gYmUgdXNlZCBmb3JcbiAqIG5hbWUuXG4gKlxuICogICAgIHV0aWxzLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdsZW5ndGgnLFxuICogICAgICAgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgfVxuICogICAgICwgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgfVxuICogICAgICk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoJ2ZvbycsIGZuLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmhhdmUubGVuZ3RoKDMpO1xuICogICAgIGV4cGVjdChteUZvbykudG8uaGF2ZS5sZW5ndGguYWJvdmUoMyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgbWV0aG9kIC8gcHJvcGVydHkgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCAvIHByb3BlcnR5IHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoYWluaW5nQmVoYXZpb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgcHJvcGVydHlcbiAqIEBuYW1lIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcikge1xuICB2YXIgY2hhaW5hYmxlQmVoYXZpb3IgPSBjdHguX19tZXRob2RzW25hbWVdO1xuXG4gIHZhciBfY2hhaW5pbmdCZWhhdmlvciA9IGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3I7XG4gIGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNoYWluaW5nQmVoYXZpb3IoX2NoYWluaW5nQmVoYXZpb3IpLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgfTtcblxuICB2YXIgX21ldGhvZCA9IGNoYWluYWJsZUJlaGF2aW9yLm1ldGhvZDtcbiAgY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QoX21ldGhvZCkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICB9O1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZU1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgb3ZlcndyaXRlTWV0aG9kIChjdHgsIG5hbWUsIGZuKVxuICpcbiAqIE92ZXJ3aXRlcyBhbiBhbHJlYWR5IGV4aXN0aW5nIG1ldGhvZCBhbmQgcHJvdmlkZXNcbiAqIGFjY2VzcyB0byBwcmV2aW91cyBmdW5jdGlvbi4gTXVzdCByZXR1cm4gZnVuY3Rpb25cbiAqIHRvIGJlIHVzZWQgZm9yIG5hbWUuXG4gKlxuICogICAgIHV0aWxzLm92ZXJ3cml0ZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdlcXVhbCcsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gKiAgICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEZvbykge1xuICogICAgICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmoudmFsdWUpLnRvLmVxdWFsKHN0cik7XG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5lcXVhbCgnYmFyJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgbWV0aG9kIGlzIHRvIGJlIG92ZXJ3cml0dGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgdG8gb3ZlcndyaXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWUgb3ZlcndyaXRlTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGN0eCwgbmFtZSwgbWV0aG9kKSB7XG4gIHZhciBfbWV0aG9kID0gY3R4W25hbWVdXG4gICAgLCBfc3VwZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG4gIGlmIChfbWV0aG9kICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBfbWV0aG9kKVxuICAgIF9zdXBlciA9IF9tZXRob2Q7XG5cbiAgY3R4W25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QoX3N1cGVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVQcm9wZXJ0eSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgb3ZlcndyaXRlUHJvcGVydHkgKGN0eCwgbmFtZSwgZm4pXG4gKlxuICogT3ZlcndpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgcHJvcGVydHkgZ2V0dGVyIGFuZCBwcm92aWRlc1xuICogYWNjZXNzIHRvIHByZXZpb3VzIHZhbHVlLiBNdXN0IHJldHVybiBmdW5jdGlvbiB0byB1c2UgYXMgZ2V0dGVyLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVQcm9wZXJ0eShjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdvaycsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEZvbykge1xuICogICAgICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmoubmFtZSkudG8uZXF1YWwoJ2JhcicpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlUHJvcGVydHkoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uYmUub2s7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHByb3BlcnR5IHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGdldHRlciBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZSBvdmVyd3JpdGVQcm9wZXJ0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIGdldHRlcikge1xuICB2YXIgX2dldCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3R4LCBuYW1lKVxuICAgICwgX3N1cGVyID0gZnVuY3Rpb24gKCkge307XG5cbiAgaWYgKF9nZXQgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIF9nZXQuZ2V0KVxuICAgIF9zdXBlciA9IF9nZXQuZ2V0XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgbmFtZSxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0dGVyKF9zdXBlcikuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSB0ZXN0IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRhbmNpZXNcbiAqL1xuXG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG4vKipcbiAqICMgdGVzdChvYmplY3QsIGV4cHJlc3Npb24pXG4gKlxuICogVGVzdCBhbmQgb2JqZWN0IGZvciBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgYXJncykge1xuICB2YXIgbmVnYXRlID0gZmxhZyhvYmosICduZWdhdGUnKVxuICAgICwgZXhwciA9IGFyZ3NbMF07XG4gIHJldHVybiBuZWdhdGUgPyAhZXhwciA6IGV4cHI7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gdHJhbnNmZXJGbGFncyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgdHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIG9iamVjdCwgaW5jbHVkZUFsbCA9IHRydWUpXG4gKlxuICogVHJhbnNmZXIgYWxsIHRoZSBmbGFncyBmb3IgYGFzc2VydGlvbmAgdG8gYG9iamVjdGAuIElmXG4gKiBgaW5jbHVkZUFsbGAgaXMgc2V0IHRvIGBmYWxzZWAsIHRoZW4gdGhlIGJhc2UgQ2hhaVxuICogYXNzZXJ0aW9uIGZsYWdzIChuYW1lbHkgYG9iamVjdGAsIGBzc2ZpYCwgYW5kIGBtZXNzYWdlYClcbiAqIHdpbGwgbm90IGJlIHRyYW5zZmVycmVkLlxuICpcbiAqXG4gKiAgICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBBc3NlcnRpb24oKTtcbiAqICAgICB1dGlscy50cmFuc2ZlckZsYWdzKGFzc2VydGlvbiwgbmV3QXNzZXJ0aW9uKTtcbiAqXG4gKiAgICAgdmFyIGFub3RoZXJBc3Nlcml0b24gPSBuZXcgQXNzZXJ0aW9uKG15T2JqKTtcbiAqICAgICB1dGlscy50cmFuc2ZlckZsYWdzKGFzc2VydGlvbiwgYW5vdGhlckFzc2VydGlvbiwgZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7QXNzZXJ0aW9ufSBhc3NlcnRpb24gdGhlIGFzc2VydGlvbiB0byB0cmFuc2ZlciB0aGUgZmxhZ3MgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0aGUgb2JqZWN0IHRvIHRyYW5zZmVyIHRoZSBmbGFncyB0b287IHVzdWFsbHkgYSBuZXcgYXNzZXJ0aW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGVBbGxcbiAqIEBuYW1lIGdldEFsbEZsYWdzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhc3NlcnRpb24sIG9iamVjdCwgaW5jbHVkZUFsbCkge1xuICB2YXIgZmxhZ3MgPSBhc3NlcnRpb24uX19mbGFncyB8fCAoYXNzZXJ0aW9uLl9fZmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICBpZiAoIW9iamVjdC5fX2ZsYWdzKSB7XG4gICAgb2JqZWN0Ll9fZmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgaW5jbHVkZUFsbCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDMgPyBpbmNsdWRlQWxsIDogdHJ1ZTtcblxuICBmb3IgKHZhciBmbGFnIGluIGZsYWdzKSB7XG4gICAgaWYgKGluY2x1ZGVBbGwgfHxcbiAgICAgICAgKGZsYWcgIT09ICdvYmplY3QnICYmIGZsYWcgIT09ICdzc2ZpJyAmJiBmbGFnICE9ICdtZXNzYWdlJykpIHtcbiAgICAgIG9iamVjdC5fX2ZsYWdzW2ZsYWddID0gZmxhZ3NbZmxhZ107XG4gICAgfVxuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gdHlwZSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBEZXRlY3RhYmxlIGphdmFzY3JpcHQgbmF0aXZlc1xuICovXG5cbnZhciBuYXRpdmVzID0ge1xuICAgICdbb2JqZWN0IEFyZ3VtZW50c10nOiAnYXJndW1lbnRzJ1xuICAsICdbb2JqZWN0IEFycmF5XSc6ICdhcnJheSdcbiAgLCAnW29iamVjdCBEYXRlXSc6ICdkYXRlJ1xuICAsICdbb2JqZWN0IEZ1bmN0aW9uXSc6ICdmdW5jdGlvbidcbiAgLCAnW29iamVjdCBOdW1iZXJdJzogJ251bWJlcidcbiAgLCAnW29iamVjdCBSZWdFeHBdJzogJ3JlZ2V4cCdcbiAgLCAnW29iamVjdCBTdHJpbmddJzogJ3N0cmluZydcbn07XG5cbi8qKlxuICogIyMjIHR5cGUob2JqZWN0KVxuICpcbiAqIEJldHRlciBpbXBsZW1lbnRhdGlvbiBvZiBgdHlwZW9mYCBkZXRlY3Rpb24gdGhhdCBjYW5cbiAqIGJlIHVzZWQgY3Jvc3MtYnJvd3Nlci4gSGFuZGxlcyB0aGUgaW5jb25zaXN0ZW5jaWVzIG9mXG4gKiBBcnJheSwgYG51bGxgLCBhbmQgYHVuZGVmaW5lZGAgZGV0ZWN0aW9uLlxuICpcbiAqICAgICB1dGlscy50eXBlKHt9KSAvLyAnb2JqZWN0J1xuICogICAgIHV0aWxzLnR5cGUobnVsbCkgLy8gYG51bGwnXG4gKiAgICAgdXRpbHMudHlwZSh1bmRlZmluZWQpIC8vIGB1bmRlZmluZWRgXG4gKiAgICAgdXRpbHMudHlwZShbXSkgLy8gYGFycmF5YFxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byBkZXRlY3QgdHlwZSBvZlxuICogQG5hbWUgdHlwZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbiAgaWYgKG5hdGl2ZXNbc3RyXSkgcmV0dXJuIG5hdGl2ZXNbc3RyXTtcbiAgaWYgKG9iaiA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmIChvYmogPT09IE9iamVjdChvYmopKSByZXR1cm4gJ29iamVjdCc7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufTtcbiIsIi8qIVxuICogYXNzZXJ0aW9uLWVycm9yXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBKYWtlIEx1ZXIgPGpha2VAcXVhbGlhbmN5LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBvbmUgb2JqZWN0IHRvIGFub3RoZXIgZXhjbHVkaW5nIGFueSBvcmlnaW5hbGx5XG4gKiBsaXN0ZWQuIFJldHVybmVkIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGEgbmV3IGB7fWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4Y2x1ZGVkIHByb3BlcnRpZXMgLi4uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBleGNsdWRlICgpIHtcbiAgdmFyIGV4Y2x1ZGVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIGZ1bmN0aW9uIGV4Y2x1ZGVQcm9wcyAocmVzLCBvYmopIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCF+ZXhjbHVkZXMuaW5kZXhPZihrZXkpKSByZXNba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGV4dGVuZEV4Y2x1ZGUgKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAsIGkgPSAwXG4gICAgICAsIHJlcyA9IHt9O1xuXG4gICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleGNsdWRlUHJvcHMocmVzLCBhcmdzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzc2VydGlvbkVycm9yO1xuXG4vKipcbiAqICMjIyBBc3NlcnRpb25FcnJvclxuICpcbiAqIEFuIGV4dGVuc2lvbiBvZiB0aGUgSmF2YVNjcmlwdCBgRXJyb3JgIGNvbnN0cnVjdG9yIGZvclxuICogYXNzZXJ0aW9uIGFuZCB2YWxpZGF0aW9uIHNjZW5hcmlvcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgdG8gaW5jbHVkZSAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge2NhbGxlZX0gc3RhcnQgc3RhY2sgZnVuY3Rpb24gKG9wdGlvbmFsKVxuICovXG5cbmZ1bmN0aW9uIEFzc2VydGlvbkVycm9yIChtZXNzYWdlLCBfcHJvcHMsIHNzZikge1xuICB2YXIgZXh0ZW5kID0gZXhjbHVkZSgnbmFtZScsICdtZXNzYWdlJywgJ3N0YWNrJywgJ2NvbnN0cnVjdG9yJywgJ3RvSlNPTicpXG4gICAgLCBwcm9wcyA9IGV4dGVuZChfcHJvcHMgfHwge30pO1xuXG4gIC8vIGRlZmF1bHQgdmFsdWVzXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Vuc3BlY2lmaWVkIEFzc2VydGlvbkVycm9yJztcbiAgdGhpcy5zaG93RGlmZiA9IGZhbHNlO1xuXG4gIC8vIGNvcHkgZnJvbSBwcm9wZXJ0aWVzXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHRoaXNba2V5XSA9IHByb3BzW2tleV07XG4gIH1cblxuICAvLyBjYXB0dXJlIHN0YWNrIHRyYWNlXG4gIHNzZiA9IHNzZiB8fCBhcmd1bWVudHMuY2FsbGVlO1xuICBpZiAoc3NmICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3NmKTtcbiAgfVxufVxuXG4vKiFcbiAqIEluaGVyaXQgZnJvbSBFcnJvci5wcm90b3R5cGVcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cbi8qIVxuICogU3RhdGljYWxseSBzZXQgbmFtZVxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcblxuLyohXG4gKiBFbnN1cmUgY29ycmVjdCBjb25zdHJ1Y3RvclxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzc2VydGlvbkVycm9yO1xuXG4vKipcbiAqIEFsbG93IGVycm9ycyB0byBiZSBjb252ZXJ0ZWQgdG8gSlNPTiBmb3Igc3RhdGljIHRyYW5zZmVyLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZSBzdGFjayAoZGVmYXVsdDogYHRydWVgKVxuICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgdGhhdCBjYW4gYmUgYEpTT04uc3RyaW5naWZ5YFxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgdmFyIGV4dGVuZCA9IGV4Y2x1ZGUoJ2NvbnN0cnVjdG9yJywgJ3RvSlNPTicsICdzdGFjaycpXG4gICAgLCBwcm9wcyA9IGV4dGVuZCh7IG5hbWU6IHRoaXMubmFtZSB9LCB0aGlzKTtcblxuICAvLyBpbmNsdWRlIHN0YWNrIGlmIGV4aXN0cyBhbmQgbm90IHR1cm5lZCBvZmZcbiAgaWYgKGZhbHNlICE9PSBzdGFjayAmJiB0aGlzLnN0YWNrKSB7XG4gICAgcHJvcHMuc3RhY2sgPSB0aGlzLnN0YWNrO1xuICB9XG5cbiAgcmV0dXJuIHByb3BzO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvZXFsJyk7XG4iLCIvKiFcbiAqIGRlZXAtZXFsXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciB0eXBlID0gcmVxdWlyZSgndHlwZS1kZXRlY3QnKTtcblxuLyohXG4gKiBCdWZmZXIuaXNCdWZmZXIgYnJvd3NlciBzaGltXG4gKi9cblxudmFyIEJ1ZmZlcjtcbnRyeSB7IEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjsgfVxuY2F0Y2goZXgpIHtcbiAgQnVmZmVyID0ge307XG4gIEJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcEVxdWFsO1xuXG4vKipcbiAqIEFzc2VydCBzdXBlci1zdHJpY3QgKGVnYWwpIGVxdWFsaXR5IGJldHdlZW5cbiAqIHR3byBvYmplY3RzIG9mIGFueSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFcbiAqIEBwYXJhbSB7TWl4ZWR9IGJcbiAqIEBwYXJhbSB7QXJyYXl9IG1lbW9pc2VkIChvcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGVxdWFsIG1hdGNoXG4gKi9cblxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIsIG0pIHtcbiAgaWYgKHNhbWVWYWx1ZShhLCBiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKCdkYXRlJyA9PT0gdHlwZShhKSkge1xuICAgIHJldHVybiBkYXRlRXF1YWwoYSwgYik7XG4gIH0gZWxzZSBpZiAoJ3JlZ2V4cCcgPT09IHR5cGUoYSkpIHtcbiAgICByZXR1cm4gcmVnZXhwRXF1YWwoYSwgYik7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGEpKSB7XG4gICAgcmV0dXJuIGJ1ZmZlckVxdWFsKGEsIGIpO1xuICB9IGVsc2UgaWYgKCdhcmd1bWVudHMnID09PSB0eXBlKGEpKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50c0VxdWFsKGEsIGIsIG0pO1xuICB9IGVsc2UgaWYgKCF0eXBlRXF1YWwoYSwgYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoKCdvYmplY3QnICE9PSB0eXBlKGEpICYmICdvYmplY3QnICE9PSB0eXBlKGIpKVxuICAmJiAoJ2FycmF5JyAhPT0gdHlwZShhKSAmJiAnYXJyYXknICE9PSB0eXBlKGIpKSkge1xuICAgIHJldHVybiBzYW1lVmFsdWUoYSwgYik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iamVjdEVxdWFsKGEsIGIsIG0pO1xuICB9XG59XG5cbi8qIVxuICogU3RyaWN0IChlZ2FsKSBlcXVhbGl0eSB0ZXN0LiBFbnN1cmVzIHRoYXQgTmFOIGFsd2F5c1xuICogZXF1YWxzIE5hTiBhbmQgYC0wYCBkb2VzIG5vdCBlcXVhbCBgKzBgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFcbiAqIEBwYXJhbSB7TWl4ZWR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGVxdWFsIG1hdGNoXG4gKi9cblxuZnVuY3Rpb24gc2FtZVZhbHVlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbn1cblxuLyohXG4gKiBDb21wYXJlIHRoZSB0eXBlcyBvZiB0d28gZ2l2ZW4gb2JqZWN0cyBhbmRcbiAqIHJldHVybiBpZiB0aGV5IGFyZSBlcXVhbC4gTm90ZSB0aGF0IGFuIEFycmF5XG4gKiBoYXMgYSB0eXBlIG9mIGBhcnJheWAgKG5vdCBgb2JqZWN0YCkgYW5kIGFyZ3VtZW50c1xuICogaGF2ZSBhIHR5cGUgb2YgYGFyZ3VtZW50c2AgKG5vdCBgYXJyYXlgL2BvYmplY3RgKS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiB0eXBlRXF1YWwoYSwgYikge1xuICByZXR1cm4gdHlwZShhKSA9PT0gdHlwZShiKTtcbn1cblxuLyohXG4gKiBDb21wYXJlIHR3byBEYXRlIG9iamVjdHMgYnkgYXNzZXJ0aW5nIHRoYXRcbiAqIHRoZSB0aW1lIHZhbHVlcyBhcmUgZXF1YWwgdXNpbmcgYHNhdmVWYWx1ZWAuXG4gKlxuICogQHBhcmFtIHtEYXRlfSBhXG4gKiBAcGFyYW0ge0RhdGV9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGRhdGVFcXVhbChhLCBiKSB7XG4gIGlmICgnZGF0ZScgIT09IHR5cGUoYikpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHNhbWVWYWx1ZShhLmdldFRpbWUoKSwgYi5nZXRUaW1lKCkpO1xufVxuXG4vKiFcbiAqIENvbXBhcmUgdHdvIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYnkgY29udmVydGluZyB0aGVtXG4gKiB0byBzdHJpbmcgYW5kIGNoZWNraW5nIGZvciBgc2FtZVZhbHVlYC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gYVxuICogQHBhcmFtIHtSZWdFeHB9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIHJlZ2V4cEVxdWFsKGEsIGIpIHtcbiAgaWYgKCdyZWdleHAnICE9PSB0eXBlKGIpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBzYW1lVmFsdWUoYS50b1N0cmluZygpLCBiLnRvU3RyaW5nKCkpO1xufVxuXG4vKiFcbiAqIEFzc2VydCBkZWVwIGVxdWFsaXR5IG9mIHR3byBgYXJndW1lbnRzYCBvYmplY3RzLlxuICogVW5mb3J0dW5hdGVseSwgdGhlc2UgbXVzdCBiZSBzbGljZWQgdG8gYXJyYXlzXG4gKiBwcmlvciB0byB0ZXN0IHRvIGVuc3VyZSBubyBiYWQgYmVoYXZpb3IuXG4gKlxuICogQHBhcmFtIHtBcmd1bWVudHN9IGFcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBiXG4gKiBAcGFyYW0ge0FycmF5fSBtZW1vaXplIChvcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGFyZ3VtZW50c0VxdWFsKGEsIGIsIG0pIHtcbiAgaWYgKCdhcmd1bWVudHMnICE9PSB0eXBlKGIpKSByZXR1cm4gZmFsc2U7XG4gIGEgPSBbXS5zbGljZS5jYWxsKGEpO1xuICBiID0gW10uc2xpY2UuY2FsbChiKTtcbiAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBtKTtcbn1cblxuLyohXG4gKiBHZXQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcmV0dXJuIHtBcnJheX0gcHJvcGVydHkgbmFtZXNcbiAqL1xuXG5mdW5jdGlvbiBlbnVtZXJhYmxlKGEpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gYSkgcmVzLnB1c2goa2V5KTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyohXG4gKiBTaW1wbGUgZXF1YWxpdHkgZm9yIGZsYXQgaXRlcmFibGUgb2JqZWN0c1xuICogc3VjaCBhcyBBcnJheXMgb3IgTm9kZS5qcyBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7SXRlcmFibGV9IGFcbiAqIEBwYXJhbSB7SXRlcmFibGV9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGl0ZXJhYmxlRXF1YWwoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09ICBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBpID0gMDtcbiAgdmFyIG1hdGNoID0gdHJ1ZTtcblxuICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuLyohXG4gKiBFeHRlbnNpb24gdG8gYGl0ZXJhYmxlRXF1YWxgIHNwZWNpZmljYWxseVxuICogZm9yIE5vZGUuanMgQnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYVxuICogQHBhcmFtIHtNaXhlZH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gYnVmZmVyRXF1YWwoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaXRlcmFibGVFcXVhbChhLCBiKTtcbn1cblxuLyohXG4gKiBCbG9jayBmb3IgYG9iamVjdEVxdWFsYCBlbnN1cmluZyBub24tZXhpc3RpbmdcbiAqIHZhbHVlcyBkb24ndCBnZXQgaW4uXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbHVlKGEpIHtcbiAgcmV0dXJuIGEgIT09IG51bGwgJiYgYSAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKiFcbiAqIFJlY3Vyc2l2ZWx5IGNoZWNrIHRoZSBlcXVhbGl0eSBvZiB0d28gb2JqZWN0cy5cbiAqIE9uY2UgYmFzaWMgc2FtZW5lc3MgaGFzIGJlZW4gZXN0YWJsaXNoZWQgaXQgd2lsbFxuICogZGVmZXIgdG8gYGRlZXBFcXVhbGAgZm9yIGVhY2ggZW51bWVyYWJsZSBrZXlcbiAqIGluIHRoZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYVxuICogQHBhcmFtIHtNaXhlZH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gb2JqZWN0RXF1YWwoYSwgYiwgbSkge1xuICBpZiAoIWlzVmFsdWUoYSkgfHwgIWlzVmFsdWUoYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGk7XG4gIGlmIChtKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgobVtpXVswXSA9PT0gYSAmJiBtW2ldWzFdID09PSBiKVxuICAgICAgfHwgIChtW2ldWzBdID09PSBiICYmIG1baV1bMV0gPT09IGEpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtID0gW107XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBrYSA9IGVudW1lcmFibGUoYSk7XG4gICAgdmFyIGtiID0gZW51bWVyYWJsZShiKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcblxuICBpZiAoIWl0ZXJhYmxlRXF1YWwoa2EsIGtiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG0ucHVzaChbIGEsIGIgXSk7XG5cbiAgdmFyIGtleTtcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgbSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvdHlwZScpO1xuIiwiLyohXG4gKiB0eXBlLWRldGVjdFxuICogQ29weXJpZ2h0KGMpIDIwMTMgamFrZSBsdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0c1xuICovXG5cbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBnZXRUeXBlO1xuXG4vKiFcbiAqIERldGVjdGFibGUgamF2YXNjcmlwdCBuYXRpdmVzXG4gKi9cblxudmFyIG5hdGl2ZXMgPSB7XG4gICAgJ1tvYmplY3QgQXJyYXldJzogJ2FycmF5J1xuICAsICdbb2JqZWN0IFJlZ0V4cF0nOiAncmVnZXhwJ1xuICAsICdbb2JqZWN0IEZ1bmN0aW9uXSc6ICdmdW5jdGlvbidcbiAgLCAnW29iamVjdCBBcmd1bWVudHNdJzogJ2FyZ3VtZW50cydcbiAgLCAnW29iamVjdCBEYXRlXSc6ICdkYXRlJ1xufTtcblxuLyoqXG4gKiAjIyMgdHlwZU9mIChvYmopXG4gKlxuICogVXNlIHNldmVyYWwgZGlmZmVyZW50IHRlY2huaXF1ZXMgdG8gZGV0ZXJtaW5lXG4gKiB0aGUgdHlwZSBvZiBvYmplY3QgYmVpbmcgdGVzdGVkLlxuICpcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAqIEByZXR1cm4ge1N0cmluZ30gb2JqZWN0IHR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZ2V0VHlwZSAob2JqKSB7XG4gIHZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbiAgaWYgKG5hdGl2ZXNbc3RyXSkgcmV0dXJuIG5hdGl2ZXNbc3RyXTtcbiAgaWYgKG9iaiA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmIChvYmogPT09IE9iamVjdChvYmopKSByZXR1cm4gJ29iamVjdCc7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufVxuXG5leHBvcnRzLkxpYnJhcnkgPSBMaWJyYXJ5O1xuXG4vKipcbiAqICMjIyBMaWJyYXJ5XG4gKlxuICogQ3JlYXRlIGEgcmVwb3NpdG9yeSBmb3IgY3VzdG9tIHR5cGUgZGV0ZWN0aW9uLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGliID0gbmV3IHR5cGUuTGlicmFyeTtcbiAqIGBgYFxuICpcbiAqL1xuXG5mdW5jdGlvbiBMaWJyYXJ5ICgpIHtcbiAgdGhpcy50ZXN0cyA9IHt9O1xufVxuXG4vKipcbiAqICMjIyMgLm9mIChvYmopXG4gKlxuICogRXhwb3NlIHJlcGxhY2VtZW50IGB0eXBlb2ZgIGRldGVjdGlvbiB0byB0aGUgbGlicmFyeS5cbiAqXG4gKiBgYGBqc1xuICogaWYgKCdzdHJpbmcnID09PSBsaWIub2YoJ2hlbGxvIHdvcmxkJykpIHtcbiAqICAgLy8gLi4uXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3QgdG8gdGVzdFxuICogQHJldHVybiB7U3RyaW5nfSB0eXBlXG4gKi9cblxuTGlicmFyeS5wcm90b3R5cGUub2YgPSBnZXRUeXBlO1xuXG4vKipcbiAqICMjIyMgLmRlZmluZSAodHlwZSwgdGVzdClcbiAqXG4gKiBBZGQgYSB0ZXN0IHRvIGZvciB0aGUgYC50ZXN0KClgIGFzc2VydGlvbi5cbiAqXG4gKiBDYW4gYmUgZGVmaW5lZCBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbjpcbiAqXG4gKiBgYGBqc1xuICogbGliLmRlZmluZSgnaW50JywgL15bMC05XSskLyk7XG4gKiBgYGBcbiAqXG4gKiAuLi4gb3IgYXMgYSBmdW5jdGlvbjpcbiAqXG4gKiBgYGBqc1xuICogbGliLmRlZmluZSgnYmxuJywgZnVuY3Rpb24gKG9iaikge1xuICogICBpZiAoJ2Jvb2xlYW4nID09PSBsaWIub2Yob2JqKSkgcmV0dXJuIHRydWU7XG4gKiAgIHZhciBibG5zID0gWyAneWVzJywgJ25vJywgJ3RydWUnLCAnZmFsc2UnLCAxLCAwIF07XG4gKiAgIGlmICgnc3RyaW5nJyA9PT0gbGliLm9mKG9iaikpIG9iaiA9IG9iai50b0xvd2VyQ2FzZSgpO1xuICogICByZXR1cm4gISEgfmJsbnMuaW5kZXhPZihvYmopO1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtSZWdFeHB8RnVuY3Rpb259IHRlc3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTGlicmFyeS5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24gKHR5cGUsIHRlc3QpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLnRlc3RzW3R5cGVdO1xuICB0aGlzLnRlc3RzW3R5cGVdID0gdGVzdDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqICMjIyMgLnRlc3QgKG9iaiwgdGVzdClcbiAqXG4gKiBBc3NlcnQgdGhhdCBhbiBvYmplY3QgaXMgb2YgdHlwZS4gV2lsbCBmaXJzdFxuICogY2hlY2sgbmF0aXZlcywgYW5kIGlmIHRoYXQgZG9lcyBub3QgcGFzcyBpdCB3aWxsXG4gKiB1c2UgdGhlIHVzZXIgZGVmaW5lZCBjdXN0b20gdGVzdHMuXG4gKlxuICogYGBganNcbiAqIGFzc2VydChsaWIudGVzdCgnMScsICdpbnQnKSk7XG4gKiBhc3NlcnQobGliLnRlc3QoJ3llcycsICdibG4nKSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTGlicmFyeS5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIChvYmosIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IGdldFR5cGUob2JqKSkgcmV0dXJuIHRydWU7XG4gIHZhciB0ZXN0ID0gdGhpcy50ZXN0c1t0eXBlXTtcblxuICBpZiAodGVzdCAmJiAncmVnZXhwJyA9PT0gZ2V0VHlwZSh0ZXN0KSkge1xuICAgIHJldHVybiB0ZXN0LnRlc3Qob2JqKTtcbiAgfSBlbHNlIGlmICh0ZXN0ICYmICdmdW5jdGlvbicgPT09IGdldFR5cGUodGVzdCkpIHtcbiAgICByZXR1cm4gdGVzdChvYmopO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignVHlwZSB0ZXN0IFwiJyArIHR5cGUgKyAnXCIgbm90IGRlZmluZWQgb3IgaW52YWxpZC4nKTtcbiAgfVxufTtcbiIsIi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyB3aGVuIHVzZWQgaW4gbm9kZSwgdGhpcyB3aWxsIGFjdHVhbGx5IGxvYWQgdGhlIHV0aWwgbW9kdWxlIHdlIGRlcGVuZCBvblxuLy8gdmVyc3VzIGxvYWRpbmcgdGhlIGJ1aWx0aW4gdXRpbCBtb2R1bGUgYXMgaGFwcGVucyBvdGhlcndpc2Vcbi8vIHRoaXMgaXMgYSBidWcgaW4gbm9kZSBtb2R1bGUgbG9hZGluZyBhcyBmYXIgYXMgSSBhbSBjb25jZXJuZWRcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbC8nKTtcblxudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBub24gdjggYnJvd3NlcnMgc28gd2UgY2FuIGhhdmUgYSBzdGFja3RyYWNlXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIHZhciBvdXQgPSBlcnIuc3RhY2s7XG5cbiAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lc1xuICAgICAgdmFyIGZuX25hbWUgPSBzdGFja1N0YXJ0RnVuY3Rpb24ubmFtZTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKHV0aWwuaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7XG4gIH1cbiAgaWYgKHV0aWwuaXNOdW1iZXIodmFsdWUpICYmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKHZhbHVlKSB8fCB1dGlsLmlzUmVnRXhwKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodXRpbC5pc1N0cmluZyhzKSkge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpIHtcbiAgcmV0dXJuIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHNlbGYuYWN0dWFsLCByZXBsYWNlciksIDEyOCkgKyAnICcgK1xuICAgICAgICAgc2VsZi5vcGVyYXRvciArICcgJyArXG4gICAgICAgICB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmV4cGVjdGVkLCByZXBsYWNlciksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKHV0aWwuaXNCdWZmZXIoYWN0dWFsKSAmJiB1dGlsLmlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIGlmIChhY3R1YWwubGVuZ3RoICE9IGV4cGVjdGVkLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3R1YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhY3R1YWxbaV0gIT09IGV4cGVjdGVkW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNEYXRlKGFjdHVhbCkgJiYgdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMgSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBSZWdFeHAgb2JqZWN0IHdpdGggdGhlIHNhbWUgc291cmNlIGFuZFxuICAvLyBwcm9wZXJ0aWVzIChgZ2xvYmFsYCwgYG11bHRpbGluZWAsIGBsYXN0SW5kZXhgLCBgaWdub3JlQ2FzZWApLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNSZWdFeHAoYWN0dWFsKSAmJiB1dGlsLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKCF1dGlsLmlzT2JqZWN0KGFjdHVhbCkgJiYgIXV0aWwuaXNPYmplY3QoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiKSB7XG4gIGlmICh1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGEpIHx8IHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy9+fn5JJ3ZlIG1hbmFnZWQgdG8gYnJlYWsgT2JqZWN0LmtleXMgdGhyb3VnaCBzY3Jld3kgYXJndW1lbnRzIHBhc3NpbmcuXG4gIC8vICAgQ29udmVydGluZyB0byBhcnJheSBzb2x2ZXMgdGhlIHByb2JsZW0uXG4gIGlmIChpc0FyZ3VtZW50cyhhKSkge1xuICAgIGlmICghaXNBcmd1bWVudHMoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiKTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBrYSA9IG9iamVjdEtleXMoYSksXG4gICAgICAgIGtiID0gb2JqZWN0S2V5cyhiKSxcbiAgICAgICAga2V5LCBpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFfZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBhc3NlcnQuc3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG4vLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXNcbi8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodXRpbC5pc1N0cmluZyhleHBlY3RlZCkpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgYWN0dWFsID0gZTtcbiAgfVxuXG4gIG1lc3NhZ2UgPSAoZXhwZWN0ZWQgJiYgZXhwZWN0ZWQubmFtZSA/ICcgKCcgKyBleHBlY3RlZC5uYW1lICsgJykuJyA6ICcuJykgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuICBpZiAoc2hvdWxkVGhyb3cgJiYgIWFjdHVhbCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKCFzaG91bGRUaHJvdyAmJiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cy5hcHBseSh0aGlzLCBbdHJ1ZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW2ZhbHNlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikge3Rocm93IGVycjt9fTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiL1VzZXJzL3dlaWxpL3dvcmsvZmgtc2Rrcy9maC1qcy1zZGsvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIvKipcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEF1dGhvcjogICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogTGljZW5zZTogIE1JVFxuICpcbiAqIGBucG0gaW5zdGFsbCBidWZmZXJgXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTJcblxuLyoqXG4gKiBJZiBgQnVmZmVyLl91c2VUeXBlZEFycmF5c2A6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChjb21wYXRpYmxlIGRvd24gdG8gSUU2KVxuICovXG5CdWZmZXIuX3VzZVR5cGVkQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgIC8vIERldGVjdCBpZiBicm93c2VyIHN1cHBvcnRzIFR5cGVkIEFycmF5cy4gU3VwcG9ydGVkIGJyb3dzZXJzIGFyZSBJRSAxMCssXG4gICAvLyBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLCBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgLy8gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IGFkZGluZyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXM/IElmXG4gIC8vIG5vdCwgdGhlbiB0aGF0J3MgdGhlIHNhbWUgYXMgbm8gYFVpbnQ4QXJyYXlgIHN1cHBvcnQuIFdlIG5lZWQgdG8gYmUgYWJsZSB0b1xuICAvLyBhZGQgYWxsIHRoZSBub2RlIEJ1ZmZlciBBUEkgbWV0aG9kcy5cbiAgLy8gQnVnIGluIEZpcmVmb3ggNC0yOSwgbm93IGZpeGVkOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzhcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMClcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgLy8gQ2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdFxuXG4gIC8vIFdvcmthcm91bmQ6IG5vZGUncyBiYXNlNjQgaW1wbGVtZW50YXRpb24gYWxsb3dzIGZvciBub24tcGFkZGVkIHN0cmluZ3NcbiAgLy8gd2hpbGUgYmFzZTY0LWpzIGRvZXMgbm90LlxuICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgc3ViamVjdCA9IHN0cmluZ3RyaW0oc3ViamVjdClcbiAgICB3aGlsZSAoc3ViamVjdC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICBzdWJqZWN0ID0gc3ViamVjdCArICc9J1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aFxuICB2YXIgbGVuZ3RoXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdClcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0Lmxlbmd0aCkgLy8gQXNzdW1lIG9iamVjdCBpcyBhbiBhcnJheVxuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgYXJyYXkgb3Igc3RyaW5nLicpXG5cbiAgdmFyIGJ1ZlxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBhdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBidWYgPSB0aGlzXG4gICAgYnVmLmxlbmd0aCA9IGxlbmd0aFxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgaVxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgc3ViamVjdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAvLyBTcGVlZCBvcHRpbWl6YXRpb24gLS0gdXNlIHNldCBpZiB3ZSdyZSBjb3B5aW5nIGZyb20gYSBVaW50OEFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgICAgZWxzZVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0W2ldXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbi8vIFNUQVRJQyBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gKGIpIHtcbiAgcmV0dXJuICEhKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHZhciByZXRcbiAgc3RyID0gc3RyICsgJydcbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAvIDJcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBhc3NlcnQoaXNBcnJheShsaXN0KSwgJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuJyArXG4gICAgICAnbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuLy8gQlVGRkVSIElOU1RBTkNFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIF9oZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGFzc2VydChzdHJMZW4gJSAyID09PSAwLCAnSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgYXNzZXJ0KCFpc05hTihieXRlKSwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gYnl0ZVxuICB9XG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gaSAqIDJcbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gX3V0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF9hc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBfYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX3V0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHsgIC8vIGxlZ2FjeVxuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IF9oZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSBfdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IF9hc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBfYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IF9iYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gX3V0ZjE2bGVXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG4gIHN0YXJ0ID0gTnVtYmVyKHN0YXJ0KSB8fCAwXG4gIGVuZCA9IChlbmQgIT09IHVuZGVmaW5lZClcbiAgICA/IE51bWJlcihlbmQpXG4gICAgOiBlbmQgPSBzZWxmLmxlbmd0aFxuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKGVuZCA9PT0gc3RhcnQpXG4gICAgcmV0dXJuICcnXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IF9oZXhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSBfdXRmOFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IF9hc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBfYmluYXJ5U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IF9iYXNlNjRTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gX3V0ZjE2bGVTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpc1xuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBhc3NlcnQodGFyZ2V0X3N0YXJ0ID49IDAgJiYgdGFyZ2V0X3N0YXJ0IDwgdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCBzb3VyY2UubGVuZ3RoLCAnc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gc291cmNlLmxlbmd0aCwgJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydClcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnRcblxuICAvLyBjb3B5IVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyBpKyspXG4gICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gX3V0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBfYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBfYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIF9oZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIF91dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2krMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gY2xhbXAoc3RhcnQsIGxlbiwgMClcbiAgZW5kID0gY2xhbXAoZW5kLCBsZW4sIGxlbilcblxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIHJldHVybiBhdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRVSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmW29mZnNldF0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMl0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICAgIHZhbCB8PSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXQgKyAzXSA8PCAyNCA+Pj4gMClcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAxXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAyXSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDNdXG4gICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXRdIDw8IDI0ID4+PiAwKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHZhciBuZWcgPSB0aGlzW29mZnNldF0gJiAweDgwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiBfcmVhZEludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IF9yZWFkVUludDE2KGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQzMihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwMDAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRGbG9hdCAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRmxvYXQodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZERvdWJsZSAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmYpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm5cblxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxufVxuXG5mdW5jdGlvbiBfd3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZiwgLTB4ODApXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHRoaXMud3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHRoaXMud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmYsIC0weDgwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICBfd3JpdGVVSW50MTYoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDMyKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQzMihidWYsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLmNoYXJDb2RlQXQoMClcbiAgfVxuXG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSksICd2YWx1ZSBpcyBub3QgYSBudW1iZXInKVxuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLmxlbmd0aCwgJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHRoaXMubGVuZ3RoLCAnZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdGhpc1tpXSA9IHZhbHVlXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3V0ID0gW11cbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKVxuICAgIGlmIChpID09PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLidcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+J1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKVxuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IHRoZSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbmZ1bmN0aW9uIGF1Z21lbnQgKGFycikge1xuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbmZ1bmN0aW9uIGNsYW1wIChpbmRleCwgbGVuLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHJldHVybiBkZWZhdWx0VmFsdWVcbiAgaW5kZXggPSB+fmluZGV4OyAgLy8gQ29lcmNlIHRvIGludGVnZXIuXG4gIGlmIChpbmRleCA+PSBsZW4pIHJldHVybiBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICBpbmRleCArPSBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBjb2VyY2UgKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpXG4gIHJldHVybiBsZW5ndGggPCAwID8gMCA6IGxlbmd0aFxufVxuXG5mdW5jdGlvbiBpc0FycmF5IChzdWJqZWN0KSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoc3ViamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgfSkoc3ViamVjdClcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50ICh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA+PSAwLCAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmc2ludCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodGVzdCwgbWVzc2FnZSkge1xuICBpZiAoIXRlc3QpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdGYWlsZWQgYXNzZXJ0aW9uJylcbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgWkVSTyAgID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSClcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRtb2R1bGUuZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KCkpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNMRSA/IC0xIDogMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qZ2xvYmFsIHdpbmRvdywgZ2xvYmFsKi9cbnZhciB1dGlsID0gcmVxdWlyZShcInV0aWxcIilcbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpXG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxudmFyIGNvbnNvbGVcbnZhciB0aW1lcyA9IHt9XG5cbmlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jb25zb2xlKSB7XG4gICAgY29uc29sZSA9IGdsb2JhbC5jb25zb2xlXG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gd2luZG93LmNvbnNvbGVcbn0gZWxzZSB7XG4gICAgY29uc29sZSA9IHt9XG59XG5cbnZhciBmdW5jdGlvbnMgPSBbXG4gICAgW2xvZywgXCJsb2dcIl1cbiAgICAsIFtpbmZvLCBcImluZm9cIl1cbiAgICAsIFt3YXJuLCBcIndhcm5cIl1cbiAgICAsIFtlcnJvciwgXCJlcnJvclwiXVxuICAgICwgW3RpbWUsIFwidGltZVwiXVxuICAgICwgW3RpbWVFbmQsIFwidGltZUVuZFwiXVxuICAgICwgW3RyYWNlLCBcInRyYWNlXCJdXG4gICAgLCBbZGlyLCBcImRpclwiXVxuICAgICwgW2Fzc2VydCwgXCJhc3NlcnRcIl1cbl1cblxuZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHVwbGUgPSBmdW5jdGlvbnNbaV1cbiAgICB2YXIgZiA9IHR1cGxlWzBdXG4gICAgdmFyIG5hbWUgPSB0dXBsZVsxXVxuXG4gICAgaWYgKCFjb25zb2xlW25hbWVdKSB7XG4gICAgICAgIGNvbnNvbGVbbmFtZV0gPSBmXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnNvbGVcblxuZnVuY3Rpb24gbG9nKCkge31cblxuZnVuY3Rpb24gaW5mbygpIHtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIHdhcm4oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiBlcnJvcigpIHtcbiAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB0aW1lKGxhYmVsKSB7XG4gICAgdGltZXNbbGFiZWxdID0gRGF0ZS5ub3coKVxufVxuXG5mdW5jdGlvbiB0aW1lRW5kKGxhYmVsKSB7XG4gICAgdmFyIHRpbWUgPSB0aW1lc1tsYWJlbF1cbiAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBsYWJlbDogXCIgKyBsYWJlbClcbiAgICB9XG5cbiAgICB2YXIgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gdGltZVxuICAgIGNvbnNvbGUubG9nKGxhYmVsICsgXCI6IFwiICsgZHVyYXRpb24gKyBcIm1zXCIpXG59XG5cbmZ1bmN0aW9uIHRyYWNlKCkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKVxuICAgIGVyci5uYW1lID0gXCJUcmFjZVwiXG4gICAgZXJyLm1lc3NhZ2UgPSB1dGlsLmZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spXG59XG5cbmZ1bmN0aW9uIGRpcihvYmplY3QpIHtcbiAgICBjb25zb2xlLmxvZyh1dGlsLmluc3BlY3Qob2JqZWN0KSArIFwiXFxuXCIpXG59XG5cbmZ1bmN0aW9uIGFzc2VydChleHByZXNzaW9uKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBhcnIgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAgICAgYXNzZXJ0Lm9rKGZhbHNlLCB1dGlsLmZvcm1hdC5hcHBseShudWxsLCBhcnIpKVxuICAgIH1cbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsIi8qXG4gKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG47KGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG5cbiAgICAoZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IGRlZmluaXRpb24oKTtcbiAgICAgICAgfVxuICAgIH0oJ2xvZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcbiAgICAgICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib3VuZFRvQ29uc29sZShjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm91bmRUb0NvbnNvbGUoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBib3VuZFRvQ29uc29sZShjb25zb2xlLCBtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gY29uc29sZVttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIGlmIChtZXRob2QuYmluZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uQmluZGluZ1dyYXBwZXIobWV0aG9kLCBjb25zb2xlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZVttZXRob2ROYW1lXSwgY29uc29sZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIElFOCArIE1vZGVybml6ciwgdGhlIGJpbmQgc2hpbSB3aWxsIHJlamVjdCB0aGUgYWJvdmUsIHNvIHdlIGZhbGwgYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uQmluZGluZ1dyYXBwZXIobWV0aG9kLCBjb25zb2xlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGVbbWV0aG9kTmFtZV0uYmluZChjb25zb2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQmluZGluZ1dyYXBwZXIoZiwgY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShmLCBbY29udGV4dCwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgICAgICBcImluZm9cIixcbiAgICAgICAgICAgIFwid2FyblwiLFxuICAgICAgICAgICAgXCJlcnJvclwiXG4gICAgICAgIF07XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKG1ldGhvZEZhY3RvcnkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgIHNlbGZbbG9nTWV0aG9kc1tpaV1dID0gbWV0aG9kRmFjdG9yeShsb2dNZXRob2RzW2lpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb29raWVzQXZhaWxhYmxlKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBsb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxTdG9yYWdlRmFpbCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxldmVsTmFtZTtcblxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNlbGYubGV2ZWxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubGV2ZWxzLmhhc093blByb3BlcnR5KGtleSkgJiYgc2VsZi5sZXZlbHNba2V5XSA9PT0gbGV2ZWxOdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxOYW1lID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogU2V0dGluZyBsb2NhbFN0b3JhZ2UgY2FuIGNyZWF0ZSBhIERPTSAyMiBFeGNlcHRpb24gaWYgcnVubmluZyBpbiBQcml2YXRlIG1vZGVcbiAgICAgICAgICAgICAgICAgKiBpbiBTYWZhcmksIHNvIGV2ZW4gaWYgaXQgaXMgYXZhaWxhYmxlIHdlIG5lZWQgdG8gY2F0Y2ggYW55IGVycm9ycyB3aGVuIHRyeWluZ1xuICAgICAgICAgICAgICAgICAqIHRvIHdyaXRlIHRvIGl0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVsnbG9nbGV2ZWwnXSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZUZhaWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlRmFpbCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2VGYWlsICYmIGNvb2tpZXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPSBcImxvZ2xldmVsPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29va2llUmVnZXggPSAvbG9nbGV2ZWw9KFteO10rKS87XG5cbiAgICAgICAgZnVuY3Rpb24gbG9hZFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2VbJ2xvZ2xldmVsJ107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkICYmIGNvb2tpZXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHZhciBjb29raWVNYXRjaCA9IGNvb2tpZVJlZ2V4LmV4ZWMod2luZG93LmRvY3VtZW50LmNvb2tpZSkgfHwgW107XG4gICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSBjb29raWVNYXRjaFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSBcIldBUk5cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICpcbiAgICAgICAgICogUHVibGljIEFQSVxuICAgICAgICAgKlxuICAgICAgICAgKi9cblxuICAgICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID09PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZlttZXRob2ROYW1lXS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxldmVsIDw9IHNlbGYubGV2ZWxzW21ldGhvZE5hbWUudG9VcHBlckNhc2UoKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5UKTtcbiAgICAgICAgfTtcblxuICAgICAgICBsb2FkUGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSkpO1xufSkoKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iLCIoZnVuY3Rpb24gKHNpbm9uQ2hhaSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gTW9kdWxlIHN5c3RlbXMgbWFnaWMgZGFuY2UuXG5cbiAgICBpZiAodHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIE5vZGVKU1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHNpbm9uQ2hhaTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRFxuICAgICAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNpbm9uQ2hhaTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXIgZW52aXJvbm1lbnQgKHVzdWFsbHkgPHNjcmlwdD4gdGFnKTogcGx1ZyBpbiB0byBnbG9iYWwgY2hhaSBpbnN0YW5jZSBkaXJlY3RseS5cbiAgICAgICAgY2hhaS51c2Uoc2lub25DaGFpKTtcbiAgICB9XG59KGZ1bmN0aW9uIHNpbm9uQ2hhaShjaGFpLCB1dGlscykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgZnVuY3Rpb24gaXNTcHkocHV0YXRpdmVTcHkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwdXRhdGl2ZVNweSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICB0eXBlb2YgcHV0YXRpdmVTcHkuZ2V0Q2FsbCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICB0eXBlb2YgcHV0YXRpdmVTcHkuY2FsbGVkV2l0aEV4YWN0bHkgPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aW1lc0luV29yZHMoY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50ID09PSAxID8gXCJvbmNlXCIgOlxuICAgICAgICAgICAgICAgY291bnQgPT09IDIgPyBcInR3aWNlXCIgOlxuICAgICAgICAgICAgICAgY291bnQgPT09IDMgPyBcInRocmljZVwiIDpcbiAgICAgICAgICAgICAgIChjb3VudCB8fCAwKSArIFwiIHRpbWVzXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDYWxsKHB1dGF0aXZlQ2FsbCkge1xuICAgICAgICByZXR1cm4gcHV0YXRpdmVDYWxsICYmIGlzU3B5KHB1dGF0aXZlQ2FsbC5wcm94eSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0Q2FuV29ya1dpdGgoYXNzZXJ0aW9uKSB7XG4gICAgICAgIGlmICghaXNTcHkoYXNzZXJ0aW9uLl9vYmopICYmICFpc0NhbGwoYXNzZXJ0aW9uLl9vYmopKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHV0aWxzLmluc3BlY3QoYXNzZXJ0aW9uLl9vYmopICsgXCIgaXMgbm90IGEgc3B5IG9yIGEgY2FsbCB0byBhIHNweSFcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNZXNzYWdlcyhzcHksIGFjdGlvbiwgbm9uTmVnYXRlZFN1ZmZpeCwgYWx3YXlzLCBhcmdzKSB7XG4gICAgICAgIHZhciB2ZXJiUGhyYXNlID0gYWx3YXlzID8gXCJhbHdheXMgaGF2ZSBcIiA6IFwiaGF2ZSBcIjtcbiAgICAgICAgbm9uTmVnYXRlZFN1ZmZpeCA9IG5vbk5lZ2F0ZWRTdWZmaXggfHwgXCJcIjtcbiAgICAgICAgaWYgKGlzU3B5KHNweS5wcm94eSkpIHtcbiAgICAgICAgICAgIHNweSA9IHNweS5wcm94eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByaW50ZkFycmF5KGFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3B5LnByaW50Zi5hcHBseShzcHksIGFycmF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZmZpcm1hdGl2ZTogcHJpbnRmQXJyYXkoW1wiZXhwZWN0ZWQgJW4gdG8gXCIgKyB2ZXJiUGhyYXNlICsgYWN0aW9uICsgbm9uTmVnYXRlZFN1ZmZpeF0uY29uY2F0KGFyZ3MpKSxcbiAgICAgICAgICAgIG5lZ2F0aXZlOiBwcmludGZBcnJheShbXCJleHBlY3RlZCAlbiB0byBub3QgXCIgKyB2ZXJiUGhyYXNlICsgYWN0aW9uXS5jb25jYXQoYXJncykpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2lub25Qcm9wZXJ0eShuYW1lLCBhY3Rpb24sIG5vbk5lZ2F0ZWRTdWZmaXgpIHtcbiAgICAgICAgdXRpbHMuYWRkUHJvcGVydHkoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCBuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhc3NlcnRDYW5Xb3JrV2l0aCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gZ2V0TWVzc2FnZXModGhpcy5fb2JqLCBhY3Rpb24sIG5vbk5lZ2F0ZWRTdWZmaXgsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0KHRoaXMuX29ialtuYW1lXSwgbWVzc2FnZXMuYWZmaXJtYXRpdmUsIG1lc3NhZ2VzLm5lZ2F0aXZlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2lub25Qcm9wZXJ0eUFzQm9vbGVhbk1ldGhvZChuYW1lLCBhY3Rpb24sIG5vbk5lZ2F0ZWRTdWZmaXgpIHtcbiAgICAgICAgdXRpbHMuYWRkTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgbmFtZSwgZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgYXNzZXJ0Q2FuV29ya1dpdGgodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciBtZXNzYWdlcyA9IGdldE1lc3NhZ2VzKHRoaXMuX29iaiwgYWN0aW9uLCBub25OZWdhdGVkU3VmZml4LCBmYWxzZSwgW3RpbWVzSW5Xb3JkcyhhcmcpXSk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydCh0aGlzLl9vYmpbbmFtZV0gPT09IGFyZywgbWVzc2FnZXMuYWZmaXJtYXRpdmUsIG1lc3NhZ2VzLm5lZ2F0aXZlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlU2lub25NZXRob2RIYW5kbGVyKHNpbm9uTmFtZSwgYWN0aW9uLCBub25OZWdhdGVkU3VmZml4KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhc3NlcnRDYW5Xb3JrV2l0aCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIGFsd2F5c1Npbm9uTWV0aG9kID0gXCJhbHdheXNcIiArIHNpbm9uTmFtZVswXS50b1VwcGVyQ2FzZSgpICsgc2lub25OYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIHZhciBzaG91bGRCZUFsd2F5cyA9IHV0aWxzLmZsYWcodGhpcywgXCJhbHdheXNcIikgJiYgdHlwZW9mIHRoaXMuX29ialthbHdheXNTaW5vbk1ldGhvZF0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIHZhciBzaW5vbk1ldGhvZCA9IHNob3VsZEJlQWx3YXlzID8gYWx3YXlzU2lub25NZXRob2QgOiBzaW5vbk5hbWU7XG5cbiAgICAgICAgICAgIHZhciBtZXNzYWdlcyA9IGdldE1lc3NhZ2VzKHRoaXMuX29iaiwgYWN0aW9uLCBub25OZWdhdGVkU3VmZml4LCBzaG91bGRCZUFsd2F5cywgc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0KHRoaXMuX29ialtzaW5vbk1ldGhvZF0uYXBwbHkodGhpcy5fb2JqLCBhcmd1bWVudHMpLCBtZXNzYWdlcy5hZmZpcm1hdGl2ZSwgbWVzc2FnZXMubmVnYXRpdmUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNpbm9uTWV0aG9kQXNQcm9wZXJ0eShuYW1lLCBhY3Rpb24sIG5vbk5lZ2F0ZWRTdWZmaXgpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBjcmVhdGVTaW5vbk1ldGhvZEhhbmRsZXIobmFtZSwgYWN0aW9uLCBub25OZWdhdGVkU3VmZml4KTtcbiAgICAgICAgdXRpbHMuYWRkUHJvcGVydHkoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCBuYW1lLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleGNlcHRpb25hbFNpbm9uTWV0aG9kKGNoYWlOYW1lLCBzaW5vbk5hbWUsIGFjdGlvbiwgbm9uTmVnYXRlZFN1ZmZpeCkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGNyZWF0ZVNpbm9uTWV0aG9kSGFuZGxlcihzaW5vbk5hbWUsIGFjdGlvbiwgbm9uTmVnYXRlZFN1ZmZpeCk7XG4gICAgICAgIHV0aWxzLmFkZE1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsIGNoYWlOYW1lLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaW5vbk1ldGhvZChuYW1lLCBhY3Rpb24sIG5vbk5lZ2F0ZWRTdWZmaXgpIHtcbiAgICAgICAgZXhjZXB0aW9uYWxTaW5vbk1ldGhvZChuYW1lLCBuYW1lLCBhY3Rpb24sIG5vbk5lZ2F0ZWRTdWZmaXgpO1xuICAgIH1cblxuICAgIHV0aWxzLmFkZFByb3BlcnR5KGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgXCJhbHdheXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlscy5mbGFnKHRoaXMsIFwiYWx3YXlzXCIsIHRydWUpO1xuICAgIH0pO1xuXG4gICAgc2lub25Qcm9wZXJ0eShcImNhbGxlZFwiLCBcImJlZW4gY2FsbGVkXCIsIFwiIGF0IGxlYXN0IG9uY2UsIGJ1dCBpdCB3YXMgbmV2ZXIgY2FsbGVkXCIpO1xuICAgIHNpbm9uUHJvcGVydHlBc0Jvb2xlYW5NZXRob2QoXCJjYWxsQ291bnRcIiwgXCJiZWVuIGNhbGxlZCBleGFjdGx5ICUxXCIsIFwiLCBidXQgaXQgd2FzIGNhbGxlZCAlYyVDXCIpO1xuICAgIHNpbm9uUHJvcGVydHkoXCJjYWxsZWRPbmNlXCIsIFwiYmVlbiBjYWxsZWQgZXhhY3RseSBvbmNlXCIsIFwiLCBidXQgaXQgd2FzIGNhbGxlZCAlYyVDXCIpO1xuICAgIHNpbm9uUHJvcGVydHkoXCJjYWxsZWRUd2ljZVwiLCBcImJlZW4gY2FsbGVkIGV4YWN0bHkgdHdpY2VcIiwgXCIsIGJ1dCBpdCB3YXMgY2FsbGVkICVjJUNcIik7XG4gICAgc2lub25Qcm9wZXJ0eShcImNhbGxlZFRocmljZVwiLCBcImJlZW4gY2FsbGVkIGV4YWN0bHkgdGhyaWNlXCIsIFwiLCBidXQgaXQgd2FzIGNhbGxlZCAlYyVDXCIpO1xuICAgIHNpbm9uTWV0aG9kQXNQcm9wZXJ0eShcImNhbGxlZFdpdGhOZXdcIiwgXCJiZWVuIGNhbGxlZCB3aXRoIG5ld1wiKTtcbiAgICBzaW5vbk1ldGhvZChcImNhbGxlZEJlZm9yZVwiLCBcImJlZW4gY2FsbGVkIGJlZm9yZSAlMVwiKTtcbiAgICBzaW5vbk1ldGhvZChcImNhbGxlZEFmdGVyXCIsIFwiYmVlbiBjYWxsZWQgYWZ0ZXIgJTFcIik7XG4gICAgc2lub25NZXRob2QoXCJjYWxsZWRPblwiLCBcImJlZW4gY2FsbGVkIHdpdGggJTEgYXMgdGhpc1wiLCBcIiwgYnV0IGl0IHdhcyBjYWxsZWQgd2l0aCAldCBpbnN0ZWFkXCIpO1xuICAgIHNpbm9uTWV0aG9kKFwiY2FsbGVkV2l0aFwiLCBcImJlZW4gY2FsbGVkIHdpdGggYXJndW1lbnRzICUqXCIsIFwiJUNcIik7XG4gICAgc2lub25NZXRob2QoXCJjYWxsZWRXaXRoRXhhY3RseVwiLCBcImJlZW4gY2FsbGVkIHdpdGggZXhhY3QgYXJndW1lbnRzICUqXCIsIFwiJUNcIik7XG4gICAgc2lub25NZXRob2QoXCJjYWxsZWRXaXRoTWF0Y2hcIiwgXCJiZWVuIGNhbGxlZCB3aXRoIGFyZ3VtZW50cyBtYXRjaGluZyAlKlwiLCBcIiVDXCIpO1xuICAgIHNpbm9uTWV0aG9kKFwicmV0dXJuZWRcIiwgXCJyZXR1cm5lZCAlMVwiKTtcbiAgICBleGNlcHRpb25hbFNpbm9uTWV0aG9kKFwidGhyb3duXCIsIFwidGhyZXdcIiwgXCJ0aHJvd24gJTFcIik7XG59KSk7XG4iLCJ2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCl7XHJcbiAgc3dpdGNoICh0b1N0cmluZy5jYWxsKHZhbCkpIHtcclxuICAgIGNhc2UgJ1tvYmplY3QgRnVuY3Rpb25dJzogcmV0dXJuICdmdW5jdGlvbidcclxuICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOiByZXR1cm4gJ2RhdGUnXHJcbiAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOiByZXR1cm4gJ3JlZ2V4cCdcclxuICAgIGNhc2UgJ1tvYmplY3QgQXJndW1lbnRzXSc6IHJldHVybiAnYXJndW1lbnRzJ1xyXG4gICAgY2FzZSAnW29iamVjdCBBcnJheV0nOiByZXR1cm4gJ2FycmF5J1xyXG4gICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzogcmV0dXJuICdzdHJpbmcnXHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHZhbCA9PSAnb2JqZWN0JyAmJiB2YWwgJiYgdHlwZW9mIHZhbC5sZW5ndGggPT0gJ251bWJlcicpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsLmNhbGxlZSA9PSAnZnVuY3Rpb24nKSByZXR1cm4gJ2FyZ3VtZW50cyc7XHJcbiAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICBpZiAoZXggaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gJ2FyZ3VtZW50cyc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiAnbnVsbCdcclxuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJ1xyXG4gIGlmICh2YWwgJiYgdmFsLm5vZGVUeXBlID09PSAxKSByZXR1cm4gJ2VsZW1lbnQnXHJcbiAgaWYgKHZhbCA9PT0gT2JqZWN0KHZhbCkpIHJldHVybiAnb2JqZWN0J1xyXG5cclxuICByZXR1cm4gdHlwZW9mIHZhbFxyXG59XHJcbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuNi4wXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBFc3RhYmxpc2ggdGhlIG9iamVjdCB0aGF0IGdldHMgcmV0dXJuZWQgdG8gYnJlYWsgb3V0IG9mIGEgbG9vcCBpdGVyYXRpb24uXG4gIHZhciBicmVha2VyID0ge307XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXJcbiAgICBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIGNvbmNhdCAgICAgICAgICAgPSBBcnJheVByb3RvLmNvbmNhdCxcbiAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyXG4gICAgbmF0aXZlRm9yRWFjaCAgICAgID0gQXJyYXlQcm90by5mb3JFYWNoLFxuICAgIG5hdGl2ZU1hcCAgICAgICAgICA9IEFycmF5UHJvdG8ubWFwLFxuICAgIG5hdGl2ZVJlZHVjZSAgICAgICA9IEFycmF5UHJvdG8ucmVkdWNlLFxuICAgIG5hdGl2ZVJlZHVjZVJpZ2h0ICA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQsXG4gICAgbmF0aXZlRmlsdGVyICAgICAgID0gQXJyYXlQcm90by5maWx0ZXIsXG4gICAgbmF0aXZlRXZlcnkgICAgICAgID0gQXJyYXlQcm90by5ldmVyeSxcbiAgICBuYXRpdmVTb21lICAgICAgICAgPSBBcnJheVByb3RvLnNvbWUsXG4gICAgbmF0aXZlSW5kZXhPZiAgICAgID0gQXJyYXlQcm90by5pbmRleE9mLFxuICAgIG5hdGl2ZUxhc3RJbmRleE9mICA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2YsXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZDtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QgdmlhIGEgc3RyaW5nIGlkZW50aWZpZXIsXG4gIC8vIGZvciBDbG9zdXJlIENvbXBpbGVyIFwiYWR2YW5jZWRcIiBtb2RlLlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjYuMCc7XG5cbiAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBUaGUgY29ybmVyc3RvbmUsIGFuIGBlYWNoYCBpbXBsZW1lbnRhdGlvbiwgYWthIGBmb3JFYWNoYC5cbiAgLy8gSGFuZGxlcyBvYmplY3RzIHdpdGggdGhlIGJ1aWx0LWluIGBmb3JFYWNoYCwgYXJyYXlzLCBhbmQgcmF3IG9iamVjdHMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBmb3JFYWNoYCBpZiBhdmFpbGFibGUuXG4gIHZhciBlYWNoID0gXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdG9yIHRvIGVhY2ggZWxlbWVudC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYG1hcGAgaWYgYXZhaWxhYmxlLlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgaWYgKG5hdGl2ZU1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHJldHVybiBvYmoubWFwKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXN1bHRzLnB1c2goaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICB2YXIgcmVkdWNlRXJyb3IgPSAnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgcmVkdWNlYCBpZiBhdmFpbGFibGUuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcbiAgICBpZiAobmF0aXZlUmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgICAgaWYgKGNvbnRleHQpIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZShpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlKGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSB2YWx1ZTtcbiAgICAgICAgaW5pdGlhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaW5pdGlhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGByZWR1Y2VSaWdodGAgaWYgYXZhaWxhYmxlLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XG4gICAgaWYgKG5hdGl2ZVJlZHVjZVJpZ2h0ICYmIG9iai5yZWR1Y2VSaWdodCA9PT0gbmF0aXZlUmVkdWNlUmlnaHQpIHtcbiAgICAgIGlmIChjb250ZXh0KSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICByZXR1cm4gaW5pdGlhbCA/IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlUmlnaHQoaXRlcmF0b3IpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSArbGVuZ3RoKSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgfVxuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGluZGV4ID0ga2V5cyA/IGtleXNbLS1sZW5ndGhdIDogLS1sZW5ndGg7XG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgbWVtbyA9IG9ialtpbmRleF07XG4gICAgICAgIGluaXRpYWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgbWVtbywgb2JqW2luZGV4XSwgaW5kZXgsIGxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaW5pdGlhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBmaWx0ZXJgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICAgIGlmIChuYXRpdmVGaWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSByZXR1cm4gb2JqLmZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICB9LCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGV2ZXJ5YCBpZiBhdmFpbGFibGUuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBfLmlkZW50aXR5KTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKG5hdGl2ZUV2ZXJ5ICYmIG9iai5ldmVyeSA9PT0gbmF0aXZlRXZlcnkpIHJldHVybiBvYmouZXZlcnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoIShyZXN1bHQgPSByZXN1bHQgJiYgcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkpIHJldHVybiBicmVha2VyO1xuICAgIH0pO1xuICAgIHJldHVybiAhIXJlc3VsdDtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHNvbWVgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgdmFyIGFueSA9IF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IF8uaWRlbnRpdHkpO1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKG5hdGl2ZVNvbWUgJiYgb2JqLnNvbWUgPT09IG5hdGl2ZVNvbWUpIHJldHVybiBvYmouc29tZShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChyZXN1bHQgfHwgKHJlc3VsdCA9IHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpKSByZXR1cm4gYnJlYWtlcjtcbiAgICB9KTtcbiAgICByZXR1cm4gISFyZXN1bHQ7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiB2YWx1ZSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgb2JqLmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHJldHVybiBvYmouaW5kZXhPZih0YXJnZXQpICE9IC0xO1xuICAgIHJldHVybiBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0YXJnZXQ7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgaXNGdW5jID0gXy5pc0Z1bmN0aW9uKG1ldGhvZCk7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiAoaXNGdW5jID8gbWV0aG9kIDogdmFsdWVbbWV0aG9kXSkuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8ucHJvcGVydHkoa2V5KSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubWF0Y2hlcyhhdHRycykpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcyhhdHRycykpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IG9yIChlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgLy8gQ2FuJ3Qgb3B0aW1pemUgYXJyYXlzIG9mIGludGVnZXJzIGxvbmdlciB0aGFuIDY1LDUzNSBlbGVtZW50cy5cbiAgLy8gU2VlIFtXZWJLaXQgQnVnIDgwNzk3XShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODA3OTcpXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0FycmF5KG9iaikgJiYgb2JqWzBdID09PSArb2JqWzBdICYmIG9iai5sZW5ndGggPCA2NTUzNSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIG9iaik7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlO1xuICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzQXJyYXkob2JqKSAmJiBvYmpbMF0gPT09ICtvYmpbMF0gJiYgb2JqLmxlbmd0aCA8IDY1NTM1KSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgb2JqKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlO1xuICAgICAgaWYgKGNvbXB1dGVkIDwgbGFzdENvbXB1dGVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYW4gYXJyYXksIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmFuZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzaHVmZmxlZCA9IFtdO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmFuZCA9IF8ucmFuZG9tKGluZGV4KyspO1xuICAgICAgc2h1ZmZsZWRbaW5kZXggLSAxXSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmIChvYmoubGVuZ3RoICE9PSArb2JqLmxlbmd0aCkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBsb29rdXAgaXRlcmF0b3JzLlxuICB2YXIgbG9va3VwSXRlcmF0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0b3IuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yID0gbG9va3VwSXRlcmF0b3IoaXRlcmF0b3IpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0b3IgPSBsb29rdXBJdGVyYXRvcihpdGVyYXRvcik7XG4gICAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgYmVoYXZpb3IocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIF8uZ3JvdXBCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwga2V5LCB2YWx1ZSkge1xuICAgIF8uaGFzKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldLnB1c2godmFsdWUpIDogcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCBrZXksIHZhbHVlKSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwga2V5KSB7XG4gICAgXy5oYXMocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0rKyA6IHJlc3VsdFtrZXldID0gMTtcbiAgfSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yID0gbG9va3VwSXRlcmF0b3IoaXRlcmF0b3IpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcbiAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgYXJyYXlbbWlkXSkgPCB2YWx1ZSA/IGxvdyA9IG1pZCArIDEgOiBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKChuID09IG51bGwpIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XG4gICAgaWYgKG4gPCAwKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGhcbiAgLy8gYF8ubWFwYC5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIGFycmF5Lmxlbmd0aCAtICgobiA9PSBudWxsKSB8fCBndWFyZCA/IDEgOiBuKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKChuID09IG51bGwpIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIE1hdGgubWF4KGFycmF5Lmxlbmd0aCAtIG4sIDApKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKlxuICAvLyBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAobiA9PSBudWxsKSB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIG91dHB1dCkge1xuICAgIGlmIChzaGFsbG93ICYmIF8uZXZlcnkoaW5wdXQsIF8uaXNBcnJheSkpIHtcbiAgICAgIHJldHVybiBjb25jYXQuYXBwbHkob3V0cHV0LCBpbnB1dCk7XG4gICAgfVxuICAgIGVhY2goaW5wdXQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkge1xuICAgICAgICBzaGFsbG93ID8gcHVzaC5hcHBseShvdXRwdXQsIHZhbHVlKSA6IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIG91dHB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIFtdKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFNwbGl0IGFuIGFycmF5IGludG8gdHdvIGFycmF5czogb25lIHdob3NlIGVsZW1lbnRzIGFsbCBzYXRpc2Z5IHRoZSBnaXZlblxuICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gIF8ucGFydGl0aW9uID0gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBwYXNzID0gW10sIGZhaWwgPSBbXTtcbiAgICBlYWNoKGFycmF5LCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAocHJlZGljYXRlKGVsZW0pID8gcGFzcyA6IGZhaWwpLnB1c2goZWxlbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0b3I7XG4gICAgICBpdGVyYXRvciA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGluaXRpYWwgPSBpdGVyYXRvciA/IF8ubWFwKGFycmF5LCBpdGVyYXRvciwgY29udGV4dCkgOiBhcnJheTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZWFjaChpbml0aWFsLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIGlmIChpc1NvcnRlZCA/ICghaW5kZXggfHwgc2VlbltzZWVuLmxlbmd0aCAtIDFdICE9PSB2YWx1ZSkgOiAhXy5jb250YWlucyhzZWVuLCB2YWx1ZSkpIHtcbiAgICAgICAgc2Vlbi5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGFycmF5W2luZGV4XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShfLmZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKF8udW5pcShhcnJheSksIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiBfLmV2ZXJ5KHJlc3QsIGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBfLmNvbnRhaW5zKG90aGVyLCBpdGVtKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpeyByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpOyB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSBfLm1heChfLnBsdWNrKGFyZ3VtZW50cywgJ2xlbmd0aCcpLmNvbmNhdCgwKSk7XG4gICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRzW2ldID0gXy5wbHVjayhhcmd1bWVudHMsICcnICsgaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICBpZiAobGlzdCA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gSWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwbHkgdXMgd2l0aCBpbmRleE9mIChJJ20gbG9va2luZyBhdCB5b3UsICoqTVNJRSoqKSxcbiAgLy8gd2UgbmVlZCB0aGlzIGZ1bmN0aW9uLiBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuXG4gIC8vIGl0ZW0gaW4gYW4gYXJyYXksIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBpbmRleE9mYCBpZiBhdmFpbGFibGUuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgaXNTb3J0ZWQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpID0gKGlzU29ydGVkIDwgMCA/IE1hdGgubWF4KDAsIGxlbmd0aCArIGlzU29ydGVkKSA6IGlzU29ydGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkgPSBfLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2ldID09PSBpdGVtID8gaSA6IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmF0aXZlSW5kZXhPZiAmJiBhcnJheS5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtLCBpc1NvcnRlZCk7XG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGxhc3RJbmRleE9mYCBpZiBhdmFpbGFibGUuXG4gIF8ubGFzdEluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgZnJvbSkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7XG4gICAgdmFyIGhhc0luZGV4ID0gZnJvbSAhPSBudWxsO1xuICAgIGlmIChuYXRpdmVMYXN0SW5kZXhPZiAmJiBhcnJheS5sYXN0SW5kZXhPZiA9PT0gbmF0aXZlTGFzdEluZGV4T2YpIHtcbiAgICAgIHJldHVybiBoYXNJbmRleCA/IGFycmF5Lmxhc3RJbmRleE9mKGl0ZW0sIGZyb20pIDogYXJyYXkubGFzdEluZGV4T2YoaXRlbSk7XG4gICAgfVxuICAgIHZhciBpID0gKGhhc0luZGV4ID8gZnJvbSA6IGFycmF5Lmxlbmd0aCk7XG4gICAgd2hpbGUgKGktLSkgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IGFyZ3VtZW50c1syXSB8fCAxO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgcmFuZ2UgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlKGlkeCA8IGxlbmd0aCkge1xuICAgICAgcmFuZ2VbaWR4KytdID0gc3RhcnQ7XG4gICAgICBzdGFydCArPSBzdGVwO1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJldXNhYmxlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBwcm90b3R5cGUgc2V0dGluZy5cbiAgdmFyIGN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgdmFyIGFyZ3MsIGJvdW5kO1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSkgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuICAgICAgdmFyIHNlbGYgPSBuZXcgY3RvcjtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICB2YXIgYXJncyA9IGJvdW5kQXJncy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3NbaV0gPT09IF8pIGFyZ3NbaV0gPSBhcmd1bWVudHNbcG9zaXRpb24rK107XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBmdW5jcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBlYWNoKGZ1bmNzLCBmdW5jdGlvbihmKSB7IG9ialtmXSA9IF8uYmluZChvYmpbZl0sIG9iaik7IH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW8gPSB7fTtcbiAgICBoYXNoZXIgfHwgKGhhc2hlciA9IF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfLmhhcyhtZW1vLCBrZXkpID8gbWVtb1trZXldIDogKG1lbW9ba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpeyByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTsgfSwgd2FpdCk7XG4gIH07XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgcmV0dXJuIF8uZGVsYXkuYXBwbHkoXywgW2Z1bmMsIDFdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG4gICAgICBpZiAobGFzdCA8IHdhaXQpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciByYW4gPSBmYWxzZSwgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocmFuKSByZXR1cm4gbWVtbztcbiAgICAgIHJhbiA9IHRydWU7XG4gICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGZvciAodmFyIGkgPSBmdW5jcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcmdzID0gW2Z1bmNzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGFmdGVyIGJlaW5nIGNhbGxlZCBOIHRpbWVzLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXG4gIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcbiAgfTtcblxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgXy5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBlYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgY29weSA9IHt9O1xuICAgIHZhciBrZXlzID0gY29uY2F0LmFwcGx5KEFycmF5UHJvdG8sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgZWFjaChrZXlzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChrZXkgaW4gb2JqKSBjb3B5W2tleV0gPSBvYmpba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBjb3B5ID0ge307XG4gICAgdmFyIGtleXMgPSBjb25jYXQuYXBwbHkoQXJyYXlQcm90bywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoIV8uY29udGFpbnMoa2V5cywga2V5KSkgY29weVtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBlYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKG9ialtwcm9wXSA9PT0gdm9pZCAwKSBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiBhID09IFN0cmluZyhiKTtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3JcbiAgICAgICAgLy8gb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiBhICE9ICthID8gYiAhPSArYiA6IChhID09IDAgPyAxIC8gYSA9PSAxIC8gYiA6IGEgPT0gK2IpO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09ICtiO1xuICAgICAgLy8gUmVnRXhwcyBhcmUgY29tcGFyZWQgYnkgdGhlaXIgc291cmNlIHBhdHRlcm5zIGFuZCBmbGFncy5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAgIHJldHVybiBhLnNvdXJjZSA9PSBiLnNvdXJjZSAmJlxuICAgICAgICAgICAgICAgYS5nbG9iYWwgPT0gYi5nbG9iYWwgJiZcbiAgICAgICAgICAgICAgIGEubXVsdGlsaW5lID09IGIubXVsdGlsaW5lICYmXG4gICAgICAgICAgICAgICBhLmlnbm9yZUNhc2UgPT0gYi5pZ25vcmVDYXNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT0gYjtcbiAgICB9XG4gICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzXG4gICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgKGFDdG9yIGluc3RhbmNlb2YgYUN0b3IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgKGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcbiAgICB2YXIgc2l6ZSA9IDAsIHJlc3VsdCA9IHRydWU7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGNsYXNzTmFtZSA9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIHNpemUgPSBhLmxlbmd0aDtcbiAgICAgIHJlc3VsdCA9IHNpemUgPT0gYi5sZW5ndGg7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBlcShhW3NpemVdLCBiW3NpemVdLCBhU3RhY2ssIGJTdGFjaykpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICAgIGlmIChfLmhhcyhhLCBrZXkpKSB7XG4gICAgICAgICAgLy8gQ291bnQgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXIuXG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBmb3IgKGtleSBpbiBiKSB7XG4gICAgICAgICAgaWYgKF8uaGFzKGIsIGtleSkgJiYgIShzaXplLS0pKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSAhc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIsIFtdLCBbXSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cC5cbiAgZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFKSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gISEob2JqICYmIF8uaGFzKG9iaiwgJ2NhbGxlZScpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLlxuICBpZiAodHlwZW9mICgvLi8pICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRvcnMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgXy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqID09PSBhdHRycykgcmV0dXJuIHRydWU7IC8vYXZvaWQgY29tcGFyaW5nIGFuIG9iamVjdCB0byBpdHNlbGYuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9O1xuXG4gIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlbnRpdHlNYXAgPSB7XG4gICAgZXNjYXBlOiB7XG4gICAgICAnJic6ICcmYW1wOycsXG4gICAgICAnPCc6ICcmbHQ7JyxcbiAgICAgICc+JzogJyZndDsnLFxuICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICBcIidcIjogJyYjeDI3OydcbiAgICB9XG4gIH07XG4gIGVudGl0eU1hcC51bmVzY2FwZSA9IF8uaW52ZXJ0KGVudGl0eU1hcC5lc2NhcGUpO1xuXG4gIC8vIFJlZ2V4ZXMgY29udGFpbmluZyB0aGUga2V5cyBhbmQgdmFsdWVzIGxpc3RlZCBpbW1lZGlhdGVseSBhYm92ZS5cbiAgdmFyIGVudGl0eVJlZ2V4ZXMgPSB7XG4gICAgZXNjYXBlOiAgIG5ldyBSZWdFeHAoJ1snICsgXy5rZXlzKGVudGl0eU1hcC5lc2NhcGUpLmpvaW4oJycpICsgJ10nLCAnZycpLFxuICAgIHVuZXNjYXBlOiBuZXcgUmVnRXhwKCcoJyArIF8ua2V5cyhlbnRpdHlNYXAudW5lc2NhcGUpLmpvaW4oJ3wnKSArICcpJywgJ2cnKVxuICB9O1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgXy5lYWNoKFsnZXNjYXBlJywgJ3VuZXNjYXBlJ10sIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIF9bbWV0aG9kXSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgaWYgKHN0cmluZyA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gKCcnICsgc3RyaW5nKS5yZXBsYWNlKGVudGl0eVJlZ2V4ZXNbbWV0aG9kXSwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eU1hcFttZXRob2RdW21hdGNoXTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgYHByb3BlcnR5YCBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0IHdpdGggdGhlXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdCc6ICAgICAndCcsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdHxcXHUyMDI4fFxcdTIwMjkvZztcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgZGF0YSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgcmVuZGVyO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgICAgIC5yZXBsYWNlKGVzY2FwZXIsIGZ1bmN0aW9uKG1hdGNoKSB7IHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTsgfSk7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH1cbiAgICAgIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyBcInJldHVybiBfX3A7XFxuXCI7XG5cbiAgICB0cnkge1xuICAgICAgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmIChkYXRhKSByZXR1cm4gcmVuZGVyKGRhdGEsIF8pO1xuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24gc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonKSArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGRlbGVnYXRlIHRvIHRoZSB3cmFwcGVyLlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8ob2JqKS5jaGFpbigpO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PSAnc2hpZnQnIHx8IG5hbWUgPT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICBfLmV4dGVuZChfLnByb3RvdHlwZSwge1xuXG4gICAgLy8gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICAgIGNoYWluOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NoYWluID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuIiwiLyogYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgSlNDb3ZlcmFnZSAtIGRvIG5vdCBlZGl0ICovXG5pZiAodHlwZW9mIF8kanNjb3ZlcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIF8kanNjb3ZlcmFnZSA9IHt9O1xuaWYgKCEgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVsxMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzE0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVsxNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzE5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVsyMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzIzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVsyNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzI2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVsyN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMzBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzMxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVszMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMzNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzM0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVszNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bNDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzQxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVs0NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bNDVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzQ4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVs0OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bNTJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzU5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVs2M10gPSAwO1xufVxuXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzFdKys7XG52YXIgWERvbWFpblJlcXVlc3RXcmFwcGVyID0gKGZ1bmN0aW9uICh4ZHIpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzJdKys7XG4gIHRoaXMueGRyID0geGRyO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bM10rKztcbiAgdGhpcy5pc1dyYXBwZXIgPSB0cnVlO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bNF0rKztcbiAgdGhpcy5yZWFkeVN0YXRlID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzVdKys7XG4gIHRoaXMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzZdKys7XG4gIHRoaXMuc3RhdHVzID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzddKys7XG4gIHRoaXMuc3RhdHVzVGV4dCA9IFwiXCI7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVs4XSsrO1xuICB0aGlzLnJlc3BvbnNlVGV4dCA9IFwiXCI7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVs5XSsrO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVsxMF0rKztcbiAgdGhpcy54ZHIub25sb2FkID0gKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzExXSsrO1xuICBzZWxmLnJlYWR5U3RhdGUgPSA0O1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMTJdKys7XG4gIHNlbGYuc3RhdHVzID0gMjAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMTNdKys7XG4gIHNlbGYuc3RhdHVzVGV4dCA9IFwiXCI7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVsxNF0rKztcbiAgc2VsZi5yZXNwb25zZVRleHQgPSBzZWxmLnhkci5yZXNwb25zZVRleHQ7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVsxNV0rKztcbiAgaWYgKHNlbGYub25yZWFkeXN0YXRlY2hhbmdlKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzE2XSsrO1xuICAgIHNlbGYub25yZWFkeXN0YXRlY2hhbmdlKCk7XG4gIH1cbn0pO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMTldKys7XG4gIHRoaXMueGRyLm9uZXJyb3IgPSAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMjBdKys7XG4gIGlmIChzZWxmLm9uZXJyb3IpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMjFdKys7XG4gICAgc2VsZi5vbmVycm9yKCk7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzIzXSsrO1xuICBzZWxmLnJlYWR5U3RhdGUgPSA0O1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMjRdKys7XG4gIHNlbGYuc3RhdHVzID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzI1XSsrO1xuICBzZWxmLnN0YXR1c1RleHQgPSBcIlwiO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMjZdKys7XG4gIGlmIChzZWxmLm9ucmVhZHlzdGF0ZWNoYW5nZSkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVsyN10rKztcbiAgICBzZWxmLm9ucmVhZHlzdGF0ZWNoYW5nZSgpO1xuICB9XG59KTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzMwXSsrO1xuICB0aGlzLnhkci5vbnRpbWVvdXQgPSAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bMzFdKys7XG4gIHNlbGYucmVhZHlTdGF0ZSA9IDQ7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVszMl0rKztcbiAgc2VsZi5zdGF0dXMgPSA0MDg7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVszM10rKztcbiAgc2VsZi5zdGF0dXNUZXh0ID0gXCJ0aW1lb3V0XCI7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVszNF0rKztcbiAgaWYgKHNlbGYub25yZWFkeXN0YXRlY2hhbmdlKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddWzM1XSsrO1xuICAgIHNlbGYub25yZWFkeXN0YXRlY2hhbmdlKCk7XG4gIH1cbn0pO1xufSk7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bNDBdKys7XG5YRG9tYWluUmVxdWVzdFdyYXBwZXIucHJvdG90eXBlLm9wZW4gPSAoZnVuY3Rpb24gKG1ldGhvZCwgdXJsLCBhc3luKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVs0MV0rKztcbiAgdGhpcy54ZHIub3BlbihtZXRob2QsIHVybCk7XG59KTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVs0NF0rKztcblhEb21haW5SZXF1ZXN0V3JhcHBlci5wcm90b3R5cGUuc2VuZCA9IChmdW5jdGlvbiAoZGF0YSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bNDVdKys7XG4gIHRoaXMueGRyLnNlbmQoZGF0YSk7XG59KTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVs0OF0rKztcblhEb21haW5SZXF1ZXN0V3JhcHBlci5wcm90b3R5cGUuYWJvcnQgPSAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bNDldKys7XG4gIHRoaXMueGRyLmFib3J0KCk7XG59KTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVs1Ml0rKztcblhEb21haW5SZXF1ZXN0V3JhcHBlci5wcm90b3R5cGUuc2V0UmVxdWVzdEhlYWRlciA9IChmdW5jdGlvbiAobiwgdikge1xufSk7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvWERvbWFpblJlcXVlc3RXcmFwcGVyLmpzJ11bNTldKys7XG5YRG9tYWluUmVxdWVzdFdyYXBwZXIucHJvdG90eXBlLmdldFJlc3BvbnNlSGVhZGVyID0gKGZ1bmN0aW9uIChuKSB7XG59KTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9YRG9tYWluUmVxdWVzdFdyYXBwZXIuanMnXVs2M10rKztcbm1vZHVsZS5leHBvcnRzID0gWERvbWFpblJlcXVlc3RXcmFwcGVyO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL1hEb21haW5SZXF1ZXN0V3JhcHBlci5qcyddLnNvdXJjZSA9IFtcInZhciBYRG9tYWluUmVxdWVzdFdyYXBwZXIgPSBmdW5jdGlvbih4ZHIpe1wiLFwiICB0aGlzLnhkciA9IHhkcjtcIixcIiAgdGhpcy5pc1dyYXBwZXIgPSB0cnVlO1wiLFwiICB0aGlzLnJlYWR5U3RhdGUgPSAwO1wiLFwiICB0aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XCIsXCIgIHRoaXMuc3RhdHVzID0gMDtcIixcIiAgdGhpcy5zdGF0dXNUZXh0ID0gXFxcIlxcXCI7XCIsXCIgIHRoaXMucmVzcG9uc2VUZXh0ID0gXFxcIlxcXCI7XCIsXCIgIHZhciBzZWxmID0gdGhpcztcIixcIiAgdGhpcy54ZHIub25sb2FkID0gZnVuY3Rpb24oKXtcIixcIiAgICAgIHNlbGYucmVhZHlTdGF0ZSA9IDQ7XCIsXCIgICAgICBzZWxmLnN0YXR1cyA9IDIwMDtcIixcIiAgICAgIHNlbGYuc3RhdHVzVGV4dCA9IFxcXCJcXFwiO1wiLFwiICAgICAgc2VsZi5yZXNwb25zZVRleHQgPSBzZWxmLnhkci5yZXNwb25zZVRleHQ7XCIsXCIgICAgICBpZihzZWxmLm9ucmVhZHlzdGF0ZWNoYW5nZSl7XCIsXCIgICAgICAgICAgc2VsZi5vbnJlYWR5c3RhdGVjaGFuZ2UoKTtcIixcIiAgICAgIH1cIixcIiAgfTtcIixcIiAgdGhpcy54ZHIub25lcnJvciA9IGZ1bmN0aW9uKCl7XCIsXCIgICAgICBpZihzZWxmLm9uZXJyb3Ipe1wiLFwiICAgICAgICAgIHNlbGYub25lcnJvcigpO1wiLFwiICAgICAgfVwiLFwiICAgICAgc2VsZi5yZWFkeVN0YXRlID0gNDtcIixcIiAgICAgIHNlbGYuc3RhdHVzID0gMDtcIixcIiAgICAgIHNlbGYuc3RhdHVzVGV4dCA9IFxcXCJcXFwiO1wiLFwiICAgICAgaWYoc2VsZi5vbnJlYWR5c3RhdGVjaGFuZ2Upe1wiLFwiICAgICAgICAgIHNlbGYub25yZWFkeXN0YXRlY2hhbmdlKCk7XCIsXCIgICAgICB9XCIsXCIgIH07XCIsXCIgIHRoaXMueGRyLm9udGltZW91dCA9IGZ1bmN0aW9uKCl7XCIsXCIgICAgICBzZWxmLnJlYWR5U3RhdGUgPSA0O1wiLFwiICAgICAgc2VsZi5zdGF0dXMgPSA0MDg7XCIsXCIgICAgICBzZWxmLnN0YXR1c1RleHQgPSBcXFwidGltZW91dFxcXCI7XCIsXCIgICAgICBpZihzZWxmLm9ucmVhZHlzdGF0ZWNoYW5nZSl7XCIsXCIgICAgICAgICAgc2VsZi5vbnJlYWR5c3RhdGVjaGFuZ2UoKTtcIixcIiAgICAgIH1cIixcIiAgfTtcIixcIn07XCIsXCJcIixcIlhEb21haW5SZXF1ZXN0V3JhcHBlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBhc3luKXtcIixcIiAgdGhpcy54ZHIub3BlbihtZXRob2QsIHVybCk7XCIsXCJ9O1wiLFwiXCIsXCJYRG9tYWluUmVxdWVzdFdyYXBwZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKXtcIixcIiAgdGhpcy54ZHIuc2VuZChkYXRhKTtcIixcIn07XCIsXCJcIixcIlhEb21haW5SZXF1ZXN0V3JhcHBlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1wiLFwiICB0aGlzLnhkci5hYm9ydCgpO1wiLFwifTtcIixcIlwiLFwiWERvbWFpblJlcXVlc3RXcmFwcGVyLnByb3RvdHlwZS5zZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24obiwgdil7XCIsXCIgIC8vbm90IHN1cHBvcnRlZCBieSB4ZHJcIixcIiAgLy9Hb29kIGRvYyBvbiBsaW1pdGF0aW9ucyBvZiBYRG9tYWluUmVxdWVzdCBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XCIsXCIgIC8vWERvbWFpblJlcXVlc3QgZG9lc24ndCBhbGxvdyBzZXR0aW5nIGN1c3RvbSByZXF1ZXN0IGhlYWRlcnMuIEJ1dCBpdCBpcyB0aGUgb25seSBhdmFpbGFibGUgb3B0aW9uIHRvIGRvIENPUlMgcmVxdWVzdHMgaW4gSUU4ICZhbXA7IDkuIEluIElFMTAsIHRoZXkgZmluYWxseSBzdGFydCB0byB1c2Ugc3RhbmRhcmQgWE1MSHR0cFJlcXVlc3QuXCIsXCIgIC8vVG8gc3VwcG9ydCBGSCBhdXRoIHRva2VucyBpbiBJRTgmYW1wOzksIHdlIGhhdmUgdG8gZmluZCBhIGRpZmZlcmVudCB3YXkgb2YgZG9pbmcgaXQuXCIsXCJ9O1wiLFwiXCIsXCJYRG9tYWluUmVxdWVzdFdyYXBwZXIucHJvdG90eXBlLmdldFJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24obil7XCIsXCIgIC8vbm90IHN1cHBvcnRlZCBieSB4ZHJcIixcIn07XCIsXCJcIixcIm1vZHVsZS5leHBvcnRzID0gWERvbWFpblJlcXVlc3RXcmFwcGVyO1wiXTtcbiIsIi8qIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IEpTQ292ZXJhZ2UgLSBkbyBub3QgZWRpdCAqL1xuaWYgKHR5cGVvZiBfJGpzY292ZXJhZ2UgPT09ICd1bmRlZmluZWQnKSBfJGpzY292ZXJhZ2UgPSB7fTtcbmlmICghIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ10pIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzI1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzM4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs0MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzQzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNDZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs0OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzQ5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs1Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzU1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs1OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzY0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs2Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzY3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs3MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzcxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs3NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzc1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs3N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzc4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bODBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs4MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzgyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bODNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs4NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzg1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bODhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs4OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzkwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bOTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs5M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzk0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bOTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs5Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzk4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTAxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTAyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTAzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTA1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTA3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTEyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTEzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTE0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTE2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTE4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTE5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTIwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTIxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTI0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTI1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTI2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTI3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTI4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTI5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTMzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTM0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTM5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTQwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTQxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTQ1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTQ2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTUwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTUyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTUzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTU2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTU3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTYxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTYyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTYzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTY0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTY2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTY5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTcwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTcyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTczXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTc0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTc3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTc4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTc5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTgwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTgxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTg0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTg1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTg2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTg3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTg4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTkyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTk0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTk1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTk3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjAyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjAzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjEwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjEyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjE1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjE2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjE5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjIwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjIzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjI0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjI4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjMwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjMxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjMyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjM1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjM4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjM5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjQwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjQxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjQzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjQ2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjQ3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjQ5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjUwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjUzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjU0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjU2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjU5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjkwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjkxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjk3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjk4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzAyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzAzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzA0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzA2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzA4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzEyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzE1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzE2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzIyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzIzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzI0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzMzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzM0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzQxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzQzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzQ0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzQ1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzQ2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzQ4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzUwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzUyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzUzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzU0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzU4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzU5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzYwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzYxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzYzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzY0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzY3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzY4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzY5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzcwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzcxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzcyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzc0XSA9IDA7XG59XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzExXSsrO1xudmFyIGV2ZW50c0hhbmRsZXIgPSByZXF1aXJlKFwiLi9ldmVudHNcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzEyXSsrO1xudmFyIFhEb21haW5SZXF1ZXN0V3JhcHBlciA9IHJlcXVpcmUoXCIuL1hEb21haW5SZXF1ZXN0V3JhcHBlclwiKTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTNdKys7XG52YXIgY29uc3RzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxNF0rKztcbnZhciBsb2dnZXIgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE2XSsrO1xudmFyIHR5cGU7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE3XSsrO1xudHJ5IHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxOF0rKztcbiAgdHlwZSA9IHJlcXVpcmUoXCJ0eXBlLW9mXCIpO1xufVxuY2F0Y2ggKGV4KSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjFdKys7XG4gIHZhciByID0gcmVxdWlyZTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyMl0rKztcbiAgdHlwZSA9IHIoXCJ0eXBlXCIpO1xufVxuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyNV0rKztcbnZhciBqc29ucElEID0gMCwgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsIGtleSwgbmFtZSwgcnNjcmlwdCA9IC88c2NyaXB0XFxiW148XSooPzooPyE8XFwvc2NyaXB0Pik8W148XSopKjxcXC9zY3JpcHQ+L2dpLCBzY3JpcHRUeXBlUkUgPSAvXig/OnRleHR8YXBwbGljYXRpb24pXFwvamF2YXNjcmlwdC9pLCB4bWxUeXBlUkUgPSAvXig/OnRleHR8YXBwbGljYXRpb24pXFwveG1sL2ksIGpzb25UeXBlID0gXCJhcHBsaWNhdGlvbi9qc29uXCIsIGh0bWxUeXBlID0gXCJ0ZXh0L2h0bWxcIiwgYmxhbmtSRSA9IC9eXFxzKiQvO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszNl0rKztcbnZhciBhamF4ID0gbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszN10rKztcbiAgdmFyIHNldHRpbmdzID0gZXh0ZW5kKHt9LCBvcHRpb25zIHx8IHt9KTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszOF0rKztcbiAgZm9yIChrZXkgaW4gYWpheC5zZXR0aW5ncykge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzldKys7XG4gICAgaWYgKHNldHRpbmdzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszOV0rKztcbiAgICAgIHNldHRpbmdzW2tleV0gPSBhamF4LnNldHRpbmdzW2tleV07XG4gICAgfVxufVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzQxXSsrO1xuICBhamF4U3RhcnQoc2V0dGluZ3MpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzQzXSsrO1xuICBpZiAoISBzZXR0aW5ncy5jcm9zc0RvbWFpbikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNDNdKys7XG4gICAgc2V0dGluZ3MuY3Jvc3NEb21haW4gPSAvXihbXFx3LV0rOik/XFwvXFwvKFteXFwvXSspLy50ZXN0KHNldHRpbmdzLnVybCkgJiYgUmVnRXhwLiQyICE9IHdpbmRvdy5sb2NhdGlvbi5ob3N0O1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNDZdKys7XG4gIHZhciBkYXRhVHlwZSA9IHNldHRpbmdzLmRhdGFUeXBlLCBoYXNQbGFjZWhvbGRlciA9IC89XFw/Ly50ZXN0KHNldHRpbmdzLnVybCk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNDhdKys7XG4gIGlmIChkYXRhVHlwZSA9PSBcImpzb25wXCIgfHwgaGFzUGxhY2Vob2xkZXIpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzQ5XSsrO1xuICAgIGlmICghIGhhc1BsYWNlaG9sZGVyKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzUwXSsrO1xuICAgICAgc2V0dGluZ3MudXJsID0gYXBwZW5kUXVlcnkoc2V0dGluZ3MudXJsLCAoc2V0dGluZ3MuanNvbnA/IHNldHRpbmdzLmpzb25wOiBcIl9jYWxsYmFja1wiKSArIFwiPT9cIik7XG4gICAgfVxuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNTJdKys7XG4gICAgcmV0dXJuIGFqYXguSlNPTlAoc2V0dGluZ3MpO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNTVdKys7XG4gIGlmICghIHNldHRpbmdzLnVybCkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNTVdKys7XG4gICAgc2V0dGluZ3MudXJsID0gd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCk7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs1Nl0rKztcbiAgc2VyaWFsaXplRGF0YShzZXR0aW5ncyk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNThdKys7XG4gIHZhciBtaW1lID0gc2V0dGluZ3MuYWNjZXB0c1tkYXRhVHlwZV0sIGJhc2VIZWFkZXJzID0ge30sIHByb3RvY29sID0gL14oW1xcdy1dKzopXFwvXFwvLy50ZXN0KHNldHRpbmdzLnVybCk/IFJlZ0V4cC4kMTogd2luZG93LmxvY2F0aW9uLnByb3RvY29sLCB4aHIgPSBzZXR0aW5ncy54aHIoc2V0dGluZ3MuY3Jvc3NEb21haW4pLCBhYm9ydFRpbWVvdXQ7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNjRdKys7XG4gIGlmICghIHNldHRpbmdzLmNyb3NzRG9tYWluKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs2NF0rKztcbiAgICBiYXNlSGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs2NV0rKztcbiAgaWYgKG1pbWUpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzY2XSsrO1xuICAgIGJhc2VIZWFkZXJzLkFjY2VwdCA9IG1pbWU7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs2N10rKztcbiAgICBpZiAobWltZS5pbmRleE9mKFwiLFwiKSA+IC0xKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzY3XSsrO1xuICAgICAgbWltZSA9IG1pbWUuc3BsaXQoXCIsXCIsIDIpWzBdO1xuICAgIH1cbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzY4XSsrO1xuICAgIHhoci5vdmVycmlkZU1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlKG1pbWUpO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNzBdKys7XG4gIGlmIChzZXR0aW5ncy5jb250ZW50VHlwZSB8fCAoc2V0dGluZ3MuZGF0YSAmJiAhIHNldHRpbmdzLmZvcm1kYXRhICYmIHNldHRpbmdzLnR5cGUudG9VcHBlckNhc2UoKSAhPSBcIkdFVFwiKSkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNzFdKys7XG4gICAgYmFzZUhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSAoc2V0dGluZ3MuY29udGVudFR5cGUgfHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIik7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs3Ml0rKztcbiAgc2V0dGluZ3MuaGVhZGVycyA9IGV4dGVuZChiYXNlSGVhZGVycywgc2V0dGluZ3MuaGVhZGVycyB8fCB7fSk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNzRdKys7XG4gIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzc1XSsrO1xuICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNzZdKys7XG4gICAgY2xlYXJUaW1lb3V0KGFib3J0VGltZW91dCk7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs3N10rKztcbiAgICB2YXIgcmVzdWx0LCBlcnJvciA9IGZhbHNlO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bNzhdKys7XG4gICAgaWYgKHNldHRpbmdzLnRyeUpTT05QKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzgwXSsrO1xuICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDAgJiYgc2V0dGluZ3MuY3Jvc3NEb21haW4gJiYgISB4aHIuaXNUaW1lb3V0ICYmIHByb3RvY29sICE9IFwiZmlsZTpcIikge1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzgxXSsrO1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJyZXRyeSBhamF4IGNhbGwgd2l0aCBqc29ucFwiKTtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs4Ml0rKztcbiAgICAgICAgc2V0dGluZ3MudHlwZSA9IFwiR0VUXCI7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bODNdKys7XG4gICAgICAgIHNldHRpbmdzLmRhdGFUeXBlID0gXCJqc29ucFwiO1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzg0XSsrO1xuICAgICAgICBzZXR0aW5ncy5kYXRhID0gXCJfanNvbnBkYXRhPVwiICsgc2V0dGluZ3MuZGF0YTtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs4NV0rKztcbiAgICAgICAgcmV0dXJuIGFqYXgoc2V0dGluZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzg4XSsrO1xuICAgIGlmICgoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkgfHwgeGhyLnN0YXR1cyA9PSAzMDQgfHwgKHhoci5zdGF0dXMgPT0gMCAmJiBwcm90b2NvbCA9PSBcImZpbGU6XCIpKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzg5XSsrO1xuICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZSB8fCBtaW1lVG9EYXRhVHlwZSh4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJjb250ZW50LXR5cGVcIikpO1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs5MF0rKztcbiAgICAgIHJlc3VsdCA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzkxXSsrO1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiYWpheCByZXNwb25zZSA6OiBzdGF0dXMgPSBcIiArIHhoci5zdGF0dXMgKyBcIiA6OiBib2R5ID0gXCIgKyByZXN1bHQpO1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs5M10rKztcbiAgICAgIHRyeSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bOTRdKys7XG4gICAgICAgIGlmIChkYXRhVHlwZSA9PSBcInNjcmlwdFwiKSB7XG4gICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs5NF0rKztcbiAgICAgICAgICAoMSwgZXZhbCkocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzk1XSsrO1xuICAgICAgICAgIGlmIChkYXRhVHlwZSA9PSBcInhtbFwiKSB7XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzk1XSsrO1xuICAgICAgICAgICAgcmVzdWx0ID0geGhyLnJlc3BvbnNlWE1MO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bOTZdKys7XG4gICAgICAgICAgICBpZiAoZGF0YVR5cGUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVs5Nl0rKztcbiAgICAgICAgICAgICAgcmVzdWx0ID0gYmxhbmtSRS50ZXN0KHJlc3VsdCk/IG51bGw6IEpTT04ucGFyc2UocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bOThdKys7XG4gICAgICAgIGVycm9yID0gZTtcbiAgICAgIH1cbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTAxXSsrO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTAyXSsrO1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJhamF4IGVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxMDNdKys7XG4gICAgICAgIGFqYXhFcnJvcihlcnJvciwgXCJwYXJzZXJlcnJvclwiLCB4aHIsIHNldHRpbmdzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzEwNV0rKztcbiAgICAgICAgYWpheFN1Y2Nlc3MocmVzdWx0LCB4aHIsIHNldHRpbmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzEwN10rKztcbiAgICAgIGFqYXhFcnJvcihudWxsLCBcImVycm9yXCIsIHhociwgc2V0dGluZ3MpO1xuICAgIH1cbiAgfVxufSk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTEyXSsrO1xuICB2YXIgYXN5bmMgPSBcImFzeW5jXCIgaW4gc2V0dGluZ3M/IHNldHRpbmdzLmFzeW5jOiB0cnVlO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzExM10rKztcbiAgbG9nZ2VyLmRlYnVnKFwiYWpheCBjYWxsIHNldHRpbmdzXCIsIHNldHRpbmdzKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxMTRdKys7XG4gIHhoci5vcGVuKHNldHRpbmdzLnR5cGUsIHNldHRpbmdzLnVybCwgYXN5bmMpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzExNl0rKztcbiAgZm9yIChuYW1lIGluIHNldHRpbmdzLmhlYWRlcnMpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzExNl0rKztcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBzZXR0aW5ncy5oZWFkZXJzW25hbWVdKTtcbn1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxMThdKys7XG4gIGlmIChhamF4QmVmb3JlU2VuZCh4aHIsIHNldHRpbmdzKSA9PT0gZmFsc2UpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzExOV0rKztcbiAgICBsb2dnZXIuZGVidWcoXCJhamF4IGNhbGwgaXMgYWJvcnRlZCBkdWUgdG8gYWpheEJlZm9yZVNlbmRcIik7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxMjBdKys7XG4gICAgeGhyLmFib3J0KCk7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxMjFdKys7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTI0XSsrO1xuICBpZiAoc2V0dGluZ3MudGltZW91dCA+IDApIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzEyNF0rKztcbiAgICBhYm9ydFRpbWVvdXQgPSBzZXRUaW1lb3V0KChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTI1XSsrO1xuICBsb2dnZXIuZGVidWcoXCJhamF4IGNhbGwgdGltZWQgb3V0XCIpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzEyNl0rKztcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzEyN10rKztcbiAgeGhyLmFib3J0KCk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTI4XSsrO1xuICB4aHIuaXNUaW1lb3V0ID0gdHJ1ZTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxMjldKys7XG4gIGFqYXhFcnJvcihudWxsLCBcInRpbWVvdXRcIiwgeGhyLCBzZXR0aW5ncyk7XG59KSwgc2V0dGluZ3MudGltZW91dCk7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxMzNdKys7XG4gIHhoci5zZW5kKHNldHRpbmdzLmRhdGE/IHNldHRpbmdzLmRhdGE6IG51bGwpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzEzNF0rKztcbiAgcmV0dXJuIHhocjtcbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxMzldKys7XG5mdW5jdGlvbiB0cmlnZ2VyQW5kUmV0dXJuKGNvbnRleHQsIGV2ZW50TmFtZSwgZGF0YSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE0MF0rKztcbiAgZXZlbnRzSGFuZGxlci5lbWl0KGV2ZW50TmFtZSwgZGF0YSk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTQxXSsrO1xuICByZXR1cm4gdHJ1ZTtcbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTQ1XSsrO1xuZnVuY3Rpb24gdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgZXZlbnROYW1lLCBkYXRhKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTQ2XSsrO1xuICBpZiAoc2V0dGluZ3MuZ2xvYmFsKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxNDZdKys7XG4gICAgcmV0dXJuIHRyaWdnZXJBbmRSZXR1cm4oY29udGV4dCB8fCBkb2N1bWVudCwgZXZlbnROYW1lLCBkYXRhKTtcbiAgfVxufVxuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxNTBdKys7XG5hamF4LmFjdGl2ZSA9IDA7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE1Ml0rKztcbmZ1bmN0aW9uIGFqYXhTdGFydChzZXR0aW5ncykge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE1M10rKztcbiAgaWYgKHNldHRpbmdzLmdsb2JhbCAmJiBhamF4LmFjdGl2ZSsrID09PSAwKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxNTNdKys7XG4gICAgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgbnVsbCwgXCJhamF4U3RhcnRcIik7XG4gIH1cbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTU2XSsrO1xuZnVuY3Rpb24gYWpheFN0b3Aoc2V0dGluZ3MpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxNTddKys7XG4gIGlmIChzZXR0aW5ncy5nbG9iYWwgJiYgISAoLS1hamF4LmFjdGl2ZSkpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE1N10rKztcbiAgICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBudWxsLCBcImFqYXhTdG9wXCIpO1xuICB9XG59XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE2MV0rKztcbmZ1bmN0aW9uIGFqYXhCZWZvcmVTZW5kKHhociwgc2V0dGluZ3MpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxNjJdKys7XG4gIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxNjNdKys7XG4gIGlmIChzZXR0aW5ncy5iZWZvcmVTZW5kLmNhbGwoY29udGV4dCwgeGhyLCBzZXR0aW5ncykgPT09IGZhbHNlKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxNjRdKys7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTY2XSsrO1xuICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCBcImFqYXhTZW5kXCIsIFt4aHIsIHNldHRpbmdzXSk7XG59XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE2OV0rKztcbmZ1bmN0aW9uIGFqYXhTdWNjZXNzKGRhdGEsIHhociwgc2V0dGluZ3MpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxNzBdKys7XG4gIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dCwgc3RhdHVzID0gXCJzdWNjZXNzXCI7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTcyXSsrO1xuICBzZXR0aW5ncy5zdWNjZXNzLmNhbGwoY29udGV4dCwgZGF0YSwgc3RhdHVzLCB4aHIpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE3M10rKztcbiAgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgXCJhamF4U3VjY2Vzc1wiLCBbeGhyLCBzZXR0aW5ncywgZGF0YV0pO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE3NF0rKztcbiAgYWpheENvbXBsZXRlKHN0YXR1cywgeGhyLCBzZXR0aW5ncyk7XG59XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE3N10rKztcbmZ1bmN0aW9uIGFqYXhFcnJvcihlcnJvciwgdHlwZSwgeGhyLCBzZXR0aW5ncykge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE3OF0rKztcbiAgdmFyIGNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0O1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE3OV0rKztcbiAgc2V0dGluZ3MuZXJyb3IuY2FsbChjb250ZXh0LCB4aHIsIHR5cGUsIGVycm9yKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxODBdKys7XG4gIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsIFwiYWpheEVycm9yXCIsIFt4aHIsIHNldHRpbmdzLCBlcnJvcl0pO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE4MV0rKztcbiAgYWpheENvbXBsZXRlKHR5cGUsIHhociwgc2V0dGluZ3MpO1xufVxuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxODRdKys7XG5mdW5jdGlvbiBhamF4Q29tcGxldGUoc3RhdHVzLCB4aHIsIHNldHRpbmdzKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTg1XSsrO1xuICB2YXIgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHQ7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTg2XSsrO1xuICBzZXR0aW5ncy5jb21wbGV0ZS5jYWxsKGNvbnRleHQsIHhociwgc3RhdHVzKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxODddKys7XG4gIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsIFwiYWpheENvbXBsZXRlXCIsIFt4aHIsIHNldHRpbmdzXSk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTg4XSsrO1xuICBhamF4U3RvcChzZXR0aW5ncyk7XG59XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE5Ml0rKztcbmZ1bmN0aW9uIGVtcHR5KCkge1xufVxuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsxOTRdKys7XG5hamF4LkpTT05QID0gKGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMTk1XSsrO1xuICBpZiAoISAoXCJ0eXBlXCIgaW4gb3B0aW9ucykpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE5NV0rKztcbiAgICByZXR1cm4gYWpheChvcHRpb25zKTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzE5N10rKztcbiAgdmFyIGNhbGxiYWNrTmFtZSA9IFwianNvbnBcIiArICgrK2pzb25wSUQpLCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpLCBhYm9ydCA9IChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjAyXSsrO1xuICBpZiAoY2FsbGJhY2tOYW1lIGluIHdpbmRvdykge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjAyXSsrO1xuICAgIHdpbmRvd1tjYWxsYmFja05hbWVdID0gZW1wdHk7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyMDNdKys7XG4gIGFqYXhDb21wbGV0ZShcImFib3J0XCIsIHhociwgb3B0aW9ucyk7XG59KSwgeGhyID0ge2Fib3J0OiBhYm9ydH0sIGFib3J0VGltZW91dCwgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjEwXSsrO1xuICBpZiAob3B0aW9ucy5lcnJvcikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjEwXSsrO1xuICAgIHNjcmlwdC5vbmVycm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyMTFdKys7XG4gIHhoci5hYm9ydCgpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzIxMl0rKztcbiAgb3B0aW9ucy5lcnJvcigpO1xufSk7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyMTVdKys7XG4gIHdpbmRvd1tjYWxsYmFja05hbWVdID0gKGZ1bmN0aW9uIChkYXRhKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjE2XSsrO1xuICBjbGVhclRpbWVvdXQoYWJvcnRUaW1lb3V0KTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyMTldKys7XG4gIGRlbGV0ZSB3aW5kb3dbY2FsbGJhY2tOYW1lXTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyMjBdKys7XG4gIGFqYXhTdWNjZXNzKGRhdGEsIHhociwgb3B0aW9ucyk7XG59KTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyMjNdKys7XG4gIHNlcmlhbGl6ZURhdGEob3B0aW9ucyk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjI0XSsrO1xuICBzY3JpcHQuc3JjID0gb3B0aW9ucy51cmwucmVwbGFjZSgvPVxcPy8sIFwiPVwiICsgY2FsbGJhY2tOYW1lKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyMjhdKys7XG4gIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyMzBdKys7XG4gIGlmIChvcHRpb25zLnRpbWVvdXQgPiAwKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyMzBdKys7XG4gICAgYWJvcnRUaW1lb3V0ID0gc2V0VGltZW91dCgoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzIzMV0rKztcbiAgeGhyLmFib3J0KCk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjMyXSsrO1xuICBhamF4Q29tcGxldGUoXCJ0aW1lb3V0XCIsIHhociwgb3B0aW9ucyk7XG59KSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzIzNV0rKztcbiAgcmV0dXJuIHhocjtcbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyMzhdKys7XG5mdW5jdGlvbiBpc0lFKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzIzOV0rKztcbiAgdmFyIGllID0gZmFsc2U7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjQwXSsrO1xuICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpID49IDApIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzI0MV0rKztcbiAgICBpZSA9IHRydWU7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyNDNdKys7XG4gIHJldHVybiBpZTtcbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjQ2XSsrO1xuZnVuY3Rpb24gZ2V0WGhyKGNyb3NzRG9tYWluKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjQ3XSsrO1xuICB2YXIgeGhyID0gbnVsbDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyNDldKys7XG4gIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzI1MF0rKztcbiAgICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzI1M10rKztcbiAgaWYgKGlzSUUoKSAmJiAoY3Jvc3NEb21haW4gPT09IHRydWUpICYmIHR5cGVvZiB3aW5kb3cuWERvbWFpblJlcXVlc3QgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzI1NF0rKztcbiAgICB4aHIgPSBuZXcgWERvbWFpblJlcXVlc3RXcmFwcGVyKG5ldyBYRG9tYWluUmVxdWVzdCgpKTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzI1Nl0rKztcbiAgcmV0dXJuIHhocjtcbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjU5XSsrO1xuYWpheC5zZXR0aW5ncyA9IHt0eXBlOiBcIkdFVFwiLCBiZWZvcmVTZW5kOiBlbXB0eSwgc3VjY2VzczogZW1wdHksIGVycm9yOiBlbXB0eSwgY29tcGxldGU6IGVtcHR5LCBjb250ZXh0OiBudWxsLCBnbG9iYWw6IHRydWUsIHhocjogZ2V0WGhyLCBhY2NlcHRzOiB7c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdFwiLCBqc29uOiBqc29uVHlwZSwgeG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIiwgaHRtbDogaHRtbFR5cGUsIHRleHQ6IFwidGV4dC9wbGFpblwifSwgY3Jvc3NEb21haW46IGZhbHNlLCB0aW1lb3V0OiBjb25zdHMuZmhfdGltZW91dH07XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzI5MF0rKztcbmZ1bmN0aW9uIG1pbWVUb0RhdGFUeXBlKG1pbWUpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVsyOTFdKys7XG4gIHJldHVybiBtaW1lICYmIChtaW1lID09IGh0bWxUeXBlPyBcImh0bWxcIjogbWltZSA9PSBqc29uVHlwZT8gXCJqc29uXCI6IHNjcmlwdFR5cGVSRS50ZXN0KG1pbWUpPyBcInNjcmlwdFwiOiB4bWxUeXBlUkUudGVzdChtaW1lKSAmJiBcInhtbFwiKSB8fCBcInRleHRcIjtcbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMjk3XSsrO1xuZnVuY3Rpb24gYXBwZW5kUXVlcnkodXJsLCBxdWVyeSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzI5OF0rKztcbiAgcmV0dXJuICh1cmwgKyBcIiZcIiArIHF1ZXJ5KS5yZXBsYWNlKC9bJj9dezEsMn0vLCBcIj9cIik7XG59XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzMwMl0rKztcbmZ1bmN0aW9uIHNlcmlhbGl6ZURhdGEob3B0aW9ucykge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzMwM10rKztcbiAgaWYgKHR5cGUob3B0aW9ucy5kYXRhKSA9PT0gXCJvYmplY3RcIikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzA0XSsrO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kYXRhLmFwcGVuZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzMwNl0rKztcbiAgICAgIG9wdGlvbnMuZm9ybWRhdGEgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzA4XSsrO1xuICAgICAgb3B0aW9ucy5kYXRhID0gcGFyYW0ob3B0aW9ucy5kYXRhKTtcbiAgICB9XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszMTFdKys7XG4gIGlmIChvcHRpb25zLmRhdGEgJiYgKCEgb3B0aW9ucy50eXBlIHx8IG9wdGlvbnMudHlwZS50b1VwcGVyQ2FzZSgpID09IFwiR0VUXCIpKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszMTJdKys7XG4gICAgb3B0aW9ucy51cmwgPSBhcHBlbmRRdWVyeShvcHRpb25zLnVybCwgb3B0aW9ucy5kYXRhKTtcbiAgfVxufVxuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszMTVdKys7XG5hamF4LmdldCA9IChmdW5jdGlvbiAodXJsLCBzdWNjZXNzKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzE2XSsrO1xuICByZXR1cm4gYWpheCh7dXJsOiB1cmwsIHN1Y2Nlc3M6IHN1Y2Nlc3N9KTtcbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszMjJdKys7XG5hamF4LnBvc3QgPSAoZnVuY3Rpb24gKHVybCwgZGF0YSwgc3VjY2VzcywgZGF0YVR5cGUpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszMjNdKys7XG4gIGlmICh0eXBlKGRhdGEpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzMyM10rKztcbiAgICBkYXRhVHlwZSA9IGRhdGFUeXBlIHx8IHN1Y2Nlc3MsIHN1Y2Nlc3MgPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzMyNF0rKztcbiAgcmV0dXJuIGFqYXgoe3R5cGU6IFwiUE9TVFwiLCB1cmw6IHVybCwgZGF0YTogZGF0YSwgc3VjY2Vzczogc3VjY2VzcywgZGF0YVR5cGU6IGRhdGFUeXBlfSk7XG59KTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzMzXSsrO1xuYWpheC5nZXRKU09OID0gKGZ1bmN0aW9uICh1cmwsIHN1Y2Nlc3MpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszMzRdKys7XG4gIHJldHVybiBhamF4KHt1cmw6IHVybCwgc3VjY2Vzczogc3VjY2VzcywgZGF0YVR5cGU6IFwianNvblwifSk7XG59KTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzQxXSsrO1xudmFyIGVzY2FwZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzQzXSsrO1xuZnVuY3Rpb24gc2VyaWFsaXplKHBhcmFtcywgb2JqLCB0cmFkaXRpb25hbCwgc2NvcGUpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszNDRdKys7XG4gIHZhciBhcnJheSA9IHR5cGUob2JqKSA9PT0gXCJhcnJheVwiO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzM0NV0rKztcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzQ2XSsrO1xuICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzQ4XSsrO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszNDhdKys7XG4gICAgICBrZXkgPSB0cmFkaXRpb25hbD8gc2NvcGU6IHNjb3BlICsgXCJbXCIgKyAoYXJyYXk/IFwiXCI6IGtleSkgKyBcIl1cIjtcbiAgICB9XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszNTBdKys7XG4gICAgaWYgKCEgc2NvcGUgJiYgYXJyYXkpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzUwXSsrO1xuICAgICAgcGFyYW1zLmFkZCh2YWx1ZS5uYW1lLCB2YWx1ZS52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszNTJdKys7XG4gICAgICBpZiAodHJhZGl0aW9uYWw/ICh0eXBlKHZhbHVlKSA9PT0gXCJhcnJheVwiKTogKHR5cGUodmFsdWUpID09PSBcIm9iamVjdFwiKSkge1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzM1M10rKztcbiAgICAgICAgc2VyaWFsaXplKHBhcmFtcywgdmFsdWUsIHRyYWRpdGlvbmFsLCBrZXkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzU0XSsrO1xuICAgICAgICBwYXJhbXMuYWRkKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbn1cbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzU4XSsrO1xuZnVuY3Rpb24gcGFyYW0ob2JqLCB0cmFkaXRpb25hbCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzM1OV0rKztcbiAgdmFyIHBhcmFtcyA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzM2MF0rKztcbiAgcGFyYW1zLmFkZCA9IChmdW5jdGlvbiAoaywgdikge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzM2MV0rKztcbiAgdGhpcy5wdXNoKGVzY2FwZShrKSArIFwiPVwiICsgZXNjYXBlKHYpKTtcbn0pO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzM2M10rKztcbiAgc2VyaWFsaXplKHBhcmFtcywgb2JqLCB0cmFkaXRpb25hbCk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzY0XSsrO1xuICByZXR1cm4gcGFyYW1zLmpvaW4oXCImXCIpLnJlcGxhY2UoXCIlMjBcIiwgXCIrXCIpO1xufVxuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszNjddKys7XG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0KSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzY4XSsrO1xuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzY5XSsrO1xuICBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkuZm9yRWFjaCgoZnVuY3Rpb24gKHNvdXJjZSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYWpheC5qcyddWzM3MF0rKztcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXVszNzFdKys7XG4gICAgaWYgKHNvdXJjZVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzcyXSsrO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG59XG59KSk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hamF4LmpzJ11bMzc0XSsrO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FqYXguanMnXS5zb3VyY2UgPSBbXCIvL2Egc2hhbWVsZXNzIGNvcHkgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vRm9yYmVzTGluZGVzYXkvYWpheC9ibG9iL21hc3Rlci9pbmRleC5qcy4gXCIsXCIvL2l0IGhhcyB0aGUgc2FtZSBtZXRob2RzIGFuZCBjb25maWcgb3B0aW9ucyBhcyBqUXVlcnkvemVwdG9qcyBidXQgdmVyeSBsaWdodCB3ZWlnaHQuIHNlZSBodHRwOi8vYXBpLmpxdWVyeS5jb20valF1ZXJ5LmFqYXgvXCIsXCIvL2EgZmV3IHNtYWxsIGNoYW5nZXMgYXJlIG1hZGUgZm9yIHN1cHBvcnRpbmcgSUUgOCBhbmQgb3RoZXIgZmVhdHVyZXM6XCIsXCIvLzEuIHVzZSBnZXRYaHIgZnVuY3Rpb24gdG8gcmVwbGFjZSB0aGUgZGVmYXVsdCBYTUxIdHRwUmVxdWVzdCBpbXBsZW1lbnRhdGlvbiBmb3Igc3VwcG9ydGluZyBJRThcIixcIi8vMi4gSW50ZWdyYXRlIHdpdGggZXZlbnRzIGVtaXR0ZXIuIFNvIHRvIHN1YnNjcmliZSBhamF4IGV2ZW50cywgeW91IGNhbiBkbyAkZmgub24oXFxcImFqYXhTdGFydFxcXCIsIGhhbmRsZXIpLiBTZWUgaHR0cDovL2FwaS5qcXVlcnkuY29tL0FqYXhfRXZlbnRzLyBmb3IgZnVsbCBsaXN0IG9mIGV2ZW50c1wiLFwiLy8zLiBhbGxvdyBwYXNzaW5nIHhociBmYWN0b3J5IG1ldGhvZCB0aHJvdWdoIG9wdGlvbnM6IGUuZy4gJGZoLmFqYXgoe3hocjogZnVuY3Rpb24oKXsvKm93biBpbXBsZW1lbnRhdGlvbiBvZiB4aHIqL319KTsgXCIsXCIvLzQuIFVzZSBmaF90aW1lb3V0IHZhbHVlIGFzIHRoZSBkZWZhdWx0IHRpbWVvdXRcIixcIi8vNS4gYW4gZXh0cmEgb3B0aW9uIGNhbGxlZCBcXFwidHJ5SlNPTlBcXFwiIHRvIGFsbG93IHRyeSB0aGUgc2FtZSBjYWxsIHdpdGggSlNPTlAgaWYgbm9ybWFsIENPUlMgZmFpbGVkIC0gc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnRlcm5hbGx5XCIsXCIvLzYuIGZvciBqc29ucCwgYWxsb3cgdG8gc3BlY2lmeSB0aGUgY2FsbGJhY2sgcXVlcnkgcGFyYW0gbmFtZSB1c2luZyB0aGUgXFxcImpzb25wXFxcIiBvcHRpb25cIixcIlwiLFwidmFyIGV2ZW50c0hhbmRsZXIgPSByZXF1aXJlKFxcXCIuL2V2ZW50c1xcXCIpO1wiLFwidmFyIFhEb21haW5SZXF1ZXN0V3JhcHBlciA9IHJlcXVpcmUoXFxcIi4vWERvbWFpblJlcXVlc3RXcmFwcGVyXFxcIik7XCIsXCJ2YXIgY29uc3RzID0gcmVxdWlyZShcXFwiLi9jb25zdGFudHNcXFwiKTtcIixcInZhciBsb2dnZXIgPSByZXF1aXJlKFxcXCIuL2xvZ2dlclxcXCIpO1wiLFwiXCIsXCJ2YXIgdHlwZVwiLFwidHJ5IHtcIixcIiAgdHlwZSA9IHJlcXVpcmUoJ3R5cGUtb2YnKVwiLFwifSBjYXRjaCAoZXgpIHtcIixcIiAgLy9oaWRlIGZyb20gYnJvd3NlcmlmeVwiLFwiICB2YXIgciA9IHJlcXVpcmVcIixcIiAgdHlwZSA9IHIoJ3R5cGUnKVwiLFwifVwiLFwiXCIsXCJ2YXIganNvbnBJRCA9IDAsXCIsXCIgIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFwiLFwiICBrZXksXCIsXCIgIG5hbWUsXCIsXCIgIHJzY3JpcHQgPSAvJmx0O3NjcmlwdFxcXFxiW14mbHQ7XSooPzooPyEmbHQ7XFxcXC9zY3JpcHQmZ3Q7KSZsdDtbXiZsdDtdKikqJmx0O1xcXFwvc2NyaXB0Jmd0Oy9naSxcIixcIiAgc2NyaXB0VHlwZVJFID0gL14oPzp0ZXh0fGFwcGxpY2F0aW9uKVxcXFwvamF2YXNjcmlwdC9pLFwiLFwiICB4bWxUeXBlUkUgPSAvXig/OnRleHR8YXBwbGljYXRpb24pXFxcXC94bWwvaSxcIixcIiAganNvblR5cGUgPSAnYXBwbGljYXRpb24vanNvbicsXCIsXCIgIGh0bWxUeXBlID0gJ3RleHQvaHRtbCcsXCIsXCIgIGJsYW5rUkUgPSAvXlxcXFxzKiQvO1wiLFwiXCIsXCJ2YXIgYWpheCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcIixcIiAgdmFyIHNldHRpbmdzID0gZXh0ZW5kKHt9LCBvcHRpb25zIHx8IHt9KVwiLFwiICBmb3IgKGtleSBpbiBhamF4LnNldHRpbmdzKVwiLFwiICAgIGlmIChzZXR0aW5nc1trZXldID09PSB1bmRlZmluZWQpIHNldHRpbmdzW2tleV0gPSBhamF4LnNldHRpbmdzW2tleV1cIixcIlwiLFwiICBhamF4U3RhcnQoc2V0dGluZ3MpXCIsXCJcIixcIiAgaWYgKCFzZXR0aW5ncy5jcm9zc0RvbWFpbikgc2V0dGluZ3MuY3Jvc3NEb21haW4gPSAvXihbXFxcXHctXSs6KT9cXFxcL1xcXFwvKFteXFxcXC9dKykvLnRlc3Qoc2V0dGluZ3MudXJsKSAmYW1wOyZhbXA7XCIsXCIgICAgUmVnRXhwLiQyICE9IHdpbmRvdy5sb2NhdGlvbi5ob3N0XCIsXCJcIixcIiAgdmFyIGRhdGFUeXBlID0gc2V0dGluZ3MuZGF0YVR5cGUsXCIsXCIgICAgaGFzUGxhY2Vob2xkZXIgPSAvPVxcXFw/Ly50ZXN0KHNldHRpbmdzLnVybClcIixcIiAgICBpZiAoZGF0YVR5cGUgPT0gJ2pzb25wJyB8fCBoYXNQbGFjZWhvbGRlcikge1wiLFwiICAgICAgaWYgKCFoYXNQbGFjZWhvbGRlcikge1wiLFwiICAgICAgICBzZXR0aW5ncy51cmwgPSBhcHBlbmRRdWVyeShzZXR0aW5ncy51cmwsIChzZXR0aW5ncy5qc29ucD8gc2V0dGluZ3MuanNvbnA6ICdfY2FsbGJhY2snKSArICc9PycpO1wiLFwiICAgICAgfVwiLFwiICAgICAgcmV0dXJuIGFqYXguSlNPTlAoc2V0dGluZ3MpXCIsXCIgICAgfVwiLFwiXCIsXCIgIGlmICghc2V0dGluZ3MudXJsKSBzZXR0aW5ncy51cmwgPSB3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKVwiLFwiICBzZXJpYWxpemVEYXRhKHNldHRpbmdzKVwiLFwiXCIsXCIgIHZhciBtaW1lID0gc2V0dGluZ3MuYWNjZXB0c1tkYXRhVHlwZV0sXCIsXCIgICAgYmFzZUhlYWRlcnMgPSB7fSxcIixcIiAgICBwcm90b2NvbCA9IC9eKFtcXFxcdy1dKzopXFxcXC9cXFxcLy8udGVzdChzZXR0aW5ncy51cmwpID8gUmVnRXhwLiQxIDogd2luZG93LmxvY2F0aW9uLnByb3RvY29sLFwiLFwiICAgIHhociA9IHNldHRpbmdzLnhocihzZXR0aW5ncy5jcm9zc0RvbWFpbiksXCIsXCIgICAgYWJvcnRUaW1lb3V0XCIsXCJcIixcIiAgaWYgKCFzZXR0aW5ncy5jcm9zc0RvbWFpbikgYmFzZUhlYWRlcnNbJ1gtUmVxdWVzdGVkLVdpdGgnXSA9ICdYTUxIdHRwUmVxdWVzdCdcIixcIiAgaWYgKG1pbWUpIHtcIixcIiAgICBiYXNlSGVhZGVyc1snQWNjZXB0J10gPSBtaW1lXCIsXCIgICAgaWYgKG1pbWUuaW5kZXhPZignLCcpICZndDsgLTEpIG1pbWUgPSBtaW1lLnNwbGl0KCcsJywgMilbMF1cIixcIiAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSAmYW1wOyZhbXA7IHhoci5vdmVycmlkZU1pbWVUeXBlKG1pbWUpXCIsXCIgIH1cIixcIiAgaWYgKHNldHRpbmdzLmNvbnRlbnRUeXBlIHx8IChzZXR0aW5ncy5kYXRhICZhbXA7JmFtcDsgIXNldHRpbmdzLmZvcm1kYXRhICZhbXA7JmFtcDsgc2V0dGluZ3MudHlwZS50b1VwcGVyQ2FzZSgpICE9ICdHRVQnKSlcIixcIiAgICBiYXNlSGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAoc2V0dGluZ3MuY29udGVudFR5cGUgfHwgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpXCIsXCIgIHNldHRpbmdzLmhlYWRlcnMgPSBleHRlbmQoYmFzZUhlYWRlcnMsIHNldHRpbmdzLmhlYWRlcnMgfHwge30pXCIsXCJcIixcIiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcIixcIiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1wiLFwiICAgICAgY2xlYXJUaW1lb3V0KGFib3J0VGltZW91dClcIixcIiAgICAgIHZhciByZXN1bHQsIGVycm9yID0gZmFsc2VcIixcIiAgICAgIGlmKHNldHRpbmdzLnRyeUpTT05QKXtcIixcIiAgICAgICAgLy9jaGVjayBpZiB0aGUgcmVxdWVzdCBoYXMgZmFpbC4gSW4gc29tZSBjYXNlcywgd2UgbWF5IHdhbnQgdG8gdHJ5IGpzb25wIGFzIHdlbGwuIEFnYWluLCBGSCBvbmx5Li4uXCIsXCIgICAgICAgIGlmKHhoci5zdGF0dXMgPT09IDAgJmFtcDsmYW1wOyBzZXR0aW5ncy5jcm9zc0RvbWFpbiAmYW1wOyZhbXA7ICF4aHIuaXNUaW1lb3V0ICZhbXA7JmFtcDsgIHByb3RvY29sICE9ICdmaWxlOicpe1wiLFwiICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcXFwicmV0cnkgYWpheCBjYWxsIHdpdGgganNvbnBcXFwiKVwiLFwiICAgICAgICAgIHNldHRpbmdzLnR5cGUgPSBcXFwiR0VUXFxcIjtcIixcIiAgICAgICAgICBzZXR0aW5ncy5kYXRhVHlwZSA9IFxcXCJqc29ucFxcXCI7XCIsXCIgICAgICAgICAgc2V0dGluZ3MuZGF0YSA9IFxcXCJfanNvbnBkYXRhPVxcXCIgKyBzZXR0aW5ncy5kYXRhO1wiLFwiICAgICAgICAgIHJldHVybiBhamF4KHNldHRpbmdzKTtcIixcIiAgICAgICAgfVwiLFwiICAgICAgfVwiLFwiICAgICAgaWYgKCh4aHIuc3RhdHVzICZndDs9IDIwMCAmYW1wOyZhbXA7IHhoci5zdGF0dXMgJmx0OyAzMDApIHx8IHhoci5zdGF0dXMgPT0gMzA0IHx8ICh4aHIuc3RhdHVzID09IDAgJmFtcDsmYW1wOyBwcm90b2NvbCA9PSAnZmlsZTonKSkge1wiLFwiICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlIHx8IG1pbWVUb0RhdGFUeXBlKHhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJykpXCIsXCIgICAgICAgIHJlc3VsdCA9IHhoci5yZXNwb25zZVRleHRcIixcIiAgICAgICAgbG9nZ2VyLmRlYnVnKFxcXCJhamF4IHJlc3BvbnNlIDo6IHN0YXR1cyA9IFxcXCIgKyB4aHIuc3RhdHVzICsgXFxcIiA6OiBib2R5ID0gXFxcIiArIHJlc3VsdClcIixcIlwiLFwiICAgICAgICB0cnkge1wiLFwiICAgICAgICAgIGlmIChkYXRhVHlwZSA9PSAnc2NyaXB0JykoMSwgZXZhbCkocmVzdWx0KVwiLFwiICAgICAgICAgIGVsc2UgaWYgKGRhdGFUeXBlID09ICd4bWwnKSByZXN1bHQgPSB4aHIucmVzcG9uc2VYTUxcIixcIiAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PSAnanNvbicpIHJlc3VsdCA9IGJsYW5rUkUudGVzdChyZXN1bHQpID8gbnVsbCA6IEpTT04ucGFyc2UocmVzdWx0KVwiLFwiICAgICAgICB9IGNhdGNoIChlKSB7XCIsXCIgICAgICAgICAgZXJyb3IgPSBlXCIsXCIgICAgICAgIH1cIixcIlwiLFwiICAgICAgICBpZiAoZXJyb3IpIHtcIixcIiAgICAgICAgICBsb2dnZXIuZGVidWcoXFxcImFqYXggZXJyb3JcXFwiLCBlcnJvcik7XCIsXCIgICAgICAgICAgYWpheEVycm9yKGVycm9yLCAncGFyc2VyZXJyb3InLCB4aHIsIHNldHRpbmdzKVwiLFwiICAgICAgICB9XCIsXCIgICAgICAgIGVsc2UgYWpheFN1Y2Nlc3MocmVzdWx0LCB4aHIsIHNldHRpbmdzKVwiLFwiICAgICAgfSBlbHNlIHtcIixcIiAgICAgICAgYWpheEVycm9yKG51bGwsICdlcnJvcicsIHhociwgc2V0dGluZ3MpXCIsXCIgICAgICB9XCIsXCIgICAgfVwiLFwiICB9XCIsXCJcIixcIiAgdmFyIGFzeW5jID0gJ2FzeW5jJyBpbiBzZXR0aW5ncyA/IHNldHRpbmdzLmFzeW5jIDogdHJ1ZVwiLFwiICBsb2dnZXIuZGVidWcoXFxcImFqYXggY2FsbCBzZXR0aW5nc1xcXCIsIHNldHRpbmdzKVwiLFwiICB4aHIub3BlbihzZXR0aW5ncy50eXBlLCBzZXR0aW5ncy51cmwsIGFzeW5jKVwiLFwiXCIsXCIgIGZvciAobmFtZSBpbiBzZXR0aW5ncy5oZWFkZXJzKSB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBzZXR0aW5ncy5oZWFkZXJzW25hbWVdKVwiLFwiXCIsXCIgIGlmIChhamF4QmVmb3JlU2VuZCh4aHIsIHNldHRpbmdzKSA9PT0gZmFsc2UpIHtcIixcIiAgICBsb2dnZXIuZGVidWcoXFxcImFqYXggY2FsbCBpcyBhYm9ydGVkIGR1ZSB0byBhamF4QmVmb3JlU2VuZFxcXCIpXCIsXCIgICAgeGhyLmFib3J0KClcIixcIiAgICByZXR1cm4gZmFsc2VcIixcIiAgfVwiLFwiXCIsXCIgIGlmIChzZXR0aW5ncy50aW1lb3V0ICZndDsgMCkgYWJvcnRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XCIsXCIgICAgbG9nZ2VyLmRlYnVnKFxcXCJhamF4IGNhbGwgdGltZWQgb3V0XFxcIilcIixcIiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHlcIixcIiAgICB4aHIuYWJvcnQoKVwiLFwiICAgIHhoci5pc1RpbWVvdXQgPSB0cnVlXCIsXCIgICAgYWpheEVycm9yKG51bGwsICd0aW1lb3V0JywgeGhyLCBzZXR0aW5ncylcIixcIiAgfSwgc2V0dGluZ3MudGltZW91dClcIixcIlwiLFwiICAvLyBhdm9pZCBzZW5kaW5nIGVtcHR5IHN0cmluZyAoIzMxOSlcIixcIiAgeGhyLnNlbmQoc2V0dGluZ3MuZGF0YSA/IHNldHRpbmdzLmRhdGEgOiBudWxsKVwiLFwiICByZXR1cm4geGhyXCIsXCJ9XCIsXCJcIixcIlwiLFwiLy8gdHJpZ2dlciBhIGN1c3RvbSBldmVudCBhbmQgcmV0dXJuIHRydWVcIixcImZ1bmN0aW9uIHRyaWdnZXJBbmRSZXR1cm4oY29udGV4dCwgZXZlbnROYW1lLCBkYXRhKSB7XCIsXCIgIGV2ZW50c0hhbmRsZXIuZW1pdChldmVudE5hbWUsIGRhdGEpO1wiLFwiICByZXR1cm4gdHJ1ZTtcIixcIn1cIixcIlwiLFwiLy8gdHJpZ2dlciBhbiBBamF4IFxcXCJnbG9iYWxcXFwiIGV2ZW50XCIsXCJmdW5jdGlvbiB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCBldmVudE5hbWUsIGRhdGEpIHtcIixcIiAgaWYgKHNldHRpbmdzLmdsb2JhbCkgcmV0dXJuIHRyaWdnZXJBbmRSZXR1cm4oY29udGV4dCB8fCBkb2N1bWVudCwgZXZlbnROYW1lLCBkYXRhKVwiLFwifVwiLFwiXCIsXCIvLyBOdW1iZXIgb2YgYWN0aXZlIEFqYXggcmVxdWVzdHNcIixcImFqYXguYWN0aXZlID0gMFwiLFwiXCIsXCJmdW5jdGlvbiBhamF4U3RhcnQoc2V0dGluZ3MpIHtcIixcIiAgaWYgKHNldHRpbmdzLmdsb2JhbCAmYW1wOyZhbXA7IGFqYXguYWN0aXZlKysgPT09IDApIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIG51bGwsICdhamF4U3RhcnQnKVwiLFwifVwiLFwiXCIsXCJmdW5jdGlvbiBhamF4U3RvcChzZXR0aW5ncykge1wiLFwiICBpZiAoc2V0dGluZ3MuZ2xvYmFsICZhbXA7JmFtcDsgISgtLWFqYXguYWN0aXZlKSkgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgbnVsbCwgJ2FqYXhTdG9wJylcIixcIn1cIixcIlwiLFwiLy8gdHJpZ2dlcnMgYW4gZXh0cmEgZ2xvYmFsIGV2ZW50IFxcXCJhamF4QmVmb3JlU2VuZFxcXCIgdGhhdCdzIGxpa2UgXFxcImFqYXhTZW5kXFxcIiBidXQgY2FuY2VsYWJsZVwiLFwiZnVuY3Rpb24gYWpheEJlZm9yZVNlbmQoeGhyLCBzZXR0aW5ncykge1wiLFwiICB2YXIgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHRcIixcIiAgaWYgKHNldHRpbmdzLmJlZm9yZVNlbmQuY2FsbChjb250ZXh0LCB4aHIsIHNldHRpbmdzKSA9PT0gZmFsc2UpXCIsXCIgICAgcmV0dXJuIGZhbHNlXCIsXCJcIixcIiAgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgJ2FqYXhTZW5kJywgW3hociwgc2V0dGluZ3NdKVwiLFwifVwiLFwiXCIsXCJmdW5jdGlvbiBhamF4U3VjY2VzcyhkYXRhLCB4aHIsIHNldHRpbmdzKSB7XCIsXCIgIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dCxcIixcIiAgICBzdGF0dXMgPSAnc3VjY2VzcydcIixcIiAgc2V0dGluZ3Muc3VjY2Vzcy5jYWxsKGNvbnRleHQsIGRhdGEsIHN0YXR1cywgeGhyKVwiLFwiICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCAnYWpheFN1Y2Nlc3MnLCBbeGhyLCBzZXR0aW5ncywgZGF0YV0pXCIsXCIgIGFqYXhDb21wbGV0ZShzdGF0dXMsIHhociwgc2V0dGluZ3MpXCIsXCJ9XCIsXCIvLyB0eXBlOiBcXFwidGltZW91dFxcXCIsIFxcXCJlcnJvclxcXCIsIFxcXCJhYm9ydFxcXCIsIFxcXCJwYXJzZXJlcnJvclxcXCJcIixcImZ1bmN0aW9uIGFqYXhFcnJvcihlcnJvciwgdHlwZSwgeGhyLCBzZXR0aW5ncykge1wiLFwiICB2YXIgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHRcIixcIiAgc2V0dGluZ3MuZXJyb3IuY2FsbChjb250ZXh0LCB4aHIsIHR5cGUsIGVycm9yKVwiLFwiICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCAnYWpheEVycm9yJywgW3hociwgc2V0dGluZ3MsIGVycm9yXSlcIixcIiAgYWpheENvbXBsZXRlKHR5cGUsIHhociwgc2V0dGluZ3MpXCIsXCJ9XCIsXCIvLyBzdGF0dXM6IFxcXCJzdWNjZXNzXFxcIiwgXFxcIm5vdG1vZGlmaWVkXFxcIiwgXFxcImVycm9yXFxcIiwgXFxcInRpbWVvdXRcXFwiLCBcXFwiYWJvcnRcXFwiLCBcXFwicGFyc2VyZXJyb3JcXFwiXCIsXCJmdW5jdGlvbiBhamF4Q29tcGxldGUoc3RhdHVzLCB4aHIsIHNldHRpbmdzKSB7XCIsXCIgIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dFwiLFwiICBzZXR0aW5ncy5jb21wbGV0ZS5jYWxsKGNvbnRleHQsIHhociwgc3RhdHVzKVwiLFwiICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCAnYWpheENvbXBsZXRlJywgW3hociwgc2V0dGluZ3NdKVwiLFwiICBhamF4U3RvcChzZXR0aW5ncylcIixcIn1cIixcIlwiLFwiLy8gRW1wdHkgZnVuY3Rpb24sIHVzZWQgYXMgZGVmYXVsdCBjYWxsYmFja1wiLFwiZnVuY3Rpb24gZW1wdHkoKSB7fVwiLFwiXCIsXCJhamF4LkpTT05QID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcIixcIiAgaWYgKCEoJ3R5cGUnIGluIG9wdGlvbnMpKSByZXR1cm4gYWpheChvcHRpb25zKVwiLFwiXCIsXCIgIHZhciBjYWxsYmFja05hbWUgPSAnanNvbnAnICsgKCsranNvbnBJRCksXCIsXCIgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksXCIsXCIgICAgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XCIsXCIgICAgICAvL3RvZG86IHJlbW92ZSBzY3JpcHRcIixcIiAgICAgIC8vJChzY3JpcHQpLnJlbW92ZSgpXCIsXCIgICAgICBpZiAoY2FsbGJhY2tOYW1lIGluIHdpbmRvdykgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBlbXB0eVwiLFwiICAgICAgYWpheENvbXBsZXRlKCdhYm9ydCcsIHhociwgb3B0aW9ucylcIixcIiAgICB9LFwiLFwiICAgIHhociA9IHtcIixcIiAgICAgIGFib3J0OiBhYm9ydFwiLFwiICAgIH0sIGFib3J0VGltZW91dCxcIixcIiAgICBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImhlYWRcXFwiKVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcIixcIlwiLFwiICBpZiAob3B0aW9ucy5lcnJvcikgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XCIsXCIgICAgeGhyLmFib3J0KClcIixcIiAgICBvcHRpb25zLmVycm9yKClcIixcIiAgfVwiLFwiXCIsXCIgIHdpbmRvd1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24gKGRhdGEpIHtcIixcIiAgICBjbGVhclRpbWVvdXQoYWJvcnRUaW1lb3V0KVwiLFwiICAgIC8vdG9kbzogcmVtb3ZlIHNjcmlwdFwiLFwiICAgIC8vJChzY3JpcHQpLnJlbW92ZSgpXCIsXCIgICAgZGVsZXRlIHdpbmRvd1tjYWxsYmFja05hbWVdXCIsXCIgICAgYWpheFN1Y2Nlc3MoZGF0YSwgeGhyLCBvcHRpb25zKVwiLFwiICB9XCIsXCJcIixcIiAgc2VyaWFsaXplRGF0YShvcHRpb25zKVwiLFwiICBzY3JpcHQuc3JjID0gb3B0aW9ucy51cmwucmVwbGFjZSgvPVxcXFw/LywgJz0nICsgY2FsbGJhY2tOYW1lKVwiLFwiXCIsXCIgIC8vIFVzZSBpbnNlcnRCZWZvcmUgaW5zdGVhZCBvZiBhcHBlbmRDaGlsZCB0byBjaXJjdW12ZW50IGFuIElFNiBidWcuXCIsXCIgIC8vIFRoaXMgYXJpc2VzIHdoZW4gYSBiYXNlIG5vZGUgaXMgdXNlZCAoc2VlIGpRdWVyeSBidWdzICMyNzA5IGFuZCAjNDM3OCkuXCIsXCIgIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcIixcIlwiLFwiICBpZiAob3B0aW9ucy50aW1lb3V0ICZndDsgMCkgYWJvcnRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XCIsXCIgICAgeGhyLmFib3J0KClcIixcIiAgICBhamF4Q29tcGxldGUoJ3RpbWVvdXQnLCB4aHIsIG9wdGlvbnMpXCIsXCIgIH0sIG9wdGlvbnMudGltZW91dClcIixcIlwiLFwiICByZXR1cm4geGhyXCIsXCJ9XCIsXCJcIixcImZ1bmN0aW9uIGlzSUUoKXtcIixcIiAgdmFyIGllID0gZmFsc2U7XCIsXCIgIGlmKG5hdmlnYXRvci51c2VyQWdlbnQgJmFtcDsmYW1wOyBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXFxcIk1TSUVcXFwiKSAmZ3Q7PTAgKXtcIixcIiAgICBpZSA9IHRydWU7XCIsXCIgIH1cIixcIiAgcmV0dXJuIGllO1wiLFwifVwiLFwiXCIsXCJmdW5jdGlvbiBnZXRYaHIoY3Jvc3NEb21haW4pe1wiLFwiICB2YXIgeGhyID0gbnVsbDtcIixcIiAgLy9hbHdheXMgdXNlIFhNTEh0dHBSZXF1ZXN0IGlmIGF2YWlsYWJsZVwiLFwiICBpZih3aW5kb3cuWE1MSHR0cFJlcXVlc3Qpe1wiLFwiICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1wiLFwiICB9XCIsXCIgIC8vZm9yIElFOFwiLFwiICBpZihpc0lFKCkgJmFtcDsmYW1wOyAoY3Jvc3NEb21haW4gPT09IHRydWUpICZhbXA7JmFtcDsgdHlwZW9mIHdpbmRvdy5YRG9tYWluUmVxdWVzdCAhPT0gXFxcInVuZGVmaW5lZFxcXCIpe1wiLFwiICAgIHhociA9IG5ldyBYRG9tYWluUmVxdWVzdFdyYXBwZXIobmV3IFhEb21haW5SZXF1ZXN0KCkpO1wiLFwiICB9XCIsXCIgIHJldHVybiB4aHI7XCIsXCJ9XCIsXCJcIixcImFqYXguc2V0dGluZ3MgPSB7XCIsXCIgIC8vIERlZmF1bHQgdHlwZSBvZiByZXF1ZXN0XCIsXCIgIHR5cGU6ICdHRVQnLFwiLFwiICAvLyBDYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIGJlZm9yZSByZXF1ZXN0XCIsXCIgIGJlZm9yZVNlbmQ6IGVtcHR5LFwiLFwiICAvLyBDYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIGlmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzXCIsXCIgIHN1Y2Nlc3M6IGVtcHR5LFwiLFwiICAvLyBDYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIHRoZSB0aGUgc2VydmVyIGRyb3BzIGVycm9yXCIsXCIgIGVycm9yOiBlbXB0eSxcIixcIiAgLy8gQ2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCBvbiByZXF1ZXN0IGNvbXBsZXRlIChib3RoOiBlcnJvciBhbmQgc3VjY2VzcylcIixcIiAgY29tcGxldGU6IGVtcHR5LFwiLFwiICAvLyBUaGUgY29udGV4dCBmb3IgdGhlIGNhbGxiYWNrc1wiLFwiICBjb250ZXh0OiBudWxsLFwiLFwiICAvLyBXaGV0aGVyIHRvIHRyaWdnZXIgXFxcImdsb2JhbFxcXCIgQWpheCBldmVudHNcIixcIiAgZ2xvYmFsOiB0cnVlLFwiLFwiICAvLyBUcmFuc3BvcnRcIixcIiAgeGhyOiBnZXRYaHIsXCIsXCIgIC8vIE1JTUUgdHlwZXMgbWFwcGluZ1wiLFwiICBhY2NlcHRzOiB7XCIsXCIgICAgc2NyaXB0OiAndGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcIixcIiAgICBqc29uOiBqc29uVHlwZSxcIixcIiAgICB4bWw6ICdhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sJyxcIixcIiAgICBodG1sOiBodG1sVHlwZSxcIixcIiAgICB0ZXh0OiAndGV4dC9wbGFpbidcIixcIiAgfSxcIixcIiAgLy8gV2hldGhlciB0aGUgcmVxdWVzdCBpcyB0byBhbm90aGVyIGRvbWFpblwiLFwiICBjcm9zc0RvbWFpbjogZmFsc2UsXCIsXCIgIC8vIERlZmF1bHQgdGltZW91dFwiLFwiICB0aW1lb3V0OiBjb25zdHMuZmhfdGltZW91dFwiLFwifVwiLFwiXCIsXCJmdW5jdGlvbiBtaW1lVG9EYXRhVHlwZShtaW1lKSB7XCIsXCIgIHJldHVybiBtaW1lICZhbXA7JmFtcDsgKG1pbWUgPT0gaHRtbFR5cGUgPyAnaHRtbCcgOlwiLFwiICAgIG1pbWUgPT0ganNvblR5cGUgPyAnanNvbicgOlwiLFwiICAgIHNjcmlwdFR5cGVSRS50ZXN0KG1pbWUpID8gJ3NjcmlwdCcgOlwiLFwiICAgIHhtbFR5cGVSRS50ZXN0KG1pbWUpICZhbXA7JmFtcDsgJ3htbCcpIHx8ICd0ZXh0J1wiLFwifVwiLFwiXCIsXCJmdW5jdGlvbiBhcHBlbmRRdWVyeSh1cmwsIHF1ZXJ5KSB7XCIsXCIgIHJldHVybiAodXJsICsgJyZhbXA7JyArIHF1ZXJ5KS5yZXBsYWNlKC9bJmFtcDs/XXsxLDJ9LywgJz8nKVwiLFwifVwiLFwiXCIsXCIvLyBzZXJpYWxpemUgcGF5bG9hZCBhbmQgYXBwZW5kIGl0IHRvIHRoZSBVUkwgZm9yIEdFVCByZXF1ZXN0c1wiLFwiZnVuY3Rpb24gc2VyaWFsaXplRGF0YShvcHRpb25zKSB7XCIsXCIgIGlmICh0eXBlKG9wdGlvbnMuZGF0YSkgPT09ICdvYmplY3QnKSB7XCIsXCIgICAgaWYodHlwZW9mIG9wdGlvbnMuZGF0YS5hcHBlbmQgPT09IFxcXCJmdW5jdGlvblxcXCIpe1wiLFwiICAgICAgLy93ZSBhcmUgZGVhbGluZyB3aXRoIEZvcm1EYXRhLCBkbyBub3Qgc2VyaWFsaXplXCIsXCIgICAgICBvcHRpb25zLmZvcm1kYXRhID0gdHJ1ZTtcIixcIiAgICB9IGVsc2Uge1wiLFwiICAgICAgb3B0aW9ucy5kYXRhID0gcGFyYW0ob3B0aW9ucy5kYXRhKVwiLFwiICAgIH1cIixcIiAgfVwiLFwiICBpZiAob3B0aW9ucy5kYXRhICZhbXA7JmFtcDsgKCFvcHRpb25zLnR5cGUgfHwgb3B0aW9ucy50eXBlLnRvVXBwZXJDYXNlKCkgPT0gJ0dFVCcpKVwiLFwiICAgIG9wdGlvbnMudXJsID0gYXBwZW5kUXVlcnkob3B0aW9ucy51cmwsIG9wdGlvbnMuZGF0YSlcIixcIn1cIixcIlwiLFwiYWpheC5nZXQgPSBmdW5jdGlvbiAodXJsLCBzdWNjZXNzKSB7XCIsXCIgIHJldHVybiBhamF4KHtcIixcIiAgICB1cmw6IHVybCxcIixcIiAgICBzdWNjZXNzOiBzdWNjZXNzXCIsXCIgIH0pXCIsXCJ9XCIsXCJcIixcImFqYXgucG9zdCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIHN1Y2Nlc3MsIGRhdGFUeXBlKSB7XCIsXCIgIGlmICh0eXBlKGRhdGEpID09PSAnZnVuY3Rpb24nKSBkYXRhVHlwZSA9IGRhdGFUeXBlIHx8IHN1Y2Nlc3MsIHN1Y2Nlc3MgPSBkYXRhLCBkYXRhID0gbnVsbFwiLFwiICByZXR1cm4gYWpheCh7XCIsXCIgICAgdHlwZTogJ1BPU1QnLFwiLFwiICAgIHVybDogdXJsLFwiLFwiICAgIGRhdGE6IGRhdGEsXCIsXCIgICAgc3VjY2Vzczogc3VjY2VzcyxcIixcIiAgICBkYXRhVHlwZTogZGF0YVR5cGVcIixcIiAgfSlcIixcIn1cIixcIlwiLFwiYWpheC5nZXRKU09OID0gZnVuY3Rpb24gKHVybCwgc3VjY2Vzcykge1wiLFwiICByZXR1cm4gYWpheCh7XCIsXCIgICAgdXJsOiB1cmwsXCIsXCIgICAgc3VjY2Vzczogc3VjY2VzcyxcIixcIiAgICBkYXRhVHlwZTogJ2pzb24nXCIsXCIgIH0pXCIsXCJ9XCIsXCJcIixcInZhciBlc2NhcGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XCIsXCJcIixcImZ1bmN0aW9uIHNlcmlhbGl6ZShwYXJhbXMsIG9iaiwgdHJhZGl0aW9uYWwsIHNjb3BlKSB7XCIsXCIgIHZhciBhcnJheSA9IHR5cGUob2JqKSA9PT0gJ2FycmF5JztcIixcIiAgZm9yICh2YXIga2V5IGluIG9iaikge1wiLFwiICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1wiLFwiXCIsXCIgICAgaWYgKHNjb3BlKSBrZXkgPSB0cmFkaXRpb25hbCA/IHNjb3BlIDogc2NvcGUgKyAnWycgKyAoYXJyYXkgPyAnJyA6IGtleSkgKyAnXSdcIixcIiAgICAvLyBoYW5kbGUgZGF0YSBpbiBzZXJpYWxpemVBcnJheSgpIGZvcm1hdFwiLFwiICAgIGlmICghc2NvcGUgJmFtcDsmYW1wOyBhcnJheSkgcGFyYW1zLmFkZCh2YWx1ZS5uYW1lLCB2YWx1ZS52YWx1ZSlcIixcIiAgICAvLyByZWN1cnNlIGludG8gbmVzdGVkIG9iamVjdHNcIixcIiAgICBlbHNlIGlmICh0cmFkaXRpb25hbCA/ICh0eXBlKHZhbHVlKSA9PT0gJ2FycmF5JykgOiAodHlwZSh2YWx1ZSkgPT09ICdvYmplY3QnKSlcIixcIiAgICAgIHNlcmlhbGl6ZShwYXJhbXMsIHZhbHVlLCB0cmFkaXRpb25hbCwga2V5KVwiLFwiICAgIGVsc2UgcGFyYW1zLmFkZChrZXksIHZhbHVlKVwiLFwiICB9XCIsXCJ9XCIsXCJcIixcImZ1bmN0aW9uIHBhcmFtKG9iaiwgdHJhZGl0aW9uYWwpIHtcIixcIiAgdmFyIHBhcmFtcyA9IFtdXCIsXCIgIHBhcmFtcy5hZGQgPSBmdW5jdGlvbiAoaywgdikge1wiLFwiICAgIHRoaXMucHVzaChlc2NhcGUoaykgKyAnPScgKyBlc2NhcGUodikpXCIsXCIgIH1cIixcIiAgc2VyaWFsaXplKHBhcmFtcywgb2JqLCB0cmFkaXRpb25hbClcIixcIiAgcmV0dXJuIHBhcmFtcy5qb2luKCcmYW1wOycpLnJlcGxhY2UoJyUyMCcsICcrJylcIixcIn1cIixcIlwiLFwiZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCkge1wiLFwiICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XCIsXCIgIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKS5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcIixcIiAgICBmb3IgKGtleSBpbiBzb3VyY2UpXCIsXCIgICAgICBpZiAoc291cmNlW2tleV0gIT09IHVuZGVmaW5lZClcIixcIiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVwiLFwiICB9KVwiLFwiICByZXR1cm4gdGFyZ2V0XCIsXCJ9XCJdO1xuIiwiLyogYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgSlNDb3ZlcmFnZSAtIGRvIG5vdCBlZGl0ICovXG5pZiAodHlwZW9mIF8kanNjb3ZlcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIF8kanNjb3ZlcmFnZSA9IHt9O1xuaWYgKCEgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddID0gW107XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfYWN0LmpzJ11bMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVszXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfYWN0LmpzJ11bNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVs2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfYWN0LmpzJ11bOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVsxMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfYWN0LmpzJ11bMTJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVsxM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzIzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfYWN0LmpzJ11bMjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVsyOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzMwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfYWN0LmpzJ11bMzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVszMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzM2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfYWN0LmpzJ11bMzddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVs0MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzQxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfYWN0LmpzJ11bNDJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVs0M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzQ1XSA9IDA7XG59XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzFdKys7XG52YXIgbG9nZ2VyID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVsyXSsrO1xudmFyIGNsb3VkID0gcmVxdWlyZShcIi4vd2FpdEZvckNsb3VkXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVszXSsrO1xudmFyIGZocGFyYW1zID0gcmVxdWlyZShcIi4vZmhwYXJhbXNcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzRdKys7XG52YXIgYWpheCA9IHJlcXVpcmUoXCIuL2FqYXhcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzVdKys7XG52YXIgSlNPTiA9IHJlcXVpcmUoXCJKU09OXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVs2XSsrO1xudmFyIGhhbmRsZUVycm9yID0gcmVxdWlyZShcIi4vaGFuZGxlRXJyb3JcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzhdKys7XG5mdW5jdGlvbiBkb0FjdENhbGwob3B0cywgc3VjY2VzcywgZmFpbCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzldKys7XG4gIHZhciBjbG91ZF9ob3N0ID0gY2xvdWQuZ2V0Q2xvdWRIb3N0KCk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfYWN0LmpzJ11bMTBdKys7XG4gIHZhciB1cmwgPSBjbG91ZF9ob3N0LmdldEFjdFVybChvcHRzLmFjdCk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfYWN0LmpzJ11bMTFdKys7XG4gIHZhciBwYXJhbXMgPSBvcHRzLnJlcSB8fCB7fTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVsxMl0rKztcbiAgcGFyYW1zID0gZmhwYXJhbXMuYWRkRkhQYXJhbXMocGFyYW1zKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVsxM10rKztcbiAgcmV0dXJuIGFqYXgoe1widXJsXCI6IHVybCwgXCJ0cnlKU09OUFwiOiB0cnVlLCBcInR5cGVcIjogXCJQT1NUXCIsIFwiZGF0YVR5cGVcIjogXCJqc29uXCIsIFwiZGF0YVwiOiBKU09OLnN0cmluZ2lmeShwYXJhbXMpLCBcImNvbnRlbnRUeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLCBcInRpbWVvdXRcIjogb3B0cy50aW1lb3V0LCBcInN1Y2Nlc3NcIjogc3VjY2VzcywgXCJlcnJvclwiOiAoZnVuY3Rpb24gKHJlcSwgc3RhdHVzVGV4dCwgZXJyb3IpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVsyM10rKztcbiAgcmV0dXJuIGhhbmRsZUVycm9yKGZhaWwsIHJlcSwgc3RhdHVzVGV4dCwgZXJyb3IpO1xufSl9KTtcbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfYWN0LmpzJ11bMjhdKys7XG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAob3B0cywgc3VjY2VzcywgZmFpbCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzI5XSsrO1xuICBsb2dnZXIuZGVidWcoXCJhY3QgaXMgY2FsbGVkXCIpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzMwXSsrO1xuICBpZiAoISBmYWlsKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVszMV0rKztcbiAgICBmYWlsID0gKGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfYWN0LmpzJ11bMzJdKys7XG4gIGxvZ2dlci5kZWJ1Zyhtc2cgKyBcIjpcIiArIEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG59KTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzM2XSsrO1xuICBpZiAoISBvcHRzLmFjdCkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfYWN0LmpzJ11bMzddKys7XG4gICAgcmV0dXJuIGZhaWwoXCJhY3Rfbm9fYWN0aW9uXCIsIHt9KTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzQwXSsrO1xuICBjbG91ZC5yZWFkeSgoZnVuY3Rpb24gKGVyciwgY2xvdWRIb3N0KSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfYWN0LmpzJ11bNDFdKys7XG4gIGxvZ2dlci5kZWJ1ZyhcIkNhbGxpbmcgZmhhY3Qgbm93XCIpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzQyXSsrO1xuICBpZiAoZXJyKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9hY3QuanMnXVs0M10rKztcbiAgICByZXR1cm4gZmFpbChlcnIubWVzc2FnZSwgZXJyKTtcbiAgfVxuICBlbHNlIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddWzQ1XSsrO1xuICAgIGRvQWN0Q2FsbChvcHRzLCBzdWNjZXNzLCBmYWlsKTtcbiAgfVxufSkpO1xufSk7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2FjdC5qcyddLnNvdXJjZSA9IFtcInZhciBsb2dnZXIgPXJlcXVpcmUoXFxcIi4vbG9nZ2VyXFxcIik7XCIsXCJ2YXIgY2xvdWQgPSByZXF1aXJlKFxcXCIuL3dhaXRGb3JDbG91ZFxcXCIpO1wiLFwidmFyIGZocGFyYW1zID0gcmVxdWlyZShcXFwiLi9maHBhcmFtc1xcXCIpO1wiLFwidmFyIGFqYXggPSByZXF1aXJlKFxcXCIuL2FqYXhcXFwiKTtcIixcInZhciBKU09OID0gcmVxdWlyZShcXFwiSlNPTlxcXCIpO1wiLFwidmFyIGhhbmRsZUVycm9yID0gcmVxdWlyZShcXFwiLi9oYW5kbGVFcnJvclxcXCIpO1wiLFwiXCIsXCJmdW5jdGlvbiBkb0FjdENhbGwob3B0cywgc3VjY2VzcywgZmFpbCl7XCIsXCIgIHZhciBjbG91ZF9ob3N0ID0gY2xvdWQuZ2V0Q2xvdWRIb3N0KCk7XCIsXCIgIHZhciB1cmwgPSBjbG91ZF9ob3N0LmdldEFjdFVybChvcHRzLmFjdCk7XCIsXCIgIHZhciBwYXJhbXMgPSBvcHRzLnJlcSB8fCB7fTtcIixcIiAgcGFyYW1zID0gZmhwYXJhbXMuYWRkRkhQYXJhbXMocGFyYW1zKTtcIixcIiAgcmV0dXJuIGFqYXgoe1wiLFwiICAgIFxcXCJ1cmxcXFwiOiB1cmwsXCIsXCIgICAgXFxcInRyeUpTT05QXFxcIjogdHJ1ZSxcIixcIiAgICBcXFwidHlwZVxcXCI6IFxcXCJQT1NUXFxcIixcIixcIiAgICBcXFwiZGF0YVR5cGVcXFwiOiBcXFwianNvblxcXCIsXCIsXCIgICAgXFxcImRhdGFcXFwiOiBKU09OLnN0cmluZ2lmeShwYXJhbXMpLFwiLFwiICAgIFxcXCJjb250ZW50VHlwZVxcXCI6IFxcXCJhcHBsaWNhdGlvbi9qc29uXFxcIixcIixcIiAgICBcXFwidGltZW91dFxcXCI6IG9wdHMudGltZW91dCxcIixcIiAgICBcXFwic3VjY2Vzc1xcXCI6IHN1Y2Nlc3MsXCIsXCIgICAgXFxcImVycm9yXFxcIjogZnVuY3Rpb24ocmVxLCBzdGF0dXNUZXh0LCBlcnJvcil7XCIsXCIgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoZmFpbCwgcmVxLCBzdGF0dXNUZXh0LCBlcnJvcik7XCIsXCIgICAgfVwiLFwiICB9KVwiLFwifVwiLFwiXCIsXCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdHMsIHN1Y2Nlc3MsIGZhaWwpe1wiLFwiICBsb2dnZXIuZGVidWcoXFxcImFjdCBpcyBjYWxsZWRcXFwiKTtcIixcIiAgaWYoIWZhaWwpe1wiLFwiICAgIGZhaWwgPSBmdW5jdGlvbihtc2csIGVycm9yKXtcIixcIiAgICAgIGxvZ2dlci5kZWJ1Zyhtc2cgKyBcXFwiOlxcXCIgKyBKU09OLnN0cmluZ2lmeShlcnJvcikpO1wiLFwiICAgIH07XCIsXCIgIH1cIixcIlwiLFwiICBpZighb3B0cy5hY3Qpe1wiLFwiICAgIHJldHVybiBmYWlsKCdhY3Rfbm9fYWN0aW9uJywge30pO1wiLFwiICB9XCIsXCJcIixcIiAgY2xvdWQucmVhZHkoZnVuY3Rpb24oZXJyLCBjbG91ZEhvc3Qpe1wiLFwiICAgIGxvZ2dlci5kZWJ1ZyhcXFwiQ2FsbGluZyBmaGFjdCBub3dcXFwiKTtcIixcIiAgICBpZihlcnIpe1wiLFwiICAgICAgcmV0dXJuIGZhaWwoZXJyLm1lc3NhZ2UsIGVycik7XCIsXCIgICAgfSBlbHNlIHtcIixcIiAgICAgIGRvQWN0Q2FsbChvcHRzLCBzdWNjZXNzLCBmYWlsKTtcIixcIiAgICB9XCIsXCIgIH0pXCIsXCJ9XCJdO1xuIiwiLyogYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgSlNDb3ZlcmFnZSAtIGRvIG5vdCBlZGl0ICovXG5pZiAodHlwZW9mIF8kanNjb3ZlcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIF8kanNjb3ZlcmFnZSA9IHt9O1xuaWYgKCEgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9jbG91ZC5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfY2xvdWQuanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bMTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9jbG91ZC5qcyddWzExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfY2xvdWQuanMnXVsxMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bMTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9jbG91ZC5qcyddWzIyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfY2xvdWQuanMnXVsyN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bMjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9jbG91ZC5qcyddWzI5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfY2xvdWQuanMnXVszMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bMzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9jbG91ZC5qcyddWzM1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfY2xvdWQuanMnXVszNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bMzddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9jbG91ZC5qcyddWzM4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfY2xvdWQuanMnXVs0MF0gPSAwO1xufVxuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9jbG91ZC5qcyddWzFdKys7XG52YXIgbG9nZ2VyID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9jbG91ZC5qcyddWzJdKys7XG52YXIgY2xvdWQgPSByZXF1aXJlKFwiLi93YWl0Rm9yQ2xvdWRcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bM10rKztcbnZhciBmaHBhcmFtcyA9IHJlcXVpcmUoXCIuL2ZocGFyYW1zXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9jbG91ZC5qcyddWzRdKys7XG52YXIgYWpheCA9IHJlcXVpcmUoXCIuL2FqYXhcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bNV0rKztcbnZhciBKU09OID0gcmVxdWlyZShcIkpTT05cIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bNl0rKztcbnZhciBoYW5kbGVFcnJvciA9IHJlcXVpcmUoXCIuL2hhbmRsZUVycm9yXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9jbG91ZC5qcyddWzhdKys7XG5mdW5jdGlvbiBkb0Nsb3VkQ2FsbChvcHRzLCBzdWNjZXNzLCBmYWlsKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfY2xvdWQuanMnXVs5XSsrO1xuICB2YXIgY2xvdWRfaG9zdCA9IGNsb3VkLmdldENsb3VkSG9zdCgpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bMTBdKys7XG4gIHZhciB1cmwgPSBjbG91ZF9ob3N0LmdldENsb3VkVXJsKG9wdHMucGF0aCk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfY2xvdWQuanMnXVsxMV0rKztcbiAgdmFyIHBhcmFtcyA9IG9wdHMuZGF0YSB8fCB7fTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9jbG91ZC5qcyddWzEyXSsrO1xuICBwYXJhbXMgPSBmaHBhcmFtcy5hZGRGSFBhcmFtcyhwYXJhbXMpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bMTNdKys7XG4gIHJldHVybiBhamF4KHtcInVybFwiOiB1cmwsIFwidHlwZVwiOiBvcHRzLm1ldGhvZCB8fCBcIlBPU1RcIiwgXCJkYXRhVHlwZVwiOiBvcHRzLmRhdGFUeXBlIHx8IFwianNvblwiLCBcImRhdGFcIjogSlNPTi5zdHJpbmdpZnkocGFyYW1zKSwgXCJjb250ZW50VHlwZVwiOiBvcHRzLmNvbnRlbnRUeXBlIHx8IFwiYXBwbGljYXRpb24vanNvblwiLCBcInRpbWVvdXRcIjogb3B0cy50aW1lb3V0LCBcInN1Y2Nlc3NcIjogc3VjY2VzcywgXCJlcnJvclwiOiAoZnVuY3Rpb24gKHJlcSwgc3RhdHVzVGV4dCwgZXJyb3IpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9jbG91ZC5qcyddWzIyXSsrO1xuICByZXR1cm4gaGFuZGxlRXJyb3IoZmFpbCwgcmVxLCBzdGF0dXNUZXh0LCBlcnJvcik7XG59KX0pO1xufVxuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9jbG91ZC5qcyddWzI3XSsrO1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKG9wdHMsIHN1Y2Nlc3MsIGZhaWwpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9jbG91ZC5qcyddWzI4XSsrO1xuICBsb2dnZXIuZGVidWcoXCJjbG91ZCBpcyBjYWxsZWRcIik7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfY2xvdWQuanMnXVsyOV0rKztcbiAgaWYgKCEgZmFpbCkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfY2xvdWQuanMnXVszMF0rKztcbiAgICBmYWlsID0gKGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfY2xvdWQuanMnXVszMV0rKztcbiAgbG9nZ2VyLmRlYnVnKG1zZyArIFwiOlwiICsgSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcbn0pO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfY2xvdWQuanMnXVszNV0rKztcbiAgY2xvdWQucmVhZHkoKGZ1bmN0aW9uIChlcnIsIGNsb3VkSG9zdCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bMzZdKys7XG4gIGxvZ2dlci5kZWJ1ZyhcIkNhbGxpbmcgZmhhY3Qgbm93XCIpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bMzddKys7XG4gIGlmIChlcnIpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBpX2Nsb3VkLmpzJ11bMzhdKys7XG4gICAgcmV0dXJuIGZhaWwoZXJyLm1lc3NhZ2UsIGVycik7XG4gIH1cbiAgZWxzZSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwaV9jbG91ZC5qcyddWzQwXSsrO1xuICAgIGRvQ2xvdWRDYWxsKG9wdHMsIHN1Y2Nlc3MsIGZhaWwpO1xuICB9XG59KSk7XG59KTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcGlfY2xvdWQuanMnXS5zb3VyY2UgPSBbXCJ2YXIgbG9nZ2VyID1yZXF1aXJlKFxcXCIuL2xvZ2dlclxcXCIpO1wiLFwidmFyIGNsb3VkID0gcmVxdWlyZShcXFwiLi93YWl0Rm9yQ2xvdWRcXFwiKTtcIixcInZhciBmaHBhcmFtcyA9IHJlcXVpcmUoXFxcIi4vZmhwYXJhbXNcXFwiKTtcIixcInZhciBhamF4ID0gcmVxdWlyZShcXFwiLi9hamF4XFxcIik7XCIsXCJ2YXIgSlNPTiA9IHJlcXVpcmUoXFxcIkpTT05cXFwiKTtcIixcInZhciBoYW5kbGVFcnJvciA9IHJlcXVpcmUoXFxcIi4vaGFuZGxlRXJyb3JcXFwiKTtcIixcIlwiLFwiZnVuY3Rpb24gZG9DbG91ZENhbGwob3B0cywgc3VjY2VzcywgZmFpbCl7XCIsXCIgIHZhciBjbG91ZF9ob3N0ID0gY2xvdWQuZ2V0Q2xvdWRIb3N0KCk7XCIsXCIgIHZhciB1cmwgPSBjbG91ZF9ob3N0LmdldENsb3VkVXJsKG9wdHMucGF0aCk7XCIsXCIgIHZhciBwYXJhbXMgPSBvcHRzLmRhdGEgfHwge307XCIsXCIgIHBhcmFtcyA9IGZocGFyYW1zLmFkZEZIUGFyYW1zKHBhcmFtcyk7XCIsXCIgIHJldHVybiBhamF4KHtcIixcIiAgICBcXFwidXJsXFxcIjogdXJsLFwiLFwiICAgIFxcXCJ0eXBlXFxcIjogb3B0cy5tZXRob2QgfHwgXFxcIlBPU1RcXFwiLFwiLFwiICAgIFxcXCJkYXRhVHlwZVxcXCI6IG9wdHMuZGF0YVR5cGUgfHwgXFxcImpzb25cXFwiLFwiLFwiICAgIFxcXCJkYXRhXFxcIjogSlNPTi5zdHJpbmdpZnkocGFyYW1zKSxcIixcIiAgICBcXFwiY29udGVudFR5cGVcXFwiOiBvcHRzLmNvbnRlbnRUeXBlIHx8IFxcXCJhcHBsaWNhdGlvbi9qc29uXFxcIixcIixcIiAgICBcXFwidGltZW91dFxcXCI6IG9wdHMudGltZW91dCxcIixcIiAgICBcXFwic3VjY2Vzc1xcXCI6IHN1Y2Nlc3MsXCIsXCIgICAgXFxcImVycm9yXFxcIjogZnVuY3Rpb24ocmVxLCBzdGF0dXNUZXh0LCBlcnJvcil7XCIsXCIgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoZmFpbCwgcmVxLCBzdGF0dXNUZXh0LCBlcnJvcik7XCIsXCIgICAgfVwiLFwiICB9KVwiLFwifVwiLFwiXCIsXCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdHMsIHN1Y2Nlc3MsIGZhaWwpe1wiLFwiICBsb2dnZXIuZGVidWcoXFxcImNsb3VkIGlzIGNhbGxlZFxcXCIpO1wiLFwiICBpZighZmFpbCl7XCIsXCIgICAgZmFpbCA9IGZ1bmN0aW9uKG1zZywgZXJyb3Ipe1wiLFwiICAgICAgbG9nZ2VyLmRlYnVnKG1zZyArIFxcXCI6XFxcIiArIEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XCIsXCIgICAgfTtcIixcIiAgfVwiLFwiXCIsXCIgIGNsb3VkLnJlYWR5KGZ1bmN0aW9uKGVyciwgY2xvdWRIb3N0KXtcIixcIiAgICBsb2dnZXIuZGVidWcoXFxcIkNhbGxpbmcgZmhhY3Qgbm93XFxcIik7XCIsXCIgICAgaWYoZXJyKXtcIixcIiAgICAgIHJldHVybiBmYWlsKGVyci5tZXNzYWdlLCBlcnIpO1wiLFwiICAgIH0gZWxzZSB7XCIsXCIgICAgICBkb0Nsb3VkQ2FsbChvcHRzLCBzdWNjZXNzLCBmYWlsKTtcIixcIiAgICB9XCIsXCIgIH0pXCIsXCJ9XCJdO1xuIiwiLyogYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgSlNDb3ZlcmFnZSAtIGRvIG5vdCBlZGl0ICovXG5pZiAodHlwZW9mIF8kanNjb3ZlcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIF8kanNjb3ZlcmFnZSA9IHt9O1xuaWYgKCEgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ10pIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ10gPSBbXTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ11bMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcHBQcm9wcy5qcyddWzNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ11bNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcHBQcm9wcy5qcyddWzhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ11bOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsxMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsxMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsxNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsxNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsxNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsxN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsxOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsxOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsyMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsyMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsyMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsyM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsyNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsyN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVszMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVszM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVszNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVszNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVszOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs0M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs0NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs0Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs0N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs1Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs1M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs1Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs1N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs2MF0gPSAwO1xufVxuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ11bMV0rKztcbnZhciBjb25zdHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsyXSsrO1xudmFyIGFqYXggPSByZXF1aXJlKFwiLi9hamF4XCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ11bM10rKztcbnZhciBsb2dnZXIgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs0XSsrO1xudmFyIHFzID0gcmVxdWlyZShcIi4vcXVlcnlNYXBcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs2XSsrO1xudmFyIGFwcF9wcm9wcyA9IG51bGw7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs4XSsrO1xudmFyIGxvYWQgPSAoZnVuY3Rpb24gKGNiKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcHBQcm9wcy5qcyddWzldKys7XG4gIHZhciBkb2NfdXJsID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ11bMTBdKys7XG4gIHZhciB1cmxfcGFyYW1zID0gcXMoZG9jX3VybCk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcHBQcm9wcy5qcyddWzExXSsrO1xuICB2YXIgbG9jYWwgPSAodHlwZW9mIHVybF9wYXJhbXMudXJsICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ11bMTRdKys7XG4gIGlmIChsb2NhbCkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcHBQcm9wcy5qcyddWzE1XSsrO1xuICAgIGFwcF9wcm9wcyA9IHt9O1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcHBQcm9wcy5qcyddWzE2XSsrO1xuICAgIGFwcF9wcm9wcy5sb2NhbCA9IHRydWU7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ11bMTddKys7XG4gICAgYXBwX3Byb3BzLmhvc3QgPSB1cmxfcGFyYW1zLnVybDtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsxOF0rKztcbiAgICBhcHBfcHJvcHMuYXBwaWQgPSBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcHBQcm9wcy5qcyddWzE5XSsrO1xuICAgIGFwcF9wcm9wcy5hcHBrZXkgPSBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsyMF0rKztcbiAgICBhcHBfcHJvcHMucHJvamVjdGlkID0gXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsyMV0rKztcbiAgICBhcHBfcHJvcHMuY29ubmVjdGlvbnRhZyA9IFwiMC4wLjFcIjtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVsyMl0rKztcbiAgICBhcHBfcHJvcHMubG9nbGV2ZWwgPSB1cmxfcGFyYW1zLmxvZ2xldmVsO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcHBQcm9wcy5qcyddWzIzXSsrO1xuICAgIHJldHVybiBjYihudWxsLCBhcHBfcHJvcHMpO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcHBQcm9wcy5qcyddWzI2XSsrO1xuICB2YXIgY29uZmlnX3VybCA9IHVybF9wYXJhbXMuZmhjb25maWcgfHwgY29uc3RzLmNvbmZpZ19qcztcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ11bMjddKys7XG4gIGFqYXgoe3VybDogY29uZmlnX3VybCwgZGF0YVR5cGU6IFwianNvblwiLCBzdWNjZXNzOiAoZnVuY3Rpb24gKGRhdGEpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ11bMzFdKys7XG4gIGxvZ2dlci5kZWJ1ZyhcImZoY29uZmlnID0gXCIgKyBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcHBQcm9wcy5qcyddWzMzXSsrO1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcHBQcm9wcy5qcyddWzM0XSsrO1xuICAgIHJldHVybiBjYihuZXcgRXJyb3IoXCJhcHBfY29uZmlnX21pc3NpbmdcIikpO1xuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcHBQcm9wcy5qcyddWzM2XSsrO1xuICAgIGFwcF9wcm9wcyA9IGRhdGE7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ11bMzhdKys7XG4gICAgY2IobnVsbCwgYXBwX3Byb3BzKTtcbiAgfVxufSksIGVycm9yOiAoZnVuY3Rpb24gKHJlcSwgc3RhdHVzVGV4dCwgZXJyb3IpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ11bNDNdKys7XG4gIGlmICh3aW5kb3cuZmhfYXBwX3Byb3BzKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ11bNDRdKys7XG4gICAgcmV0dXJuIGNiKG51bGwsIHdpbmRvdy5maF9hcHBfcHJvcHMpO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcHBQcm9wcy5qcyddWzQ2XSsrO1xuICBsb2dnZXIuZXJyb3IoY29uc3RzLmNvbmZpZ19qcyArIFwiIE5vdCBGb3VuZFwiKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ11bNDddKys7XG4gIGNiKG5ldyBFcnJvcihcImFwcF9jb25maWdfbWlzc2luZ1wiKSk7XG59KX0pO1xufSk7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs1Ml0rKztcbnZhciBzZXRBcHBQcm9wcyA9IChmdW5jdGlvbiAocHJvcHMpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2FwcFByb3BzLmpzJ11bNTNdKys7XG4gIGFwcF9wcm9wcyA9IHByb3BzO1xufSk7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs1Nl0rKztcbnZhciBnZXRBcHBQcm9wcyA9IChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcHBQcm9wcy5qcyddWzU3XSsrO1xuICByZXR1cm4gYXBwX3Byb3BzO1xufSk7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvYXBwUHJvcHMuanMnXVs2MF0rKztcbm1vZHVsZS5leHBvcnRzID0ge2xvYWQ6IGxvYWQsIGdldEFwcFByb3BzOiBnZXRBcHBQcm9wcywgc2V0QXBwUHJvcHM6IHNldEFwcFByb3BzfTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9hcHBQcm9wcy5qcyddLnNvdXJjZSA9IFtcInZhciBjb25zdHMgPSByZXF1aXJlKFxcXCIuL2NvbnN0YW50c1xcXCIpO1wiLFwidmFyIGFqYXggPSByZXF1aXJlKFxcXCIuL2FqYXhcXFwiKTtcIixcInZhciBsb2dnZXIgPSByZXF1aXJlKFxcXCIuL2xvZ2dlclxcXCIpO1wiLFwidmFyIHFzID0gcmVxdWlyZShcXFwiLi9xdWVyeU1hcFxcXCIpO1wiLFwiXCIsXCJ2YXIgYXBwX3Byb3BzID0gbnVsbDtcIixcIlwiLFwidmFyIGxvYWQgPSBmdW5jdGlvbihjYikge1wiLFwiICB2YXIgZG9jX3VybCA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XCIsXCIgIHZhciB1cmxfcGFyYW1zID0gcXMoZG9jX3VybCk7XCIsXCIgIHZhciBsb2NhbCA9ICh0eXBlb2YgdXJsX3BhcmFtcy51cmwgIT09ICd1bmRlZmluZWQnKTtcIixcIlwiLFwiICAvLyBGb3IgbG9jYWwgZW52aXJvbm1lbnRzLCBubyBpbml0IG5lZWRlZFwiLFwiICBpZiAobG9jYWwpIHtcIixcIiAgICBhcHBfcHJvcHMgPSB7fTtcIixcIiAgICBhcHBfcHJvcHMubG9jYWwgPSB0cnVlO1wiLFwiICAgIGFwcF9wcm9wcy5ob3N0ID0gdXJsX3BhcmFtcy51cmw7XCIsXCIgICAgYXBwX3Byb3BzLmFwcGlkID0gXFxcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFxcXCI7XCIsXCIgICAgYXBwX3Byb3BzLmFwcGtleSA9IFxcXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXFxcIjtcIixcIiAgICBhcHBfcHJvcHMucHJvamVjdGlkID0gXFxcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFxcXCI7XCIsXCIgICAgYXBwX3Byb3BzLmNvbm5lY3Rpb250YWcgPSBcXFwiMC4wLjFcXFwiO1wiLFwiICAgIGFwcF9wcm9wcy5sb2dsZXZlbCA9IHVybF9wYXJhbXMubG9nbGV2ZWw7XCIsXCIgICAgcmV0dXJuIGNiKG51bGwsIGFwcF9wcm9wcyk7XCIsXCIgIH1cIixcIlwiLFwiICB2YXIgY29uZmlnX3VybCA9IHVybF9wYXJhbXMuZmhjb25maWcgfHwgY29uc3RzLmNvbmZpZ19qcztcIixcIiAgYWpheCh7XCIsXCIgICAgdXJsOiBjb25maWdfdXJsLFwiLFwiICAgIGRhdGFUeXBlOiBcXFwianNvblxcXCIsXCIsXCIgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1wiLFwiICAgICAgbG9nZ2VyLmRlYnVnKFxcXCJmaGNvbmZpZyA9IFxcXCIgKyBKU09OLnN0cmluZ2lmeShkYXRhKSk7XCIsXCIgICAgICAvL3doZW4gbG9hZCB0aGUgY29uZmlnIGZpbGUgb24gZGV2aWNlLCBiZWNhdXNlIGZpbGU6Ly8gcHJvdG9jb2wgaXMgdXNlZCwgaXQgd2lsbCBuZXZlciBjYWxsIGZhaWwgY2FsbCBiYWNrLiBUaGUgc3VjY2VzcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBidXQgdGhlIGRhdGEgdmFsdWUgd2lsbCBiZSBudWxsLlwiLFwiICAgICAgaWYgKG51bGwgPT09IGRhdGEpIHtcIixcIiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihcXFwiYXBwX2NvbmZpZ19taXNzaW5nXFxcIikpO1wiLFwiICAgICAgfSBlbHNlIHtcIixcIiAgICAgICAgYXBwX3Byb3BzID0gZGF0YTtcIixcIlwiLFwiICAgICAgICBjYihudWxsLCBhcHBfcHJvcHMpO1wiLFwiICAgICAgfVwiLFwiICAgIH0sXCIsXCIgICAgZXJyb3I6IGZ1bmN0aW9uKHJlcSwgc3RhdHVzVGV4dCwgZXJyb3IpIHtcIixcIiAgICAgIC8vZmggdjIgb25seVwiLFwiICAgICAgaWYod2luZG93LmZoX2FwcF9wcm9wcyl7XCIsXCIgICAgICAgIHJldHVybiBjYihudWxsLCB3aW5kb3cuZmhfYXBwX3Byb3BzKTtcIixcIiAgICAgIH1cIixcIiAgICAgIGxvZ2dlci5lcnJvcihjb25zdHMuY29uZmlnX2pzICsgXFxcIiBOb3QgRm91bmRcXFwiKTtcIixcIiAgICAgIGNiKG5ldyBFcnJvcihcXFwiYXBwX2NvbmZpZ19taXNzaW5nXFxcIikpO1wiLFwiICAgIH1cIixcIiAgfSk7XCIsXCJ9O1wiLFwiXCIsXCJ2YXIgc2V0QXBwUHJvcHMgPSBmdW5jdGlvbihwcm9wcykge1wiLFwiICBhcHBfcHJvcHMgPSBwcm9wcztcIixcIn07XCIsXCJcIixcInZhciBnZXRBcHBQcm9wcyA9IGZ1bmN0aW9uKCkge1wiLFwiICByZXR1cm4gYXBwX3Byb3BzO1wiLFwifTtcIixcIlwiLFwibW9kdWxlLmV4cG9ydHMgPSB7XCIsXCIgIGxvYWQ6IGxvYWQsXCIsXCIgIGdldEFwcFByb3BzOiBnZXRBcHBQcm9wcyxcIixcIiAgc2V0QXBwUHJvcHM6IHNldEFwcFByb3BzXCIsXCJ9O1wiXTtcbiIsIi8qIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IEpTQ292ZXJhZ2UgLSBkbyBub3QgZWRpdCAqL1xuaWYgKHR5cGVvZiBfJGpzY292ZXJhZ2UgPT09ICd1bmRlZmluZWQnKSBfJGpzY292ZXJhZ2UgPSB7fTtcbmlmICghIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9jb25zdGFudHMuanMnXSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvY29uc3RhbnRzLmpzJ10gPSBbXTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2NvbnN0YW50cy5qcyddWzFdID0gMDtcbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9jb25zdGFudHMuanMnXVsxXSsrO1xubW9kdWxlLmV4cG9ydHMgPSB7XCJmaF90aW1lb3V0XCI6IDIwMDAwLCBcImJveHByZWZpeFwiOiBcIi9ib3gvc3J2LzEuMS9cIiwgXCJzZGtfdmVyc2lvblwiOiBcIkJVSUxEX1ZFUlNJT05cIiwgXCJjb25maWdfanNcIjogXCJmaGNvbmZpZy5qc29uXCIsIFwiSU5JVF9FVkVOVFwiOiBcImZoaW5pdFwifTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9jb25zdGFudHMuanMnXS5zb3VyY2UgPSBbXCJtb2R1bGUuZXhwb3J0cyA9IHtcIixcIiAgXFxcImZoX3RpbWVvdXRcXFwiOiAyMDAwMCxcIixcIiAgXFxcImJveHByZWZpeFxcXCI6IFxcXCIvYm94L3Nydi8xLjEvXFxcIixcIixcIiAgXFxcInNka192ZXJzaW9uXFxcIjogXFxcIkJVSUxEX1ZFUlNJT05cXFwiLFwiLFwiICBcXFwiY29uZmlnX2pzXFxcIjogXFxcImZoY29uZmlnLmpzb25cXFwiLFwiLFwiICBcXFwiSU5JVF9FVkVOVFxcXCI6IFxcXCJmaGluaXRcXFwiXCIsXCJ9O1wiXTtcbiIsIi8qIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IEpTQ292ZXJhZ2UgLSBkbyBub3QgZWRpdCAqL1xuaWYgKHR5cGVvZiBfJGpzY292ZXJhZ2UgPT09ICd1bmRlZmluZWQnKSBfJGpzY292ZXJhZ2UgPSB7fTtcbmlmICghIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9jb29raWVzLmpzJ10pIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2Nvb2tpZXMuanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvY29va2llcy5qcyddWzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2Nvb2tpZXMuanMnXVszXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9jb29raWVzLmpzJ11bNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvY29va2llcy5qcyddWzVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2Nvb2tpZXMuanMnXVs2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9jb29raWVzLmpzJ11bN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvY29va2llcy5qcyddWzhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2Nvb2tpZXMuanMnXVsxMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvY29va2llcy5qcyddWzExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9jb29raWVzLmpzJ11bMTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2Nvb2tpZXMuanMnXVsxOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvY29va2llcy5qcyddWzE5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9jb29raWVzLmpzJ11bMjBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2Nvb2tpZXMuanMnXVsyMV0gPSAwO1xufVxuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2Nvb2tpZXMuanMnXVsxXSsrO1xubW9kdWxlLmV4cG9ydHMgPSB7cmVhZENvb2tpZVZhbHVlOiAoZnVuY3Rpb24gKGNvb2tpZV9uYW1lKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9jb29raWVzLmpzJ11bM10rKztcbiAgdmFyIG5hbWVfc3RyID0gY29va2llX25hbWUgKyBcIj1cIjtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2Nvb2tpZXMuanMnXVs0XSsrO1xuICB2YXIgY29va2llcyA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdChcIjtcIik7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9jb29raWVzLmpzJ11bNV0rKztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29raWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2Nvb2tpZXMuanMnXVs2XSsrO1xuICAgIHZhciBjID0gY29va2llc1tpXTtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvY29va2llcy5qcyddWzddKys7XG4gICAgd2hpbGUgKGMuY2hhckF0KDApID09PSBcIiBcIikge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2Nvb2tpZXMuanMnXVs4XSsrO1xuICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcbn1cbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvY29va2llcy5qcyddWzEwXSsrO1xuICAgIGlmIChjLmluZGV4T2YobmFtZV9zdHIpID09PSAwKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvY29va2llcy5qcyddWzExXSsrO1xuICAgICAgcmV0dXJuIGMuc3Vic3RyaW5nKG5hbWVfc3RyLmxlbmd0aCwgYy5sZW5ndGgpO1xuICAgIH1cbn1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2Nvb2tpZXMuanMnXVsxNF0rKztcbiAgcmV0dXJuIG51bGw7XG59KSwgY3JlYXRlQ29va2llOiAoZnVuY3Rpb24gKGNvb2tpZV9uYW1lLCBjb29raWVfdmFsdWUpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2Nvb2tpZXMuanMnXVsxOF0rKztcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvY29va2llcy5qcyddWzE5XSsrO1xuICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAzMTUzNjAwMDAwMDAwKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2Nvb2tpZXMuanMnXVsyMF0rKztcbiAgdmFyIGV4cGlyZXMgPSBcIjsgZXhwaXJlcz1cIiArIGRhdGUudG9HTVRTdHJpbmcoKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2Nvb2tpZXMuanMnXVsyMV0rKztcbiAgZG9jdW1lbnQuY29va2llID0gY29va2llX25hbWUgKyBcIj1cIiArIGNvb2tpZV92YWx1ZSArIGV4cGlyZXMgKyBcIjsgcGF0aCA9IC9cIjtcbn0pfTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9jb29raWVzLmpzJ10uc291cmNlID0gW1wibW9kdWxlLmV4cG9ydHMgPSB7XCIsXCIgIHJlYWRDb29raWVWYWx1ZSAgOiBmdW5jdGlvbiAoY29va2llX25hbWUpIHtcIixcIiAgICB2YXIgbmFtZV9zdHIgPSBjb29raWVfbmFtZSArIFxcXCI9XFxcIjtcIixcIiAgICB2YXIgY29va2llcyA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdChcXFwiO1xcXCIpO1wiLFwiICAgIGZvciAodmFyIGkgPSAwOyBpICZsdDsgY29va2llcy5sZW5ndGg7IGkrKykge1wiLFwiICAgICAgdmFyIGMgPSBjb29raWVzW2ldO1wiLFwiICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09PSAnICcpIHtcIixcIiAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcIixcIiAgICAgIH1cIixcIiAgICAgIGlmIChjLmluZGV4T2YobmFtZV9zdHIpID09PSAwKSB7XCIsXCIgICAgICAgIHJldHVybiBjLnN1YnN0cmluZyhuYW1lX3N0ci5sZW5ndGgsIGMubGVuZ3RoKTtcIixcIiAgICAgIH1cIixcIiAgICB9XCIsXCIgICAgcmV0dXJuIG51bGw7XCIsXCIgIH0sXCIsXCJcIixcIiAgY3JlYXRlQ29va2llIDogZnVuY3Rpb24gKGNvb2tpZV9uYW1lLCBjb29raWVfdmFsdWUpIHtcIixcIiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XCIsXCIgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgMzY1MDAgKiAyNCAqIDYwICogNjAgKiAxMDAwKTsgLy8xMDAgeWVhcnNcIixcIiAgICB2YXIgZXhwaXJlcyA9IFxcXCI7IGV4cGlyZXM9XFxcIiArIGRhdGUudG9HTVRTdHJpbmcoKTtcIixcIiAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWVfbmFtZSArIFxcXCI9XFxcIiArIGNvb2tpZV92YWx1ZSArIGV4cGlyZXMgKyBcXFwiOyBwYXRoID0gL1xcXCI7XCIsXCIgIH1cIixcIn07XCJdO1xuIiwiLyogYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgSlNDb3ZlcmFnZSAtIGRvIG5vdCBlZGl0ICovXG5pZiAodHlwZW9mIF8kanNjb3ZlcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIF8kanNjb3ZlcmFnZSA9IHt9O1xuaWYgKCEgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bMTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVsxMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bMTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzE0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVsxNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bMTddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzE4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVsxOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bMjBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzIyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVsyOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bMjldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzMwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVszMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bMzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzMzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVszNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bNDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzQxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVs0NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bNDZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzQ3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVs0OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bNDldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzUwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVs1Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bNTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzU0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVs1NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bNjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzYyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVs2NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bNjddID0gMDtcbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVsxXSsrO1xudmFyIGNvb2tpZXMgPSByZXF1aXJlKFwiLi9jb29raWVzXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzJdKys7XG52YXIgdXVpZE1vZHVsZSA9IHJlcXVpcmUoXCIuL3V1aWRcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bM10rKztcbnZhciBsb2dnZXIgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bNV0rKztcbm1vZHVsZS5leHBvcnRzID0ge1wiZ2V0RGV2aWNlSWRcIjogKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzldKys7XG4gIGlmICh0eXBlb2Ygd2luZG93LmZoZGV2aWNlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZmhkZXZpY2UudXVpZCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVsxMF0rKztcbiAgICByZXR1cm4gd2luZG93LmZoZGV2aWNlLnV1aWQ7XG4gIH1cbiAgZWxzZSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzExXSsrO1xuICAgIGlmICh0eXBlb2Ygd2luZG93LmRldmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRldmljZS51dWlkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bMTJdKys7XG4gICAgICByZXR1cm4gd2luZG93LmRldmljZS51dWlkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVsxM10rKztcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yLmRldmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbmF2aWdhdG9yLmRldmljZS51dWlkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVsxNF0rKztcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5kZXZpY2UudXVpZDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bMTZdKys7XG4gICAgICAgIHZhciBfbW9ja191dWlkX2Nvb2tpZV9uYW1lID0gXCJtb2NrX3V1aWRcIjtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzE3XSsrO1xuICAgICAgICB2YXIgdXVpZCA9IGNvb2tpZXMucmVhZENvb2tpZVZhbHVlKF9tb2NrX3V1aWRfY29va2llX25hbWUpO1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bMThdKys7XG4gICAgICAgIGlmIChudWxsID09IHV1aWQpIHtcbiAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bMTldKys7XG4gICAgICAgICAgdXVpZCA9IHV1aWRNb2R1bGUuY3JlYXRlVVVJRCgpO1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVsyMF0rKztcbiAgICAgICAgICBjb29raWVzLmNyZWF0ZUNvb2tpZShfbW9ja191dWlkX2Nvb2tpZV9uYW1lLCB1dWlkKTtcbiAgICAgICAgfVxuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bMjJdKys7XG4gICAgICAgIHJldHVybiB1dWlkO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSksIFwiZ2V0Q3VpZE1hcFwiOiAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bMjhdKys7XG4gIGlmICh0eXBlb2Ygd2luZG93LmZoZGV2aWNlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZmhkZXZpY2UuY3VpZE1hcCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVsyOV0rKztcbiAgICByZXR1cm4gd2luZG93LmZoZGV2aWNlLmN1aWRNYXA7XG4gIH1cbiAgZWxzZSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzMwXSsrO1xuICAgIGlmICh0eXBlb2Ygd2luZG93LmRldmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRldmljZS5jdWlkTWFwICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bMzFdKys7XG4gICAgICByZXR1cm4gd2luZG93LmRldmljZS5jdWlkTWFwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVszMl0rKztcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yLmRldmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbmF2aWdhdG9yLmRldmljZS5jdWlkTWFwICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVszM10rKztcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5kZXZpY2UuY3VpZE1hcDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzM2XSsrO1xuICByZXR1cm4gbnVsbDtcbn0pLCBcImdldERlc3RpbmF0aW9uXCI6IChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVs0MF0rKztcbiAgdmFyIGRlc3RpbmF0aW9uID0gbnVsbDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzQxXSsrO1xuICB2YXIgcGxhdGZvcm1zVG9UZXN0ID0gcmVxdWlyZShcIi4vcGxhdGZvcm1zTWFwXCIpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bNDRdKys7XG4gIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bNDZdKys7XG4gIHZhciBkZXN0X292ZXJyaWRlID0gZG9jdW1lbnQubG9jYXRpb24uc2VhcmNoLnNwbGl0KFwiZmhfZGVzdGluYXRpb25fY29kZT1cIik7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVs0N10rKztcbiAgaWYgKGRlc3Rfb3ZlcnJpZGUubGVuZ3RoID4gMSkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVs0OF0rKztcbiAgICBkZXN0aW5hdGlvbiA9IGRlc3Rfb3ZlcnJpZGVbMV07XG4gIH1cbiAgZWxzZSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzQ5XSsrO1xuICAgIGlmICh0eXBlb2Ygd2luZG93LmZoX2Rlc3RpbmF0aW9uX2NvZGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVs1MF0rKztcbiAgICAgIGRlc3RpbmF0aW9uID0gd2luZG93LmZoX2Rlc3RpbmF0aW9uX2NvZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzUyXSsrO1xuICAgICAgcGxhdGZvcm1zVG9UZXN0LmZvckVhY2goKGZ1bmN0aW9uICh0ZXN0RGVzdGluYXRpb24pIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzUzXSsrO1xuICB0ZXN0RGVzdGluYXRpb24udGVzdC5mb3JFYWNoKChmdW5jdGlvbiAoZGVzdGluYXRpb25UZXN0KSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVs1NF0rKztcbiAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKGRlc3RpbmF0aW9uVGVzdCkgPiAtMSkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVs1NV0rKztcbiAgICBkZXN0aW5hdGlvbiA9IHRlc3REZXN0aW5hdGlvbi5kZXN0aW5hdGlvbjtcbiAgfVxufSkpO1xufSkpO1xuICAgIH1cbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bNjFdKys7XG4gIGlmIChkZXN0aW5hdGlvbiA9PSBudWxsKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddWzYyXSsrO1xuICAgIGRlc3RpbmF0aW9uID0gXCJ3ZWJcIjtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZGV2aWNlLmpzJ11bNjVdKys7XG4gIGxvZ2dlci5kZWJ1ZyhcImRlc3RpbmF0aW9uID0gXCIgKyBkZXN0aW5hdGlvbik7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9kZXZpY2UuanMnXVs2N10rKztcbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufSl9O1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2RldmljZS5qcyddLnNvdXJjZSA9IFtcInZhciBjb29raWVzID0gcmVxdWlyZShcXFwiLi9jb29raWVzXFxcIik7XCIsXCJ2YXIgdXVpZE1vZHVsZSA9IHJlcXVpcmUoXFxcIi4vdXVpZFxcXCIpO1wiLFwidmFyIGxvZ2dlciA9IHJlcXVpcmUoXFxcIi4vbG9nZ2VyXFxcIik7XCIsXCJcIixcIm1vZHVsZS5leHBvcnRzID0ge1wiLFwiICAvL3RyeSB0byBnZXQgdGhlIHVuaXF1ZSBkZXZpY2UgaWRlbnRpZmllclwiLFwiICBcXFwiZ2V0RGV2aWNlSWRcXFwiOiBmdW5jdGlvbigpe1wiLFwiICAgIC8vY2hlY2sgZm9yIGNvcmRvdmEvcGhvbmVnYXAgZmlyc3RcIixcIiAgICBpZih0eXBlb2Ygd2luZG93LmZoZGV2aWNlICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmYW1wOyZhbXA7IHR5cGVvZiB3aW5kb3cuZmhkZXZpY2UudXVpZCAhPT0gXFxcInVuZGVmaW5lZFxcXCIpe1wiLFwiICAgICAgcmV0dXJuIHdpbmRvdy5maGRldmljZS51dWlkO1wiLFwiICAgIH0gZWxzZSBpZih0eXBlb2Ygd2luZG93LmRldmljZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJmFtcDsmYW1wOyB0eXBlb2Ygd2luZG93LmRldmljZS51dWlkICE9PSBcXFwidW5kZWZpbmVkXFxcIil7XCIsXCIgICAgICByZXR1cm4gd2luZG93LmRldmljZS51dWlkO1wiLFwiICAgIH0gIGVsc2UgaWYodHlwZW9mIG5hdmlnYXRvci5kZXZpY2UgIT09IFxcXCJ1bmRlZmluZWRcXFwiICZhbXA7JmFtcDsgdHlwZW9mIG5hdmlnYXRvci5kZXZpY2UudXVpZCAhPT0gXFxcInVuZGVmaW5lZFxcXCIpe1wiLFwiICAgICAgcmV0dXJuIG5hdmlnYXRvci5kZXZpY2UudXVpZDtcIixcIiAgICB9IGVsc2Uge1wiLFwiICAgICAgdmFyIF9tb2NrX3V1aWRfY29va2llX25hbWUgPSBcXFwibW9ja191dWlkXFxcIjtcIixcIiAgICAgIHZhciB1dWlkID0gY29va2llcy5yZWFkQ29va2llVmFsdWUoX21vY2tfdXVpZF9jb29raWVfbmFtZSk7XCIsXCIgICAgICBpZihudWxsID09IHV1aWQpe1wiLFwiICAgICAgICAgIHV1aWQgPSB1dWlkTW9kdWxlLmNyZWF0ZVVVSUQoKTtcIixcIiAgICAgICAgICBjb29raWVzLmNyZWF0ZUNvb2tpZShfbW9ja191dWlkX2Nvb2tpZV9uYW1lLCB1dWlkKTtcIixcIiAgICAgIH1cIixcIiAgICAgIHJldHVybiB1dWlkO1wiLFwiICAgIH1cIixcIiAgfSxcIixcIlwiLFwiICAvL3RoaXMgaXMgZm9yIGZpeGluZyBhbmFseXRpY3MgaXNzdWVzIHdoZW4gdXBncmFkaW5nIGZyb20gaW82IHRvIGlvczcuIFByb2JhYmx5IGNhbiBiZSBkZXByZWNhdGVkIG5vd1wiLFwiICBcXFwiZ2V0Q3VpZE1hcFxcXCI6IGZ1bmN0aW9uKCl7XCIsXCIgICAgaWYodHlwZW9mIHdpbmRvdy5maGRldmljZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJmFtcDsmYW1wOyB0eXBlb2Ygd2luZG93LmZoZGV2aWNlLmN1aWRNYXAgIT09IFxcXCJ1bmRlZmluZWRcXFwiKXtcIixcIiAgICAgIHJldHVybiB3aW5kb3cuZmhkZXZpY2UuY3VpZE1hcDtcIixcIiAgICB9IGVsc2UgaWYodHlwZW9mIHdpbmRvdy5kZXZpY2UgIT09IFxcXCJ1bmRlZmluZWRcXFwiICZhbXA7JmFtcDsgdHlwZW9mIHdpbmRvdy5kZXZpY2UuY3VpZE1hcCAhPT0gXFxcInVuZGVmaW5lZFxcXCIpe1wiLFwiICAgICAgcmV0dXJuIHdpbmRvdy5kZXZpY2UuY3VpZE1hcDtcIixcIiAgICB9ICBlbHNlIGlmKHR5cGVvZiBuYXZpZ2F0b3IuZGV2aWNlICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmYW1wOyZhbXA7IHR5cGVvZiBuYXZpZ2F0b3IuZGV2aWNlLmN1aWRNYXAgIT09IFxcXCJ1bmRlZmluZWRcXFwiKXtcIixcIiAgICAgIHJldHVybiBuYXZpZ2F0b3IuZGV2aWNlLmN1aWRNYXA7XCIsXCIgICAgfVwiLFwiXCIsXCIgICAgcmV0dXJuIG51bGw7XCIsXCIgIH0sXCIsXCJcIixcIiAgXFxcImdldERlc3RpbmF0aW9uXFxcIjogZnVuY3Rpb24oKXtcIixcIiAgICB2YXIgZGVzdGluYXRpb24gPSBudWxsO1wiLFwiICAgIHZhciBwbGF0Zm9ybXNUb1Rlc3QgPSByZXF1aXJlKFxcXCIuL3BsYXRmb3Jtc01hcFxcXCIpO1wiLFwiXCIsXCJcIixcIiAgICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcIixcIlwiLFwiICAgIHZhciBkZXN0X292ZXJyaWRlID0gZG9jdW1lbnQubG9jYXRpb24uc2VhcmNoLnNwbGl0KFxcXCJmaF9kZXN0aW5hdGlvbl9jb2RlPVxcXCIpO1wiLFwiICAgIGlmIChkZXN0X292ZXJyaWRlLmxlbmd0aCAmZ3Q7IDEpIHtcIixcIiAgICAgZGVzdGluYXRpb24gPSBkZXN0X292ZXJyaWRlWzFdO1wiLFwiICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdy5maF9kZXN0aW5hdGlvbl9jb2RlICE9PSAndW5kZWZpbmVkJykge1wiLFwiICAgICAgZGVzdGluYXRpb24gPSB3aW5kb3cuZmhfZGVzdGluYXRpb25fY29kZTtcIixcIiAgICB9IGVsc2Uge1wiLFwiICAgICAgcGxhdGZvcm1zVG9UZXN0LmZvckVhY2goZnVuY3Rpb24odGVzdERlc3RpbmF0aW9uKXtcIixcIiAgICAgICAgdGVzdERlc3RpbmF0aW9uLnRlc3QuZm9yRWFjaChmdW5jdGlvbihkZXN0aW5hdGlvblRlc3Qpe1wiLFwiICAgICAgICAgIGlmKHVzZXJBZ2VudC5pbmRleE9mKGRlc3RpbmF0aW9uVGVzdCkgJmd0OyAtMSl7XCIsXCIgICAgICAgICAgICBkZXN0aW5hdGlvbiA9IHRlc3REZXN0aW5hdGlvbi5kZXN0aW5hdGlvbjtcIixcIiAgICAgICAgICB9XCIsXCIgICAgICAgIH0pO1wiLFwiICAgICAgfSk7XCIsXCIgICAgfVwiLFwiXCIsXCIgICAgaWYoZGVzdGluYXRpb24gPT0gbnVsbCl7IC8vTm8gdXNlciBhZ2VudHMgd2VyZSBmb3VuZCwgc2V0IHRvIGRlZmF1bHQgd2ViXCIsXCIgICAgICBkZXN0aW5hdGlvbiA9IFxcXCJ3ZWJcXFwiO1wiLFwiICAgIH1cIixcIlwiLFwiICAgIGxvZ2dlci5kZWJ1ZyhcXFwiZGVzdGluYXRpb24gPSBcXFwiICsgZGVzdGluYXRpb24pO1wiLFwiXCIsXCIgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1wiLFwiICB9XCIsXCJ9XCJdO1xuIiwiLyogYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgSlNDb3ZlcmFnZSAtIGRvIG5vdCBlZGl0ICovXG5pZiAodHlwZW9mIF8kanNjb3ZlcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIF8kanNjb3ZlcmFnZSA9IHt9O1xuaWYgKCEgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2V2ZW50cy5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ldmVudHMuanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZXZlbnRzLmpzJ11bMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZXZlbnRzLmpzJ11bM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZXZlbnRzLmpzJ11bNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZXZlbnRzLmpzJ11bNl0gPSAwO1xufVxuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2V2ZW50cy5qcyddWzFdKys7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50c1wiKS5FdmVudEVtaXR0ZXI7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvZXZlbnRzLmpzJ11bM10rKztcbnZhciBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2V2ZW50cy5qcyddWzRdKys7XG5lbWl0dGVyLnNldE1heExpc3RlbmVycygwKTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ldmVudHMuanMnXVs2XSsrO1xubW9kdWxlLmV4cG9ydHMgPSBlbWl0dGVyO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2V2ZW50cy5qcyddLnNvdXJjZSA9IFtcInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XCIsXCJcIixcInZhciBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1wiLFwiZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoMCk7XCIsXCJcIixcIm1vZHVsZS5leHBvcnRzID0gZW1pdHRlcjtcIl07XG4iLCIvKiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBKU0NvdmVyYWdlIC0gZG8gbm90IGVkaXQgKi9cbmlmICh0eXBlb2YgXyRqc2NvdmVyYWdlID09PSAndW5kZWZpbmVkJykgXyRqc2NvdmVyYWdlID0ge307XG5pZiAoISBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVsxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2ZocGFyYW1zLmpzJ11bM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVs0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2ZocGFyYW1zLmpzJ11bN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVs5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzEwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzEzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzE0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzE1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzE2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzE4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzE5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzIzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzI0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzI2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzI3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzI5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzMwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzMyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzMzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzM0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzM3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzM4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzM5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzQwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzQxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzQyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzQzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzQ0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzQ1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzQ5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzUwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzUxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzU0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzU1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzU2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzU3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzYwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzYxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzY0XSA9IDA7XG59XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVsxXSsrO1xudmFyIGRldmljZSA9IHJlcXVpcmUoXCIuL2RldmljZVwiKTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzJdKys7XG52YXIgc2RrdmVyc2lvbiA9IHJlcXVpcmUoXCIuL3Nka3ZlcnNpb25cIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVszXSsrO1xudmFyIGFwcFByb3BzID0gcmVxdWlyZShcIi4vYXBwUHJvcHNcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVs0XSsrO1xudmFyIGxvZ2dlciA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzZdKys7XG52YXIgZGVmYXVsdFBhcmFtcyA9IG51bGw7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVs3XSsrO1xudmFyIGF1dGhTZXNzaW9uVG9rZW4gPSBudWxsO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2ZocGFyYW1zLmpzJ11bOV0rKztcbnZhciBidWlsZEZIUGFyYW1zID0gKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2ZocGFyYW1zLmpzJ11bMTBdKys7XG4gIGlmIChkZWZhdWx0UGFyYW1zKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2ZocGFyYW1zLmpzJ11bMTFdKys7XG4gICAgcmV0dXJuIGRlZmF1bHRQYXJhbXM7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2ZocGFyYW1zLmpzJ11bMTNdKys7XG4gIHZhciBmaHBhcmFtcyA9IHt9O1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVsxNF0rKztcbiAgZmhwYXJhbXMuY3VpZCA9IGRldmljZS5nZXREZXZpY2VJZCgpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVsxNV0rKztcbiAgZmhwYXJhbXMuY3VpZE1hcCA9IGRldmljZS5nZXRDdWlkTWFwKCk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzE2XSsrO1xuICBmaHBhcmFtcy5kZXN0aW5hdGlvbiA9IGRldmljZS5nZXREZXN0aW5hdGlvbigpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVsxOF0rKztcbiAgaWYgKHdpbmRvdy5kZXZpY2UgfHwgbmF2aWdhdG9yLmRldmljZSkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzE5XSsrO1xuICAgIGZocGFyYW1zLmRldmljZSA9IHdpbmRvdy5kZXZpY2UgfHwgbmF2aWdhdG9yLmRldmljZTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVsyM10rKztcbiAgaWYgKHR5cGVvZiB3aW5kb3cuZmhfYXBwX3ZlcnNpb24gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVsyNF0rKztcbiAgICBmaHBhcmFtcy5hcHBfdmVyc2lvbiA9IGZoX2FwcF92ZXJzaW9uO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzI2XSsrO1xuICBpZiAodHlwZW9mIHdpbmRvdy5maF9wcm9qZWN0X3ZlcnNpb24gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVsyN10rKztcbiAgICBmaHBhcmFtcy5wcm9qZWN0X3ZlcnNpb24gPSBmaF9wcm9qZWN0X3ZlcnNpb247XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2ZocGFyYW1zLmpzJ11bMjldKys7XG4gIGlmICh0eXBlb2Ygd2luZG93LmZoX3Byb2plY3RfYXBwX3ZlcnNpb24gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVszMF0rKztcbiAgICBmaHBhcmFtcy5wcm9qZWN0X2FwcF92ZXJzaW9uID0gZmhfcHJvamVjdF9hcHBfdmVyc2lvbjtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVszMl0rKztcbiAgZmhwYXJhbXMuc2RrX3ZlcnNpb24gPSBzZGt2ZXJzaW9uKCk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzMzXSsrO1xuICBpZiAoYXV0aFNlc3Npb25Ub2tlbikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzM0XSsrO1xuICAgIGZocGFyYW1zLnNlc3Npb25Ub2tlbiA9IGF1dGhTZXNzaW9uVG9rZW47XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2ZocGFyYW1zLmpzJ11bMzddKys7XG4gIHZhciBhcHBfcHJvcHMgPSBhcHBQcm9wcy5nZXRBcHBQcm9wcygpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVszOF0rKztcbiAgaWYgKGFwcF9wcm9wcykge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzM5XSsrO1xuICAgIGZocGFyYW1zLmFwcGlkID0gYXBwX3Byb3BzLmFwcGlkO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzQwXSsrO1xuICAgIGZocGFyYW1zLmFwcGtleSA9IGFwcF9wcm9wcy5hcHBrZXk7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2ZocGFyYW1zLmpzJ11bNDFdKys7XG4gICAgZmhwYXJhbXMucHJvamVjdGlkID0gYXBwX3Byb3BzLnByb2plY3RpZDtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVs0Ml0rKztcbiAgICBmaHBhcmFtcy5hbmFseXRpY3NUYWcgPSBhcHBfcHJvcHMuYW5hbHl0aWNzVGFnO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzQzXSsrO1xuICAgIGZocGFyYW1zLmNvbm5lY3Rpb250YWcgPSBhcHBfcHJvcHMuY29ubmVjdGlvbnRhZztcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVs0NF0rKztcbiAgICBpZiAoYXBwX3Byb3BzLmluaXQpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzQ1XSsrO1xuICAgICAgZmhwYXJhbXMuaW5pdCA9IHR5cGVvZiBhcHBfcHJvcHMuaW5pdCA9PT0gXCJzdHJpbmdcIj8gSlNPTi5wYXJzZShhcHBfcHJvcHMuaW5pdCk6IGFwcF9wcm9wcy5pbml0O1xuICAgIH1cbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVs0OV0rKztcbiAgZGVmYXVsdFBhcmFtcyA9IGZocGFyYW1zO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVs1MF0rKztcbiAgbG9nZ2VyLmRlYnVnKFwiZmhwYXJhbXMgPSBcIiwgZGVmYXVsdFBhcmFtcyk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzUxXSsrO1xuICByZXR1cm4gZmhwYXJhbXM7XG59KTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzU0XSsrO1xudmFyIGFkZEZIUGFyYW1zID0gKGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2ZocGFyYW1zLmpzJ11bNTVdKys7XG4gIHZhciBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzU2XSsrO1xuICBwYXJhbXMuX19maCA9IGJ1aWxkRkhQYXJhbXMoKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2ZocGFyYW1zLmpzJ11bNTddKys7XG4gIHJldHVybiBwYXJhbXM7XG59KTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9maHBhcmFtcy5qcyddWzYwXSsrO1xudmFyIHNldEF1dGhTZXNzaW9uVG9rZW4gPSAoZnVuY3Rpb24gKHNlc3Npb25Ub2tlbikge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvZmhwYXJhbXMuanMnXVs2MV0rKztcbiAgYXV0aFNlc3Npb25Ub2tlbiA9IHNlc3Npb25Ub2tlbjtcbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2ZocGFyYW1zLmpzJ11bNjRdKys7XG5tb2R1bGUuZXhwb3J0cyA9IHtcImJ1aWxkRkhQYXJhbXNcIjogYnVpbGRGSFBhcmFtcywgXCJhZGRGSFBhcmFtc1wiOiBhZGRGSFBhcmFtcywgXCJzZXRBdXRoU2Vzc2lvblRva2VuXCI6IHNldEF1dGhTZXNzaW9uVG9rZW59O1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2ZocGFyYW1zLmpzJ10uc291cmNlID0gW1widmFyIGRldmljZSA9IHJlcXVpcmUoXFxcIi4vZGV2aWNlXFxcIik7XCIsXCJ2YXIgc2RrdmVyc2lvbiA9IHJlcXVpcmUoXFxcIi4vc2RrdmVyc2lvblxcXCIpO1wiLFwidmFyIGFwcFByb3BzID0gcmVxdWlyZShcXFwiLi9hcHBQcm9wc1xcXCIpO1wiLFwidmFyIGxvZ2dlciA9IHJlcXVpcmUoXFxcIi4vbG9nZ2VyXFxcIik7XCIsXCJcIixcInZhciBkZWZhdWx0UGFyYW1zID0gbnVsbDtcIixcInZhciBhdXRoU2Vzc2lvblRva2VuID0gbnVsbDtcIixcIi8vVE9ETzogcmV2aWV3IHRoZXNlIG9wdGlvbnMsIHdlIHByb2JhYmx5IG9ubHkgbmVlZHMgYWxsIG9mIHRoZW0gZm9yIGluaXQgY2FsbHMsIGJ1dCB3ZSBzaG91bGRuJ3QgbmVlZCBhbGwgb2YgdGhlbSBmb3IgYWN0IGNhbGxzXCIsXCJ2YXIgYnVpbGRGSFBhcmFtcyA9IGZ1bmN0aW9uKCl7XCIsXCIgIGlmKGRlZmF1bHRQYXJhbXMpe1wiLFwiICAgIHJldHVybiBkZWZhdWx0UGFyYW1zO1wiLFwiICB9XCIsXCIgIHZhciBmaHBhcmFtcyA9IHt9O1wiLFwiICBmaHBhcmFtcy5jdWlkID0gZGV2aWNlLmdldERldmljZUlkKCk7XCIsXCIgIGZocGFyYW1zLmN1aWRNYXAgPSBkZXZpY2UuZ2V0Q3VpZE1hcCgpO1wiLFwiICBmaHBhcmFtcy5kZXN0aW5hdGlvbiA9IGRldmljZS5nZXREZXN0aW5hdGlvbigpO1wiLFwiICBcIixcIiAgaWYod2luZG93LmRldmljZSB8fCBuYXZpZ2F0b3IuZGV2aWNlKXtcIixcIiAgICBmaHBhcmFtcy5kZXZpY2UgPSB3aW5kb3cuZGV2aWNlIHx8IG5hdmlnYXRvci5kZXZpY2U7XCIsXCIgIH1cIixcIlwiLFwiICAvL2JhY2t3YXJkIGNvbXBhdGlibGVcIixcIiAgaWYgKHR5cGVvZiB3aW5kb3cuZmhfYXBwX3ZlcnNpb24gIT09ICd1bmRlZmluZWQnKXtcIixcIiAgICBmaHBhcmFtcy5hcHBfdmVyc2lvbiA9IGZoX2FwcF92ZXJzaW9uO1wiLFwiICB9XCIsXCIgIGlmICh0eXBlb2Ygd2luZG93LmZoX3Byb2plY3RfdmVyc2lvbiAhPT0gJ3VuZGVmaW5lZCcpe1wiLFwiICAgIGZocGFyYW1zLnByb2plY3RfdmVyc2lvbiA9IGZoX3Byb2plY3RfdmVyc2lvbjtcIixcIiAgfVwiLFwiICBpZiAodHlwZW9mIHdpbmRvdy5maF9wcm9qZWN0X2FwcF92ZXJzaW9uICE9PSAndW5kZWZpbmVkJyl7XCIsXCIgICAgZmhwYXJhbXMucHJvamVjdF9hcHBfdmVyc2lvbiA9IGZoX3Byb2plY3RfYXBwX3ZlcnNpb247XCIsXCIgIH1cIixcIiAgZmhwYXJhbXMuc2RrX3ZlcnNpb24gPSBzZGt2ZXJzaW9uKCk7XCIsXCIgIGlmKGF1dGhTZXNzaW9uVG9rZW4pe1wiLFwiICAgIGZocGFyYW1zLnNlc3Npb25Ub2tlbiA9IGF1dGhTZXNzaW9uVG9rZW47XCIsXCIgIH1cIixcIlwiLFwiICB2YXIgYXBwX3Byb3BzID0gYXBwUHJvcHMuZ2V0QXBwUHJvcHMoKTtcIixcIiAgaWYoYXBwX3Byb3BzKXtcIixcIiAgICBmaHBhcmFtcy5hcHBpZCA9IGFwcF9wcm9wcy5hcHBpZDtcIixcIiAgICBmaHBhcmFtcy5hcHBrZXkgPSBhcHBfcHJvcHMuYXBwa2V5O1wiLFwiICAgIGZocGFyYW1zLnByb2plY3RpZCA9IGFwcF9wcm9wcy5wcm9qZWN0aWQ7XCIsXCIgICAgZmhwYXJhbXMuYW5hbHl0aWNzVGFnID0gIGFwcF9wcm9wcy5hbmFseXRpY3NUYWc7XCIsXCIgICAgZmhwYXJhbXMuY29ubmVjdGlvbnRhZyA9IGFwcF9wcm9wcy5jb25uZWN0aW9udGFnO1wiLFwiICAgIGlmKGFwcF9wcm9wcy5pbml0KXtcIixcIiAgICAgIGZocGFyYW1zLmluaXQgPSB0eXBlb2YoYXBwX3Byb3BzLmluaXQpID09PSBcXFwic3RyaW5nXFxcIiA/IEpTT04ucGFyc2UoYXBwX3Byb3BzLmluaXQpIDogYXBwX3Byb3BzLmluaXQ7XCIsXCIgICAgfVwiLFwiICB9XCIsXCIgIFwiLFwiICBkZWZhdWx0UGFyYW1zID0gZmhwYXJhbXM7XCIsXCIgIGxvZ2dlci5kZWJ1ZyhcXFwiZmhwYXJhbXMgPSBcXFwiLCBkZWZhdWx0UGFyYW1zKTtcIixcIiAgcmV0dXJuIGZocGFyYW1zO1wiLFwifVwiLFwiXCIsXCJ2YXIgYWRkRkhQYXJhbXMgPSBmdW5jdGlvbihwYXJhbXMpe1wiLFwiICB2YXIgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1wiLFwiICBwYXJhbXMuX19maCA9IGJ1aWxkRkhQYXJhbXMoKTtcIixcIiAgcmV0dXJuIHBhcmFtcztcIixcIn1cIixcIlwiLFwidmFyIHNldEF1dGhTZXNzaW9uVG9rZW4gPSBmdW5jdGlvbihzZXNzaW9uVG9rZW4pe1wiLFwiICBhdXRoU2Vzc2lvblRva2VuID0gc2Vzc2lvblRva2VuO1wiLFwifVwiLFwiXCIsXCJtb2R1bGUuZXhwb3J0cyA9IHtcIixcIiAgXFxcImJ1aWxkRkhQYXJhbXNcXFwiOiBidWlsZEZIUGFyYW1zLFwiLFwiICBcXFwiYWRkRkhQYXJhbXNcXFwiOiBhZGRGSFBhcmFtcyxcIixcIiAgXFxcInNldEF1dGhTZXNzaW9uVG9rZW5cXFwiOnNldEF1dGhTZXNzaW9uVG9rZW5cIixcIn1cIl07XG4iLCIvKiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBKU0NvdmVyYWdlIC0gZG8gbm90IGVkaXQgKi9cbmlmICh0eXBlb2YgXyRqc2NvdmVyYWdlID09PSAndW5kZWZpbmVkJykgXyRqc2NvdmVyYWdlID0ge307XG5pZiAoISBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaGFuZGxlRXJyb3IuanMnXSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaGFuZGxlRXJyb3IuanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaGFuZGxlRXJyb3IuanMnXVsxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9oYW5kbGVFcnJvci5qcyddWzNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaGFuZGxlRXJyb3IuanMnXVs1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9oYW5kbGVFcnJvci5qcyddWzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaGFuZGxlRXJyb3IuanMnXVs4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9oYW5kbGVFcnJvci5qcyddWzldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bMTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bMTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bMTJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bMTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bMThdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bMTldID0gMDtcbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9oYW5kbGVFcnJvci5qcyddWzFdKys7XG52YXIgSlNPTiA9IHJlcXVpcmUoXCJKU09OXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bM10rKztcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uIChmYWlsLCByZXEsIHJlc1N0YXR1cywgZXJyb3IpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bNF0rKztcbiAgdmFyIGVycnJhdztcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bNV0rKztcbiAgdmFyIHN0YXR1c0NvZGUgPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaGFuZGxlRXJyb3IuanMnXVs2XSsrO1xuICBpZiAocmVxKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bN10rKztcbiAgICB0cnkge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bOF0rKztcbiAgICAgIHN0YXR1c0NvZGUgPSByZXEuc3RhdHVzO1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bOV0rKztcbiAgICAgIHZhciByZXMgPSBKU09OLnBhcnNlKHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bMTBdKys7XG4gICAgICBlcnJyYXcgPSByZXMuZXJyb3IgfHwgcmVzLm1zZztcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9oYW5kbGVFcnJvci5qcyddWzExXSsrO1xuICAgICAgaWYgKGVycnJhdyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9oYW5kbGVFcnJvci5qcyddWzEyXSsrO1xuICAgICAgICBlcnJyYXcgPSBlcnJyYXcuam9pbihcIlxcblwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9oYW5kbGVFcnJvci5qcyddWzE1XSsrO1xuICAgICAgZXJycmF3ID0gcmVxLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bMThdKys7XG4gIGlmIChmYWlsKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ11bMTldKys7XG4gICAgZmFpbChlcnJyYXcsIHtzdGF0dXM6IHN0YXR1c0NvZGUsIG1lc3NhZ2U6IHJlc1N0YXR1cywgZXJyb3I6IGVycm9yfSk7XG4gIH1cbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hhbmRsZUVycm9yLmpzJ10uc291cmNlID0gW1widmFyIEpTT04gPSByZXF1aXJlKFxcXCJKU09OXFxcIik7XCIsXCJcIixcIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZmFpbCwgcmVxLCByZXNTdGF0dXMsIGVycm9yKXtcIixcIiAgdmFyIGVycnJhdztcIixcIiAgdmFyIHN0YXR1c0NvZGUgPSAwO1wiLFwiICBpZihyZXEpe1wiLFwiICAgIHRyeXtcIixcIiAgICAgIHN0YXR1c0NvZGUgPSByZXEuc3RhdHVzO1wiLFwiICAgICAgdmFyIHJlcyA9IEpTT04ucGFyc2UocmVxLnJlc3BvbnNlVGV4dCk7XCIsXCIgICAgICBlcnJyYXcgPSByZXMuZXJyb3IgfHwgcmVzLm1zZztcIixcIiAgICAgIGlmIChlcnJyYXcgaW5zdGFuY2VvZiBBcnJheSkge1wiLFwiICAgICAgICBlcnJyYXcgPSBlcnJyYXcuam9pbignXFxcXG4nKTtcIixcIiAgICAgIH1cIixcIiAgICB9IGNhdGNoKGUpe1wiLFwiICAgICAgZXJycmF3ID0gcmVxLnJlc3BvbnNlVGV4dDtcIixcIiAgICB9XCIsXCIgIH1cIixcIiAgaWYoZmFpbCl7XCIsXCIgICAgZmFpbChlcnJyYXcsIHtcIixcIiAgICAgIHN0YXR1czogc3RhdHVzQ29kZSxcIixcIiAgICAgIG1lc3NhZ2U6IHJlc1N0YXR1cyxcIixcIiAgICAgIGVycm9yOiBlcnJvclwiLFwiICAgIH0pO1wiLFwiICB9XCIsXCJ9O1wiXTtcbiIsIi8qIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IEpTQ292ZXJhZ2UgLSBkbyBub3QgZWRpdCAqL1xuaWYgKHR5cGVvZiBfJGpzY292ZXJhZ2UgPT09ICd1bmRlZmluZWQnKSBfJGpzY292ZXJhZ2UgPSB7fTtcbmlmICghIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddID0gW107XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVs0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVs3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMTJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMTddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMjBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMjJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMjNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMjZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMjddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMzBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMzNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMzVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNDFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNDNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNDRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNDVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNDddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNTJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNTldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNjBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNjJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNjRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNjddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNzNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNzRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNzldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bODBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bODFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bODJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bODRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bODldID0gMDtcbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzFdKys7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMl0rKztcbnZhciBhcHBQcm9wcyA9IHJlcXVpcmUoXCIuL2FwcFByb3BzXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNF0rKztcbmZ1bmN0aW9uIHJlbW92ZUVuZFNsYXNoKGlucHV0KSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzVdKys7XG4gIHZhciByZXQgPSBpbnB1dDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNl0rKztcbiAgaWYgKHJldC5jaGFyQXQocmV0Lmxlbmd0aCAtIDEpID09PSBcIi9cIikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzddKys7XG4gICAgcmV0ID0gcmV0LnN1YnN0cmluZygwLCByZXQubGVuZ3RoIC0gMSk7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bOV0rKztcbiAgcmV0dXJuIHJldDtcbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzEyXSsrO1xuZnVuY3Rpb24gcmVtb3ZlU3RhcnRTbGFzaChpbnB1dCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVsxM10rKztcbiAgdmFyIHJldCA9IGlucHV0O1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVsxNF0rKztcbiAgaWYgKHJldC5sZW5ndGggPiAxICYmIHJldC5jaGFyQXQoMCkgPT09IFwiL1wiKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMTVdKys7XG4gICAgcmV0ID0gcmV0LnN1YnN0cmluZygxLCByZXQubGVuZ3RoKTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVsxN10rKztcbiAgcmV0dXJuIHJldDtcbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzIwXSsrO1xuZnVuY3Rpb24gQ2xvdWRIb3N0KGNsb3VkX3Byb3BzKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzIxXSsrO1xuICB0aGlzLmNsb3VkX3Byb3BzID0gY2xvdWRfcHJvcHM7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzIyXSsrO1xuICB0aGlzLmNsb3VkX2hvc3QgPSB1bmRlZmluZWQ7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzIzXSsrO1xuICB0aGlzLmlzTGVnYWN5ID0gZmFsc2U7XG59XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVsyNl0rKztcbkNsb3VkSG9zdC5wcm90b3R5cGUuZ2V0SG9zdCA9IChmdW5jdGlvbiAoYXBwVHlwZSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVsyN10rKztcbiAgaWYgKHRoaXMuY2xvdWRfaG9zdCkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzI4XSsrO1xuICAgIHJldHVybiB0aGlzLmNsb3VkX2hvc3Q7XG4gIH1cbiAgZWxzZSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMzBdKys7XG4gICAgdmFyIHVybDtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVszMV0rKztcbiAgICB2YXIgYXBwX3R5cGU7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMzJdKys7XG4gICAgaWYgKHRoaXMuY2xvdWRfcHJvcHMgJiYgdGhpcy5jbG91ZF9wcm9wcy5ob3N0cykge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bMzNdKys7XG4gICAgICB1cmwgPSB0aGlzLmNsb3VkX3Byb3BzLmhvc3RzLnVybDtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzM1XSsrO1xuICAgICAgaWYgKHR5cGVvZiB1cmwgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNDBdKys7XG4gICAgICAgIHZhciBjbG91ZF9ob3N0ID0gdGhpcy5jbG91ZF9wcm9wcy5ob3N0cy5yZWxlYXNlQ2xvdWRVcmw7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzQxXSsrO1xuICAgICAgICBhcHBfdHlwZSA9IHRoaXMuY2xvdWRfcHJvcHMuaG9zdHMucmVsZWFzZUNsb3VkVHlwZTtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNDNdKys7XG4gICAgICAgIGlmICh0eXBlb2YgYXBwVHlwZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcHBUeXBlLmluZGV4T2YoXCJkZXZcIikgPiAtMSkge1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzQ0XSsrO1xuICAgICAgICAgIGNsb3VkX2hvc3QgPSB0aGlzLmNsb3VkX3Byb3BzLmhvc3RzLmRlYnVnQ2xvdWRVcmw7XG4gICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNDVdKys7XG4gICAgICAgICAgYXBwX3R5cGUgPSB0aGlzLmNsb3VkX3Byb3BzLmhvc3RzLmRlYnVnQ2xvdWRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzQ3XSsrO1xuICAgICAgICB1cmwgPSBjbG91ZF9ob3N0O1xuICAgICAgfVxuICAgIH1cbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVs1MF0rKztcbiAgICB1cmwgPSByZW1vdmVFbmRTbGFzaCh1cmwpO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzUxXSsrO1xuICAgIHRoaXMuY2xvdWRfaG9zdCA9IHVybDtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVs1Ml0rKztcbiAgICBpZiAoYXBwX3R5cGUgPT09IFwiZmhcIikge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNTNdKys7XG4gICAgICB0aGlzLmlzTGVnYWN5ID0gdHJ1ZTtcbiAgICB9XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNTVdKys7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxufSk7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVs1OV0rKztcbkNsb3VkSG9zdC5wcm90b3R5cGUuZ2V0QWN0VXJsID0gKGZ1bmN0aW9uIChhY3QpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNjBdKys7XG4gIHZhciBhcHBfcHJvcHMgPSBhcHBQcm9wcy5nZXRBcHBQcm9wcygpIHx8IHt9O1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVs2MV0rKztcbiAgaWYgKHR5cGVvZiB0aGlzLmNsb3VkX2hvc3QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVs2Ml0rKztcbiAgICB0aGlzLmdldEhvc3QoYXBwX3Byb3BzLm1vZGUpO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzY0XSsrO1xuICBpZiAodGhpcy5pc0xlZ2FjeSkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzY1XSsrO1xuICAgIHJldHVybiB0aGlzLmNsb3VkX2hvc3QgKyBjb25zdGFudHMuYm94cHJlZml4ICsgXCJhY3QvXCIgKyB0aGlzLmNsb3VkX3Byb3BzLmRvbWFpbiArIFwiL1wiICsgYXBwX3Byb3BzLmFwcGlkICsgXCIvXCIgKyBhY3QgKyBcIi9cIiArIGFwcF9wcm9wcy5hcHBpZDtcbiAgfVxuICBlbHNlIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVs2N10rKztcbiAgICByZXR1cm4gdGhpcy5jbG91ZF9ob3N0ICsgXCIvY2xvdWQvXCIgKyBhY3Q7XG4gIH1cbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNzFdKys7XG5DbG91ZEhvc3QucHJvdG90eXBlLmdldE1CQUFTVXJsID0gKGZ1bmN0aW9uIChzZXJ2aWNlKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzcyXSsrO1xuICB2YXIgYXBwX3Byb3BzID0gYXBwUHJvcHMuZ2V0QXBwUHJvcHMoKSB8fCB7fTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNzNdKys7XG4gIGlmICh0eXBlb2YgdGhpcy5jbG91ZF9ob3N0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNzRdKys7XG4gICAgdGhpcy5nZXRIb3N0KGFwcF9wcm9wcy5tb2RlKTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVs3Nl0rKztcbiAgcmV0dXJuIHRoaXMuY2xvdWRfaG9zdCArIFwiL21iYWFzL1wiICsgc2VydmljZTtcbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bNzldKys7XG5DbG91ZEhvc3QucHJvdG90eXBlLmdldENsb3VkVXJsID0gKGZ1bmN0aW9uIChwYXRoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddWzgwXSsrO1xuICB2YXIgYXBwX3Byb3BzID0gYXBwUHJvcHMuZ2V0QXBwUHJvcHMoKSB8fCB7fTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bODFdKys7XG4gIGlmICh0eXBlb2YgdGhpcy5jbG91ZF9ob3N0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bODJdKys7XG4gICAgdGhpcy5nZXRIb3N0KGFwcF9wcm9wcy5tb2RlKTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaG9zdHMuanMnXVs4NF0rKztcbiAgcmV0dXJuIHRoaXMuY2xvdWRfaG9zdCArIFwiL1wiICsgcmVtb3ZlU3RhcnRTbGFzaChwYXRoKTtcbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2hvc3RzLmpzJ11bODldKys7XG5tb2R1bGUuZXhwb3J0cyA9IENsb3VkSG9zdDtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9ob3N0cy5qcyddLnNvdXJjZSA9IFtcInZhciBjb25zdGFudHMgPSByZXF1aXJlKFxcXCIuL2NvbnN0YW50c1xcXCIpO1wiLFwidmFyIGFwcFByb3BzID0gcmVxdWlyZShcXFwiLi9hcHBQcm9wc1xcXCIpO1wiLFwiXCIsXCJmdW5jdGlvbiByZW1vdmVFbmRTbGFzaChpbnB1dCl7XCIsXCIgIHZhciByZXQgPSBpbnB1dDtcIixcIiAgaWYocmV0LmNoYXJBdChyZXQubGVuZ3RoIC0gMSkgPT09IFxcXCIvXFxcIil7XCIsXCIgICAgcmV0ID0gcmV0LnN1YnN0cmluZygwLCByZXQubGVuZ3RoLTEpO1wiLFwiICB9XCIsXCIgIHJldHVybiByZXQ7XCIsXCJ9XCIsXCJcIixcImZ1bmN0aW9uIHJlbW92ZVN0YXJ0U2xhc2goaW5wdXQpe1wiLFwiICB2YXIgcmV0ID0gaW5wdXQ7XCIsXCIgIGlmKHJldC5sZW5ndGggJmd0OyAxICZhbXA7JmFtcDsgcmV0LmNoYXJBdCgwKSA9PT0gXFxcIi9cXFwiKXtcIixcIiAgICByZXQgPSByZXQuc3Vic3RyaW5nKDEsIHJldC5sZW5ndGgpO1wiLFwiICB9XCIsXCIgIHJldHVybiByZXQ7XCIsXCJ9XCIsXCJcIixcImZ1bmN0aW9uIENsb3VkSG9zdChjbG91ZF9wcm9wcyl7XCIsXCIgIHRoaXMuY2xvdWRfcHJvcHMgPSBjbG91ZF9wcm9wcztcIixcIiAgdGhpcy5jbG91ZF9ob3N0ID0gdW5kZWZpbmVkO1wiLFwiICB0aGlzLmlzTGVnYWN5ID0gZmFsc2U7XCIsXCJ9XCIsXCJcIixcIkNsb3VkSG9zdC5wcm90b3R5cGUuZ2V0SG9zdCA9IGZ1bmN0aW9uKGFwcFR5cGUpe1wiLFwiICBpZih0aGlzLmNsb3VkX2hvc3Qpe1wiLFwiICAgIHJldHVybiB0aGlzLmNsb3VkX2hvc3Q7XCIsXCIgIH0gZWxzZSB7XCIsXCIgICAgdmFyIHVybDtcIixcIiAgICB2YXIgYXBwX3R5cGU7XCIsXCIgICAgaWYodGhpcy5jbG91ZF9wcm9wcyAmYW1wOyZhbXA7IHRoaXMuY2xvdWRfcHJvcHMuaG9zdHMpe1wiLFwiICAgICAgdXJsID0gdGhpcy5jbG91ZF9wcm9wcy5ob3N0cy51cmw7XCIsXCJcIixcIiAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1wiLFwiICAgICAgICAvLyByZXNvbHZlIHVybCB0aGUgb2xkIHdheSBpLmUuIGRlcGVuZGluZyBvblwiLFwiICAgICAgICAvLyAtYnVybnQgaW4gYXBwIG1vZGVcIixcIiAgICAgICAgLy8gLXJldHVybmVkIGRldiBvciBsaXZlIHVybFwiLFwiICAgICAgICAvLyAtcmV0dXJuZWQgZGV2IG9yIGxpdmUgdHlwZSAobm9kZSBvciBmaChyaGlubyBvciBwcm94eWluZykpXCIsXCIgICAgICAgIHZhciBjbG91ZF9ob3N0ID0gdGhpcy5jbG91ZF9wcm9wcy5ob3N0cy5yZWxlYXNlQ2xvdWRVcmw7XCIsXCIgICAgICAgIGFwcF90eXBlID0gdGhpcy5jbG91ZF9wcm9wcy5ob3N0cy5yZWxlYXNlQ2xvdWRUeXBlO1wiLFwiXCIsXCIgICAgICAgIGlmKHR5cGVvZiBhcHBUeXBlICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmYW1wOyZhbXA7IGFwcFR5cGUuaW5kZXhPZihcXFwiZGV2XFxcIikgJmd0OyAtMSl7XCIsXCIgICAgICAgICAgY2xvdWRfaG9zdCA9IHRoaXMuY2xvdWRfcHJvcHMuaG9zdHMuZGVidWdDbG91ZFVybDtcIixcIiAgICAgICAgICBhcHBfdHlwZSA9IHRoaXMuY2xvdWRfcHJvcHMuaG9zdHMuZGVidWdDbG91ZFR5cGU7XCIsXCIgICAgICAgIH1cIixcIiAgICAgICAgdXJsID0gY2xvdWRfaG9zdDtcIixcIiAgICAgIH1cIixcIiAgICB9XCIsXCIgICAgdXJsID0gcmVtb3ZlRW5kU2xhc2godXJsKTtcIixcIiAgICB0aGlzLmNsb3VkX2hvc3QgPSB1cmw7XCIsXCIgICAgaWYoYXBwX3R5cGUgPT09IFxcXCJmaFxcXCIpe1wiLFwiICAgICAgdGhpcy5pc0xlZ2FjeSA9IHRydWU7XCIsXCIgICAgfVwiLFwiICAgIHJldHVybiB1cmw7XCIsXCIgIH1cIixcIn1cIixcIlwiLFwiQ2xvdWRIb3N0LnByb3RvdHlwZS5nZXRBY3RVcmwgPSBmdW5jdGlvbihhY3Qpe1wiLFwiICB2YXIgYXBwX3Byb3BzID0gYXBwUHJvcHMuZ2V0QXBwUHJvcHMoKSB8fCB7fTtcIixcIiAgaWYodHlwZW9mIHRoaXMuY2xvdWRfaG9zdCA9PT0gXFxcInVuZGVmaW5lZFxcXCIpe1wiLFwiICAgIHRoaXMuZ2V0SG9zdChhcHBfcHJvcHMubW9kZSk7XCIsXCIgIH1cIixcIiAgaWYodGhpcy5pc0xlZ2FjeSl7XCIsXCIgICAgcmV0dXJuIHRoaXMuY2xvdWRfaG9zdCArIGNvbnN0YW50cy5ib3hwcmVmaXggKyBcXFwiYWN0L1xcXCIgKyB0aGlzLmNsb3VkX3Byb3BzLmRvbWFpbiArIFxcXCIvXFxcIiArIGFwcF9wcm9wcy5hcHBpZCArIFxcXCIvXFxcIiArIGFjdCArIFxcXCIvXFxcIiArIGFwcF9wcm9wcy5hcHBpZDtcIixcIiAgfSBlbHNlIHtcIixcIiAgICByZXR1cm4gdGhpcy5jbG91ZF9ob3N0ICsgXFxcIi9jbG91ZC9cXFwiICsgYWN0O1wiLFwiICB9XCIsXCJ9XCIsXCJcIixcIkNsb3VkSG9zdC5wcm90b3R5cGUuZ2V0TUJBQVNVcmwgPSBmdW5jdGlvbihzZXJ2aWNlKXtcIixcIiAgdmFyIGFwcF9wcm9wcyA9IGFwcFByb3BzLmdldEFwcFByb3BzKCkgfHwge307XCIsXCIgIGlmKHR5cGVvZiB0aGlzLmNsb3VkX2hvc3QgPT09IFxcXCJ1bmRlZmluZWRcXFwiKXtcIixcIiAgICB0aGlzLmdldEhvc3QoYXBwX3Byb3BzLm1vZGUpO1wiLFwiICB9XCIsXCIgIHJldHVybiB0aGlzLmNsb3VkX2hvc3QgKyBcXFwiL21iYWFzL1xcXCIgKyBzZXJ2aWNlO1wiLFwifVwiLFwiXCIsXCJDbG91ZEhvc3QucHJvdG90eXBlLmdldENsb3VkVXJsID0gZnVuY3Rpb24ocGF0aCl7XCIsXCIgIHZhciBhcHBfcHJvcHMgPSBhcHBQcm9wcy5nZXRBcHBQcm9wcygpIHx8IHt9O1wiLFwiICBpZih0eXBlb2YgdGhpcy5jbG91ZF9ob3N0ID09PSBcXFwidW5kZWZpbmVkXFxcIil7XCIsXCIgICAgdGhpcy5nZXRIb3N0KGFwcF9wcm9wcy5tb2RlKTtcIixcIiAgfVwiLFwiICByZXR1cm4gdGhpcy5jbG91ZF9ob3N0ICsgXFxcIi9cXFwiICsgcmVtb3ZlU3RhcnRTbGFzaChwYXRoKTtcIixcIn1cIixcIlwiLFwiXCIsXCJcIixcIm1vZHVsZS5leHBvcnRzID0gQ2xvdWRIb3N0O1wiXTtcbiIsIi8qIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IEpTQ292ZXJhZ2UgLSBkbyBub3QgZWRpdCAqL1xuaWYgKHR5cGVvZiBfJGpzY292ZXJhZ2UgPT09ICd1bmRlZmluZWQnKSBfJGpzY292ZXJhZ2UgPSB7fTtcbmlmICghIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddID0gW107XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVszXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVs2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVs5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzEwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzEzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzE0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzE1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzE2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzIwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzIxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzIyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzI1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzI2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzQzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzUwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzU0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzU4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzU5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzYzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzY0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzY1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzY5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzcwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzczXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzc1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzc2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzc3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzc4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzc5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzgwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzgxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzg0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzg2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzg3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzkwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzkyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzEwMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVsxMDVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bMTA2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzExM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVsxMTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bMTE1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzEyMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVsxMjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bMTIyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzEzNF0gPSAwO1xufVxuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bMV0rKztcbnZhciBsb2FkU2NyaXB0ID0gcmVxdWlyZShcIi4vbG9hZFNjcmlwdFwiKTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzJdKys7XG52YXIgTGF3bmNoYWlyID0gcmVxdWlyZShcIi4uLy4uL2xpYnMvZ2VuZXJhdGVkL2xhd25jaGFpclwiKTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzNdKys7XG52YXIgbGF3bmNoYWlyZXh0ID0gcmVxdWlyZShcIi4vbGF3bmNoYWlyLWV4dFwiKTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzRdKys7XG52YXIgY29uc3RzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bNV0rKztcbnZhciBmaHBhcmFtcyA9IHJlcXVpcmUoXCIuL2ZocGFyYW1zXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bNl0rKztcbnZhciBhamF4ID0gcmVxdWlyZShcIi4vYWpheFwiKTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzddKys7XG52YXIgaGFuZGxlRXJyb3IgPSByZXF1aXJlKFwiLi9oYW5kbGVFcnJvclwiKTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzhdKys7XG52YXIgbG9nZ2VyID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bOV0rKztcbnZhciBKU09OID0gcmVxdWlyZShcIkpTT05cIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVsxMF0rKztcbnZhciBoYXNoRnVuYyA9IHJlcXVpcmUoXCIuL3NlY3VyaXR5L2hhc2hcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVsxMV0rKztcbnZhciBhcHBQcm9wcyA9IHJlcXVpcmUoXCIuL2FwcFByb3BzXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bMTNdKys7XG52YXIgaW5pdCA9IChmdW5jdGlvbiAoY2IpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bMTRdKys7XG4gIGFwcFByb3BzLmxvYWQoKGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bMTVdKys7XG4gIGlmIChlcnIpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVsxNV0rKztcbiAgICByZXR1cm4gY2IoZXJyKTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVsxNl0rKztcbiAgcmV0dXJuIGxvYWRDbG91ZFByb3BzKGRhdGEsIGNiKTtcbn0pKTtcbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bMjBdKys7XG52YXIgbG9hZENsb3VkUHJvcHMgPSAoZnVuY3Rpb24gKGFwcF9wcm9wcywgY2FsbGJhY2spIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bMjFdKys7XG4gIGlmIChhcHBfcHJvcHMubG9nbGV2ZWwpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVsyMl0rKztcbiAgICBsb2dnZXIuc2V0TGV2ZWwoYXBwX3Byb3BzLmxvZ2xldmVsKTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVsyNV0rKztcbiAgaWYgKGFwcF9wcm9wcy5sb2NhbCkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzI2XSsrO1xuICAgIHZhciByZXMgPSB7XCJkb21haW5cIjogXCJsb2NhbFwiLCBcImZpcnN0VGltZVwiOiBmYWxzZSwgXCJob3N0c1wiOiB7XCJkZWJ1Z0Nsb3VkVHlwZVwiOiBcIm5vZGVcIiwgXCJkZWJ1Z0Nsb3VkVXJsXCI6IGFwcF9wcm9wcy5ob3N0LCBcInJlbGVhc2VDbG91ZFR5cGVcIjogXCJub2RlXCIsIFwicmVsZWFzZUNsb3VkVXJsXCI6IGFwcF9wcm9wcy5ob3N0LCBcInR5cGVcIjogXCJjbG91ZF9ub2RlanNcIiwgXCJ1cmxcIjogYXBwX3Byb3BzLmhvc3R9LCBcImluaXRcIjoge1widHJhY2tJZFwiOiBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwifSwgXCJzdGF0dXNcIjogXCJva1wifTtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVs0M10rKztcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge2Nsb3VkOiByZXN9KTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVs1MF0rKztcbiAgbGF3bmNoYWlyZXh0LmFkZEFkYXB0ZXIoYXBwX3Byb3BzLCBoYXNoRnVuYyk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzU0XSsrO1xuICB2YXIgbGNDb25mID0ge25hbWU6IFwiZmhfaW5pdF9zdG9yYWdlXCIsIGFkYXB0ZXI6IFtcImRvbVwiLCBcIndlYmtpdC1zcWxpdGVcIiwgXCJsb2NhbEZpbGVTdG9yYWdlXCIsIFwid2luZG93LW5hbWVcIl0sIGZhaWw6IChmdW5jdGlvbiAobXNnLCBlcnIpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bNThdKys7XG4gIHZhciBlcnJvcl9tZXNzYWdlID0gXCJyZWFkL3NhdmUgZnJvbS90byBsb2NhbCBzdG9yYWdlIGZhaWxlZCAgbXNnOlwiICsgbXNnICsgXCIgZXJyOlwiICsgZXJyO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVs1OV0rKztcbiAgcmV0dXJuIGZhaWwoZXJyb3JfbWVzc2FnZSwge30pO1xufSl9O1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVs2M10rKztcbiAgdmFyIHN0b3JhZ2UgPSBudWxsO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVs2NF0rKztcbiAgdHJ5IHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVs2NV0rKztcbiAgICBzdG9yYWdlID0gbmV3IExhd25jaGFpcihsY0NvbmYsIChmdW5jdGlvbiAoKSB7XG59KSk7XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVs2OV0rKztcbiAgICBsY0NvbmYuYWRhcHRlciA9IHVuZGVmaW5lZDtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVs3MF0rKztcbiAgICBzdG9yYWdlID0gbmV3IExhd25jaGFpcihsY0NvbmYsIChmdW5jdGlvbiAoKSB7XG59KSk7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bNzNdKys7XG4gIHZhciBwYXRoID0gYXBwX3Byb3BzLmhvc3QgKyBjb25zdHMuYm94cHJlZml4ICsgXCJhcHAvaW5pdFwiO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVs3NV0rKztcbiAgc3RvcmFnZS5nZXQoXCJmaF9pbml0XCIsIChmdW5jdGlvbiAoc3RvcmFnZV9yZXMpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bNzZdKys7XG4gIHZhciBzYXZlZEhvc3QgPSBudWxsO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVs3N10rKztcbiAgaWYgKHN0b3JhZ2VfcmVzICYmIHN0b3JhZ2VfcmVzLnZhbHVlICE9PSBudWxsICYmIHR5cGVvZiBzdG9yYWdlX3Jlcy52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzdG9yYWdlX3JlcyAhPT0gXCJcIikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzc4XSsrO1xuICAgIHN0b3JhZ2VfcmVzID0gdHlwZW9mIHN0b3JhZ2VfcmVzID09PSBcInN0cmluZ1wiPyBKU09OLnBhcnNlKHN0b3JhZ2VfcmVzKTogc3RvcmFnZV9yZXM7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bNzldKys7XG4gICAgc3RvcmFnZV9yZXMudmFsdWUgPSB0eXBlb2Ygc3RvcmFnZV9yZXMudmFsdWUgPT09IFwic3RyaW5nXCI/IEpTT04ucGFyc2Uoc3RvcmFnZV9yZXMudmFsdWUpOiBzdG9yYWdlX3Jlcy52YWx1ZTtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVs4MF0rKztcbiAgICBpZiAoc3RvcmFnZV9yZXMudmFsdWUuaW5pdCkge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bODFdKys7XG4gICAgICBhcHBfcHJvcHMuaW5pdCA9IHN0b3JhZ2VfcmVzLnZhbHVlLmluaXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bODRdKys7XG4gICAgICBhcHBfcHJvcHMuaW5pdCA9IHR5cGVvZiBzdG9yYWdlX3Jlcy52YWx1ZSA9PT0gXCJzdHJpbmdcIj8gSlNPTi5wYXJzZShzdG9yYWdlX3Jlcy52YWx1ZSk6IHN0b3JhZ2VfcmVzLnZhbHVlO1xuICAgIH1cbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVs4Nl0rKztcbiAgICBpZiAoc3RvcmFnZV9yZXMudmFsdWUuaG9zdHMpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzg3XSsrO1xuICAgICAgc2F2ZWRIb3N0ID0gc3RvcmFnZV9yZXMudmFsdWU7XG4gICAgfVxuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzkwXSsrO1xuICB2YXIgZGF0YSA9IGZocGFyYW1zLmJ1aWxkRkhQYXJhbXMoKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bOTJdKys7XG4gIGFqYXgoe1widXJsXCI6IHBhdGgsIFwidHlwZVwiOiBcIlBPU1RcIiwgXCJ0cnlKU09OUFwiOiB0cnVlLCBcImRhdGFUeXBlXCI6IFwianNvblwiLCBcImNvbnRlbnRUeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLCBcImRhdGFcIjogSlNPTi5zdHJpbmdpZnkoZGF0YSksIFwidGltZW91dFwiOiBhcHBfcHJvcHMudGltZW91dCB8fCBjb25zdHMuZmhfdGltZW91dCwgXCJzdWNjZXNzXCI6IChmdW5jdGlvbiAoaW5pdFJlcykge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVsxMDFdKys7XG4gIHN0b3JhZ2Uuc2F2ZSh7a2V5OiBcImZoX2luaXRcIiwgdmFsdWU6IGluaXRSZXN9LCAoZnVuY3Rpb24gKCkge1xufSkpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVsxMDVdKys7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzEwNl0rKztcbiAgICBjYWxsYmFjayhudWxsLCB7Y2xvdWQ6IGluaXRSZXN9KTtcbiAgfVxufSksIFwiZXJyb3JcIjogKGZ1bmN0aW9uIChyZXEsIHN0YXR1c1RleHQsIGVycm9yKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzExM10rKztcbiAgaWYgKHNhdmVkSG9zdCkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzExNF0rKztcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzExNV0rKztcbiAgICAgIGNhbGxiYWNrKG51bGwsIHtjbG91ZDogc2F2ZWRIb3N0fSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzEyMF0rKztcbiAgICBoYW5kbGVFcnJvcigoZnVuY3Rpb24gKG1zZywgZXJyKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9pbml0aWFsaXplci5qcyddWzEyMV0rKztcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2luaXRpYWxpemVyLmpzJ11bMTIyXSsrO1xuICAgIGNhbGxiYWNrKHtlcnJvcjogZXJyLCBtZXNzYWdlOiBtc2d9KTtcbiAgfVxufSksIHJlcSwgc3RhdHVzVGV4dCwgZXJyb3IpO1xuICB9XG59KX0pO1xufSkpO1xufSk7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXVsxMzRdKys7XG5tb2R1bGUuZXhwb3J0cyA9IHtcImluaXRcIjogaW5pdCwgXCJsb2FkQ2xvdWRQcm9wc1wiOiBsb2FkQ2xvdWRQcm9wc307XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvaW5pdGlhbGl6ZXIuanMnXS5zb3VyY2UgPSBbXCJ2YXIgbG9hZFNjcmlwdCA9IHJlcXVpcmUoXFxcIi4vbG9hZFNjcmlwdFxcXCIpO1wiLFwidmFyIExhd25jaGFpciA9IHJlcXVpcmUoJy4uLy4uL2xpYnMvZ2VuZXJhdGVkL2xhd25jaGFpcicpO1wiLFwidmFyIGxhd25jaGFpcmV4dCA9IHJlcXVpcmUoJy4vbGF3bmNoYWlyLWV4dCcpO1wiLFwidmFyIGNvbnN0cyA9IHJlcXVpcmUoXFxcIi4vY29uc3RhbnRzXFxcIik7XCIsXCJ2YXIgZmhwYXJhbXMgPSByZXF1aXJlKFxcXCIuL2ZocGFyYW1zXFxcIik7XCIsXCJ2YXIgYWpheCA9IHJlcXVpcmUoXFxcIi4vYWpheFxcXCIpO1wiLFwidmFyIGhhbmRsZUVycm9yID0gcmVxdWlyZShcXFwiLi9oYW5kbGVFcnJvclxcXCIpO1wiLFwidmFyIGxvZ2dlciA9IHJlcXVpcmUoXFxcIi4vbG9nZ2VyXFxcIik7XCIsXCJ2YXIgSlNPTiA9IHJlcXVpcmUoXFxcIkpTT05cXFwiKTtcIixcInZhciBoYXNoRnVuYyA9IHJlcXVpcmUoXFxcIi4vc2VjdXJpdHkvaGFzaFxcXCIpO1wiLFwidmFyIGFwcFByb3BzID0gcmVxdWlyZShcXFwiLi9hcHBQcm9wc1xcXCIpO1wiLFwiXCIsXCJ2YXIgaW5pdCA9IGZ1bmN0aW9uKGNiKSB7XCIsXCIgIGFwcFByb3BzLmxvYWQoZnVuY3Rpb24oZXJyLCBkYXRhKSB7XCIsXCIgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XCIsXCIgICAgcmV0dXJuIGxvYWRDbG91ZFByb3BzKGRhdGEsIGNiKTtcIixcIiAgfSk7XCIsXCJ9XCIsXCJcIixcInZhciBsb2FkQ2xvdWRQcm9wcyA9IGZ1bmN0aW9uKGFwcF9wcm9wcywgY2FsbGJhY2spIHtcIixcIiAgaWYoYXBwX3Byb3BzLmxvZ2xldmVsKXtcIixcIiAgICBsb2dnZXIuc2V0TGV2ZWwoYXBwX3Byb3BzLmxvZ2xldmVsKTtcIixcIiAgfVwiLFwiICAvLyBJZiBsb2NhbCAtIHNob3J0Y2lyY3VpdCB0aGUgaW5pdCAtIGp1c3QgcmV0dXJuIHRoZSBob3N0XCIsXCIgIGlmIChhcHBfcHJvcHMubG9jYWwpIHtcIixcIiAgICB2YXIgcmVzID0ge1wiLFwiICAgICAgXFxcImRvbWFpblxcXCI6IFxcXCJsb2NhbFxcXCIsXCIsXCIgICAgICBcXFwiZmlyc3RUaW1lXFxcIjogZmFsc2UsXCIsXCIgICAgICBcXFwiaG9zdHNcXFwiOiB7XCIsXCIgICAgICAgIFxcXCJkZWJ1Z0Nsb3VkVHlwZVxcXCI6IFxcXCJub2RlXFxcIixcIixcIiAgICAgICAgXFxcImRlYnVnQ2xvdWRVcmxcXFwiOiBhcHBfcHJvcHMuaG9zdCxcIixcIiAgICAgICAgXFxcInJlbGVhc2VDbG91ZFR5cGVcXFwiOiBcXFwibm9kZVxcXCIsXCIsXCIgICAgICAgIFxcXCJyZWxlYXNlQ2xvdWRVcmxcXFwiOiBhcHBfcHJvcHMuaG9zdCxcIixcIiAgICAgICAgXFxcInR5cGVcXFwiOiBcXFwiY2xvdWRfbm9kZWpzXFxcIixcIixcIiAgICAgICAgXFxcInVybFxcXCI6IGFwcF9wcm9wcy5ob3N0XCIsXCIgICAgICB9LFwiLFwiICAgICAgXFxcImluaXRcXFwiOiB7XCIsXCIgICAgICAgIFxcXCJ0cmFja0lkXFxcIjogXFxcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFxcXCJcIixcIiAgICAgIH0sXCIsXCIgICAgICBcXFwic3RhdHVzXFxcIjogXFxcIm9rXFxcIlwiLFwiICAgIH07XCIsXCJcIixcIiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge1wiLFwiICAgICAgY2xvdWQ6IHJlc1wiLFwiICAgIH0pO1wiLFwiICB9XCIsXCJcIixcIlwiLFwiICAvL25vdyB3ZSBoYXZlIGFwcCBwcm9wcywgYWRkIHRoZSBmaWxlU3RvcmFnZUFkYXB0ZXJcIixcIiAgbGF3bmNoYWlyZXh0LmFkZEFkYXB0ZXIoYXBwX3Byb3BzLCBoYXNoRnVuYyk7XCIsXCIgIC8vZG9tIGFkYXB0ZXIgZG9lbnMndCB3b3JrIG9uIHdpbmRvd3MgcGhvbmUsIHNvIGRvbid0IHNwZWNpZnkgdGhlIGFkYXB0ZXIgaWYgdGhlIGRvbSBvbmUgZmFpbGVkXCIsXCIgIC8vd2Ugc3BlY2lmeSB0aGUgb3JkZXIgb2YgbGF3bmNoYWlyIGFkYXB0ZXJzIHRvIHVzZSwgbGF3bmNoYWlyIHdpbGwgZmluZCB0aGUgcmlnaHQgb25lIHRvIHVzZSwgdG8ga2VlcCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBrZWVwIHRoZSBvcmRlclwiLFwiICAvL2FzIGRvbSwgd2Via2l0LXNxbGl0ZSwgbG9jYWxGaWxlU3RvcmFnZSwgd2luZG93LW5hbWVcIixcIiAgdmFyIGxjQ29uZiA9IHtcIixcIiAgICBuYW1lOiBcXFwiZmhfaW5pdF9zdG9yYWdlXFxcIixcIixcIiAgICBhZGFwdGVyOiBbXFxcImRvbVxcXCIsIFxcXCJ3ZWJraXQtc3FsaXRlXFxcIiwgXFxcImxvY2FsRmlsZVN0b3JhZ2VcXFwiLCBcXFwid2luZG93LW5hbWVcXFwiXSxcIixcIiAgICBmYWlsOiBmdW5jdGlvbihtc2csIGVycikge1wiLFwiICAgICAgdmFyIGVycm9yX21lc3NhZ2UgPSAncmVhZC9zYXZlIGZyb20vdG8gbG9jYWwgc3RvcmFnZSBmYWlsZWQgIG1zZzonICsgbXNnICsgJyBlcnI6JyArIGVycjtcIixcIiAgICAgIHJldHVybiBmYWlsKGVycm9yX21lc3NhZ2UsIHt9KTtcIixcIiAgICB9XCIsXCIgIH07XCIsXCJcIixcIiAgdmFyIHN0b3JhZ2UgPSBudWxsO1wiLFwiICB0cnkge1wiLFwiICAgIHN0b3JhZ2UgPSBuZXcgTGF3bmNoYWlyKGxjQ29uZiwgZnVuY3Rpb24oKSB7fSk7XCIsXCIgIH0gY2F0Y2ggKGUpIHtcIixcIiAgICAvL3doZW4gZG9tIGFkYXB0ZXIgZmFpbGVkLCBMYXduY2hhaXIgdGhyb3dzIGFuIGVycm9yXCIsXCIgICAgLy9zaG91ZG4ndCBnbyBpbiBoZXJlIGFueW1vcmVcIixcIiAgICBsY0NvbmYuYWRhcHRlciA9IHVuZGVmaW5lZDtcIixcIiAgICBzdG9yYWdlID0gbmV3IExhd25jaGFpcihsY0NvbmYsIGZ1bmN0aW9uKCkge30pO1wiLFwiICB9XCIsXCJcIixcIiAgdmFyIHBhdGggPSBhcHBfcHJvcHMuaG9zdCArIGNvbnN0cy5ib3hwcmVmaXggKyBcXFwiYXBwL2luaXRcXFwiO1wiLFwiXCIsXCIgIHN0b3JhZ2UuZ2V0KCdmaF9pbml0JywgZnVuY3Rpb24oc3RvcmFnZV9yZXMpIHtcIixcIiAgICB2YXIgc2F2ZWRIb3N0ID0gbnVsbDtcIixcIiAgICBpZiAoc3RvcmFnZV9yZXMgJmFtcDsmYW1wOyBzdG9yYWdlX3Jlcy52YWx1ZSAhPT0gbnVsbCAmYW1wOyZhbXA7IHR5cGVvZihzdG9yYWdlX3Jlcy52YWx1ZSkgIT09IFxcXCJ1bmRlZmluZWRcXFwiICZhbXA7JmFtcDsgc3RvcmFnZV9yZXMgIT09IFxcXCJcXFwiKSB7XCIsXCIgICAgICBzdG9yYWdlX3JlcyA9IHR5cGVvZihzdG9yYWdlX3JlcykgPT09IFxcXCJzdHJpbmdcXFwiID8gSlNPTi5wYXJzZShzdG9yYWdlX3JlcykgOiBzdG9yYWdlX3JlcztcIixcIiAgICAgIHN0b3JhZ2VfcmVzLnZhbHVlID0gdHlwZW9mKHN0b3JhZ2VfcmVzLnZhbHVlKSA9PT0gXFxcInN0cmluZ1xcXCIgPyBKU09OLnBhcnNlKHN0b3JhZ2VfcmVzLnZhbHVlKSA6IHN0b3JhZ2VfcmVzLnZhbHVlO1wiLFwiICAgICAgaWYgKHN0b3JhZ2VfcmVzLnZhbHVlLmluaXQpIHtcIixcIiAgICAgICAgYXBwX3Byb3BzLmluaXQgPSBzdG9yYWdlX3Jlcy52YWx1ZS5pbml0O1wiLFwiICAgICAgfSBlbHNlIHtcIixcIiAgICAgICAgLy9rZWVwIGl0IGJhY2t3YXJkIGNvbXBhdGlibGUuXCIsXCIgICAgICAgIGFwcF9wcm9wcy5pbml0ID0gdHlwZW9mKHN0b3JhZ2VfcmVzLnZhbHVlKSA9PT0gXFxcInN0cmluZ1xcXCIgPyBKU09OLnBhcnNlKHN0b3JhZ2VfcmVzLnZhbHVlKSA6IHN0b3JhZ2VfcmVzLnZhbHVlO1wiLFwiICAgICAgfVwiLFwiICAgICAgaWYgKHN0b3JhZ2VfcmVzLnZhbHVlLmhvc3RzKSB7XCIsXCIgICAgICAgIHNhdmVkSG9zdCA9IHN0b3JhZ2VfcmVzLnZhbHVlO1wiLFwiICAgICAgfVwiLFwiICAgIH1cIixcIiAgICB2YXIgZGF0YSA9IGZocGFyYW1zLmJ1aWxkRkhQYXJhbXMoKTtcIixcIlwiLFwiICAgIGFqYXgoe1wiLFwiICAgICAgXFxcInVybFxcXCI6IHBhdGgsXCIsXCIgICAgICBcXFwidHlwZVxcXCI6IFxcXCJQT1NUXFxcIixcIixcIiAgICAgIFxcXCJ0cnlKU09OUFxcXCI6IHRydWUsXCIsXCIgICAgICBcXFwiZGF0YVR5cGVcXFwiOiBcXFwianNvblxcXCIsXCIsXCIgICAgICBcXFwiY29udGVudFR5cGVcXFwiOiBcXFwiYXBwbGljYXRpb24vanNvblxcXCIsXCIsXCIgICAgICBcXFwiZGF0YVxcXCI6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFwiLFwiICAgICAgXFxcInRpbWVvdXRcXFwiOiBhcHBfcHJvcHMudGltZW91dCB8fCBjb25zdHMuZmhfdGltZW91dCxcIixcIiAgICAgIFxcXCJzdWNjZXNzXFxcIjogZnVuY3Rpb24oaW5pdFJlcykge1wiLFwiICAgICAgICBzdG9yYWdlLnNhdmUoe1wiLFwiICAgICAgICAgIGtleTogXFxcImZoX2luaXRcXFwiLFwiLFwiICAgICAgICAgIHZhbHVlOiBpbml0UmVzXCIsXCIgICAgICAgIH0sIGZ1bmN0aW9uKCkge30pO1wiLFwiICAgICAgICBpZiAoY2FsbGJhY2spIHtcIixcIiAgICAgICAgICBjYWxsYmFjayhudWxsLCB7XCIsXCIgICAgICAgICAgICBjbG91ZDogaW5pdFJlc1wiLFwiICAgICAgICAgIH0pO1wiLFwiICAgICAgICB9XCIsXCIgICAgICB9LFwiLFwiICAgICAgXFxcImVycm9yXFxcIjogZnVuY3Rpb24ocmVxLCBzdGF0dXNUZXh0LCBlcnJvcikge1wiLFwiICAgICAgICAvL3VzZSB0aGUgY2FjaGVkIGhvc3QgaWYgd2UgaGF2ZSBhIGNvcHlcIixcIiAgICAgICAgaWYgKHNhdmVkSG9zdCkge1wiLFwiICAgICAgICAgIGlmIChjYWxsYmFjaykge1wiLFwiICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge1wiLFwiICAgICAgICAgICAgICBjbG91ZDogc2F2ZWRIb3N0XCIsXCIgICAgICAgICAgICB9KTtcIixcIiAgICAgICAgICB9XCIsXCIgICAgICAgIH0gZWxzZSB7XCIsXCIgICAgICAgICAgaGFuZGxlRXJyb3IoZnVuY3Rpb24obXNnLCBlcnIpIHtcIixcIiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1wiLFwiICAgICAgICAgICAgICBjYWxsYmFjayh7XCIsXCIgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcIixcIiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2dcIixcIiAgICAgICAgICAgICAgfSk7XCIsXCIgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgfSwgcmVxLCBzdGF0dXNUZXh0LCBlcnJvcik7XCIsXCIgICAgICAgIH1cIixcIiAgICAgIH1cIixcIiAgICB9KTtcIixcIiAgfSk7XCIsXCJ9O1wiLFwiXCIsXCJtb2R1bGUuZXhwb3J0cyA9IHtcIixcIiAgXFxcImluaXRcXFwiOiBpbml0LFwiLFwiICBcXFwibG9hZENsb3VkUHJvcHNcXFwiOiBsb2FkQ2xvdWRQcm9wc1wiLFwifVwiXTtcbiIsIi8qIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IEpTQ292ZXJhZ2UgLSBkbyBub3QgZWRpdCAqL1xuaWYgKHR5cGVvZiBfJGpzY292ZXJhZ2UgPT09ICd1bmRlZmluZWQnKSBfJGpzY292ZXJhZ2UgPSB7fTtcbmlmICghIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ10pIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVszXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzE0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMThdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzIxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsyNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzI3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsyOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzMwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVszMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzM0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVszN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzM5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bNDJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs0M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzQ4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bNTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs1NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzU1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bNTldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs2M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzY0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bNjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs2Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzY4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bNzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs3Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzczXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bNzhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs4MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzgzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bODZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs5Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzk2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bOTddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs5OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzk5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTAwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTAxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTAyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTA1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTA2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTE2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTE4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTIyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTI4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTM0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTM1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTM2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTM4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTQwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTQ3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTUxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTUzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTU0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTU2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTU3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTYyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTY1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTY4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTc0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTgxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTgyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTg1XSA9IDA7XG59XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzFdKys7XG52YXIgTGF3bmNoYWlyID0gcmVxdWlyZShcIi4uLy4uL2xpYnMvZ2VuZXJhdGVkL2xhd25jaGFpclwiKTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bM10rKztcbnZhciBmaWxlU3RvcmFnZUFkYXB0ZXIgPSAoZnVuY3Rpb24gKGFwcF9wcm9wcywgaGFzaEZ1bmMpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs2XSsrO1xuICBmdW5jdGlvbiBkb0xvZyhtZXNzKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs3XSsrO1xuICAgIGlmIChjb25zb2xlKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzhdKys7XG4gICAgICBjb25zb2xlLmxvZyhtZXNzKTtcbiAgICB9XG59XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTJdKys7XG4gIHZhciBmYWlsID0gKGZ1bmN0aW9uIChlLCBpKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTNdKys7XG4gIGlmIChjb25zb2xlKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxM10rKztcbiAgICBjb25zb2xlLmxvZyhcImVycm9yIGluIGZpbGUgc3lzdGVtIGFkYXB0ZXIgIVwiLCBlLCBpKTtcbiAgfVxuICBlbHNlIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzE0XSsrO1xuICAgIHRocm93IGU7XG4gIH1cbn0pO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzE4XSsrO1xuICBmdW5jdGlvbiBmaWxlbmFtZUZvcktleShrZXksIGNiKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxOV0rKztcbiAgICBrZXkgPSBhcHBfcHJvcHMuYXBwaWQgKyBrZXk7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsyMV0rKztcbiAgICBoYXNoRnVuYyh7YWxnb3JpdGhtOiBcIk1ENVwiLCB0ZXh0OiBrZXl9LCAoZnVuY3Rpb24gKHJlc3VsdCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzI1XSsrO1xuICB2YXIgZmlsZW5hbWUgPSByZXN1bHQuaGFzaHZhbHVlICsgXCIudHh0XCI7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMjZdKys7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yLmV4dGVybmFsc3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMjddKys7XG4gICAgbmF2aWdhdG9yLmV4dGVybmFsc3RvcmFnZS5lbmFibGUoKGZ1bmN0aW9uIGhhbmRsZVN1Y2Nlc3MocmVzKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMjhdKys7XG4gIHZhciBwYXRoID0gZmlsZW5hbWU7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMjldKys7XG4gIGlmIChyZXMucGF0aCkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMzBdKys7XG4gICAgcGF0aCA9IHJlcy5wYXRoO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMzFdKys7XG4gICAgaWYgKCEgcGF0aC5tYXRjaCgvXFwvJC8pKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzMyXSsrO1xuICAgICAgcGF0aCArPSBcIi9cIjtcbiAgICB9XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVszNF0rKztcbiAgICBwYXRoICs9IGZpbGVuYW1lO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMzZdKys7XG4gIGZpbGVuYW1lID0gcGF0aDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVszN10rKztcbiAgcmV0dXJuIGNiKGZpbGVuYW1lKTtcbn0pLCAoZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMzldKys7XG4gIHJldHVybiBjYihmaWxlbmFtZSk7XG59KSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs0Ml0rKztcbiAgICBkb0xvZyhcImZpbGVuYW1lRm9yS2V5IGtleT1cIiArIGtleSArIFwiICwgRmlsZW5hbWU6IFwiICsgZmlsZW5hbWUpO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bNDNdKys7XG4gICAgcmV0dXJuIGNiKGZpbGVuYW1lKTtcbiAgfVxufSkpO1xufVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzQ4XSsrO1xuICByZXR1cm4gKHt2YWxpZDogKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs1MF0rKztcbiAgcmV0dXJuICEgISB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW07XG59KSwgaW5pdDogKGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzU0XSsrO1xuICBpZiAob3B0aW9ucyAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvcHRpb25zLmZhaWwpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzU0XSsrO1xuICAgIGZhaWwgPSBvcHRpb25zLmZhaWw7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs1NV0rKztcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs1NV0rKztcbiAgICB0aGlzLmZuKHRoaXMubmFtZSwgY2FsbGJhY2spLmNhbGwodGhpcywgdGhpcyk7XG4gIH1cbn0pLCBrZXlzOiAoZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bNTldKys7XG4gIHRocm93IFwiQ3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIjtcbn0pLCBzYXZlOiAoZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVs2M10rKztcbiAgdmFyIGtleSA9IG9iai5rZXk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bNjRdKys7XG4gIHZhciB2YWx1ZSA9IG9iai52YWwgfHwgb2JqLnZhbHVlO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzY1XSsrO1xuICBmaWxlbmFtZUZvcktleShrZXksIChmdW5jdGlvbiAoaGFzaCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzY2XSsrO1xuICB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0oTG9jYWxGaWxlU3lzdGVtLlBFUlNJU1RFTlQsIDAsIChmdW5jdGlvbiBnb3RGUyhmaWxlU3lzdGVtKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bNjhdKys7XG4gIGZpbGVTeXN0ZW0ucm9vdC5nZXRGaWxlKGhhc2gsIHtjcmVhdGU6IHRydWV9LCAoZnVuY3Rpb24gZ290RmlsZUVudHJ5KGZpbGVFbnRyeSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzcxXSsrO1xuICBmaWxlRW50cnkuY3JlYXRlV3JpdGVyKChmdW5jdGlvbiBnb3RGaWxlV3JpdGVyKHdyaXRlcikge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzcyXSsrO1xuICB3cml0ZXIub253cml0ZSA9IChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bNzNdKys7XG4gIHJldHVybiBjYWxsYmFjayh7a2V5OiBrZXksIHZhbDogdmFsdWV9KTtcbn0pO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzc4XSsrO1xuICB3cml0ZXIud3JpdGUodmFsdWUpO1xufSksIChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bODBdKys7XG4gIGZhaWwoXCJbc2F2ZV0gRmFpbGVkIHRvIGNyZWF0ZSBmaWxlIHdyaXRlclwiKTtcbn0pKTtcbn0pLCAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzgzXSsrO1xuICBmYWlsKFwiW3NhdmVdIEZhaWxlZCB0byBnZXRGaWxlXCIpO1xufSkpO1xufSksIChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bODZdKys7XG4gIGZhaWwoXCJbc2F2ZV0gRmFpbGVkIHRvIHJlcXVlc3RGaWxlU3lzdGVtXCIpO1xufSkpO1xufSkpO1xufSksIGJhdGNoOiAoZnVuY3Rpb24gKHJlY29yZHMsIGNhbGxiYWNrKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bOTJdKys7XG4gIHRocm93IFwiQ3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIjtcbn0pLCBnZXQ6IChmdW5jdGlvbiAoa2V5LCBjYWxsYmFjaykge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzk2XSsrO1xuICBmaWxlbmFtZUZvcktleShrZXksIChmdW5jdGlvbiAoaGFzaCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzk3XSsrO1xuICB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0oTG9jYWxGaWxlU3lzdGVtLlBFUlNJU1RFTlQsIDAsIChmdW5jdGlvbiBnb3RGUyhmaWxlU3lzdGVtKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bOThdKys7XG4gIGZpbGVTeXN0ZW0ucm9vdC5nZXRGaWxlKGhhc2gsIHt9LCAoZnVuY3Rpb24gZ290RmlsZUVudHJ5KGZpbGVFbnRyeSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzk5XSsrO1xuICBmaWxlRW50cnkuZmlsZSgoZnVuY3Rpb24gZ290RmlsZShmaWxlKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTAwXSsrO1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxMDFdKys7XG4gIHJlYWRlci5vbmxvYWRlbmQgPSAoZnVuY3Rpb24gKGV2dCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzEwMl0rKztcbiAgdmFyIHRleHQgPSBldnQudGFyZ2V0LnJlc3VsdDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxMDVdKys7XG4gIHRyeSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxMDZdKys7XG4gICAgdGV4dCA9IGRlY29kZVVSSUNvbXBvbmVudCh0ZXh0KTtcbiAgfVxuICBjYXRjaCAoZSkge1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTExXSsrO1xuICByZXR1cm4gY2FsbGJhY2soe2tleToga2V5LCB2YWw6IHRleHR9KTtcbn0pO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzExNl0rKztcbiAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG59KSwgKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxMThdKys7XG4gIGZhaWwoXCJbbG9hZF0gRmFpbGVkIHRvIGdldEZpbGVcIik7XG59KSk7XG59KSwgKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxMjJdKys7XG4gIGNhbGxiYWNrKHtrZXk6IGtleSwgdmFsOiBudWxsfSk7XG59KSk7XG59KSwgKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxMjhdKys7XG4gIGZhaWwoXCJbbG9hZF0gRmFpbGVkIHRvIGdldCBmaWxlU3lzdGVtXCIpO1xufSkpO1xufSkpO1xufSksIGV4aXN0czogKGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTM0XSsrO1xuICBmaWxlbmFtZUZvcktleShrZXksIChmdW5jdGlvbiAoaGFzaCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzEzNV0rKztcbiAgd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtKExvY2FsRmlsZVN5c3RlbS5QRVJTSVNURU5ULCAwLCAoZnVuY3Rpb24gZ290RlMoZmlsZVN5c3RlbSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzEzNl0rKztcbiAgZmlsZVN5c3RlbS5yb290LmdldEZpbGUoaGFzaCwge30sIChmdW5jdGlvbiBnb3RGaWxlRW50cnkoZmlsZUVudHJ5KSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTM4XSsrO1xuICByZXR1cm4gY2FsbGJhY2sodHJ1ZSk7XG59KSwgKGZ1bmN0aW9uIChlcnIpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxNDBdKys7XG4gIHJldHVybiBjYWxsYmFjayhmYWxzZSk7XG59KSk7XG59KSk7XG59KSk7XG59KSwgYWxsOiAoZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTQ3XSsrO1xuICB0aHJvdyBcIkN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXCI7XG59KSwgcmVtb3ZlOiAoZnVuY3Rpb24gKGtleSwgY2FsbGJhY2spIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxNTFdKys7XG4gIGZpbGVuYW1lRm9yS2V5KGtleSwgKGZ1bmN0aW9uIChoYXNoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTUzXSsrO1xuICB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0oTG9jYWxGaWxlU3lzdGVtLlBFUlNJU1RFTlQsIDAsIChmdW5jdGlvbiBnb3RGUyhmaWxlU3lzdGVtKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTU0XSsrO1xuICBmaWxlU3lzdGVtLnJvb3QuZ2V0RmlsZShoYXNoLCB7fSwgKGZ1bmN0aW9uIGdvdEZpbGVFbnRyeShmaWxlRW50cnkpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxNTZdKys7XG4gIGZpbGVFbnRyeS5yZW1vdmUoKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxNTddKys7XG4gIHJldHVybiBjYWxsYmFjayh7a2V5OiBrZXksIHZhbDogbnVsbH0pO1xufSksIChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTYyXSsrO1xuICBmYWlsKFwiW3JlbW92ZV0gRmFpbGVkIHRvIHJlbW92ZSBmaWxlXCIpO1xufSkpO1xufSksIChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTY1XSsrO1xuICBmYWlsKFwiW3JlbW92ZV0gRmFpbGVkIHRvIGdldEZpbGVcIik7XG59KSk7XG59KSwgKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxNjhdKys7XG4gIGZhaWwoXCJbcmVtb3ZlXSBGYWlsZWQgdG8gZ2V0IGZpbGVTeXN0ZW1cIik7XG59KSk7XG59KSk7XG59KSwgbnVrZTogKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzE3NF0rKztcbiAgdGhyb3cgXCJDdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiO1xufSl9KTtcbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xhd25jaGFpci1leHQuanMnXVsxODFdKys7XG52YXIgYWRkQWRhcHRlciA9IChmdW5jdGlvbiAoYXBwX3Byb3BzLCBoYXNoRnVuYykge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddWzE4Ml0rKztcbiAgTGF3bmNoYWlyLmFkYXB0ZXIoXCJsb2NhbEZpbGVTdG9yYWdlXCIsIGZpbGVTdG9yYWdlQWRhcHRlcihhcHBfcHJvcHMsIGhhc2hGdW5jKSk7XG59KTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sYXduY2hhaXItZXh0LmpzJ11bMTg1XSsrO1xubW9kdWxlLmV4cG9ydHMgPSB7YWRkQWRhcHRlcjogYWRkQWRhcHRlcn07XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvbGF3bmNoYWlyLWV4dC5qcyddLnNvdXJjZSA9IFtcInZhciBMYXduY2hhaXIgPSByZXF1aXJlKCcuLi8uLi9saWJzL2dlbmVyYXRlZC9sYXduY2hhaXInKTtcIixcIlwiLFwidmFyIGZpbGVTdG9yYWdlQWRhcHRlciA9IGZ1bmN0aW9uIChhcHBfcHJvcHMsIGhhc2hGdW5jKSB7XCIsXCIgIC8vIHByaXZhdGUgbWV0aG9kc1wiLFwiXCIsXCIgIGZ1bmN0aW9uIGRvTG9nKG1lc3Mpe1wiLFwiICAgIGlmKGNvbnNvbGUpe1wiLFwiICAgICAgY29uc29sZS5sb2cobWVzcyk7XCIsXCIgICAgfVwiLFwiICB9XCIsXCJcIixcIiAgdmFyIGZhaWwgPSBmdW5jdGlvbiAoZSwgaSkge1wiLFwiICAgIGlmKGNvbnNvbGUpIGNvbnNvbGUubG9nKCdlcnJvciBpbiBmaWxlIHN5c3RlbSBhZGFwdGVyICEnLCBlLCBpKTtcIixcIiAgICBlbHNlIHRocm93IGU7XCIsXCIgIH07XCIsXCJcIixcIlwiLFwiICBmdW5jdGlvbiBmaWxlbmFtZUZvcktleShrZXksIGNiKSB7XCIsXCIgICAga2V5ID0gYXBwX3Byb3BzLmFwcGlkICsga2V5O1wiLFwiXCIsXCIgICAgaGFzaEZ1bmMoe1wiLFwiICAgICAgYWxnb3JpdGhtOiBcXFwiTUQ1XFxcIixcIixcIiAgICAgIHRleHQ6IGtleVwiLFwiICAgIH0sIGZ1bmN0aW9uKHJlc3VsdCkge1wiLFwiICAgICAgdmFyIGZpbGVuYW1lID0gcmVzdWx0Lmhhc2h2YWx1ZSArICcudHh0JztcIixcIiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yLmV4dGVybmFsc3RvcmFnZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcIixcIiAgICAgICAgbmF2aWdhdG9yLmV4dGVybmFsc3RvcmFnZS5lbmFibGUoZnVuY3Rpb24gaGFuZGxlU3VjY2VzcyhyZXMpe1wiLFwiICAgICAgICAgIHZhciBwYXRoID0gZmlsZW5hbWU7XCIsXCIgICAgICAgICAgaWYocmVzLnBhdGggKSB7XCIsXCIgICAgICAgICAgICBwYXRoID0gcmVzLnBhdGg7XCIsXCIgICAgICAgICAgICBpZighcGF0aC5tYXRjaCgvXFxcXC8kLykpIHtcIixcIiAgICAgICAgICAgICAgcGF0aCArPSAnLyc7XCIsXCIgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgICBwYXRoICs9IGZpbGVuYW1lO1wiLFwiICAgICAgICAgIH1cIixcIiAgICAgICAgICBmaWxlbmFtZSA9IHBhdGg7XCIsXCIgICAgICAgICAgcmV0dXJuIGNiKGZpbGVuYW1lKTtcIixcIiAgICAgICAgfSxmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIpe1wiLFwiICAgICAgICAgIHJldHVybiBjYihmaWxlbmFtZSk7XCIsXCIgICAgICAgIH0pXCIsXCIgICAgICB9IGVsc2Uge1wiLFwiICAgICAgICBkb0xvZygnZmlsZW5hbWVGb3JLZXkga2V5PScgKyBrZXkrICcgLCBGaWxlbmFtZTogJyArIGZpbGVuYW1lKTtcIixcIiAgICAgICAgcmV0dXJuIGNiKGZpbGVuYW1lKTtcIixcIiAgICAgIH1cIixcIiAgICB9KTtcIixcIiAgfVwiLFwiXCIsXCIgIHJldHVybiB7XCIsXCJcIixcIiAgICB2YWxpZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gISEod2luZG93LnJlcXVlc3RGaWxlU3lzdGVtKSB9LFwiLFwiXCIsXCIgICAgaW5pdCA6IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjayl7XCIsXCIgICAgICAvL2NhbGxzIHRoZSBwYXJlbnQgZnVuY3Rpb24gZm4gYW5kIGFwcGxpZXMgdGhpcyBzY29wZVwiLFwiICAgICAgaWYob3B0aW9ucyAmYW1wOyZhbXA7ICdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRpb25zLmZhaWwgKSBmYWlsID0gb3B0aW9ucy5mYWlsO1wiLFwiICAgICAgaWYgKGNhbGxiYWNrKSB0aGlzLmZuKHRoaXMubmFtZSwgY2FsbGJhY2spLmNhbGwodGhpcywgdGhpcyk7XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIGtleXM6IGZ1bmN0aW9uIChjYWxsYmFjayl7XCIsXCIgICAgICB0aHJvdyBcXFwiQ3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcXFwiO1wiLFwiICAgIH0sXCIsXCJcIixcIiAgICBzYXZlIDogZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spe1wiLFwiICAgICAgdmFyIGtleSA9IG9iai5rZXk7XCIsXCIgICAgICB2YXIgdmFsdWUgPSBvYmoudmFsfHxvYmoudmFsdWU7XCIsXCIgICAgICBmaWxlbmFtZUZvcktleShrZXksIGZ1bmN0aW9uKGhhc2gpIHtcIixcIiAgICAgICAgd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtKExvY2FsRmlsZVN5c3RlbS5QRVJTSVNURU5ULCAwLCBmdW5jdGlvbiBnb3RGUyhmaWxlU3lzdGVtKSB7XCIsXCJcIixcIiAgICAgICAgICBmaWxlU3lzdGVtLnJvb3QuZ2V0RmlsZShoYXNoLCB7XCIsXCIgICAgICAgICAgICBjcmVhdGU6IHRydWVcIixcIiAgICAgICAgICB9LCBmdW5jdGlvbiBnb3RGaWxlRW50cnkoZmlsZUVudHJ5KSB7XCIsXCIgICAgICAgICAgICBmaWxlRW50cnkuY3JlYXRlV3JpdGVyKGZ1bmN0aW9uIGdvdEZpbGVXcml0ZXIod3JpdGVyKSB7XCIsXCIgICAgICAgICAgICAgIHdyaXRlci5vbndyaXRlID0gZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHtcIixcIiAgICAgICAgICAgICAgICAgIGtleToga2V5LFwiLFwiICAgICAgICAgICAgICAgICAgdmFsOiB2YWx1ZVwiLFwiICAgICAgICAgICAgICAgIH0pO1wiLFwiICAgICAgICAgICAgICB9O1wiLFwiICAgICAgICAgICAgICB3cml0ZXIud3JpdGUodmFsdWUpO1wiLFwiICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICAgIGZhaWwoJ1tzYXZlXSBGYWlsZWQgdG8gY3JlYXRlIGZpbGUgd3JpdGVyJyk7XCIsXCIgICAgICAgICAgICB9KTtcIixcIiAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgIGZhaWwoJ1tzYXZlXSBGYWlsZWQgdG8gZ2V0RmlsZScpO1wiLFwiICAgICAgICAgIH0pO1wiLFwiICAgICAgICB9LCBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICBmYWlsKCdbc2F2ZV0gRmFpbGVkIHRvIHJlcXVlc3RGaWxlU3lzdGVtJyk7XCIsXCIgICAgICAgIH0pO1wiLFwiICAgICAgfSk7XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIGJhdGNoIDogZnVuY3Rpb24gKHJlY29yZHMsIGNhbGxiYWNrKXtcIixcIiAgICAgIHRocm93IFxcXCJDdXJyZW50bHkgbm90IHN1cHBvcnRlZFxcXCI7XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIGdldCA6IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrKXtcIixcIiAgICAgIGZpbGVuYW1lRm9yS2V5KGtleSwgZnVuY3Rpb24oaGFzaCkge1wiLFwiICAgICAgICB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0oTG9jYWxGaWxlU3lzdGVtLlBFUlNJU1RFTlQsIDAsIGZ1bmN0aW9uIGdvdEZTKGZpbGVTeXN0ZW0pIHtcIixcIiAgICAgICAgICBmaWxlU3lzdGVtLnJvb3QuZ2V0RmlsZShoYXNoLCB7fSwgZnVuY3Rpb24gZ290RmlsZUVudHJ5KGZpbGVFbnRyeSkge1wiLFwiICAgICAgICAgICAgZmlsZUVudHJ5LmZpbGUoZnVuY3Rpb24gZ290RmlsZShmaWxlKSB7XCIsXCIgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1wiLFwiICAgICAgICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKGV2dCkge1wiLFwiICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gZXZ0LnRhcmdldC5yZXN1bHQ7XCIsXCIgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIFVSTGVuY29kZWRcIixcIiAgICAgICAgICAgICAgICAvLyBQRyAyLjIgYnVnIGluIHJlYWRBc1RleHQoKVwiLFwiICAgICAgICAgICAgICAgIHRyeSB7XCIsXCIgICAgICAgICAgICAgICAgICB0ZXh0ID0gZGVjb2RlVVJJQ29tcG9uZW50KHRleHQpO1wiLFwiICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcIixcIiAgICAgICAgICAgICAgICAgIC8vIFN3YWxsb3cgZXhjZXB0aW9uIGlmIG5vdCBVUkxlbmNvZGVkXCIsXCIgICAgICAgICAgICAgICAgICAvLyBKdXN0IHVzZSB0aGUgcmVzdWx0XCIsXCIgICAgICAgICAgICAgICAgfVwiLFwiICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh7XCIsXCIgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcIixcIiAgICAgICAgICAgICAgICAgIHZhbDogdGV4dFwiLFwiICAgICAgICAgICAgICAgIH0pO1wiLFwiICAgICAgICAgICAgICB9O1wiLFwiICAgICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcIixcIiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICAgICAgICBmYWlsKCdbbG9hZF0gRmFpbGVkIHRvIGdldEZpbGUnKTtcIixcIiAgICAgICAgICAgIH0pO1wiLFwiICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICAgICAgLy8gU3VjY2VzcyBjYWxsYmFjayBvbiBrZXkgbG9hZCBmYWlsdXJlXCIsXCIgICAgICAgICAgICBjYWxsYmFjayh7XCIsXCIgICAgICAgICAgICAgIGtleToga2V5LFwiLFwiICAgICAgICAgICAgICB2YWw6IG51bGxcIixcIiAgICAgICAgICAgIH0pO1wiLFwiICAgICAgICAgIH0pO1wiLFwiICAgICAgICB9LCBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICBmYWlsKCdbbG9hZF0gRmFpbGVkIHRvIGdldCBmaWxlU3lzdGVtJyk7XCIsXCIgICAgICAgIH0pO1wiLFwiICAgICAgfSk7XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIGV4aXN0cyA6IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrKXtcIixcIiAgICAgIGZpbGVuYW1lRm9yS2V5KGtleSxmdW5jdGlvbiAoaGFzaCl7XCIsXCIgICAgICAgIHdpbmRvdy5yZXF1ZXN0RmlsZVN5c3RlbShMb2NhbEZpbGVTeXN0ZW0uUEVSU0lTVEVOVCwgMCwgZnVuY3Rpb24gZ290RlMoZmlsZVN5c3RlbSkge1wiLFwiICAgICAgICAgIGZpbGVTeXN0ZW0ucm9vdC5nZXRGaWxlKGhhc2gsIHt9LFwiLFwiICAgICAgICAgICAgZnVuY3Rpb24gZ290RmlsZUVudHJ5KGZpbGVFbnRyeSkge1wiLFwiICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodHJ1ZSk7XCIsXCIgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKXtcIixcIiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGZhbHNlKTtcIixcIiAgICAgICAgICAgIH0pO1wiLFwiICAgICAgICB9KTtcIixcIiAgICAgIH0pO1wiLFwiICAgIH0sXCIsXCJcIixcIiAgICBhbGwgOiBmdW5jdGlvbiAoY2FsbGJhY2spe1wiLFwiICAgICAgdGhyb3cgXFxcIkN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXFxcIjtcIixcIiAgICB9LFwiLFwiXCIsXCIgICAgcmVtb3ZlIDogZnVuY3Rpb24gKGtleSwgY2FsbGJhY2spe1wiLFwiICAgICAgZmlsZW5hbWVGb3JLZXkoa2V5LCBmdW5jdGlvbihoYXNoKSB7XCIsXCJcIixcIiAgICAgICAgd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtKExvY2FsRmlsZVN5c3RlbS5QRVJTSVNURU5ULCAwLCBmdW5jdGlvbiBnb3RGUyhmaWxlU3lzdGVtKSB7XCIsXCIgICAgICAgICAgZmlsZVN5c3RlbS5yb290LmdldEZpbGUoaGFzaCwge30sIGZ1bmN0aW9uIGdvdEZpbGVFbnRyeShmaWxlRW50cnkpIHtcIixcIlwiLFwiICAgICAgICAgICAgZmlsZUVudHJ5LnJlbW92ZShmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHtcIixcIiAgICAgICAgICAgICAgICBrZXk6IGtleSxcIixcIiAgICAgICAgICAgICAgICB2YWw6IG51bGxcIixcIiAgICAgICAgICAgICAgfSk7XCIsXCIgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgICAgZmFpbCgnW3JlbW92ZV0gRmFpbGVkIHRvIHJlbW92ZSBmaWxlJyk7XCIsXCIgICAgICAgICAgICB9KTtcIixcIiAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgIGZhaWwoJ1tyZW1vdmVdIEZhaWxlZCB0byBnZXRGaWxlJyk7XCIsXCIgICAgICAgICAgfSk7XCIsXCIgICAgICAgIH0sIGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICAgIGZhaWwoJ1tyZW1vdmVdIEZhaWxlZCB0byBnZXQgZmlsZVN5c3RlbScpO1wiLFwiICAgICAgICB9KTtcIixcIiAgICAgIH0pO1wiLFwiICAgIH0sXCIsXCJcIixcIiAgICBudWtlIDogZnVuY3Rpb24gKGNhbGxiYWNrKXtcIixcIiAgICAgIHRocm93IFxcXCJDdXJyZW50bHkgbm90IHN1cHBvcnRlZFxcXCI7XCIsXCIgICAgfVwiLFwiXCIsXCJcIixcIiAgfTtcIixcIn1cIixcIlwiLFwidmFyIGFkZEFkYXB0ZXIgPSBmdW5jdGlvbihhcHBfcHJvcHMsIGhhc2hGdW5jKXtcIixcIiAgTGF3bmNoYWlyLmFkYXB0ZXIoJ2xvY2FsRmlsZVN0b3JhZ2UnLCBmaWxlU3RvcmFnZUFkYXB0ZXIoYXBwX3Byb3BzLCBoYXNoRnVuYykpO1wiLFwifVwiLFwiXCIsXCJtb2R1bGUuZXhwb3J0cyA9IHtcIixcIiAgYWRkQWRhcHRlcjogYWRkQWRhcHRlclwiLFwifVwiXTtcbiIsIi8qIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IEpTQ292ZXJhZ2UgLSBkbyBub3QgZWRpdCAqL1xuaWYgKHR5cGVvZiBfJGpzY292ZXJhZ2UgPT09ICd1bmRlZmluZWQnKSBfJGpzY292ZXJhZ2UgPSB7fTtcbmlmICghIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sb2FkU2NyaXB0LmpzJ10pIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvYWRTY3JpcHQuanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbG9hZFNjcmlwdC5qcyddWzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvYWRTY3JpcHQuanMnXVsyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sb2FkU2NyaXB0LmpzJ11bM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbG9hZFNjcmlwdC5qcyddWzRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvYWRTY3JpcHQuanMnXVs1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sb2FkU2NyaXB0LmpzJ11bNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbG9hZFNjcmlwdC5qcyddWzddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvYWRTY3JpcHQuanMnXVs4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sb2FkU2NyaXB0LmpzJ11bOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbG9hZFNjcmlwdC5qcyddWzEwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sb2FkU2NyaXB0LmpzJ11bMTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvYWRTY3JpcHQuanMnXVsxMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbG9hZFNjcmlwdC5qcyddWzE0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sb2FkU2NyaXB0LmpzJ11bMTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvYWRTY3JpcHQuanMnXVsxNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbG9hZFNjcmlwdC5qcyddWzIwXSA9IDA7XG59XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvbG9hZFNjcmlwdC5qcyddWzFdKys7XG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbG9hZFNjcmlwdC5qcyddWzJdKys7XG4gIHZhciBzY3JpcHQ7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sb2FkU2NyaXB0LmpzJ11bM10rKztcbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sb2FkU2NyaXB0LmpzJ11bNF0rKztcbiAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvYWRTY3JpcHQuanMnXVs1XSsrO1xuICBzY3JpcHQuYXN5bmMgPSBcImFzeW5jXCI7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sb2FkU2NyaXB0LmpzJ11bNl0rKztcbiAgc2NyaXB0LnNyYyA9IHVybDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvYWRTY3JpcHQuanMnXVs3XSsrO1xuICBzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sb2FkU2NyaXB0LmpzJ11bOF0rKztcbiAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbG9hZFNjcmlwdC5qcyddWzldKys7XG4gIGlmICghIHNjcmlwdC5yZWFkeVN0YXRlIHx8IC9sb2FkZWR8Y29tcGxldGUvLnRlc3Qoc2NyaXB0LnJlYWR5U3RhdGUpKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvYWRTY3JpcHQuanMnXVsxMF0rKztcbiAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvYWRTY3JpcHQuanMnXVsxMV0rKztcbiAgICBpZiAoaGVhZCAmJiBzY3JpcHQucGFyZW50Tm9kZSkge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvYWRTY3JpcHQuanMnXVsxMl0rKztcbiAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICB9XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvYWRTY3JpcHQuanMnXVsxNF0rKztcbiAgICBzY3JpcHQgPSB1bmRlZmluZWQ7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvYWRTY3JpcHQuanMnXVsxNV0rKztcbiAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sb2FkU2NyaXB0LmpzJ11bMTZdKys7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxufSk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sb2FkU2NyaXB0LmpzJ11bMjBdKys7XG4gIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvYWRTY3JpcHQuanMnXS5zb3VyY2UgPSBbXCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XCIsXCIgIHZhciBzY3JpcHQ7XCIsXCIgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiaGVhZFxcXCIpWzBdIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcIixcIiAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwic2NyaXB0XFxcIik7XCIsXCIgIHNjcmlwdC5hc3luYyA9IFxcXCJhc3luY1xcXCI7XCIsXCIgIHNjcmlwdC5zcmMgPSB1cmw7XCIsXCIgIHNjcmlwdC50eXBlID0gXFxcInRleHQvamF2YXNjcmlwdFxcXCI7XCIsXCIgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1wiLFwiICAgIGlmICghc2NyaXB0LnJlYWR5U3RhdGUgfHwgL2xvYWRlZHxjb21wbGV0ZS8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIHtcIixcIiAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcIixcIiAgICAgIGlmIChoZWFkICZhbXA7JmFtcDsgc2NyaXB0LnBhcmVudE5vZGUpIHtcIixcIiAgICAgICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpO1wiLFwiICAgICAgfVwiLFwiICAgICAgc2NyaXB0ID0gdW5kZWZpbmVkO1wiLFwiICAgICAgaWYgKGNhbGxiYWNrICZhbXA7JmFtcDsgdHlwZW9mIGNhbGxiYWNrID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XCIsXCIgICAgICAgIGNhbGxiYWNrKCk7XCIsXCIgICAgICB9XCIsXCIgICAgfVwiLFwiICB9O1wiLFwiICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XCIsXCJ9O1wiXTtcbiIsIi8qIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IEpTQ292ZXJhZ2UgLSBkbyBub3QgZWRpdCAqL1xuaWYgKHR5cGVvZiBfJGpzY292ZXJhZ2UgPT09ICd1bmRlZmluZWQnKSBfJGpzY292ZXJhZ2UgPSB7fTtcbmlmICghIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sb2dnZXIuanMnXSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvbG9nZ2VyLmpzJ10gPSBbXTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvZ2dlci5qcyddWzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvZ2dlci5qcyddWzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvZ2dlci5qcyddWzRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL2xvZ2dlci5qcyddWzIzXSA9IDA7XG59XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvbG9nZ2VyLmpzJ11bMV0rKztcbnZhciBjb25zb2xlID0gcmVxdWlyZShcImNvbnNvbGVcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvbG9nZ2VyLmpzJ11bMl0rKztcbnZhciBsb2cgPSByZXF1aXJlKFwibG9nbGV2ZWxcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvbG9nZ2VyLmpzJ11bNF0rKztcbmxvZy5zZXRMZXZlbChcImluZm9cIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvbG9nZ2VyLmpzJ11bMjNdKys7XG5tb2R1bGUuZXhwb3J0cyA9IGxvZztcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9sb2dnZXIuanMnXS5zb3VyY2UgPSBbXCJ2YXIgY29uc29sZSA9IHJlcXVpcmUoJ2NvbnNvbGUnKTtcIixcInZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpO1wiLFwiXCIsXCJsb2cuc2V0TGV2ZWwoJ2luZm8nKTtcIixcIlwiLFwiLyoqXCIsXCIgKiBBUElzOlwiLFwiICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbC5cIixcIiAqIEluIHNob3J0LCB5b3UgY2FuIHVzZTpcIixcIiAqIGxvZy5zZXRMZXZlbChsb2dsZXZlbCkgLSBkZWZhdWx0IHRvIGluZm9cIixcIiAqIGxvZy5lbmFibGVBbGwoKSAtIGVuYWJsZSBhbGwgbG9nIG1lc3NhZ2VzXCIsXCIgKiBsb2cuZGlzYWJsZUFsbCgpIC0gZGlzYWJsZSBhbGwgbG9nIG1lc3NhZ2VzXCIsXCIgKlwiLFwiICogbG9nLnRyYWNlKG1zZylcIixcIiAqIGxvZy5kZWJ1Zyhtc2cpXCIsXCIgKiBsb2cuaW5mbyhtc2cpXCIsXCIgKiBsb2cud2Fybihtc2cpXCIsXCIgKiBsb2cuZXJyb3IobXNnKVwiLFwiICpcIixcIiAqIEF2YWlsYWJsZSBsZXZlbHM6IHsgXFxcIlRSQUNFXFxcIjogMCwgXFxcIkRFQlVHXFxcIjogMSwgXFxcIklORk9cXFwiOiAyLCBcXFwiV0FSTlxcXCI6IDMsIFxcXCJFUlJPUlxcXCI6IDQsIFxcXCJTSUxFTlRcXFwiOiA1fVwiLFwiICogVXNlIGVpdGhlciBzdHJpbmcgb3IgaW50ZWdlciB2YWx1ZVwiLFwiICovXCIsXCJtb2R1bGUuZXhwb3J0cyA9IGxvZztcIl07XG4iLCIvKiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBKU0NvdmVyYWdlIC0gZG8gbm90IGVkaXQgKi9cbmlmICh0eXBlb2YgXyRqc2NvdmVyYWdlID09PSAndW5kZWZpbmVkJykgXyRqc2NvdmVyYWdlID0ge307XG5pZiAoISBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvcGxhdGZvcm1zTWFwLmpzJ10pIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3BsYXRmb3Jtc01hcC5qcyddID0gW107XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9wbGF0Zm9ybXNNYXAuanMnXVsxXSA9IDA7XG59XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvcGxhdGZvcm1zTWFwLmpzJ11bMV0rKztcbm1vZHVsZS5leHBvcnRzID0gW3tcImRlc3RpbmF0aW9uXCI6IFwiaXBhZFwiLCBcInRlc3RcIjogW1wiaVBhZFwiXX0sIHtcImRlc3RpbmF0aW9uXCI6IFwiaXBob25lXCIsIFwidGVzdFwiOiBbXCJpUGhvbmVcIl19LCB7XCJkZXN0aW5hdGlvblwiOiBcImFuZHJvaWRcIiwgXCJ0ZXN0XCI6IFtcIkFuZHJvaWRcIl19LCB7XCJkZXN0aW5hdGlvblwiOiBcImJsYWNrYmVycnlcIiwgXCJ0ZXN0XCI6IFtcIkJsYWNrQmVycnlcIiwgXCJCQjEwXCIsIFwiUklNIFRhYmxldCBPU1wiXX0sIHtcImRlc3RpbmF0aW9uXCI6IFwid2luZG93c3Bob25lXCIsIFwidGVzdFwiOiBbXCJXaW5kb3dzIFBob25lIDhcIl19LCB7XCJkZXN0aW5hdGlvblwiOiBcIndpbmRvd3NwaG9uZTdcIiwgXCJ0ZXN0XCI6IFtcIldpbmRvd3MgUGhvbmUgT1MgN1wiXX1dO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL3BsYXRmb3Jtc01hcC5qcyddLnNvdXJjZSA9IFtcIm1vZHVsZS5leHBvcnRzID0gW1wiLFwiICB7XCIsXCIgICAgXFxcImRlc3RpbmF0aW9uXFxcIiA6XFxcImlwYWRcXFwiLFwiLFwiICAgIFxcXCJ0ZXN0XFxcIjogW1xcXCJpUGFkXFxcIl1cIixcIiAgfSxcIixcIiAge1wiLFwiICAgIFxcXCJkZXN0aW5hdGlvblxcXCIgOlxcXCJpcGhvbmVcXFwiLFwiLFwiICAgIFxcXCJ0ZXN0XFxcIjogW1xcXCJpUGhvbmVcXFwiXVwiLFwiICB9LFwiLFwiICB7XCIsXCIgICAgXFxcImRlc3RpbmF0aW9uXFxcIiA6XFxcImFuZHJvaWRcXFwiLFwiLFwiICAgIFxcXCJ0ZXN0XFxcIjogW1xcXCJBbmRyb2lkXFxcIl1cIixcIiAgfSxcIixcIiAge1wiLFwiICAgIFxcXCJkZXN0aW5hdGlvblxcXCIgOlxcXCJibGFja2JlcnJ5XFxcIixcIixcIiAgICBcXFwidGVzdFxcXCI6IFtcXFwiQmxhY2tCZXJyeVxcXCIsIFxcXCJCQjEwXFxcIiwgXFxcIlJJTSBUYWJsZXQgT1NcXFwiXS8vQmxhY2tiZXJyeSAxMCBkb2VzIG5vdCBjb250YWluIFxcXCJCbGFja2JlcnJ5XFxcIlwiLFwiICB9LFwiLFwiICB7XCIsXCIgICAgXFxcImRlc3RpbmF0aW9uXFxcIiA6XFxcIndpbmRvd3NwaG9uZVxcXCIsXCIsXCIgICAgXFxcInRlc3RcXFwiOiBbXFxcIldpbmRvd3MgUGhvbmUgOFxcXCJdXCIsXCIgIH0sXCIsXCIgIHtcIixcIiAgICBcXFwiZGVzdGluYXRpb25cXFwiIDpcXFwid2luZG93c3Bob25lN1xcXCIsXCIsXCIgICAgXFxcInRlc3RcXFwiOiBbXFxcIldpbmRvd3MgUGhvbmUgT1MgN1xcXCJdXCIsXCIgIH1cIixcIl07XCJdO1xuIiwiLyogYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgSlNDb3ZlcmFnZSAtIGRvIG5vdCBlZGl0ICovXG5pZiAodHlwZW9mIF8kanNjb3ZlcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIF8kanNjb3ZlcmFnZSA9IHt9O1xuaWYgKCEgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3F1ZXJ5TWFwLmpzJ10pIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3F1ZXJ5TWFwLmpzJ10gPSBbXTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3F1ZXJ5TWFwLmpzJ11bMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvcXVlcnlNYXAuanMnXVsyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9xdWVyeU1hcC5qcyddWzNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3F1ZXJ5TWFwLmpzJ11bNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvcXVlcnlNYXAuanMnXVs1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9xdWVyeU1hcC5qcyddWzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3F1ZXJ5TWFwLmpzJ11bN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvcXVlcnlNYXAuanMnXVs4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9xdWVyeU1hcC5qcyddWzldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3F1ZXJ5TWFwLmpzJ11bMTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3F1ZXJ5TWFwLmpzJ11bMTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3F1ZXJ5TWFwLmpzJ11bMTRdID0gMDtcbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9xdWVyeU1hcC5qcyddWzFdKys7XG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAodXJsKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9xdWVyeU1hcC5qcyddWzJdKys7XG4gIHZhciBxbWFwID0ge307XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9xdWVyeU1hcC5qcyddWzNdKys7XG4gIHZhciBpID0gdXJsLnNwbGl0KFwiP1wiKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3F1ZXJ5TWFwLmpzJ11bNF0rKztcbiAgaWYgKGkubGVuZ3RoID09PSAyKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3F1ZXJ5TWFwLmpzJ11bNV0rKztcbiAgICB2YXIgcXVlcnlTdHJpbmcgPSBpWzFdO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9xdWVyeU1hcC5qcyddWzZdKys7XG4gICAgdmFyIHBhaXJzID0gcXVlcnlTdHJpbmcuc3BsaXQoXCImXCIpO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9xdWVyeU1hcC5qcyddWzddKys7XG4gICAgcW1hcCA9IHt9O1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9xdWVyeU1hcC5qcyddWzhdKys7XG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwYWlycy5sZW5ndGg7IHArKykge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3F1ZXJ5TWFwLmpzJ11bOV0rKztcbiAgICAgIHZhciBxID0gcGFpcnNbcF07XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvcXVlcnlNYXAuanMnXVsxMF0rKztcbiAgICAgIHZhciBxcCA9IHEuc3BsaXQoXCI9XCIpO1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3F1ZXJ5TWFwLmpzJ11bMTFdKys7XG4gICAgICBxbWFwW3FwWzBdXSA9IHFwWzFdO1xufVxuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9xdWVyeU1hcC5qcyddWzE0XSsrO1xuICByZXR1cm4gcW1hcDtcbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL3F1ZXJ5TWFwLmpzJ10uc291cmNlID0gW1wibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwpIHtcIixcIiAgdmFyIHFtYXAgPSB7fTtcIixcIiAgdmFyIGkgPSB1cmwuc3BsaXQoXFxcIj9cXFwiKTtcIixcIiAgaWYgKGkubGVuZ3RoID09PSAyKSB7XCIsXCIgICAgdmFyIHF1ZXJ5U3RyaW5nID0gaVsxXTtcIixcIiAgICB2YXIgcGFpcnMgPSBxdWVyeVN0cmluZy5zcGxpdChcXFwiJmFtcDtcXFwiKTtcIixcIiAgICBxbWFwID0ge307XCIsXCIgICAgZm9yICh2YXIgcCA9IDA7IHAgJmx0OyBwYWlycy5sZW5ndGg7IHArKykge1wiLFwiICAgICAgdmFyIHEgPSBwYWlyc1twXTtcIixcIiAgICAgIHZhciBxcCA9IHEuc3BsaXQoXFxcIj1cXFwiKTtcIixcIiAgICAgIHFtYXBbcXBbMF1dID0gcXBbMV07XCIsXCIgICAgfVwiLFwiICB9XCIsXCIgIHJldHVybiBxbWFwO1wiLFwifTtcIl07XG4iLCIvKiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBKU0NvdmVyYWdlIC0gZG8gbm90IGVkaXQgKi9cbmlmICh0eXBlb2YgXyRqc2NvdmVyYWdlID09PSAndW5kZWZpbmVkJykgXyRqc2NvdmVyYWdlID0ge307XG5pZiAoISBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2RrdmVyc2lvbi5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZGt2ZXJzaW9uLmpzJ10gPSBbXTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3Nka3ZlcnNpb24uanMnXVsxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZGt2ZXJzaW9uLmpzJ11bM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2RrdmVyc2lvbi5qcyddWzRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3Nka3ZlcnNpb24uanMnXVs1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZGt2ZXJzaW9uLmpzJ11bNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2RrdmVyc2lvbi5qcyddWzddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3Nka3ZlcnNpb24uanMnXVs4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZGt2ZXJzaW9uLmpzJ11bMTBdID0gMDtcbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZGt2ZXJzaW9uLmpzJ11bMV0rKztcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2RrdmVyc2lvbi5qcyddWzNdKys7XG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZGt2ZXJzaW9uLmpzJ11bNF0rKztcbiAgdmFyIHR5cGUgPSBcIkZIX0pTX1NES1wiO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2RrdmVyc2lvbi5qcyddWzVdKys7XG4gIGlmICh0eXBlb2Ygd2luZG93LmZoX2Rlc3RpbmF0aW9uX2NvZGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2RrdmVyc2lvbi5qcyddWzZdKys7XG4gICAgdHlwZSA9IFwiRkhfSFlCUklEX1NES1wiO1xuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZGt2ZXJzaW9uLmpzJ11bN10rKztcbiAgICBpZiAod2luZG93LlBob25lR2FwIHx8IHdpbmRvdy5jb3Jkb3ZhKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2RrdmVyc2lvbi5qcyddWzhdKys7XG4gICAgICB0eXBlID0gXCJGSF9QSE9ORUdBUF9TREtcIjtcbiAgICB9XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3Nka3ZlcnNpb24uanMnXVsxMF0rKztcbiAgcmV0dXJuIHR5cGUgKyBcIi9cIiArIGNvbnN0YW50cy5zZGtfdmVyc2lvbjtcbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL3Nka3ZlcnNpb24uanMnXS5zb3VyY2UgPSBbXCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZShcXFwiLi9jb25zdGFudHNcXFwiKTtcIixcIlwiLFwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcIixcIiAgdmFyIHR5cGUgPSBcXFwiRkhfSlNfU0RLXFxcIjtcIixcIiAgaWYgKHR5cGVvZiB3aW5kb3cuZmhfZGVzdGluYXRpb25fY29kZSAhPT0gJ3VuZGVmaW5lZCcpIHtcIixcIiAgICB0eXBlID0gXFxcIkZIX0hZQlJJRF9TREtcXFwiO1wiLFwiICB9IGVsc2UgaWYod2luZG93LlBob25lR2FwIHx8IHdpbmRvdy5jb3Jkb3ZhKSB7XCIsXCIgICAgdHlwZSA9IFxcXCJGSF9QSE9ORUdBUF9TREtcXFwiO1wiLFwiICB9XCIsXCIgIHJldHVybiB0eXBlICsgXFxcIi9cXFwiICsgY29uc3RhbnRzLnNka192ZXJzaW9uO1wiLFwifTtcIl07XG4iLCIvKiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBKU0NvdmVyYWdlIC0gZG8gbm90IGVkaXQgKi9cbmlmICh0eXBlb2YgXyRqc2NvdmVyYWdlID09PSAndW5kZWZpbmVkJykgXyRqc2NvdmVyYWdlID0ge307XG5pZiAoISBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2VjdXJpdHkvaGFzaC5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZWN1cml0eS9oYXNoLmpzJ10gPSBbXTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3NlY3VyaXR5L2hhc2guanMnXVsxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZWN1cml0eS9oYXNoLmpzJ11bNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2VjdXJpdHkvaGFzaC5qcyddWzVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3NlY3VyaXR5L2hhc2guanMnXVs2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZWN1cml0eS9oYXNoLmpzJ11bN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2VjdXJpdHkvaGFzaC5qcyddWzldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3NlY3VyaXR5L2hhc2guanMnXVsxMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2VjdXJpdHkvaGFzaC5qcyddWzExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZWN1cml0eS9oYXNoLmpzJ11bMTJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3NlY3VyaXR5L2hhc2guanMnXVsxM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2VjdXJpdHkvaGFzaC5qcyddWzE0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZWN1cml0eS9oYXNoLmpzJ11bMTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3NlY3VyaXR5L2hhc2guanMnXVsxNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2VjdXJpdHkvaGFzaC5qcyddWzE3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZWN1cml0eS9oYXNoLmpzJ11bMTldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3NlY3VyaXR5L2hhc2guanMnXVsyMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2VjdXJpdHkvaGFzaC5qcyddWzI0XSA9IDA7XG59XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2VjdXJpdHkvaGFzaC5qcyddWzFdKys7XG52YXIgQ3J5cHRvSlMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGlicy9nZW5lcmF0ZWQvY3J5cHRvXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL3NlY3VyaXR5L2hhc2guanMnXVs0XSsrO1xudmFyIGhhc2ggPSAoZnVuY3Rpb24gKHAsIHMsIGYpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3NlY3VyaXR5L2hhc2guanMnXVs1XSsrO1xuICBpZiAoISBwLnBhcmFtcy50ZXh0KSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3NlY3VyaXR5L2hhc2guanMnXVs2XSsrO1xuICAgIGYoXCJoYXNoX25vX3RleHRcIiwge30sIHApO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZWN1cml0eS9oYXNoLmpzJ11bN10rKztcbiAgICByZXR1cm47XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3NlY3VyaXR5L2hhc2guanMnXVs5XSsrO1xuICB2YXIgaGFzaFZhbHVlO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2VjdXJpdHkvaGFzaC5qcyddWzEwXSsrO1xuICBpZiAocC5wYXJhbXMuYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkgPT09IFwibWQ1XCIpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2VjdXJpdHkvaGFzaC5qcyddWzExXSsrO1xuICAgIGhhc2hWYWx1ZSA9IENyeXB0b0pTLk1ENShwLnBhcmFtcy50ZXh0KS50b1N0cmluZyhDcnlwdG9KUy5lbmMuSGV4KTtcbiAgfVxuICBlbHNlIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc2VjdXJpdHkvaGFzaC5qcyddWzEyXSsrO1xuICAgIGlmIChwLnBhcmFtcy5hbGdvcml0aG0udG9Mb3dlckNhc2UoKSA9PT0gXCJzaGExXCIpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZWN1cml0eS9oYXNoLmpzJ11bMTNdKys7XG4gICAgICBoYXNoVmFsdWUgPSBDcnlwdG9KUy5TSEExKHAucGFyYW1zLnRleHQpLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5IZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZWN1cml0eS9oYXNoLmpzJ11bMTRdKys7XG4gICAgICBpZiAocC5wYXJhbXMuYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkgPT09IFwic2hhMjU2XCIpIHtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3NlY3VyaXR5L2hhc2guanMnXVsxNV0rKztcbiAgICAgICAgaGFzaFZhbHVlID0gQ3J5cHRvSlMuU0hBMjU2KHAucGFyYW1zLnRleHQpLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5IZXgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZWN1cml0eS9oYXNoLmpzJ11bMTZdKys7XG4gICAgICAgIGlmIChwLnBhcmFtcy5hbGdvcml0aG0udG9Mb3dlckNhc2UoKSA9PT0gXCJzaGE1MTJcIikge1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZWN1cml0eS9oYXNoLmpzJ11bMTddKys7XG4gICAgICAgICAgaGFzaFZhbHVlID0gQ3J5cHRvSlMuU0hBNTEyKHAucGFyYW1zLnRleHQpLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5IZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZWN1cml0eS9oYXNoLmpzJ11bMTldKys7XG4gICAgICAgICAgcmV0dXJuIGYoXCJoYXNoX3Vuc3VwcG9ydGVkX2FsZ29yaXRobTogXCIgKyBwLnBhcmFtcy5hbGdvcml0aG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZWN1cml0eS9oYXNoLmpzJ11bMjFdKys7XG4gIHJldHVybiBzKHtcImhhc2h2YWx1ZVwiOiBoYXNoVmFsdWV9KTtcbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL3NlY3VyaXR5L2hhc2guanMnXVsyNF0rKztcbm1vZHVsZS5leHBvcnRzID0gaGFzaDtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zZWN1cml0eS9oYXNoLmpzJ10uc291cmNlID0gW1widmFyIENyeXB0b0pTID0gcmVxdWlyZShcXFwiLi4vLi4vLi4vbGlicy9nZW5lcmF0ZWQvY3J5cHRvXFxcIik7XCIsXCJcIixcIlwiLFwidmFyIGhhc2ggPSBmdW5jdGlvbihwLCBzLCBmKXtcIixcIiAgaWYgKCFwLnBhcmFtcy50ZXh0KSB7XCIsXCIgICAgZignaGFzaF9ub190ZXh0Jywge30sIHApO1wiLFwiICAgIHJldHVybjtcIixcIiAgfVwiLFwiICB2YXIgaGFzaFZhbHVlO1wiLFwiICBpZiAocC5wYXJhbXMuYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJtZDVcXFwiKSB7XCIsXCIgICAgaGFzaFZhbHVlID0gQ3J5cHRvSlMuTUQ1KHAucGFyYW1zLnRleHQpLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5IZXgpO1wiLFwiICB9IGVsc2UgaWYocC5wYXJhbXMuYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJzaGExXFxcIil7XCIsXCIgICAgaGFzaFZhbHVlID0gQ3J5cHRvSlMuU0hBMShwLnBhcmFtcy50ZXh0KS50b1N0cmluZyhDcnlwdG9KUy5lbmMuSGV4KTtcIixcIiAgfSBlbHNlIGlmKHAucGFyYW1zLmFsZ29yaXRobS50b0xvd2VyQ2FzZSgpID09PSBcXFwic2hhMjU2XFxcIil7XCIsXCIgICAgaGFzaFZhbHVlID0gQ3J5cHRvSlMuU0hBMjU2KHAucGFyYW1zLnRleHQpLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5IZXgpO1wiLFwiICB9IGVsc2UgaWYocC5wYXJhbXMuYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJzaGE1MTJcXFwiKXtcIixcIiAgICBoYXNoVmFsdWUgPSBDcnlwdG9KUy5TSEE1MTIocC5wYXJhbXMudGV4dCkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLkhleCk7XCIsXCIgIH0gZWxzZSB7XCIsXCIgICAgcmV0dXJuIGYoXFxcImhhc2hfdW5zdXBwb3J0ZWRfYWxnb3JpdGhtOiBcXFwiICsgcC5wYXJhbXMuYWxnb3JpdGhtKTtcIixcIiAgfVwiLFwiICByZXR1cm4gcyh7XFxcImhhc2h2YWx1ZVxcXCI6IGhhc2hWYWx1ZX0pO1wiLFwifVwiLFwiXCIsXCJtb2R1bGUuZXhwb3J0cyA9IGhhc2g7XCJdO1xuIiwiLyogYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgSlNDb3ZlcmFnZSAtIGRvIG5vdCBlZGl0ICovXG5pZiAodHlwZW9mIF8kanNjb3ZlcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIF8kanNjb3ZlcmFnZSA9IHt9O1xuaWYgKCEgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ10pIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ10gPSBbXTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOThdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTAyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTEyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMzBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTMyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEzNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTQxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE0NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxNDhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTQ5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE1MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxNTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTUyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE1M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxNjBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTYxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE2NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxNjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTY2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE2N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxNzBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTc0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE3NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxNzddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTc4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE4MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxODNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTg4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE5Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxOTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTk0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE5NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxOThdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTk5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzIwMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyMDddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzIxNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyMTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjE3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzIxOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyMjBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjIyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzIyN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyMjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjI5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzIzNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyMzVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjQ2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzI0N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyNjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjY0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzI2NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyNjldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjcxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzI3Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyNzNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjc0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzI3OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyODRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjg1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzI4Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyOTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjk0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzMwMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszMDNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzA0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzMwNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszMTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzEzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzMxNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszMTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzIxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzMyM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszMjRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzI1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzMyNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszMjddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzMwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzMzMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszMzddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzM5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM0MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszNDJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzQ3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM0OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszNTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzUxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM1Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszNTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzU2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM1N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszNjNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzY1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM2Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszNjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzczXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM3NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszNzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzc3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM3OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszNzldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzgwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM4M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszODRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzkwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM5MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszOTJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzk4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM5OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0MDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDA2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQwOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0MDldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDEwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQxMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0MTJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDE1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQxNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0MjJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDI0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQyNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0MjZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDI3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQyOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0MzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDMyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQzOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0MzldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDQyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ0NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0NDVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDUxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ1Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0NThdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDU5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ2MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0NjRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDY4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ2OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0NzNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDc0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ3NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0NzldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDgwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ4Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0ODRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDg2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ4OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0ODldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDkxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ5Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0OTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDk2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUwMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1MDFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTAyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUwM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1MDRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTA1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUwNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1MDddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTA4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUxMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1MTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTEyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUxM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1MTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTE2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUyMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1MjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTI2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUyN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1MjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTMwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUzMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1MzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTM0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUzNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1MzddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTM4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUzOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTQxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU0M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NDRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTQ2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU0N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NDhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTUyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU1M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTU1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU1OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NjBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTYxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU2M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NjRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTY4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU3MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTcyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU3M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NzRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTc1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU3Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NzddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTg0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU4N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1OTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTkzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU5Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjAyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYwM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MDVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjA4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYwOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYxMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjE2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYxN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MTldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjIxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYyMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjI5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYzMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MzRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjM1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY0NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2NDddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjQ5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY1MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2NTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjUyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY1M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2NTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjU4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY1OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2NjBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjYxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY2M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2NjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjY5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY3MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2NzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjczXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY3NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2NzddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjc4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY3OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2ODBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjgxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY4NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2ODVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjg2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY4N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2OTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjkzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY5NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2OTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjk3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY5OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzA3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzcwOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MDldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzEwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzcxMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzE3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzcxOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MjBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzIyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzcyM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MjRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzI1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzcyN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzI5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzczMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzMzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzczN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MzhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzQxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc0M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3NDhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzU2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc1N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3NTldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzYxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc2OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3NzBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzcxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc3M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3NzRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzc3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc3OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3ODBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzgyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc4N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3ODhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzkyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc5NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3OTddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODAyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzgwNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4MTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODEzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzgxNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4MTldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODIxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzgyMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4MjNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODI1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzgyN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4MjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODMwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzgzOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODQxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg0Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NDVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODQ2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg0N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NDhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODQ5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg1M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODU1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg1Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NTldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODY3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg2OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NjldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODcxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg3Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NzRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODc3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg3OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NzldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODgyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg4NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4ODZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODg5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg5Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4OTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODk0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg5NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4OTddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODk4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg5OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5MDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTAxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzkwMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5MDVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTA2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzkwN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5MTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTE0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzkxNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5MTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTIzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzkyNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5MjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTI2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzkyOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5MjldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTMwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzkzMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5MzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTMzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzkzNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5MzddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTM4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk0MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NDRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTQ1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk0Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NDddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTUwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk1MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NTJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTU2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk2MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTYyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk2M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NjRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTY5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk3MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTczXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk3NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NzVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTc3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk3OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5ODFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTgyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk4NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5ODZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTg3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk4OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5ODldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTkzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk5NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5OTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTk2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk5OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5OTldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTAwMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDAxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwMDJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTAwM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDA0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwMTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTAxMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDEzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwMTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTAxNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDE2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwMTldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTAyMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDIxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwMjJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTAzM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDM1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwMzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTAzN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDM4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwNDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA0MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDQzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwNDVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA0Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDQ4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwNTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA1MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDUzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwNTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA1N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDU5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwNjBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA2NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDc0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwNzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA3N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDc4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwNzldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA4MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDgyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwODNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA4NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDg2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwODddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA4OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDkxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwOTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA5NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDk2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExMDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTEwOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTE1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExMTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTExN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTE4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExMjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTEyMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTIzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExMjRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTEyNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTI3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExMjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTEzMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTMyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExMzVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTEzN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTM5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExNDFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE0Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTQzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExNDVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE0Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTQ3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExNTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE1NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTYwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExNjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE2NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTcxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExNzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE3NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTgyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExODNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE4NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTg2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExODddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE4OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTg5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExOTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE5MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTkyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExOTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE5Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjAwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMDFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTIwM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjA0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMDVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTIwNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjE1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTIxN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjE4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMTldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTIyMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjIxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMjJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTIyM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjI0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTIyNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjI3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTIyOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjQwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyNDFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI0Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjQ0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyNDVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI0Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjQ3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyNDhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI1MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjUxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyNTJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI1M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjYwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyNjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI2Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjY0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyNjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI2Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjY3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyNzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI3N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjgyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyODNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI4OF0gPSAwO1xufVxuXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMV0rKztcbnZhciBKU09OID0gcmVxdWlyZShcIkpTT05cIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyXSsrO1xudmFyIGFjdEFQSSA9IHJlcXVpcmUoXCIuL2FwaV9hY3RcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszXSsrO1xudmFyIGNsb3VkQVBJID0gcmVxdWlyZShcIi4vYXBpX2Nsb3VkXCIpO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNF0rKztcbnZhciBDcnlwdG9KUyA9IHJlcXVpcmUoXCIuLi8uLi9saWJzL2dlbmVyYXRlZC9jcnlwdG9cIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1XSsrO1xudmFyIExhd25jaGFpciA9IHJlcXVpcmUoXCIuLi8uLi9saWJzL2dlbmVyYXRlZC9sYXduY2hhaXJcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3XSsrO1xudmFyIHNlbGYgPSB7ZGVmYXVsdHM6IHtcInN5bmNfZnJlcXVlbmN5XCI6IDEwLCBcImF1dG9fc3luY19sb2NhbF91cGRhdGVzXCI6IHRydWUsIFwibm90aWZ5X2NsaWVudF9zdG9yYWdlX2ZhaWxlZFwiOiB0cnVlLCBcIm5vdGlmeV9zeW5jX3N0YXJ0ZWRcIjogdHJ1ZSwgXCJub3RpZnlfc3luY19jb21wbGV0ZVwiOiB0cnVlLCBcIm5vdGlmeV9vZmZsaW5lX3VwZGF0ZVwiOiB0cnVlLCBcIm5vdGlmeV9jb2xsaXNpb25fZGV0ZWN0ZWRcIjogdHJ1ZSwgXCJub3RpZnlfcmVtb3RlX3VwZGF0ZV9mYWlsZWRcIjogdHJ1ZSwgXCJub3RpZnlfbG9jYWxfdXBkYXRlX2FwcGxpZWRcIjogdHJ1ZSwgXCJub3RpZnlfcmVtb3RlX3VwZGF0ZV9hcHBsaWVkXCI6IHRydWUsIFwibm90aWZ5X2RlbHRhX3JlY2VpdmVkXCI6IHRydWUsIFwibm90aWZ5X3JlY29yZF9kZWx0YV9yZWNlaXZlZFwiOiB0cnVlLCBcIm5vdGlmeV9zeW5jX2ZhaWxlZFwiOiB0cnVlLCBcImRvX2NvbnNvbGVfbG9nXCI6IGZhbHNlLCBcImNyYXNoZWRfY291bnRfd2FpdFwiOiAxMCwgXCJyZXNlbmRfY3Jhc2hlZF91cGRhdGVzXCI6IHRydWUsIFwic3luY19hY3RpdmVcIjogdHJ1ZSwgXCJzdG9yYWdlX3N0cmF0ZWd5XCI6IFwiaHRtbDUtZmlsZXN5c3RlbVwiLCBcImZpbGVfc3lzdGVtX3F1b3RhXCI6IDYxNjQ0ODAwfSwgbm90aWZpY2F0aW9uczoge1wiQ0xJRU5UX1NUT1JBR0VfRkFJTEVEXCI6IFwiY2xpZW50X3N0b3JhZ2VfZmFpbGVkXCIsIFwiU1lOQ19TVEFSVEVEXCI6IFwic3luY19zdGFydGVkXCIsIFwiU1lOQ19DT01QTEVURVwiOiBcInN5bmNfY29tcGxldGVcIiwgXCJPRkZMSU5FX1VQREFURVwiOiBcIm9mZmxpbmVfdXBkYXRlXCIsIFwiQ09MTElTSU9OX0RFVEVDVEVEXCI6IFwiY29sbGlzaW9uX2RldGVjdGVkXCIsIFwiUkVNT1RFX1VQREFURV9GQUlMRURcIjogXCJyZW1vdGVfdXBkYXRlX2ZhaWxlZFwiLCBcIlJFTU9URV9VUERBVEVfQVBQTElFRFwiOiBcInJlbW90ZV91cGRhdGVfYXBwbGllZFwiLCBcIkxPQ0FMX1VQREFURV9BUFBMSUVEXCI6IFwibG9jYWxfdXBkYXRlX2FwcGxpZWRcIiwgXCJERUxUQV9SRUNFSVZFRFwiOiBcImRlbHRhX3JlY2VpdmVkXCIsIFwiUkVDT1JEX0RFTFRBX1JFQ0VJVkVEXCI6IFwicmVjb3JkX2RlbHRhX3JlY2VpdmVkXCIsIFwiU1lOQ19GQUlMRURcIjogXCJzeW5jX2ZhaWxlZFwifSwgZGF0YXNldHM6IHt9LCBjb25maWc6IHVuZGVmaW5lZCwgbm90aWZ5X2NhbGxiYWNrOiB1bmRlZmluZWQsIGhhc0N1c3RvbVN5bmM6IHVuZGVmaW5lZCwgaW5pdDogKGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg3XSsrO1xuICBzZWxmLmNvbnNvbGVMb2coXCJzeW5jIC0gaW5pdCBjYWxsZWRcIik7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg5XSsrO1xuICBzZWxmLmNvbmZpZyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2VsZi5kZWZhdWx0cykpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5MF0rKztcbiAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTFdKys7XG4gICAgc2VsZi5jb25maWdbaV0gPSBvcHRpb25zW2ldO1xufVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NF0rKztcbiAgc2VsZi5kYXRhc2V0TW9uaXRvcigpO1xufSksIG5vdGlmeTogKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5OF0rKztcbiAgc2VsZi5ub3RpZnlfY2FsbGJhY2sgPSBjYWxsYmFjaztcbn0pLCBtYW5hZ2U6IChmdW5jdGlvbiAoZGF0YXNldF9pZCwgb3B0aW9ucywgcXVlcnlfcGFyYW1zLCBtZXRhX2RhdGEsIGNiKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwMl0rKztcbiAgc2VsZi5jb25zb2xlTG9nKFwibWFuYWdlIC0gU1RBUlRcIik7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwNF0rKztcbiAgdmFyIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDZdKys7XG4gIHZhciBkb01hbmFnZSA9IChmdW5jdGlvbiAoZGF0YXNldCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDddKys7XG4gIHNlbGYuY29uc29sZUxvZyhcImRvTWFuYWdlIGRhdGFzZXQgOjogaW5pdGlhbGlzZWQgPSBcIiArIGRhdGFzZXQuaW5pdGlhbGlzZWQgKyBcIiA6OiBcIiArIGRhdGFzZXRfaWQgKyBcIiA6OiBcIiArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA5XSsrO1xuICB2YXIgZGF0YXNldENvbmZpZyA9IHNlbGYuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTExXSsrO1xuICBkYXRhc2V0LnF1ZXJ5X3BhcmFtcyA9IHF1ZXJ5X3BhcmFtcyB8fCBkYXRhc2V0LnF1ZXJ5X3BhcmFtcyB8fCB7fTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTEyXSsrO1xuICBkYXRhc2V0Lm1ldGFfZGF0YSA9IG1ldGFfZGF0YSB8fCBkYXRhc2V0Lm1ldGFfZGF0YSB8fCB7fTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTEzXSsrO1xuICBkYXRhc2V0LmNvbmZpZyA9IGRhdGFzZXRDb25maWc7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExNF0rKztcbiAgZGF0YXNldC5zeW5jUnVubmluZyA9IGZhbHNlO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTVdKys7XG4gIGRhdGFzZXQuc3luY1BlbmRpbmcgPSB0cnVlO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTZdKys7XG4gIGRhdGFzZXQuaW5pdGlhbGlzZWQgPSB0cnVlO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTddKys7XG4gIGRhdGFzZXQubWV0YSA9IHt9O1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTldKys7XG4gIHNlbGYuc2F2ZURhdGFTZXQoZGF0YXNldF9pZCwgKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTIxXSsrO1xuICBpZiAoY2IpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjJdKys7XG4gICAgY2IoKTtcbiAgfVxufSkpO1xufSk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyOF0rKztcbiAgc2VsZi5nZXREYXRhU2V0KGRhdGFzZXRfaWQsIChmdW5jdGlvbiAoZGF0YXNldCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjldKys7XG4gIHNlbGYuY29uc29sZUxvZyhcIm1hbmFnZSAtIGRhdGFzZXQgYWxyZWFkeSBsb2FkZWRcIik7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEzMF0rKztcbiAgZG9NYW5hZ2UoZGF0YXNldCk7XG59KSwgKGZ1bmN0aW9uIChlcnIpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTMyXSsrO1xuICBzZWxmLmNvbnNvbGVMb2coXCJtYW5hZ2UgLSBkYXRhc2V0IG5vdCBsb2FkZWQuLi4gdHJ5aW5nIHRvIGxvYWRcIik7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEzNV0rKztcbiAgc2VsZi5sb2FkRGF0YVNldChkYXRhc2V0X2lkLCAoZnVuY3Rpb24gKGRhdGFzZXQpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTM2XSsrO1xuICBzZWxmLmNvbnNvbGVMb2coXCJtYW5hZ2UgLSBkYXRhc2V0IGxvYWRlZCBmcm9tIGxvY2FsIHN0b3JhZ2VcIik7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE0MV0rKztcbiAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCBudWxsLCBzZWxmLm5vdGlmaWNhdGlvbnMuTE9DQUxfVVBEQVRFX0FQUExJRUQsIFwibG9hZFwiKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTQ0XSsrO1xuICBkb01hbmFnZShkYXRhc2V0KTtcbn0pLCAoZnVuY3Rpb24gKGVycikge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxNDhdKys7XG4gIHNlbGYuY29uc29sZUxvZyhcIm1hbmFnZSAtIENyZWF0aW5nIG5ldyBkYXRhc2V0IGZvciBpZCBcIiArIGRhdGFzZXRfaWQpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxNDldKys7XG4gIHZhciBkYXRhc2V0ID0ge307XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE1MF0rKztcbiAgZGF0YXNldC5kYXRhID0ge307XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE1MV0rKztcbiAgZGF0YXNldC5wZW5kaW5nID0ge307XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE1Ml0rKztcbiAgc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXSA9IGRhdGFzZXQ7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE1M10rKztcbiAgZG9NYW5hZ2UoZGF0YXNldCk7XG59KSk7XG59KSk7XG59KSwgc2V0T3B0aW9uczogKGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE2MF0rKztcbiAgaWYgKCEgc2VsZi5jb25maWcpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxNjFdKys7XG4gICAgc2VsZi5jb25maWcgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNlbGYuZGVmYXVsdHMpKTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxNjRdKys7XG4gIHZhciBkYXRhc2V0Q29uZmlnID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzZWxmLmNvbmZpZykpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxNjVdKys7XG4gIHZhciBvcHRpb25zSW4gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTY2XSsrO1xuICBmb3IgKHZhciBrIGluIG9wdGlvbnNJbikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE2N10rKztcbiAgICBkYXRhc2V0Q29uZmlnW2tdID0gb3B0aW9uc0luW2tdO1xufVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxNzBdKys7XG4gIHJldHVybiBkYXRhc2V0Q29uZmlnO1xufSksIGxpc3Q6IChmdW5jdGlvbiAoZGF0YXNldF9pZCwgc3VjY2VzcywgZmFpbHVyZSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxNzRdKys7XG4gIHNlbGYuZ2V0RGF0YVNldChkYXRhc2V0X2lkLCAoZnVuY3Rpb24gKGRhdGFzZXQpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTc1XSsrO1xuICBpZiAoZGF0YXNldCAmJiBkYXRhc2V0LmRhdGEpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxNzddKys7XG4gICAgdmFyIHJlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YXNldC5kYXRhKSk7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTc4XSsrO1xuICAgIHN1Y2Nlc3MocmVzKTtcbiAgfVxuICBlbHNlIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxODBdKys7XG4gICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE4MF0rKztcbiAgICAgIGZhaWx1cmUoXCJub19kYXRhXCIpO1xuICAgIH1cbiAgfVxufSksIChmdW5jdGlvbiAoY29kZSwgbXNnKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE4M10rKztcbiAgaWYgKGZhaWx1cmUpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxODNdKys7XG4gICAgZmFpbHVyZShjb2RlLCBtc2cpO1xuICB9XG59KSk7XG59KSwgY3JlYXRlOiAoZnVuY3Rpb24gKGRhdGFzZXRfaWQsIGRhdGEsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTg4XSsrO1xuICBzZWxmLmFkZFBlbmRpbmdPYmooZGF0YXNldF9pZCwgbnVsbCwgZGF0YSwgXCJjcmVhdGVcIiwgc3VjY2VzcywgZmFpbHVyZSk7XG59KSwgcmVhZDogKGZ1bmN0aW9uIChkYXRhc2V0X2lkLCB1aWQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTkyXSsrO1xuICBzZWxmLmdldERhdGFTZXQoZGF0YXNldF9pZCwgKGZ1bmN0aW9uIChkYXRhc2V0KSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE5M10rKztcbiAgdmFyIHJlYyA9IGRhdGFzZXQuZGF0YVt1aWRdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxOTRdKys7XG4gIGlmICghIHJlYykge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE5NV0rKztcbiAgICBmYWlsdXJlKFwidW5rbm93bl91aWRcIik7XG4gIH1cbiAgZWxzZSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTk4XSsrO1xuICAgIHZhciByZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlYykpO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzE5OV0rKztcbiAgICBzdWNjZXNzKHJlcyk7XG4gIH1cbn0pLCAoZnVuY3Rpb24gKGNvZGUsIG1zZykge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyMDJdKys7XG4gIGlmIChmYWlsdXJlKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjAyXSsrO1xuICAgIGZhaWx1cmUoY29kZSwgbXNnKTtcbiAgfVxufSkpO1xufSksIHVwZGF0ZTogKGZ1bmN0aW9uIChkYXRhc2V0X2lkLCB1aWQsIGRhdGEsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjA3XSsrO1xuICBzZWxmLmFkZFBlbmRpbmdPYmooZGF0YXNldF9pZCwgdWlkLCBkYXRhLCBcInVwZGF0ZVwiLCBzdWNjZXNzLCBmYWlsdXJlKTtcbn0pLCBcImRlbGV0ZVwiOiAoZnVuY3Rpb24gKGRhdGFzZXRfaWQsIHVpZCwgc3VjY2VzcywgZmFpbHVyZSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyMTFdKys7XG4gIHNlbGYuYWRkUGVuZGluZ09iaihkYXRhc2V0X2lkLCB1aWQsIG51bGwsIFwiZGVsZXRlXCIsIHN1Y2Nlc3MsIGZhaWx1cmUpO1xufSksIGdldFBlbmRpbmc6IChmdW5jdGlvbiAoZGF0YXNldF9pZCwgY2IpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjE1XSsrO1xuICBzZWxmLmdldERhdGFTZXQoZGF0YXNldF9pZCwgKGZ1bmN0aW9uIChkYXRhc2V0KSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzIxNl0rKztcbiAgdmFyIHJlcztcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjE3XSsrO1xuICBpZiAoZGF0YXNldCkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzIxOF0rKztcbiAgICByZXMgPSBkYXRhc2V0LnBlbmRpbmc7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjIwXSsrO1xuICBjYihyZXMpO1xufSksIChmdW5jdGlvbiAoZXJyLCBkYXRhdHNldF9pZCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyMjJdKys7XG4gIHNlbGYuY29uc29sZUxvZyhlcnIpO1xufSkpO1xufSksIGNsZWFyUGVuZGluZzogKGZ1bmN0aW9uIChkYXRhc2V0X2lkLCBjYikge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyMjddKys7XG4gIHNlbGYuZ2V0RGF0YVNldChkYXRhc2V0X2lkLCAoZnVuY3Rpb24gKGRhdGFzZXQpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjI4XSsrO1xuICBkYXRhc2V0LnBlbmRpbmcgPSB7fTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjI5XSsrO1xuICBzZWxmLnNhdmVEYXRhU2V0KGRhdGFzZXRfaWQsIGNiKTtcbn0pKTtcbn0pLCBsaXN0Q29sbGlzaW9uczogKGZ1bmN0aW9uIChkYXRhc2V0X2lkLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzIzNF0rKztcbiAgc2VsZi5nZXREYXRhU2V0KGRhdGFzZXRfaWQsIChmdW5jdGlvbiAoZGF0YXNldCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyMzVdKys7XG4gIHNlbGYuZG9DbG91ZENhbGwoe1wiZGF0YXNldF9pZFwiOiBkYXRhc2V0X2lkLCBcInJlcVwiOiB7XCJmblwiOiBcImxpc3RDb2xsaXNpb25zXCIsIFwibWV0YV9kYXRhXCI6IGRhdGFzZXQubWV0YV9kYXRhfX0sIHN1Y2Nlc3MsIGZhaWx1cmUpO1xufSksIGZhaWx1cmUpO1xufSksIHJlbW92ZUNvbGxpc2lvbjogKGZ1bmN0aW9uIChkYXRhc2V0X2lkLCBjb2xpc3Npb25IYXNoLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzI0Nl0rKztcbiAgc2VsZi5nZXREYXRhU2V0KGRhdGFzZXRfaWQsIChmdW5jdGlvbiAoZGF0YXNldCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyNDddKys7XG4gIHNlbGYuZG9DbG91ZENhbGwoe1wiZGF0YXNldF9pZFwiOiBkYXRhc2V0X2lkLCBcInJlcVwiOiB7XCJmblwiOiBcInJlbW92ZUNvbGxpc2lvblwiLCBcImhhc2hcIjogY29saXNzaW9uSGFzaCwgbWV0YV9kYXRhOiBkYXRhc2V0Lm1ldGFfZGF0YX19LCBzdWNjZXNzLCBmYWlsdXJlKTtcbn0pKTtcbn0pLCBpc09ubGluZTogKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyNjFdKys7XG4gIHZhciBvbmxpbmUgPSB0cnVlO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyNjRdKys7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yLm9uTGluZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzI2NV0rKztcbiAgICBvbmxpbmUgPSBuYXZpZ2F0b3Iub25MaW5lO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzI2OV0rKztcbiAgaWYgKG9ubGluZSkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzI3MV0rKztcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvci5uZXR3b3JrICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBuYXZpZ2F0b3IubmV0d29yay5jb25uZWN0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyNzJdKys7XG4gICAgICB2YXIgbmV0d29ya1R5cGUgPSBuYXZpZ2F0b3IubmV0d29yay5jb25uZWN0aW9uLnR5cGU7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyNzNdKys7XG4gICAgICBpZiAobmV0d29ya1R5cGUgPT09IFwibm9uZVwiIHx8IG5ldHdvcmtUeXBlID09PSBudWxsKSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzI3NF0rKztcbiAgICAgICAgb25saW5lID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzI3OV0rKztcbiAgcmV0dXJuIGNhbGxiYWNrKG9ubGluZSk7XG59KSwgZG9Ob3RpZnk6IChmdW5jdGlvbiAoZGF0YXNldF9pZCwgdWlkLCBjb2RlLCBtZXNzYWdlKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzI4NF0rKztcbiAgaWYgKHNlbGYubm90aWZ5X2NhbGxiYWNrKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMjg1XSsrO1xuICAgIGlmIChzZWxmLmNvbmZpZ1tcIm5vdGlmeV9cIiArIGNvZGVdKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyODZdKys7XG4gICAgICB2YXIgbm90aWZpY2F0aW9uID0ge1wiZGF0YXNldF9pZFwiOiBkYXRhc2V0X2lkLCBcInVpZFwiOiB1aWQsIFwiY29kZVwiOiBjb2RlLCBcIm1lc3NhZ2VcIjogbWVzc2FnZX07XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsyOTNdKys7XG4gICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzI5NF0rKztcbiAgc2VsZi5ub3RpZnlfY2FsbGJhY2sobm90aWZpY2F0aW9uKTtcbn0pLCAwKTtcbiAgICB9XG4gIH1cbn0pLCBnZXREYXRhU2V0OiAoZnVuY3Rpb24gKGRhdGFzZXRfaWQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzAxXSsrO1xuICB2YXIgZGF0YXNldCA9IHNlbGYuZGF0YXNldHNbZGF0YXNldF9pZF07XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzMwM10rKztcbiAgaWYgKGRhdGFzZXQpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszMDRdKys7XG4gICAgc3VjY2VzcyhkYXRhc2V0KTtcbiAgfVxuICBlbHNlIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszMDZdKys7XG4gICAgZmFpbHVyZShcInVua25vd25fZGF0YXNldCBcIiArIGRhdGFzZXRfaWQsIGRhdGFzZXRfaWQpO1xuICB9XG59KSwgZ2V0UXVlcnlQYXJhbXM6IChmdW5jdGlvbiAoZGF0YXNldF9pZCwgc3VjY2VzcywgZmFpbHVyZSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszMTFdKys7XG4gIHZhciBkYXRhc2V0ID0gc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzEzXSsrO1xuICBpZiAoZGF0YXNldCkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzMxNF0rKztcbiAgICBzdWNjZXNzKGRhdGFzZXQucXVlcnlfcGFyYW1zKTtcbiAgfVxuICBlbHNlIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszMTZdKys7XG4gICAgZmFpbHVyZShcInVua25vd25fZGF0YXNldCBcIiArIGRhdGFzZXRfaWQsIGRhdGFzZXRfaWQpO1xuICB9XG59KSwgc2V0UXVlcnlQYXJhbXM6IChmdW5jdGlvbiAoZGF0YXNldF9pZCwgcXVlcnlQYXJhbXMsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzIxXSsrO1xuICB2YXIgZGF0YXNldCA9IHNlbGYuZGF0YXNldHNbZGF0YXNldF9pZF07XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzMyM10rKztcbiAgaWYgKGRhdGFzZXQpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszMjRdKys7XG4gICAgZGF0YXNldC5xdWVyeV9wYXJhbXMgPSBxdWVyeVBhcmFtcztcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszMjVdKys7XG4gICAgc2VsZi5zYXZlRGF0YVNldChkYXRhc2V0X2lkKTtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszMjZdKys7XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzMyN10rKztcbiAgICAgIHN1Y2Nlc3MoZGF0YXNldC5xdWVyeV9wYXJhbXMpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszMzBdKys7XG4gICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzMzMV0rKztcbiAgICAgIGZhaWx1cmUoXCJ1bmtub3duX2RhdGFzZXQgXCIgKyBkYXRhc2V0X2lkLCBkYXRhc2V0X2lkKTtcbiAgICB9XG4gIH1cbn0pLCBnZXRNZXRhRGF0YTogKGZ1bmN0aW9uIChkYXRhc2V0X2lkLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzMzN10rKztcbiAgdmFyIGRhdGFzZXQgPSBzZWxmLmRhdGFzZXRzW2RhdGFzZXRfaWRdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszMzldKys7XG4gIGlmIChkYXRhc2V0KSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzQwXSsrO1xuICAgIHN1Y2Nlc3MoZGF0YXNldC5tZXRhX2RhdGEpO1xuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM0Ml0rKztcbiAgICBmYWlsdXJlKFwidW5rbm93bl9kYXRhc2V0IFwiICsgZGF0YXNldF9pZCwgZGF0YXNldF9pZCk7XG4gIH1cbn0pLCBzZXRNZXRhRGF0YTogKGZ1bmN0aW9uIChkYXRhc2V0X2lkLCBtZXRhRGF0YSwgc3VjY2VzcywgZmFpbHVyZSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszNDddKys7XG4gIHZhciBkYXRhc2V0ID0gc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzQ5XSsrO1xuICBpZiAoZGF0YXNldCkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM1MF0rKztcbiAgICBkYXRhc2V0Lm1ldGFfZGF0YSA9IG1ldGFEYXRhO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM1MV0rKztcbiAgICBzZWxmLnNhdmVEYXRhU2V0KGRhdGFzZXRfaWQpO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM1Ml0rKztcbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzUzXSsrO1xuICAgICAgc3VjY2VzcyhkYXRhc2V0Lm1ldGFfZGF0YSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM1Nl0rKztcbiAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzU3XSsrO1xuICAgICAgZmFpbHVyZShcInVua25vd25fZGF0YXNldCBcIiArIGRhdGFzZXRfaWQsIGRhdGFzZXRfaWQpO1xuICAgIH1cbiAgfVxufSksIGdldENvbmZpZzogKGZ1bmN0aW9uIChkYXRhc2V0X2lkLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM2M10rKztcbiAgdmFyIGRhdGFzZXQgPSBzZWxmLmRhdGFzZXRzW2RhdGFzZXRfaWRdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszNjVdKys7XG4gIGlmIChkYXRhc2V0KSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzY2XSsrO1xuICAgIHN1Y2Nlc3MoZGF0YXNldC5jb25maWcpO1xuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM2OF0rKztcbiAgICBmYWlsdXJlKFwidW5rbm93bl9kYXRhc2V0IFwiICsgZGF0YXNldF9pZCwgZGF0YXNldF9pZCk7XG4gIH1cbn0pLCBzZXRDb25maWc6IChmdW5jdGlvbiAoZGF0YXNldF9pZCwgY29uZmlnLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM3M10rKztcbiAgdmFyIGRhdGFzZXQgPSBzZWxmLmRhdGFzZXRzW2RhdGFzZXRfaWRdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszNzVdKys7XG4gIGlmIChkYXRhc2V0KSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzc2XSsrO1xuICAgIHZhciBmdWxsQ29uZmlnID0gc2VsZi5zZXRPcHRpb25zKGNvbmZpZyk7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzc3XSsrO1xuICAgIGRhdGFzZXQuY29uZmlnID0gZnVsbENvbmZpZztcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszNzhdKys7XG4gICAgc2VsZi5zYXZlRGF0YVNldChkYXRhc2V0X2lkKTtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszNzldKys7XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM4MF0rKztcbiAgICAgIHN1Y2Nlc3MoZGF0YXNldC5jb25maWcpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszODNdKys7XG4gICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM4NF0rKztcbiAgICAgIGZhaWx1cmUoXCJ1bmtub3duX2RhdGFzZXQgXCIgKyBkYXRhc2V0X2lkLCBkYXRhc2V0X2lkKTtcbiAgICB9XG4gIH1cbn0pLCBzdG9wU3luYzogKGZ1bmN0aW9uIChkYXRhc2V0X2lkLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM5MF0rKztcbiAgc2VsZi5zZXRDb25maWcoZGF0YXNldF9pZCwge1wic3luY19hY3RpdmVcIjogZmFsc2V9LCAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVszOTFdKys7XG4gIGlmIChzdWNjZXNzKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMzkyXSsrO1xuICAgIHN1Y2Nlc3MoKTtcbiAgfVxufSksIGZhaWx1cmUpO1xufSksIHN0YXJ0U3luYzogKGZ1bmN0aW9uIChkYXRhc2V0X2lkLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM5OF0rKztcbiAgc2VsZi5zZXRDb25maWcoZGF0YXNldF9pZCwge1wic3luY19hY3RpdmVcIjogdHJ1ZX0sIChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzM5OV0rKztcbiAgaWYgKHN1Y2Nlc3MpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0MDBdKys7XG4gICAgc3VjY2VzcygpO1xuICB9XG59KSwgZmFpbHVyZSk7XG59KSwgZG9TeW5jOiAoZnVuY3Rpb24gKGRhdGFzZXRfaWQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDA2XSsrO1xuICB2YXIgZGF0YXNldCA9IHNlbGYuZGF0YXNldHNbZGF0YXNldF9pZF07XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQwOF0rKztcbiAgaWYgKGRhdGFzZXQpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0MDldKys7XG4gICAgZGF0YXNldC5zeW5jUGVuZGluZyA9IHRydWU7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDEwXSsrO1xuICAgIHNlbGYuc2F2ZURhdGFTZXQoZGF0YXNldF9pZCk7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDExXSsrO1xuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0MTJdKys7XG4gICAgICBzdWNjZXNzKCk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQxNV0rKztcbiAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDE2XSsrO1xuICAgICAgZmFpbHVyZShcInVua25vd25fZGF0YXNldCBcIiArIGRhdGFzZXRfaWQsIGRhdGFzZXRfaWQpO1xuICAgIH1cbiAgfVxufSksIGZvcmNlU3luYzogKGZ1bmN0aW9uIChkYXRhc2V0X2lkLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQyMl0rKztcbiAgdmFyIGRhdGFzZXQgPSBzZWxmLmRhdGFzZXRzW2RhdGFzZXRfaWRdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0MjRdKys7XG4gIGlmIChkYXRhc2V0KSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDI1XSsrO1xuICAgIGRhdGFzZXQuc3luY0ZvcmNlZCA9IHRydWU7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDI2XSsrO1xuICAgIHNlbGYuc2F2ZURhdGFTZXQoZGF0YXNldF9pZCk7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDI3XSsrO1xuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0MjhdKys7XG4gICAgICBzdWNjZXNzKCk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQzMV0rKztcbiAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDMyXSsrO1xuICAgICAgZmFpbHVyZShcInVua25vd25fZGF0YXNldCBcIiArIGRhdGFzZXRfaWQsIGRhdGFzZXRfaWQpO1xuICAgIH1cbiAgfVxufSksIHNvcnRPYmplY3Q6IChmdW5jdGlvbiAob2JqZWN0KSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQzOF0rKztcbiAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIgfHwgb2JqZWN0ID09PSBudWxsKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDM5XSsrO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDQyXSsrO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ0NF0rKztcbiAgT2JqZWN0LmtleXMob2JqZWN0KS5zb3J0KCkuZm9yRWFjaCgoZnVuY3Rpb24gKGtleSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0NDVdKys7XG4gIHJlc3VsdC5wdXNoKHtrZXk6IGtleSwgdmFsdWU6IHNlbGYuc29ydE9iamVjdChvYmplY3Rba2V5XSl9KTtcbn0pKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDUxXSsrO1xuICByZXR1cm4gcmVzdWx0O1xufSksIHNvcnRlZFN0cmluZ2lmeTogKGZ1bmN0aW9uIChvYmopIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDU2XSsrO1xuICB2YXIgc3RyID0gXCJcIjtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDU4XSsrO1xuICB0cnkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ1OV0rKztcbiAgICBzdHIgPSBKU09OLnN0cmluZ2lmeShzZWxmLnNvcnRPYmplY3Qob2JqKSk7XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0NjFdKys7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIHN0cmluZ2lmeWluZyBzb3J0ZWQgb2JqZWN0OlwiICsgZSk7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDY0XSsrO1xuICByZXR1cm4gc3RyO1xufSksIGdlbmVyYXRlSGFzaDogKGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDY4XSsrO1xuICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEoc2VsZi5zb3J0ZWRTdHJpbmdpZnkob2JqZWN0KSk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ2OV0rKztcbiAgcmV0dXJuIGhhc2gudG9TdHJpbmcoKTtcbn0pLCBhZGRQZW5kaW5nT2JqOiAoZnVuY3Rpb24gKGRhdGFzZXRfaWQsIHVpZCwgZGF0YSwgYWN0aW9uLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ3M10rKztcbiAgc2VsZi5pc09ubGluZSgoZnVuY3Rpb24gKG9ubGluZSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0NzRdKys7XG4gIGlmICghIG9ubGluZSkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ3NV0rKztcbiAgICBzZWxmLmRvTm90aWZ5KGRhdGFzZXRfaWQsIHVpZCwgc2VsZi5ub3RpZmljYXRpb25zLk9GRkxJTkVfVVBEQVRFLCBhY3Rpb24pO1xuICB9XG59KSk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ3OV0rKztcbiAgZnVuY3Rpb24gc3RvcmVQZW5kaW5nT2JqZWN0KG9iaikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ4MF0rKztcbiAgICBvYmouaGFzaCA9IHNlbGYuZ2VuZXJhdGVIYXNoKG9iaik7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDgyXSsrO1xuICAgIHNlbGYuZ2V0RGF0YVNldChkYXRhc2V0X2lkLCAoZnVuY3Rpb24gKGRhdGFzZXQpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDg0XSsrO1xuICBkYXRhc2V0LnBlbmRpbmdbb2JqLmhhc2hdID0gb2JqO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0ODZdKys7XG4gIHNlbGYudXBkYXRlRGF0YXNldEZyb21Mb2NhbChkYXRhc2V0LCBvYmopO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0ODhdKys7XG4gIGlmIChzZWxmLmNvbmZpZy5hdXRvX3N5bmNfbG9jYWxfdXBkYXRlcykge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ4OV0rKztcbiAgICBkYXRhc2V0LnN5bmNQZW5kaW5nID0gdHJ1ZTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs0OTFdKys7XG4gIHNlbGYuc2F2ZURhdGFTZXQoZGF0YXNldF9pZCk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ5Ml0rKztcbiAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCB1aWQsIHNlbGYubm90aWZpY2F0aW9ucy5MT0NBTF9VUERBVEVfQVBQTElFRCwgYWN0aW9uKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDk0XSsrO1xuICBzdWNjZXNzKG9iaik7XG59KSwgKGZ1bmN0aW9uIChjb2RlLCBtc2cpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNDk2XSsrO1xuICBpZiAoZmFpbHVyZSkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzQ5Nl0rKztcbiAgICBmYWlsdXJlKGNvZGUsIG1zZyk7XG4gIH1cbn0pKTtcbn1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTAwXSsrO1xuICB2YXIgcGVuZGluZ09iaiA9IHt9O1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1MDFdKys7XG4gIHBlbmRpbmdPYmouaW5GbGlnaHQgPSBmYWxzZTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTAyXSsrO1xuICBwZW5kaW5nT2JqLmFjdGlvbiA9IGFjdGlvbjtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTAzXSsrO1xuICBwZW5kaW5nT2JqLnBvc3QgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTA0XSsrO1xuICBwZW5kaW5nT2JqLnBvc3RIYXNoID0gc2VsZi5nZW5lcmF0ZUhhc2gocGVuZGluZ09iai5wb3N0KTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTA1XSsrO1xuICBwZW5kaW5nT2JqLnRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1MDZdKys7XG4gIGlmIChcImNyZWF0ZVwiID09PSBhY3Rpb24pIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1MDddKys7XG4gICAgcGVuZGluZ09iai51aWQgPSBwZW5kaW5nT2JqLnBvc3RIYXNoO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUwOF0rKztcbiAgICBzdG9yZVBlbmRpbmdPYmplY3QocGVuZGluZ09iaik7XG4gIH1cbiAgZWxzZSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTEwXSsrO1xuICAgIHNlbGYucmVhZChkYXRhc2V0X2lkLCB1aWQsIChmdW5jdGlvbiAocmVjKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUxMV0rKztcbiAgcGVuZGluZ09iai51aWQgPSB1aWQ7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUxMl0rKztcbiAgcGVuZGluZ09iai5wcmUgPSByZWMuZGF0YTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTEzXSsrO1xuICBwZW5kaW5nT2JqLnByZUhhc2ggPSBzZWxmLmdlbmVyYXRlSGFzaChyZWMuZGF0YSk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUxNF0rKztcbiAgc3RvcmVQZW5kaW5nT2JqZWN0KHBlbmRpbmdPYmopO1xufSksIChmdW5jdGlvbiAoY29kZSwgbXNnKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUxNl0rKztcbiAgZmFpbHVyZShjb2RlLCBtc2cpO1xufSkpO1xuICB9XG59KSwgc3luY0xvb3A6IChmdW5jdGlvbiAoZGF0YXNldF9pZCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1MjJdKys7XG4gIHNlbGYuZ2V0RGF0YVNldChkYXRhc2V0X2lkLCAoZnVuY3Rpb24gKGRhdGFTZXQpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTI1XSsrO1xuICBkYXRhU2V0LnN5bmNQZW5kaW5nID0gZmFsc2U7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUyNl0rKztcbiAgZGF0YVNldC5zeW5jUnVubmluZyA9IHRydWU7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUyN10rKztcbiAgZGF0YVNldC5zeW5jTG9vcFN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUyOF0rKztcbiAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCBudWxsLCBzZWxmLm5vdGlmaWNhdGlvbnMuU1lOQ19TVEFSVEVELCBudWxsKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTMwXSsrO1xuICBzZWxmLmlzT25saW5lKChmdW5jdGlvbiAob25saW5lKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUzMV0rKztcbiAgaWYgKCEgb25saW5lKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTMyXSsrO1xuICAgIHNlbGYuc3luY0NvbXBsZXRlKGRhdGFzZXRfaWQsIFwib2ZmbGluZVwiLCBzZWxmLm5vdGlmaWNhdGlvbnMuU1lOQ19GQUlMRUQpO1xuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUzNF0rKztcbiAgICBzZWxmLmNoZWNrSGFzQ3VzdG9tU3luYyhkYXRhc2V0X2lkLCAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1MzZdKys7XG4gIHZhciBzeW5jTG9vcFBhcmFtcyA9IHt9O1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1MzddKys7XG4gIHN5bmNMb29wUGFyYW1zLmZuID0gXCJzeW5jXCI7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUzOF0rKztcbiAgc3luY0xvb3BQYXJhbXMuZGF0YXNldF9pZCA9IGRhdGFzZXRfaWQ7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzUzOV0rKztcbiAgc3luY0xvb3BQYXJhbXMucXVlcnlfcGFyYW1zID0gZGF0YVNldC5xdWVyeV9wYXJhbXM7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU0MF0rKztcbiAgc3luY0xvb3BQYXJhbXMuY29uZmlnID0gZGF0YVNldC5jb25maWc7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU0MV0rKztcbiAgc3luY0xvb3BQYXJhbXMubWV0YV9kYXRhID0gZGF0YVNldC5tZXRhX2RhdGE7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU0M10rKztcbiAgc3luY0xvb3BQYXJhbXMuZGF0YXNldF9oYXNoID0gZGF0YVNldC5oYXNoO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NDRdKys7XG4gIHN5bmNMb29wUGFyYW1zLmFja25vd2xlZGdlbWVudHMgPSBkYXRhU2V0LmFja25vd2xlZGdlbWVudHMgfHwgW107XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU0Nl0rKztcbiAgdmFyIHBlbmRpbmcgPSBkYXRhU2V0LnBlbmRpbmc7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU0N10rKztcbiAgdmFyIHBlbmRpbmdBcnJheSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NDhdKys7XG4gIGZvciAodmFyIGkgaW4gcGVuZGluZykge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU1Ml0rKztcbiAgICBpZiAoISBwZW5kaW5nW2ldLmluRmxpZ2h0ICYmICEgcGVuZGluZ1tpXS5jcmFzaGVkICYmICEgcGVuZGluZ1tpXS5kZWxheWVkKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NTNdKys7XG4gICAgICBwZW5kaW5nW2ldLmluRmxpZ2h0ID0gdHJ1ZTtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU1NF0rKztcbiAgICAgIHBlbmRpbmdbaV0uaW5GbGlnaHREYXRlID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NTVdKys7XG4gICAgICBwZW5kaW5nQXJyYXkucHVzaChwZW5kaW5nW2ldKTtcbiAgICB9XG59XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU1OF0rKztcbiAgc3luY0xvb3BQYXJhbXMucGVuZGluZyA9IHBlbmRpbmdBcnJheTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTYwXSsrO1xuICBpZiAocGVuZGluZ0FycmF5Lmxlbmd0aCA+IDApIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NjFdKys7XG4gICAgc2VsZi5jb25zb2xlTG9nKFwiU3RhcnRpbmcgc3luYyBsb29wIC0gZ2xvYmFsIGhhc2ggPSBcIiArIGRhdGFTZXQuaGFzaCArIFwiIDo6IHBhcmFtcyA9IFwiICsgSlNPTi5zdHJpbmdpZnkoc3luY0xvb3BQYXJhbXMsIG51bGwsIDIpKTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NjNdKys7XG4gIHRyeSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTY0XSsrO1xuICAgIHNlbGYuZG9DbG91ZENhbGwoe1wiZGF0YXNldF9pZFwiOiBkYXRhc2V0X2lkLCBcInJlcVwiOiBzeW5jTG9vcFBhcmFtc30sIChmdW5jdGlvbiAocmVzKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU2OF0rKztcbiAgdmFyIHJlYztcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTcwXSsrO1xuICBmdW5jdGlvbiBwcm9jZXNzVXBkYXRlcyh1cGRhdGVzLCBub3RpZmljYXRpb24sIGFja25vd2xlZGdlbWVudHMpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1NzFdKys7XG4gICAgaWYgKHVwZGF0ZXMpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU3Ml0rKztcbiAgICAgIGZvciAodmFyIHVwIGluIHVwZGF0ZXMpIHtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTczXSsrO1xuICAgICAgICByZWMgPSB1cGRhdGVzW3VwXTtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTc0XSsrO1xuICAgICAgICBhY2tub3dsZWRnZW1lbnRzLnB1c2gocmVjKTtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTc1XSsrO1xuICAgICAgICBpZiAoZGF0YVNldC5wZW5kaW5nW3VwXSAmJiBkYXRhU2V0LnBlbmRpbmdbdXBdLmluRmxpZ2h0ICYmICEgZGF0YVNldC5wZW5kaW5nW3VwXS5jcmFzaGVkKSB7XG4gICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTc2XSsrO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhU2V0LnBlbmRpbmdbdXBdO1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzU3N10rKztcbiAgICAgICAgICBzZWxmLmRvTm90aWZ5KGRhdGFzZXRfaWQsIHJlYy51aWQsIG5vdGlmaWNhdGlvbiwgcmVjKTtcbiAgICAgICAgfVxufVxuICAgIH1cbn1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTg0XSsrO1xuICBzZWxmLnVwZGF0ZVBlbmRpbmdGcm9tTmV3RGF0YShkYXRhc2V0X2lkLCBkYXRhU2V0LCByZXMpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1ODddKys7XG4gIHNlbGYudXBkYXRlQ3Jhc2hlZEluRmxpZ2h0RnJvbU5ld0RhdGEoZGF0YXNldF9pZCwgZGF0YVNldCwgcmVzKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNTkwXSsrO1xuICBzZWxmLnVwZGF0ZURlbGF5ZWRGcm9tTmV3RGF0YShkYXRhc2V0X2lkLCBkYXRhU2V0LCByZXMpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1OTNdKys7XG4gIHNlbGYudXBkYXRlTmV3RGF0YUZyb21JbkZsaWdodChkYXRhc2V0X2lkLCBkYXRhU2V0LCByZXMpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs1OTZdKys7XG4gIHNlbGYudXBkYXRlTmV3RGF0YUZyb21QZW5kaW5nKGRhdGFzZXRfaWQsIGRhdGFTZXQsIHJlcyk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYwMF0rKztcbiAgaWYgKHJlcy5yZWNvcmRzKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjAyXSsrO1xuICAgIGRhdGFTZXQuZGF0YSA9IHJlcy5yZWNvcmRzO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYwM10rKztcbiAgICBkYXRhU2V0Lmhhc2ggPSByZXMuaGFzaDtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MDVdKys7XG4gICAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCByZXMuaGFzaCwgc2VsZi5ub3RpZmljYXRpb25zLkRFTFRBX1JFQ0VJVkVELCBcImZ1bGwgZGF0YXNldFwiKTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MDhdKys7XG4gIGlmIChyZXMudXBkYXRlcykge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYwOV0rKztcbiAgICB2YXIgYWNrbm93bGVkZ2VtZW50cyA9IFtdO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYxMF0rKztcbiAgICBwcm9jZXNzVXBkYXRlcyhyZXMudXBkYXRlcy5hcHBsaWVkLCBzZWxmLm5vdGlmaWNhdGlvbnMuUkVNT1RFX1VQREFURV9BUFBMSUVELCBhY2tub3dsZWRnZW1lbnRzKTtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MTFdKys7XG4gICAgcHJvY2Vzc1VwZGF0ZXMocmVzLnVwZGF0ZXMuZmFpbGVkLCBzZWxmLm5vdGlmaWNhdGlvbnMuUkVNT1RFX1VQREFURV9GQUlMRUQsIGFja25vd2xlZGdlbWVudHMpO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYxMl0rKztcbiAgICBwcm9jZXNzVXBkYXRlcyhyZXMudXBkYXRlcy5jb2xsaXNpb25zLCBzZWxmLm5vdGlmaWNhdGlvbnMuQ09MTElTSU9OX0RFVEVDVEVELCBhY2tub3dsZWRnZW1lbnRzKTtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MTNdKys7XG4gICAgZGF0YVNldC5hY2tub3dsZWRnZW1lbnRzID0gYWNrbm93bGVkZ2VtZW50cztcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MTZdKys7XG4gIGlmICghIHJlcy5yZWNvcmRzICYmIHJlcy5oYXNoICYmIHJlcy5oYXNoICE9PSBkYXRhU2V0Lmhhc2gpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MTddKys7XG4gICAgc2VsZi5jb25zb2xlTG9nKFwiTG9jYWwgZGF0YXNldCBzdGFsZSAtIHN5bmNpbmcgcmVjb3JkcyA6OiBsb2NhbCBoYXNoPSBcIiArIGRhdGFTZXQuaGFzaCArIFwiIC0gcmVtb3RlSGFzaD1cIiArIHJlcy5oYXNoKTtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MTldKys7XG4gICAgc2VsZi5zeW5jUmVjb3JkcyhkYXRhc2V0X2lkKTtcbiAgfVxuICBlbHNlIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MjFdKys7XG4gICAgc2VsZi5jb25zb2xlTG9nKFwiTG9jYWwgZGF0YXNldCB1cCB0byBkYXRlXCIpO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYyMl0rKztcbiAgICBzZWxmLnN5bmNDb21wbGV0ZShkYXRhc2V0X2lkLCBcIm9ubGluZVwiLCBzZWxmLm5vdGlmaWNhdGlvbnMuU1lOQ19DT01QTEVURSk7XG4gIH1cbn0pLCAoZnVuY3Rpb24gKG1zZywgZXJyKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYyOF0rKztcbiAgc2VsZi5tYXJrSW5GbGlnaHRBc0NyYXNoZWQoZGF0YVNldCk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYyOV0rKztcbiAgc2VsZi5jb25zb2xlTG9nKFwic3luY0xvb3AgZmFpbGVkIDogbXNnPVwiICsgbXNnICsgXCIgOjogZXJyID0gXCIgKyBlcnIpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2MzBdKys7XG4gIHNlbGYuc3luY0NvbXBsZXRlKGRhdGFzZXRfaWQsIG1zZywgc2VsZi5ub3RpZmljYXRpb25zLlNZTkNfRkFJTEVEKTtcbn0pKTtcbiAgfVxuICBjYXRjaCAoZSkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYzNF0rKztcbiAgICBzZWxmLmNvbnNvbGVMb2coXCJFcnJvciBwZXJmb3JtaW5nIHN5bmMgLSBcIiArIGUpO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzYzNV0rKztcbiAgICBzZWxmLnN5bmNDb21wbGV0ZShkYXRhc2V0X2lkLCBlLCBzZWxmLm5vdGlmaWNhdGlvbnMuU1lOQ19GQUlMRUQpO1xuICB9XG59KSk7XG4gIH1cbn0pKTtcbn0pKTtcbn0pLCBzeW5jUmVjb3JkczogKGZ1bmN0aW9uIChkYXRhc2V0X2lkKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY0NV0rKztcbiAgc2VsZi5nZXREYXRhU2V0KGRhdGFzZXRfaWQsIChmdW5jdGlvbiAoZGF0YVNldCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2NDddKys7XG4gIHZhciBsb2NhbERhdGFTZXQgPSBkYXRhU2V0LmRhdGEgfHwge307XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY0OV0rKztcbiAgdmFyIGNsaWVudFJlY3MgPSB7fTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjUwXSsrO1xuICBmb3IgKHZhciBpIGluIGxvY2FsRGF0YVNldCkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY1MV0rKztcbiAgICB2YXIgdWlkID0gaTtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2NTJdKys7XG4gICAgdmFyIGhhc2ggPSBsb2NhbERhdGFTZXRbaV0uaGFzaDtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2NTNdKys7XG4gICAgY2xpZW50UmVjc1t1aWRdID0gaGFzaDtcbn1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjU2XSsrO1xuICB2YXIgc3luY1JlY1BhcmFtcyA9IHt9O1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2NThdKys7XG4gIHN5bmNSZWNQYXJhbXMuZm4gPSBcInN5bmNSZWNvcmRzXCI7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY1OV0rKztcbiAgc3luY1JlY1BhcmFtcy5kYXRhc2V0X2lkID0gZGF0YXNldF9pZDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjYwXSsrO1xuICBzeW5jUmVjUGFyYW1zLnF1ZXJ5X3BhcmFtcyA9IGRhdGFTZXQucXVlcnlfcGFyYW1zO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2NjFdKys7XG4gIHN5bmNSZWNQYXJhbXMuY2xpZW50UmVjcyA9IGNsaWVudFJlY3M7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY2M10rKztcbiAgc2VsZi5jb25zb2xlTG9nKFwic3luY1JlY1BhcmFtcyA6OiBcIiArIEpTT04uc3RyaW5naWZ5KHN5bmNSZWNQYXJhbXMpKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjY1XSsrO1xuICBzZWxmLmRvQ2xvdWRDYWxsKHtcImRhdGFzZXRfaWRcIjogZGF0YXNldF9pZCwgXCJyZXFcIjogc3luY1JlY1BhcmFtc30sIChmdW5jdGlvbiAocmVzKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY2OV0rKztcbiAgdmFyIGk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY3MV0rKztcbiAgaWYgKHJlcy5jcmVhdGUpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2NzJdKys7XG4gICAgZm9yIChpIGluIHJlcy5jcmVhdGUpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY3M10rKztcbiAgICAgIGxvY2FsRGF0YVNldFtpXSA9IHtcImhhc2hcIjogcmVzLmNyZWF0ZVtpXS5oYXNoLCBcImRhdGFcIjogcmVzLmNyZWF0ZVtpXS5kYXRhfTtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY3NF0rKztcbiAgICAgIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgaSwgc2VsZi5ub3RpZmljYXRpb25zLlJFQ09SRF9ERUxUQV9SRUNFSVZFRCwgXCJjcmVhdGVcIik7XG59XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjc3XSsrO1xuICBpZiAocmVzLnVwZGF0ZSkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY3OF0rKztcbiAgICBmb3IgKGkgaW4gcmVzLnVwZGF0ZSkge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjc5XSsrO1xuICAgICAgbG9jYWxEYXRhU2V0W2ldLmhhc2ggPSByZXMudXBkYXRlW2ldLmhhc2g7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2ODBdKys7XG4gICAgICBsb2NhbERhdGFTZXRbaV0uZGF0YSA9IHJlcy51cGRhdGVbaV0uZGF0YTtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY4MV0rKztcbiAgICAgIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgaSwgc2VsZi5ub3RpZmljYXRpb25zLlJFQ09SRF9ERUxUQV9SRUNFSVZFRCwgXCJ1cGRhdGVcIik7XG59XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjg0XSsrO1xuICBpZiAocmVzW1wiZGVsZXRlXCJdKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjg1XSsrO1xuICAgIGZvciAoaSBpbiByZXNbXCJkZWxldGVcIl0pIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY4Nl0rKztcbiAgICAgIGRlbGV0ZSBsb2NhbERhdGFTZXRbaV07XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs2ODddKys7XG4gICAgICBzZWxmLmRvTm90aWZ5KGRhdGFzZXRfaWQsIGksIHNlbGYubm90aWZpY2F0aW9ucy5SRUNPUkRfREVMVEFfUkVDRUlWRUQsIFwiZGVsZXRlXCIpO1xufVxuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY5MV0rKztcbiAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCByZXMuaGFzaCwgc2VsZi5ub3RpZmljYXRpb25zLkRFTFRBX1JFQ0VJVkVELCBcInBhcnRpYWwgZGF0YXNldFwiKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjkzXSsrO1xuICBkYXRhU2V0LmRhdGEgPSBsb2NhbERhdGFTZXQ7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY5NF0rKztcbiAgaWYgKHJlcy5oYXNoKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjk1XSsrO1xuICAgIGRhdGFTZXQuaGFzaCA9IHJlcy5oYXNoO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzY5N10rKztcbiAgc2VsZi5zeW5jQ29tcGxldGUoZGF0YXNldF9pZCwgXCJvbmxpbmVcIiwgc2VsZi5ub3RpZmljYXRpb25zLlNZTkNfQ09NUExFVEUpO1xufSksIChmdW5jdGlvbiAobXNnLCBlcnIpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNjk5XSsrO1xuICBzZWxmLmNvbnNvbGVMb2coXCJzeW5jUmVjb3JkcyBmYWlsZWQgOiBtc2c9XCIgKyBtc2cgKyBcIiA6OiBlcnI9XCIgKyBlcnIpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MDBdKys7XG4gIHNlbGYuc3luY0NvbXBsZXRlKGRhdGFzZXRfaWQsIG1zZywgc2VsZi5ub3RpZmljYXRpb25zLlNZTkNfRkFJTEVEKTtcbn0pKTtcbn0pKTtcbn0pLCBzeW5jQ29tcGxldGU6IChmdW5jdGlvbiAoZGF0YXNldF9pZCwgc3RhdHVzLCBub3RpZmljYXRpb24pIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzA3XSsrO1xuICBzZWxmLmdldERhdGFTZXQoZGF0YXNldF9pZCwgKGZ1bmN0aW9uIChkYXRhc2V0KSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzcwOF0rKztcbiAgZGF0YXNldC5zeW5jUnVubmluZyA9IGZhbHNlO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MDldKys7XG4gIGRhdGFzZXQuc3luY0xvb3BFbmQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzEwXSsrO1xuICBzZWxmLnNhdmVEYXRhU2V0KGRhdGFzZXRfaWQpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MTFdKys7XG4gIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgZGF0YXNldC5oYXNoLCBub3RpZmljYXRpb24sIHN0YXR1cyk7XG59KSk7XG59KSwgY2hlY2tEYXRhc2V0czogKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzE2XSsrO1xuICBmb3IgKHZhciBkYXRhc2V0X2lkIGluIHNlbGYuZGF0YXNldHMpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MTddKys7XG4gICAgaWYgKHNlbGYuZGF0YXNldHMuaGFzT3duUHJvcGVydHkoZGF0YXNldF9pZCkpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzcxOF0rKztcbiAgICAgIHZhciBkYXRhc2V0ID0gc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXTtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzcyMF0rKztcbiAgICAgIGlmICghIGRhdGFzZXQuc3luY1J1bm5pbmcgJiYgKGRhdGFzZXQuY29uZmlnLnN5bmNfYWN0aXZlIHx8IGRhdGFzZXQuc3luY0ZvcmNlZCkpIHtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzIyXSsrO1xuICAgICAgICB2YXIgbGFzdFN5bmNTdGFydCA9IGRhdGFzZXQuc3luY0xvb3BTdGFydDtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzIzXSsrO1xuICAgICAgICB2YXIgbGFzdFN5bmNDbXAgPSBkYXRhc2V0LnN5bmNMb29wRW5kO1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MjRdKys7XG4gICAgICAgIGlmIChsYXN0U3luY1N0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MjVdKys7XG4gICAgICAgICAgc2VsZi5jb25zb2xlTG9nKGRhdGFzZXRfaWQgKyBcIiAtIFBlcmZvcm1pbmcgaW5pdGlhbCBzeW5jXCIpO1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzcyN10rKztcbiAgICAgICAgICBkYXRhc2V0LnN5bmNQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MjhdKys7XG4gICAgICAgICAgaWYgKGxhc3RTeW5jQ21wICE9IG51bGwpIHtcbiAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzcyOV0rKztcbiAgICAgICAgICAgIHZhciB0aW1lU2luY2VMYXN0U3luYyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbGFzdFN5bmNDbXA7XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3MzBdKys7XG4gICAgICAgICAgICB2YXIgc3luY0ZyZXF1ZW5jeSA9IGRhdGFzZXQuY29uZmlnLnN5bmNfZnJlcXVlbmN5ICogMTAwMDtcbiAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzczMV0rKztcbiAgICAgICAgICAgIGlmICh0aW1lU2luY2VMYXN0U3luYyA+IHN5bmNGcmVxdWVuY3kpIHtcbiAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzMzXSsrO1xuICAgICAgICAgICAgICBkYXRhc2V0LnN5bmNQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzM3XSsrO1xuICAgICAgICBpZiAoZGF0YXNldC5zeW5jRm9yY2VkKSB7XG4gICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzM4XSsrO1xuICAgICAgICAgIGRhdGFzZXQuc3luY1BlbmRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc0MV0rKztcbiAgICAgICAgaWYgKGRhdGFzZXQuc3luY1BlbmRpbmcpIHtcbiAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3NDNdKys7XG4gICAgICAgICAgZGF0YXNldC5zeW5jRm9yY2VkID0gZmFsc2U7XG4gICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzQ4XSsrO1xuICAgICAgICAgIHNlbGYuc3luY0xvb3AoZGF0YXNldF9pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG59XG59KSwgY2hlY2tIYXNDdXN0b21TeW5jOiAoZnVuY3Rpb24gKGRhdGFzZXRfaWQsIGNiKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc1Nl0rKztcbiAgaWYgKHNlbGYuaGFzQ3VzdG9tU3luYyAhPSBudWxsKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzU3XSsrO1xuICAgIHJldHVybiBjYigpO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc1OV0rKztcbiAgc2VsZi5jb25zb2xlTG9nKFwic3RhcnRpbmcgY2hlY2sgaGFzIGN1c3RvbSBzeW5jXCIpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3NjFdKys7XG4gIGFjdEFQSSh7XCJhY3RcIjogZGF0YXNldF9pZCwgXCJyZXFcIjoge1wiZm5cIjogXCJzeW5jXCJ9fSwgKGZ1bmN0aW9uIChyZXMpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzY5XSsrO1xuICBzZWxmLmNvbnNvbGVMb2coXCJjaGVja0hhc0N1c3RvbVN5bmMgLSBzdWNjZXNzIC0gXCIsIHJlcyk7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc3MF0rKztcbiAgc2VsZi5oYXNDdXN0b21TeW5jID0gdHJ1ZTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzcxXSsrO1xuICByZXR1cm4gY2IoKTtcbn0pLCAoZnVuY3Rpb24gKG1zZywgZXJyKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc3M10rKztcbiAgc2VsZi5jb25zb2xlTG9nKFwiY2hlY2tIYXNDdXN0b21TeW5jIC0gZmFpbHVyZSAtIFwiLCBlcnIpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3NzRdKys7XG4gIGlmIChlcnIuc3RhdHVzICYmIGVyci5zdGF0dXMgPT09IDUwMCkge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc3N10rKztcbiAgICBzZWxmLmNvbnNvbGVMb2coXCJjaGVja0hhc0N1c3RvbVN5bmMgLSBmYWlsZWQgd2l0aCA1MDAsIGVuZHBvaW50IGRvZXMgZXhpc3RzXCIpO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc3OF0rKztcbiAgICBzZWxmLmhhc0N1c3RvbVN5bmMgPSB0cnVlO1xuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc4MF0rKztcbiAgICBzZWxmLmhhc0N1c3RvbVN5bmMgPSBmYWxzZTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3ODJdKys7XG4gIHJldHVybiBjYigpO1xufSkpO1xufSksIGRvQ2xvdWRDYWxsOiAoZnVuY3Rpb24gKHBhcmFtcywgc3VjY2VzcywgZmFpbHVyZSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3ODddKys7XG4gIGlmIChzZWxmLmhhc0N1c3RvbVN5bmMpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3ODhdKys7XG4gICAgYWN0QVBJKHtcImFjdFwiOiBwYXJhbXMuZGF0YXNldF9pZCwgXCJyZXFcIjogcGFyYW1zLnJlcX0sIChmdW5jdGlvbiAocmVzKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzc5Ml0rKztcbiAgc3VjY2VzcyhyZXMpO1xufSksIChmdW5jdGlvbiAobXNnLCBlcnIpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bNzk0XSsrO1xuICBmYWlsdXJlKG1zZywgZXJyKTtcbn0pKTtcbiAgfVxuICBlbHNlIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs3OTddKys7XG4gICAgY2xvdWRBUEkoe1wicGF0aFwiOiBcIi9tYmFhcy9zeW5jL1wiICsgcGFyYW1zLmRhdGFzZXRfaWQsIFwibWV0aG9kXCI6IFwicG9zdFwiLCBcImRhdGFcIjogcGFyYW1zLnJlcX0sIChmdW5jdGlvbiAocmVzKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzgwMl0rKztcbiAgc3VjY2VzcyhyZXMpO1xufSksIChmdW5jdGlvbiAobXNnLCBlcnIpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODA0XSsrO1xuICBmYWlsdXJlKG1zZywgZXJyKTtcbn0pKTtcbiAgfVxufSksIGRhdGFzZXRNb25pdG9yOiAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4MTBdKys7XG4gIHNlbGYuY2hlY2tEYXRhc2V0cygpO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4MTNdKys7XG4gIHNldFRpbWVvdXQoKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODE0XSsrO1xuICBzZWxmLmRhdGFzZXRNb25pdG9yKCk7XG59KSwgNTAwKTtcbn0pLCBzYXZlRGF0YVNldDogKGZ1bmN0aW9uIChkYXRhc2V0X2lkLCBjYikge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4MTldKys7XG4gIHZhciBvbkZhaWwgPSAoZnVuY3Rpb24gKG1zZywgZXJyKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzgyMV0rKztcbiAgdmFyIGVyck1zZyA9IFwic2F2ZSB0byBsb2NhbCBzdG9yYWdlIGZhaWxlZCAgbXNnOlwiICsgbXNnICsgXCIgZXJyOlwiICsgZXJyO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4MjJdKys7XG4gIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgbnVsbCwgc2VsZi5ub3RpZmljYXRpb25zLkNMSUVOVF9TVE9SQUdFX0ZBSUxFRCwgZXJyTXNnKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODIzXSsrO1xuICBzZWxmLmNvbnNvbGVMb2coZXJyTXNnKTtcbn0pO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4MjVdKys7XG4gIHNlbGYuZ2V0RGF0YVNldChkYXRhc2V0X2lkLCAoZnVuY3Rpb24gKGRhdGFzZXQpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODI3XSsrO1xuICBMYXduY2hhaXIoe2ZhaWw6IG9uRmFpbCwgYWRhcHRlcjogc2VsZi5jb25maWcuc3RvcmFnZV9zdHJhdGVneSwgc2l6ZTogc2VsZi5jb25maWcuZmlsZV9zeXN0ZW1fcXVvdGF9LCAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4MjhdKys7XG4gIHRoaXMuc2F2ZSh7a2V5OiBcImRhdGFzZXRfXCIgKyBkYXRhc2V0X2lkLCB2YWw6IGRhdGFzZXR9LCAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4MzBdKys7XG4gIGlmIChjYikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzgzMF0rKztcbiAgICByZXR1cm4gY2IoKTtcbiAgfVxufSkpO1xufSkpO1xufSkpO1xufSksIGxvYWREYXRhU2V0OiAoZnVuY3Rpb24gKGRhdGFzZXRfaWQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODM4XSsrO1xuICB2YXIgb25GYWlsID0gKGZ1bmN0aW9uIChtc2csIGVycikge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NDBdKys7XG4gIHZhciBlcnJNc2cgPSBcImxvYWQgZnJvbSBsb2NhbCBzdG9yYWdlIGZhaWxlZCAgbXNnOlwiICsgbXNnO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NDFdKys7XG4gIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgbnVsbCwgc2VsZi5ub3RpZmljYXRpb25zLkNMSUVOVF9TVE9SQUdFX0ZBSUxFRCwgZXJyTXNnKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODQyXSsrO1xuICBzZWxmLmNvbnNvbGVMb2coZXJyTXNnKTtcbn0pO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NDVdKys7XG4gIExhd25jaGFpcih7ZmFpbDogb25GYWlsLCBhZGFwdGVyOiBzZWxmLmNvbmZpZy5zdG9yYWdlX3N0cmF0ZWd5LCBzaXplOiBzZWxmLmNvbmZpZy5maWxlX3N5c3RlbV9xdW90YX0sIChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg0NV0rKztcbiAgdGhpcy5nZXQoXCJkYXRhc2V0X1wiICsgZGF0YXNldF9pZCwgKGZ1bmN0aW9uIChkYXRhKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg0Nl0rKztcbiAgaWYgKGRhdGEgJiYgZGF0YS52YWwgIT09IG51bGwpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NDddKys7XG4gICAgdmFyIGRhdGFzZXQgPSBkYXRhLnZhbDtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NDhdKys7XG4gICAgaWYgKHR5cGVvZiBkYXRhc2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NDldKys7XG4gICAgICBkYXRhc2V0ID0gSlNPTi5wYXJzZShkYXRhc2V0KTtcbiAgICB9XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODUzXSsrO1xuICAgIGRhdGFzZXQuaW5pdGlhbGlzZWQgPSBmYWxzZTtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NTRdKys7XG4gICAgc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXSA9IGRhdGFzZXQ7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODU1XSsrO1xuICAgIHNlbGYuY29uc29sZUxvZyhcImxvYWQgZnJvbSBsb2NhbCBzdG9yYWdlIHN1Y2Nlc3MgZm9yIGRhdGFzZXRfaWQgOlwiICsgZGF0YXNldF9pZCk7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODU2XSsrO1xuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NTZdKys7XG4gICAgICByZXR1cm4gc3VjY2VzcyhkYXRhc2V0KTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODU5XSsrO1xuICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NTldKys7XG4gICAgICByZXR1cm4gZmFpbHVyZSgpO1xuICAgIH1cbiAgfVxufSkpO1xufSkpO1xufSksIHVwZGF0ZURhdGFzZXRGcm9tTG9jYWw6IChmdW5jdGlvbiAoZGF0YXNldCwgcGVuZGluZ1JlYykge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NjddKys7XG4gIHZhciBwZW5kaW5nID0gZGF0YXNldC5wZW5kaW5nO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NjhdKys7XG4gIHZhciBwcmV2aW91c1BlbmRpbmdVaWQ7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg2OV0rKztcbiAgdmFyIHByZXZpb3VzUGVuZGluZztcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODcxXSsrO1xuICB2YXIgdWlkID0gcGVuZGluZ1JlYy51aWQ7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg3Ml0rKztcbiAgc2VsZi5jb25zb2xlTG9nKFwidXBkYXRpbmcgbG9jYWwgZGF0YXNldCBmb3IgdWlkIFwiICsgdWlkICsgXCIgLSBhY3Rpb24gPSBcIiArIHBlbmRpbmdSZWMuYWN0aW9uKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODc0XSsrO1xuICBkYXRhc2V0Lm1ldGFbdWlkXSA9IGRhdGFzZXQubWV0YVt1aWRdIHx8IHt9O1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4NzddKys7XG4gIGlmIChwZW5kaW5nUmVjLmFjdGlvbiA9PT0gXCJjcmVhdGVcIikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg3OF0rKztcbiAgICBpZiAoZGF0YXNldC5kYXRhW3VpZF0pIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg3OV0rKztcbiAgICAgIHNlbGYuY29uc29sZUxvZyhcImRhdGFzZXQgYWxyZWFkeSBleGlzdHMgZm9yIHVpZCBpbiBjcmVhdGUgOjogXCIgKyBKU09OLnN0cmluZ2lmeShkYXRhc2V0LmRhdGFbdWlkXSkpO1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODgyXSsrO1xuICAgICAgaWYgKGRhdGFzZXQubWV0YVt1aWRdLmZyb21QZW5kaW5nKSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg4NV0rKztcbiAgICAgICAgcHJldmlvdXNQZW5kaW5nVWlkID0gZGF0YXNldC5tZXRhW3VpZF0ucGVuZGluZ1VpZDtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODg2XSsrO1xuICAgICAgICBkZWxldGUgcGVuZGluZ1twcmV2aW91c1BlbmRpbmdVaWRdO1xuICAgICAgfVxuICAgIH1cbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4ODldKys7XG4gICAgZGF0YXNldC5kYXRhW3VpZF0gPSB7fTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4OTJdKys7XG4gIGlmIChwZW5kaW5nUmVjLmFjdGlvbiA9PT0gXCJ1cGRhdGVcIikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg5M10rKztcbiAgICBpZiAoZGF0YXNldC5kYXRhW3VpZF0pIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzg5NF0rKztcbiAgICAgIGlmIChkYXRhc2V0Lm1ldGFbdWlkXS5mcm9tUGVuZGluZykge1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4OTVdKys7XG4gICAgICAgIHNlbGYuY29uc29sZUxvZyhcInVwZGF0aW5nIGFuIGV4aXN0aW5nIHBlbmRpbmcgcmVjb3JkIGZvciBkYXRhc2V0IDo6IFwiICsgSlNPTi5zdHJpbmdpZnkoZGF0YXNldC5kYXRhW3VpZF0pKTtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODk3XSsrO1xuICAgICAgICBwcmV2aW91c1BlbmRpbmdVaWQgPSBkYXRhc2V0Lm1ldGFbdWlkXS5wZW5kaW5nVWlkO1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs4OThdKys7XG4gICAgICAgIGRhdGFzZXQubWV0YVt1aWRdLnByZXZpb3VzUGVuZGluZ1VpZCA9IHByZXZpb3VzUGVuZGluZ1VpZDtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bODk5XSsrO1xuICAgICAgICBwcmV2aW91c1BlbmRpbmcgPSBwZW5kaW5nW3ByZXZpb3VzUGVuZGluZ1VpZF07XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzkwMF0rKztcbiAgICAgICAgaWYgKHByZXZpb3VzUGVuZGluZykge1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzkwMV0rKztcbiAgICAgICAgICBpZiAoISBwcmV2aW91c1BlbmRpbmcuaW5GbGlnaHQpIHtcbiAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzkwMl0rKztcbiAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZyhcImV4aXN0aW5nIHByZS1mbGlnaHQgcGVuZGluZyByZWNvcmQgPSBcIiArIEpTT04uc3RyaW5naWZ5KHByZXZpb3VzUGVuZGluZykpO1xuICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTA1XSsrO1xuICAgICAgICAgICAgcHJldmlvdXNQZW5kaW5nLnBvc3QgPSBwZW5kaW5nUmVjLnBvc3Q7XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5MDZdKys7XG4gICAgICAgICAgICBwcmV2aW91c1BlbmRpbmcucG9zdEhhc2ggPSBwZW5kaW5nUmVjLnBvc3RIYXNoO1xuICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTA3XSsrO1xuICAgICAgICAgICAgZGVsZXRlIHBlbmRpbmdbcGVuZGluZ1JlYy5oYXNoXTtcbiAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzkxMF0rKztcbiAgICAgICAgICAgIHBlbmRpbmdSZWMuaGFzaCA9IHByZXZpb3VzUGVuZGluZ1VpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5MTRdKys7XG4gICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coXCJleGlzdGluZyBpbi1pbmZsaWdodCBwZW5kaW5nIHJlY29yZCA9IFwiICsgSlNPTi5zdHJpbmdpZnkocHJldmlvdXNQZW5kaW5nKSk7XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5MTVdKys7XG4gICAgICAgICAgICBwZW5kaW5nUmVjLmRlbGF5ZWQgPSB0cnVlO1xuICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTE2XSsrO1xuICAgICAgICAgICAgcGVuZGluZ1JlYy53YWl0aW5nID0gcHJldmlvdXNQZW5kaW5nLmhhc2g7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzkyM10rKztcbiAgaWYgKHBlbmRpbmdSZWMuYWN0aW9uID09PSBcImRlbGV0ZVwiKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTI0XSsrO1xuICAgIGlmIChkYXRhc2V0LmRhdGFbdWlkXSkge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTI1XSsrO1xuICAgICAgaWYgKGRhdGFzZXQubWV0YVt1aWRdLmZyb21QZW5kaW5nKSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzkyNl0rKztcbiAgICAgICAgc2VsZi5jb25zb2xlTG9nKFwiRGVsZXRpbmcgYW4gZXhpc3RpbmcgcGVuZGluZyByZWNvcmQgZm9yIGRhdGFzZXQgOjogXCIgKyBKU09OLnN0cmluZ2lmeShkYXRhc2V0LmRhdGFbdWlkXSkpO1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5MjhdKys7XG4gICAgICAgIHByZXZpb3VzUGVuZGluZ1VpZCA9IGRhdGFzZXQubWV0YVt1aWRdLnBlbmRpbmdVaWQ7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzkyOV0rKztcbiAgICAgICAgZGF0YXNldC5tZXRhW3VpZF0ucHJldmlvdXNQZW5kaW5nVWlkID0gcHJldmlvdXNQZW5kaW5nVWlkO1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5MzBdKys7XG4gICAgICAgIHByZXZpb3VzUGVuZGluZyA9IHBlbmRpbmdbcHJldmlvdXNQZW5kaW5nVWlkXTtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTMxXSsrO1xuICAgICAgICBpZiAocHJldmlvdXNQZW5kaW5nKSB7XG4gICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTMyXSsrO1xuICAgICAgICAgIGlmICghIHByZXZpb3VzUGVuZGluZy5pbkZsaWdodCkge1xuICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTMzXSsrO1xuICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKFwiZXhpc3RpbmcgcGVuZGluZyByZWNvcmQgPSBcIiArIEpTT04uc3RyaW5naWZ5KHByZXZpb3VzUGVuZGluZykpO1xuICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTM0XSsrO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzUGVuZGluZy5hY3Rpb24gPT09IFwiY3JlYXRlXCIpIHtcbiAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTM3XSsrO1xuICAgICAgICAgICAgICBkZWxldGUgcGVuZGluZ1twZW5kaW5nUmVjLmhhc2hdO1xuICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5MzhdKys7XG4gICAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nW3ByZXZpb3VzUGVuZGluZ1VpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NDBdKys7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNQZW5kaW5nLmFjdGlvbiA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NDRdKys7XG4gICAgICAgICAgICAgIHBlbmRpbmdSZWMucHJlID0gcHJldmlvdXNQZW5kaW5nLnByZTtcbiAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTQ1XSsrO1xuICAgICAgICAgICAgICBwZW5kaW5nUmVjLnByZUhhc2ggPSBwcmV2aW91c1BlbmRpbmcucHJlSGFzaDtcbiAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTQ2XSsrO1xuICAgICAgICAgICAgICBwZW5kaW5nUmVjLmluRmxpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk0N10rKztcbiAgICAgICAgICAgICAgZGVsZXRlIHBlbmRpbmdbcHJldmlvdXNQZW5kaW5nVWlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NTBdKys7XG4gICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coXCJleGlzdGluZyBpbi1pbmZsaWdodCBwZW5kaW5nIHJlY29yZCA9IFwiICsgSlNPTi5zdHJpbmdpZnkocHJldmlvdXNQZW5kaW5nKSk7XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NTFdKys7XG4gICAgICAgICAgICBwZW5kaW5nUmVjLmRlbGF5ZWQgPSB0cnVlO1xuICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTUyXSsrO1xuICAgICAgICAgICAgcGVuZGluZ1JlYy53YWl0aW5nID0gcHJldmlvdXNQZW5kaW5nLmhhc2g7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NTZdKys7XG4gICAgICBkZWxldGUgZGF0YXNldC5kYXRhW3VpZF07XG4gICAgfVxuICB9XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk2MF0rKztcbiAgaWYgKGRhdGFzZXQuZGF0YVt1aWRdKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTYxXSsrO1xuICAgIGRhdGFzZXQuZGF0YVt1aWRdLmRhdGEgPSBwZW5kaW5nUmVjLnBvc3Q7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTYyXSsrO1xuICAgIGRhdGFzZXQuZGF0YVt1aWRdLmhhc2ggPSBwZW5kaW5nUmVjLnBvc3RIYXNoO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk2M10rKztcbiAgICBkYXRhc2V0Lm1ldGFbdWlkXS5mcm9tUGVuZGluZyA9IHRydWU7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTY0XSsrO1xuICAgIGRhdGFzZXQubWV0YVt1aWRdLnBlbmRpbmdVaWQgPSBwZW5kaW5nUmVjLmhhc2g7XG4gIH1cbn0pLCB1cGRhdGVQZW5kaW5nRnJvbU5ld0RhdGE6IChmdW5jdGlvbiAoZGF0YXNldF9pZCwgZGF0YXNldCwgbmV3RGF0YSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NjldKys7XG4gIHZhciBwZW5kaW5nID0gZGF0YXNldC5wZW5kaW5nO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NzBdKys7XG4gIHZhciBuZXdSZWM7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk3Ml0rKztcbiAgaWYgKHBlbmRpbmcgJiYgbmV3RGF0YS5yZWNvcmRzKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTczXSsrO1xuICAgIGZvciAodmFyIHBlbmRpbmdIYXNoIGluIHBlbmRpbmcpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk3NF0rKztcbiAgICAgIGlmIChwZW5kaW5nLmhhc093blByb3BlcnR5KHBlbmRpbmdIYXNoKSkge1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5NzVdKys7XG4gICAgICAgIHZhciBwZW5kaW5nUmVjID0gcGVuZGluZ1twZW5kaW5nSGFzaF07XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk3N10rKztcbiAgICAgICAgZGF0YXNldC5tZXRhW3BlbmRpbmdSZWMudWlkXSA9IGRhdGFzZXQubWV0YVtwZW5kaW5nUmVjLnVpZF0gfHwge307XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk3OV0rKztcbiAgICAgICAgaWYgKHBlbmRpbmdSZWMuaW5GbGlnaHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTgxXSsrO1xuICAgICAgICAgIHNlbGYuY29uc29sZUxvZyhcInVwZGF0ZVBlbmRpbmdGcm9tTmV3RGF0YSAtIEZvdW5kIE5vbiBpbkZsaWdodCByZWNvcmQgLT4gYWN0aW9uPVwiICsgcGVuZGluZ1JlYy5hY3Rpb24gKyBcIiA6OiB1aWQ9XCIgKyBwZW5kaW5nUmVjLnVpZCArIFwiIDo6IGhhc2g9XCIgKyBwZW5kaW5nUmVjLmhhc2gpO1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk4Ml0rKztcbiAgICAgICAgICBpZiAocGVuZGluZ1JlYy5hY3Rpb24gPT09IFwidXBkYXRlXCIgfHwgcGVuZGluZ1JlYy5hY3Rpb24gPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk4NV0rKztcbiAgICAgICAgICAgIG5ld1JlYyA9IG5ld0RhdGEucmVjb3Jkc1twZW5kaW5nUmVjLnVpZF07XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5ODZdKys7XG4gICAgICAgICAgICBpZiAobmV3UmVjKSB7XG4gICAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk4N10rKztcbiAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKFwidXBkYXRlUGVuZGluZ0Zyb21OZXdEYXRhIC0gVXBkYXRpbmcgcHJlIHZhbHVlcyBmb3IgZXhpc3RpbmcgcGVuZGluZyByZWNvcmQgXCIgKyBwZW5kaW5nUmVjLnVpZCk7XG4gICAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzk4OF0rKztcbiAgICAgICAgICAgICAgcGVuZGluZ1JlYy5wcmUgPSBuZXdSZWMuZGF0YTtcbiAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTg5XSsrO1xuICAgICAgICAgICAgICBwZW5kaW5nUmVjLnByZUhhc2ggPSBuZXdSZWMuaGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5OTNdKys7XG4gICAgICAgICAgICAgIHZhciBwcmV2aW91c1BlbmRpbmdVaWQgPSBkYXRhc2V0Lm1ldGFbcGVuZGluZ1JlYy51aWRdLnByZXZpb3VzUGVuZGluZ1VpZDtcbiAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTk0XSsrO1xuICAgICAgICAgICAgICB2YXIgcHJldmlvdXNQZW5kaW5nID0gcGVuZGluZ1twcmV2aW91c1BlbmRpbmdVaWRdO1xuICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5OTVdKys7XG4gICAgICAgICAgICAgIGlmIChwcmV2aW91c1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5OTZdKys7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0RhdGEgJiYgbmV3RGF0YS51cGRhdGVzICYmIG5ld0RhdGEudXBkYXRlcy5hcHBsaWVkICYmIG5ld0RhdGEudXBkYXRlcy5hcHBsaWVkW3ByZXZpb3VzUGVuZGluZy5oYXNoXSkge1xuICAgICAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bOTk4XSsrO1xuICAgICAgICAgICAgICAgICAgdmFyIG5ld1VpZCA9IG5ld0RhdGEudXBkYXRlcy5hcHBsaWVkW3ByZXZpb3VzUGVuZGluZy5oYXNoXS51aWQ7XG4gICAgICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVs5OTldKys7XG4gICAgICAgICAgICAgICAgICBuZXdSZWMgPSBuZXdEYXRhLnJlY29yZHNbbmV3VWlkXTtcbiAgICAgICAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwMDBdKys7XG4gICAgICAgICAgICAgICAgICBpZiAobmV3UmVjKSB7XG4gICAgICAgICAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwMDFdKys7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZyhcInVwZGF0ZVBlbmRpbmdGcm9tTmV3RGF0YSAtIFVwZGF0aW5nIHByZSB2YWx1ZXMgZm9yIGV4aXN0aW5nIHBlbmRpbmcgcmVjb3JkIHdoaWNoIHdhcyBwcmV2aW91c2x5IGEgY3JlYXRlIFwiICsgcGVuZGluZ1JlYy51aWQgKyBcIiA9PT4gXCIgKyBuZXdVaWQpO1xuICAgICAgICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDAyXSsrO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLnByZSA9IG5ld1JlYy5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDAzXSsrO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLnByZUhhc2ggPSBuZXdSZWMuaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTAwNF0rKztcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1JlYy51aWQgPSBuZXdVaWQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwMTFdKys7XG4gICAgICAgICAgaWYgKHBlbmRpbmdSZWMuYWN0aW9uID09PSBcImNyZWF0ZVwiKSB7XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDEyXSsrO1xuICAgICAgICAgICAgaWYgKG5ld0RhdGEgJiYgbmV3RGF0YS51cGRhdGVzICYmIG5ld0RhdGEudXBkYXRlcy5hcHBsaWVkICYmIG5ld0RhdGEudXBkYXRlcy5hcHBsaWVkW3BlbmRpbmdIYXNoXSkge1xuICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDEzXSsrO1xuICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coXCJ1cGRhdGVQZW5kaW5nRnJvbU5ld0RhdGEgLSBGb3VuZCBhbiB1cGRhdGUgZm9yIGEgcGVuZGluZyBjcmVhdGUgXCIgKyBKU09OLnN0cmluZ2lmeShuZXdEYXRhLnVwZGF0ZXMuYXBwbGllZFtwZW5kaW5nSGFzaF0pKTtcbiAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTAxNF0rKztcbiAgICAgICAgICAgICAgbmV3UmVjID0gbmV3RGF0YS5yZWNvcmRzW25ld0RhdGEudXBkYXRlcy5hcHBsaWVkW3BlbmRpbmdIYXNoXS51aWRdO1xuICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDE1XSsrO1xuICAgICAgICAgICAgICBpZiAobmV3UmVjKSB7XG4gICAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTAxNl0rKztcbiAgICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coXCJ1cGRhdGVQZW5kaW5nRnJvbU5ld0RhdGEgLSBDaGFuZ2luZyBwZW5kaW5nIGNyZWF0ZSB0byBhbiB1cGRhdGUgYmFzZWQgb24gbmV3IHJlY29yZCAgXCIgKyBKU09OLnN0cmluZ2lmeShuZXdSZWMpKTtcbiAgICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDE5XSsrO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdSZWMuYWN0aW9uID0gXCJ1cGRhdGVcIjtcbiAgICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDIwXSsrO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdSZWMucHJlID0gbmV3UmVjLmRhdGE7XG4gICAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTAyMV0rKztcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLnByZUhhc2ggPSBuZXdSZWMuaGFzaDtcbiAgICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDIyXSsrO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdSZWMudWlkID0gbmV3RGF0YS51cGRhdGVzLmFwcGxpZWRbcGVuZGluZ0hhc2hdLnVpZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxufVxuICB9XG59KSwgdXBkYXRlTmV3RGF0YUZyb21JbkZsaWdodDogKGZ1bmN0aW9uIChkYXRhc2V0X2lkLCBkYXRhc2V0LCBuZXdEYXRhKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwMzNdKys7XG4gIHZhciBwZW5kaW5nID0gZGF0YXNldC5wZW5kaW5nO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDM1XSsrO1xuICBpZiAocGVuZGluZyAmJiBuZXdEYXRhLnJlY29yZHMpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDM2XSsrO1xuICAgIGZvciAodmFyIHBlbmRpbmdIYXNoIGluIHBlbmRpbmcpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwMzddKys7XG4gICAgICBpZiAocGVuZGluZy5oYXNPd25Qcm9wZXJ0eShwZW5kaW5nSGFzaCkpIHtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTAzOF0rKztcbiAgICAgICAgdmFyIHBlbmRpbmdSZWMgPSBwZW5kaW5nW3BlbmRpbmdIYXNoXTtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA0MF0rKztcbiAgICAgICAgaWYgKHBlbmRpbmdSZWMuaW5GbGlnaHQpIHtcbiAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDQxXSsrO1xuICAgICAgICAgIHZhciB1cGRhdGVSZWNlaXZlZEZvclBlbmRpbmcgPSAobmV3RGF0YSAmJiBuZXdEYXRhLnVwZGF0ZXMgJiYgbmV3RGF0YS51cGRhdGVzLmhhc2hlcyAmJiBuZXdEYXRhLnVwZGF0ZXMuaGFzaGVzW3BlbmRpbmdIYXNoXSk/IHRydWU6IGZhbHNlO1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwNDNdKys7XG4gICAgICAgICAgc2VsZi5jb25zb2xlTG9nKFwidXBkYXRlTmV3RGF0YUZyb21JbkZsaWdodCAtIEZvdW5kIGluZmxpZ2h0IHBlbmRpbmcgUmVjb3JkIC0gYWN0aW9uID0gXCIgKyBwZW5kaW5nUmVjLmFjdGlvbiArIFwiIDo6IGhhc2ggPSBcIiArIHBlbmRpbmdIYXNoICsgXCIgOjogdXBkYXRlUmVjZWl2ZWRGb3JQZW5kaW5nPVwiICsgdXBkYXRlUmVjZWl2ZWRGb3JQZW5kaW5nKTtcbiAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDQ1XSsrO1xuICAgICAgICAgIGlmICghIHVwZGF0ZVJlY2VpdmVkRm9yUGVuZGluZykge1xuICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA0Nl0rKztcbiAgICAgICAgICAgIHZhciBuZXdSZWMgPSBuZXdEYXRhLnJlY29yZHNbcGVuZGluZ1JlYy51aWRdO1xuICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA0OF0rKztcbiAgICAgICAgICAgIGlmIChwZW5kaW5nUmVjLmFjdGlvbiA9PT0gXCJ1cGRhdGVcIiAmJiBuZXdSZWMpIHtcbiAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA1MF0rKztcbiAgICAgICAgICAgICAgbmV3UmVjLmRhdGEgPSBwZW5kaW5nUmVjLnBvc3Q7XG4gICAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwNTFdKys7XG4gICAgICAgICAgICAgIG5ld1JlYy5oYXNoID0gcGVuZGluZ1JlYy5wb3N0SGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDUzXSsrO1xuICAgICAgICAgICAgICBpZiAocGVuZGluZ1JlYy5hY3Rpb24gPT09IFwiZGVsZXRlXCIgJiYgbmV3UmVjKSB7XG4gICAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA1NV0rKztcbiAgICAgICAgICAgICAgICBkZWxldGUgbmV3RGF0YS5yZWNvcmRzW3BlbmRpbmdSZWMudWlkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDU3XSsrO1xuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nUmVjLmFjdGlvbiA9PT0gXCJjcmVhdGVcIikge1xuICAgICAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA1OV0rKztcbiAgICAgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZyhcInVwZGF0ZU5ld0RhdGFGcm9tSW5GbGlnaHQgLSByZSBhZGRpbmcgcGVuZGluZyBjcmVhdGUgdG8gaW5jb21taW5nIGRhdGFzZXRcIik7XG4gICAgICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDYwXSsrO1xuICAgICAgICAgICAgICAgICAgdmFyIG5ld1BlbmRpbmdDcmVhdGUgPSB7ZGF0YTogcGVuZGluZ1JlYy5wb3N0LCBoYXNoOiBwZW5kaW5nUmVjLnBvc3RIYXNofTtcbiAgICAgICAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwNjRdKys7XG4gICAgICAgICAgICAgICAgICBuZXdEYXRhLnJlY29yZHNbcGVuZGluZ1JlYy51aWRdID0gbmV3UGVuZGluZ0NyZWF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbn1cbiAgfVxufSksIHVwZGF0ZU5ld0RhdGFGcm9tUGVuZGluZzogKGZ1bmN0aW9uIChkYXRhc2V0X2lkLCBkYXRhc2V0LCBuZXdEYXRhKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwNzRdKys7XG4gIHZhciBwZW5kaW5nID0gZGF0YXNldC5wZW5kaW5nO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDc2XSsrO1xuICBpZiAocGVuZGluZyAmJiBuZXdEYXRhLnJlY29yZHMpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDc3XSsrO1xuICAgIGZvciAodmFyIHBlbmRpbmdIYXNoIGluIHBlbmRpbmcpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwNzhdKys7XG4gICAgICBpZiAocGVuZGluZy5oYXNPd25Qcm9wZXJ0eShwZW5kaW5nSGFzaCkpIHtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA3OV0rKztcbiAgICAgICAgdmFyIHBlbmRpbmdSZWMgPSBwZW5kaW5nW3BlbmRpbmdIYXNoXTtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA4MV0rKztcbiAgICAgICAgaWYgKHBlbmRpbmdSZWMuaW5GbGlnaHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA4Ml0rKztcbiAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coXCJ1cGRhdGVOZXdEYXRhRnJvbVBlbmRpbmcgLSBGb3VuZCBOb24gaW5GbGlnaHQgcmVjb3JkIC0+IGFjdGlvbj1cIiArIHBlbmRpbmdSZWMuYWN0aW9uICsgXCIgOjogdWlkPVwiICsgcGVuZGluZ1JlYy51aWQgKyBcIiA6OiBoYXNoPVwiICsgcGVuZGluZ1JlYy5oYXNoKTtcbiAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDgzXSsrO1xuICAgICAgICAgIHZhciBuZXdSZWMgPSBuZXdEYXRhLnJlY29yZHNbcGVuZGluZ1JlYy51aWRdO1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEwODRdKys7XG4gICAgICAgICAgaWYgKHBlbmRpbmdSZWMuYWN0aW9uID09PSBcInVwZGF0ZVwiICYmIG5ld1JlYykge1xuICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA4Nl0rKztcbiAgICAgICAgICAgIG5ld1JlYy5kYXRhID0gcGVuZGluZ1JlYy5wb3N0O1xuICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTA4N10rKztcbiAgICAgICAgICAgIG5ld1JlYy5oYXNoID0gcGVuZGluZ1JlYy5wb3N0SGFzaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDg5XSsrO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdSZWMuYWN0aW9uID09PSBcImRlbGV0ZVwiICYmIG5ld1JlYykge1xuICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDkxXSsrO1xuICAgICAgICAgICAgICBkZWxldGUgbmV3RGF0YS5yZWNvcmRzW3BlbmRpbmdSZWMudWlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDkzXSsrO1xuICAgICAgICAgICAgICBpZiAocGVuZGluZ1JlYy5hY3Rpb24gPT09IFwiY3JlYXRlXCIpIHtcbiAgICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDk1XSsrO1xuICAgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZyhcInVwZGF0ZU5ld0RhdGFGcm9tUGVuZGluZyAtIHJlIGFkZGluZyBwZW5kaW5nIGNyZWF0ZSB0byBpbmNvbW1pbmcgZGF0YXNldFwiKTtcbiAgICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMDk2XSsrO1xuICAgICAgICAgICAgICAgIHZhciBuZXdQZW5kaW5nQ3JlYXRlID0ge2RhdGE6IHBlbmRpbmdSZWMucG9zdCwgaGFzaDogcGVuZGluZ1JlYy5wb3N0SGFzaH07XG4gICAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTEwMF0rKztcbiAgICAgICAgICAgICAgICBuZXdEYXRhLnJlY29yZHNbcGVuZGluZ1JlYy51aWRdID0gbmV3UGVuZGluZ0NyZWF0ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxufVxuICB9XG59KSwgdXBkYXRlQ3Jhc2hlZEluRmxpZ2h0RnJvbU5ld0RhdGE6IChmdW5jdGlvbiAoZGF0YXNldF9pZCwgZGF0YXNldCwgbmV3RGF0YSkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTA5XSsrO1xuICB2YXIgdXBkYXRlTm90aWZpY2F0aW9ucyA9IHthcHBsaWVkOiBzZWxmLm5vdGlmaWNhdGlvbnMuUkVNT1RFX1VQREFURV9BUFBMSUVELCBmYWlsZWQ6IHNlbGYubm90aWZpY2F0aW9ucy5SRU1PVEVfVVBEQVRFX0ZBSUxFRCwgY29sbGlzaW9uczogc2VsZi5ub3RpZmljYXRpb25zLkNPTExJU0lPTl9ERVRFQ1RFRH07XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExMTVdKys7XG4gIHZhciBwZW5kaW5nID0gZGF0YXNldC5wZW5kaW5nO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTE2XSsrO1xuICB2YXIgcmVzb2x2ZWRDcmFzaGVzID0ge307XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExMTddKys7XG4gIHZhciBwZW5kaW5nSGFzaDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTExOF0rKztcbiAgdmFyIHBlbmRpbmdSZWM7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExMjFdKys7XG4gIGlmIChwZW5kaW5nKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTEyMl0rKztcbiAgICBmb3IgKHBlbmRpbmdIYXNoIGluIHBlbmRpbmcpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExMjNdKys7XG4gICAgICBpZiAocGVuZGluZy5oYXNPd25Qcm9wZXJ0eShwZW5kaW5nSGFzaCkpIHtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTEyNF0rKztcbiAgICAgICAgcGVuZGluZ1JlYyA9IHBlbmRpbmdbcGVuZGluZ0hhc2hdO1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTI2XSsrO1xuICAgICAgICBpZiAocGVuZGluZ1JlYy5pbkZsaWdodCAmJiBwZW5kaW5nUmVjLmNyYXNoZWQpIHtcbiAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTI3XSsrO1xuICAgICAgICAgIHNlbGYuY29uc29sZUxvZyhcInVwZGF0ZUNyYXNoZWRJbkZsaWdodEZyb21OZXdEYXRhIC0gRm91bmQgY3Jhc2hlZCBpbkZsaWdodCBwZW5kaW5nIHJlY29yZCB1aWQ9XCIgKyBwZW5kaW5nUmVjLnVpZCArIFwiIDo6IGhhc2g9XCIgKyBwZW5kaW5nUmVjLmhhc2gpO1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExMjhdKys7XG4gICAgICAgICAgaWYgKG5ld0RhdGEgJiYgbmV3RGF0YS51cGRhdGVzICYmIG5ld0RhdGEudXBkYXRlcy5oYXNoZXMpIHtcbiAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExMzFdKys7XG4gICAgICAgICAgICB2YXIgY3Jhc2hlZFVwZGF0ZSA9IG5ld0RhdGEudXBkYXRlcy5oYXNoZXNbcGVuZGluZ0hhc2hdO1xuICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTEzMl0rKztcbiAgICAgICAgICAgIGlmIChjcmFzaGVkVXBkYXRlKSB7XG4gICAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExMzVdKys7XG4gICAgICAgICAgICAgIHJlc29sdmVkQ3Jhc2hlc1tjcmFzaGVkVXBkYXRlLnVpZF0gPSBjcmFzaGVkVXBkYXRlO1xuICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTM3XSsrO1xuICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coXCJ1cGRhdGVDcmFzaGVkSW5GbGlnaHRGcm9tTmV3RGF0YSAtIFJlc29sdmluZyBzdGF0dXMgZm9yIGNyYXNoZWQgaW5mbGlnaHQgcGVuZGluZyByZWNvcmQgXCIgKyBKU09OLnN0cmluZ2lmeShjcmFzaGVkVXBkYXRlKSk7XG4gICAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExMzldKys7XG4gICAgICAgICAgICAgIGlmIChjcmFzaGVkVXBkYXRlLnR5cGUgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTQxXSsrO1xuICAgICAgICAgICAgICAgIGlmIChjcmFzaGVkVXBkYXRlLmFjdGlvbiA9PT0gXCJjcmVhdGVcIikge1xuICAgICAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE0Ml0rKztcbiAgICAgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZyhcInVwZGF0ZUNyYXNoZWRJbkZsaWdodEZyb21OZXdEYXRhIC0gRGVsZXRpbmcgZmFpbGVkIGNyZWF0ZSBmcm9tIGRhdGFzZXRcIik7XG4gICAgICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTQzXSsrO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFzZXQuZGF0YVtjcmFzaGVkVXBkYXRlLnVpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE0NV0rKztcbiAgICAgICAgICAgICAgICAgIGlmIChjcmFzaGVkVXBkYXRlLmFjdGlvbiA9PT0gXCJ1cGRhdGVcIiB8fCBjcmFzaGVkVXBkYXRlLmFjdGlvbiA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTQ2XSsrO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coXCJ1cGRhdGVDcmFzaGVkSW5GbGlnaHRGcm9tTmV3RGF0YSAtIFJldmVydGluZyBmYWlsZWQgXCIgKyBjcmFzaGVkVXBkYXRlLmFjdGlvbiArIFwiIGluIGRhdGFzZXRcIik7XG4gICAgICAgICAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExNDddKys7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFzZXQuZGF0YVtjcmFzaGVkVXBkYXRlLnVpZF0gPSB7ZGF0YTogcGVuZGluZ1JlYy5wcmUsIGhhc2g6IHBlbmRpbmdSZWMucHJlSGFzaH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExNTRdKys7XG4gICAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nW3BlbmRpbmdIYXNoXTtcbiAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE1NV0rKztcbiAgICAgICAgICAgICAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCBjcmFzaGVkVXBkYXRlLnVpZCwgdXBkYXRlTm90aWZpY2F0aW9uc1tjcmFzaGVkVXBkYXRlLnR5cGVdLCBjcmFzaGVkVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTYwXSsrO1xuICAgICAgICAgICAgICBpZiAocGVuZGluZ1JlYy5jcmFzaGVkQ291bnQpIHtcbiAgICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTYxXSsrO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdSZWMuY3Jhc2hlZENvdW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE2NF0rKztcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLmNyYXNoZWRDb3VudCA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTcxXSsrO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdSZWMuY3Jhc2hlZENvdW50KSB7XG4gICAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExNzJdKys7XG4gICAgICAgICAgICAgIHBlbmRpbmdSZWMuY3Jhc2hlZENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE3NV0rKztcbiAgICAgICAgICAgICAgcGVuZGluZ1JlYy5jcmFzaGVkQ291bnQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxufVxuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExODJdKys7XG4gICAgZm9yIChwZW5kaW5nSGFzaCBpbiBwZW5kaW5nKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTgzXSsrO1xuICAgICAgaWYgKHBlbmRpbmcuaGFzT3duUHJvcGVydHkocGVuZGluZ0hhc2gpKSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExODRdKys7XG4gICAgICAgIHBlbmRpbmdSZWMgPSBwZW5kaW5nW3BlbmRpbmdIYXNoXTtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE4Nl0rKztcbiAgICAgICAgaWYgKHBlbmRpbmdSZWMuaW5GbGlnaHQgJiYgcGVuZGluZ1JlYy5jcmFzaGVkKSB7XG4gICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE4N10rKztcbiAgICAgICAgICBpZiAocGVuZGluZ1JlYy5jcmFzaGVkQ291bnQgPiBkYXRhc2V0LmNvbmZpZy5jcmFzaGVkX2NvdW50X3dhaXQpIHtcbiAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExODhdKys7XG4gICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coXCJ1cGRhdGVDcmFzaGVkSW5GbGlnaHRGcm9tTmV3RGF0YSAtIENyYXNoZWQgaW5mbGlnaHQgcGVuZGluZyByZWNvcmQgaGFzIHJlYWNoZWQgY3Jhc2hlZF9jb3VudF93YWl0IGxpbWl0IDogXCIgKyBKU09OLnN0cmluZ2lmeShwZW5kaW5nUmVjKSk7XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTg5XSsrO1xuICAgICAgICAgICAgaWYgKGRhdGFzZXQuY29uZmlnLnJlc2VuZF9jcmFzaGVkX3VwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE5MF0rKztcbiAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKFwidXBkYXRlQ3Jhc2hlZEluRmxpZ2h0RnJvbU5ld0RhdGEgLSBSZXRyeWlnIGNyYXNoZWQgaW5mbGlnaHQgcGVuZGluZyByZWNvcmRcIik7XG4gICAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzExOTFdKys7XG4gICAgICAgICAgICAgIHBlbmRpbmdSZWMuY3Jhc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTkyXSsrO1xuICAgICAgICAgICAgICBwZW5kaW5nUmVjLmluRmxpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTE5NV0rKztcbiAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKFwidXBkYXRlQ3Jhc2hlZEluRmxpZ2h0RnJvbU5ld0RhdGEgLSBEZWxldGluZyBjcmFzaGVkIGluZmxpZ2h0IHBlbmRpbmcgcmVjb3JkXCIpO1xuICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMTk2XSsrO1xuICAgICAgICAgICAgICBkZWxldGUgcGVuZGluZ1twZW5kaW5nSGFzaF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMDBdKys7XG4gICAgICAgICAgaWYgKCEgcGVuZGluZ1JlYy5pbkZsaWdodCAmJiBwZW5kaW5nUmVjLmNyYXNoZWQpIHtcbiAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMDFdKys7XG4gICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coXCJ1cGRhdGVDcmFzaGVkSW5GbGlnaHRGcm9tTmV3RGF0YSAtIFRyeWluZyB0byByZXNvbHZlIGlzc3VlcyB3aXRoIGNyYXNoZWQgbm9uIGluIGZsaWdodCByZWNvcmQgLSB1aWQgPSBcIiArIHBlbmRpbmdSZWMudWlkKTtcbiAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMDNdKys7XG4gICAgICAgICAgICB2YXIgY3Jhc2hlZFJlZiA9IHJlc29sdmVkQ3Jhc2hlc1twZW5kaW5nUmVjLnVpZF07XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjA0XSsrO1xuICAgICAgICAgICAgaWYgKGNyYXNoZWRSZWYpIHtcbiAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTIwNV0rKztcbiAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKFwidXBkYXRlQ3Jhc2hlZEluRmxpZ2h0RnJvbU5ld0RhdGEgLSBGb3VuZCBhIHN0YWxsZWQgcGVuZGluZyByZWNvcmQgYmFja2VkIHVwIGJlaGluZCBhIHJlc29sdmVkIGNyYXNoIHVpZD1cIiArIHBlbmRpbmdSZWMudWlkICsgXCIgOjogaGFzaD1cIiArIHBlbmRpbmdSZWMuaGFzaCk7XG4gICAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMDZdKys7XG4gICAgICAgICAgICAgIHBlbmRpbmdSZWMuY3Jhc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxufVxuICB9XG59KSwgdXBkYXRlRGVsYXllZEZyb21OZXdEYXRhOiAoZnVuY3Rpb24gKGRhdGFzZXRfaWQsIGRhdGFzZXQsIG5ld0RhdGEpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTIxNV0rKztcbiAgdmFyIHBlbmRpbmcgPSBkYXRhc2V0LnBlbmRpbmc7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMTZdKys7XG4gIHZhciBwZW5kaW5nSGFzaDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTIxN10rKztcbiAgdmFyIHBlbmRpbmdSZWM7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMThdKys7XG4gIGlmIChwZW5kaW5nKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTIxOV0rKztcbiAgICBmb3IgKHBlbmRpbmdIYXNoIGluIHBlbmRpbmcpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMjBdKys7XG4gICAgICBpZiAocGVuZGluZy5oYXNPd25Qcm9wZXJ0eShwZW5kaW5nSGFzaCkpIHtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTIyMV0rKztcbiAgICAgICAgcGVuZGluZ1JlYyA9IHBlbmRpbmdbcGVuZGluZ0hhc2hdO1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjIyXSsrO1xuICAgICAgICBpZiAocGVuZGluZ1JlYy5kZWxheWVkICYmIHBlbmRpbmdSZWMud2FpdGluZykge1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMjNdKys7XG4gICAgICAgICAgc2VsZi5jb25zb2xlTG9nKFwidXBkYXRlRGVsYXllZEZyb21OZXdEYXRhIC0gRm91bmQgZGVsYXllZCBwZW5kaW5nIHJlY29yZCB1aWQ9XCIgKyBwZW5kaW5nUmVjLnVpZCArIFwiIDo6IGhhc2g9XCIgKyBwZW5kaW5nUmVjLmhhc2ggKyBcIiA6OiB3YWl0aW5nPVwiICsgcGVuZGluZ1JlYy53YWl0aW5nKTtcbiAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjI0XSsrO1xuICAgICAgICAgIGlmIChuZXdEYXRhICYmIG5ld0RhdGEudXBkYXRlcyAmJiBuZXdEYXRhLnVwZGF0ZXMuaGFzaGVzKSB7XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjI1XSsrO1xuICAgICAgICAgICAgdmFyIHdhaXRpbmdSZWMgPSBuZXdEYXRhLnVwZGF0ZXMuaGFzaGVzW3BlbmRpbmdSZWMud2FpdGluZ107XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjI2XSsrO1xuICAgICAgICAgICAgaWYgKHdhaXRpbmdSZWMpIHtcbiAgICAgICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTIyN10rKztcbiAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKFwidXBkYXRlRGVsYXllZEZyb21OZXdEYXRhIC0gV2FpdGluZyBwZW5kaW5nIHJlY29yZCBpcyByZXNvbHZlZCByZWM9XCIgKyBKU09OLnN0cmluZ2lmeSh3YWl0aW5nUmVjKSk7XG4gICAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyMjhdKys7XG4gICAgICAgICAgICAgIHBlbmRpbmdSZWMuZGVsYXllZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjI5XSsrO1xuICAgICAgICAgICAgICBwZW5kaW5nUmVjLndhaXRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG59XG4gIH1cbn0pLCBtYXJrSW5GbGlnaHRBc0NyYXNoZWQ6IChmdW5jdGlvbiAoZGF0YXNldCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjQwXSsrO1xuICB2YXIgcGVuZGluZyA9IGRhdGFzZXQucGVuZGluZztcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI0MV0rKztcbiAgdmFyIHBlbmRpbmdIYXNoO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjQyXSsrO1xuICB2YXIgcGVuZGluZ1JlYztcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI0NF0rKztcbiAgaWYgKHBlbmRpbmcpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjQ1XSsrO1xuICAgIHZhciBjcmFzaGVkUmVjb3JkcyA9IHt9O1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyNDZdKys7XG4gICAgZm9yIChwZW5kaW5nSGFzaCBpbiBwZW5kaW5nKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjQ3XSsrO1xuICAgICAgaWYgKHBlbmRpbmcuaGFzT3duUHJvcGVydHkocGVuZGluZ0hhc2gpKSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyNDhdKys7XG4gICAgICAgIHBlbmRpbmdSZWMgPSBwZW5kaW5nW3BlbmRpbmdIYXNoXTtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI1MF0rKztcbiAgICAgICAgaWYgKHBlbmRpbmdSZWMuaW5GbGlnaHQpIHtcbiAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjUxXSsrO1xuICAgICAgICAgIHNlbGYuY29uc29sZUxvZyhcIk1hcmtpbmcgaW4gZmxpZ2h0IHBlbmRpbmcgcmVjb3JkIGFzIGNyYXNoZWQgOiBcIiArIHBlbmRpbmdIYXNoKTtcbiAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjUyXSsrO1xuICAgICAgICAgIHBlbmRpbmdSZWMuY3Jhc2hlZCA9IHRydWU7XG4gICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI1M10rKztcbiAgICAgICAgICBjcmFzaGVkUmVjb3Jkc1twZW5kaW5nUmVjLnVpZF0gPSBwZW5kaW5nUmVjO1xuICAgICAgICB9XG4gICAgICB9XG59XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI2MF0rKztcbiAgICBmb3IgKHBlbmRpbmdIYXNoIGluIHBlbmRpbmcpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyNjFdKys7XG4gICAgICBpZiAocGVuZGluZy5oYXNPd25Qcm9wZXJ0eShwZW5kaW5nSGFzaCkpIHtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI2Ml0rKztcbiAgICAgICAgcGVuZGluZ1JlYyA9IHBlbmRpbmdbcGVuZGluZ0hhc2hdO1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjY0XSsrO1xuICAgICAgICBpZiAoISBwZW5kaW5nUmVjLmluRmxpZ2h0ICYmICEgcGVuZGluZ1JlYy5kZWxheWVkKSB7XG4gICAgICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI2NV0rKztcbiAgICAgICAgICB2YXIgY3Jhc2hlZFJlZiA9IGNyYXNoZWRSZWNvcmRzW3BlbmRpbmdSZWMudWlkXTtcbiAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjY2XSsrO1xuICAgICAgICAgIGlmIChjcmFzaGVkUmVmKSB7XG4gICAgICAgICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjY3XSsrO1xuICAgICAgICAgICAgcGVuZGluZ1JlYy5jcmFzaGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbn1cbiAgfVxufSksIGNvbnNvbGVMb2c6IChmdW5jdGlvbiAobXNnKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyNzZdKys7XG4gIGlmIChzZWxmLmNvbmZpZy5kb19jb25zb2xlX2xvZykge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyNzddKys7XG4gICAgY29uc29sZS5sb2cobXNnKTtcbiAgfVxufSl9O1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ11bMTI4Ml0rKztcbihmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy9zeW5jLWNsaS5qcyddWzEyODNdKys7XG4gIHNlbGYuY29uZmlnID0gc2VsZi5kZWZhdWx0cztcbn0pKCk7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvc3luYy1jbGkuanMnXVsxMjg4XSsrO1xubW9kdWxlLmV4cG9ydHMgPSB7aW5pdDogc2VsZi5pbml0LCBtYW5hZ2U6IHNlbGYubWFuYWdlLCBub3RpZnk6IHNlbGYubm90aWZ5LCBkb0xpc3Q6IHNlbGYubGlzdCwgZG9DcmVhdGU6IHNlbGYuY3JlYXRlLCBkb1JlYWQ6IHNlbGYucmVhZCwgZG9VcGRhdGU6IHNlbGYudXBkYXRlLCBkb0RlbGV0ZTogc2VsZltcImRlbGV0ZVwiXSwgbGlzdENvbGxpc2lvbnM6IHNlbGYubGlzdENvbGxpc2lvbnMsIHJlbW92ZUNvbGxpc2lvbjogc2VsZi5yZW1vdmVDb2xsaXNpb24sIGdldFBlbmRpbmc6IHNlbGYuZ2V0UGVuZGluZywgY2xlYXJQZW5kaW5nOiBzZWxmLmNsZWFyUGVuZGluZywgZ2V0RGF0YXNldDogc2VsZi5nZXREYXRhU2V0LCBnZXRRdWVyeVBhcmFtczogc2VsZi5nZXRRdWVyeVBhcmFtcywgc2V0UXVlcnlQYXJhbXM6IHNlbGYuc2V0UXVlcnlQYXJhbXMsIGdldE1ldGFEYXRhOiBzZWxmLmdldE1ldGFEYXRhLCBzZXRNZXRhRGF0YTogc2VsZi5zZXRNZXRhRGF0YSwgZ2V0Q29uZmlnOiBzZWxmLmdldENvbmZpZywgc2V0Q29uZmlnOiBzZWxmLnNldENvbmZpZywgc3RhcnRTeW5jOiBzZWxmLnN0YXJ0U3luYywgc3RvcFN5bmM6IHNlbGYuc3RvcFN5bmMsIGRvU3luYzogc2VsZi5kb1N5bmMsIGZvcmNlU3luYzogc2VsZi5mb3JjZVN5bmMsIGdlbmVyYXRlSGFzaDogc2VsZi5nZW5lcmF0ZUhhc2h9O1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL3N5bmMtY2xpLmpzJ10uc291cmNlID0gW1widmFyIEpTT04gPSByZXF1aXJlKFxcXCJKU09OXFxcIik7XCIsXCJ2YXIgYWN0QVBJID0gcmVxdWlyZShcXFwiLi9hcGlfYWN0XFxcIik7XCIsXCJ2YXIgY2xvdWRBUEkgPSByZXF1aXJlKFxcXCIuL2FwaV9jbG91ZFxcXCIpO1wiLFwidmFyIENyeXB0b0pTID0gcmVxdWlyZShcXFwiLi4vLi4vbGlicy9nZW5lcmF0ZWQvY3J5cHRvXFxcIik7XCIsXCJ2YXIgTGF3bmNoYWlyID0gcmVxdWlyZSgnLi4vLi4vbGlicy9nZW5lcmF0ZWQvbGF3bmNoYWlyJyk7XCIsXCJcIixcInZhciBzZWxmID0ge1wiLFwiXCIsXCIgIC8vIENPTkZJR1wiLFwiICBkZWZhdWx0czoge1wiLFwiICAgIFxcXCJzeW5jX2ZyZXF1ZW5jeVxcXCI6IDEwLFwiLFwiICAgIC8vIEhvdyBvZnRlbiB0byBzeW5jaHJvbmlzZSBkYXRhIHdpdGggdGhlIGNsb3VkIGluIHNlY29uZHMuXCIsXCIgICAgXFxcImF1dG9fc3luY19sb2NhbF91cGRhdGVzXFxcIjogdHJ1ZSxcIixcIiAgICAvLyBTaG91bGQgbG9jYWwgY2hhZ2VzIGJlIHN5bmVkIHRvIHRoZSBjbG91ZCBpbW1lZGlhdGVseSwgb3Igc2hvdWxkIHRoZXkgd2FpdCBmb3IgdGhlIG5leHQgc3luYyBpbnRlcnZhbFwiLFwiICAgIFxcXCJub3RpZnlfY2xpZW50X3N0b3JhZ2VfZmFpbGVkXFxcIjogdHJ1ZSxcIixcIiAgICAvLyBTaG91bGQgYSBub3RpZmljYXRpb24gZXZlbnQgYmUgdHJpZ2dlcmVkIHdoZW4gbG9hZGluZy9zYXZpbmcgdG8gY2xpZW50IHN0b3JhZ2UgZmFpbHNcIixcIiAgICBcXFwibm90aWZ5X3N5bmNfc3RhcnRlZFxcXCI6IHRydWUsXCIsXCIgICAgLy8gU2hvdWxkIGEgbm90aWZpY2F0aW9uIGV2ZW50IGJlIHRyaWdnZXJlZCB3aGVuIGEgc3luYyBjeWNsZSB3aXRoIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gc3RhcnRlZFwiLFwiICAgIFxcXCJub3RpZnlfc3luY19jb21wbGV0ZVxcXCI6IHRydWUsXCIsXCIgICAgLy8gU2hvdWxkIGEgbm90aWZpY2F0aW9uIGV2ZW50IGJlIHRyaWdnZXJlZCB3aGVuIGEgc3luYyBjeWNsZSB3aXRoIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gY29tcGxldGVkXCIsXCIgICAgXFxcIm5vdGlmeV9vZmZsaW5lX3VwZGF0ZVxcXCI6IHRydWUsXCIsXCIgICAgLy8gU2hvdWxkIGEgbm90aWZpY2F0aW9uIGV2ZW50IGJlIHRyaWdnZXJlZCB3aGVuIGFuIGF0dGVtcHQgd2FzIG1hZGUgdG8gdXBkYXRlIGEgcmVjb3JkIHdoaWxlIG9mZmxpbmVcIixcIiAgICBcXFwibm90aWZ5X2NvbGxpc2lvbl9kZXRlY3RlZFxcXCI6IHRydWUsXCIsXCIgICAgLy8gU2hvdWxkIGEgbm90aWZpY2F0aW9uIGV2ZW50IGJlIHRyaWdnZXJlZCB3aGVuIGFuIHVwZGF0ZSBmYWlsZWQgZHVlIHRvIGRhdGEgY29sbGlzaW9uXCIsXCIgICAgXFxcIm5vdGlmeV9yZW1vdGVfdXBkYXRlX2ZhaWxlZFxcXCI6IHRydWUsXCIsXCIgICAgLy8gU2hvdWxkIGEgbm90aWZpY2F0aW9uIGV2ZW50IGJlIHRyaWdnZXJlZCB3aGVuIGFuIHVwZGF0ZSBmYWlsZWQgZm9yIGEgcmVhc29uIG90aGVyIHRoYW4gZGF0YSBjb2xsaXNpb25cIixcIiAgICBcXFwibm90aWZ5X2xvY2FsX3VwZGF0ZV9hcHBsaWVkXFxcIjogdHJ1ZSxcIixcIiAgICAvLyBTaG91bGQgYSBub3RpZmljYXRpb24gZXZlbnQgYmUgdHJpZ2dlcmVkIHdoZW4gYW4gdXBkYXRlIHdhcyBhcHBsaWVkIHRvIHRoZSBsb2NhbCBkYXRhIHN0b3JlXCIsXCIgICAgXFxcIm5vdGlmeV9yZW1vdGVfdXBkYXRlX2FwcGxpZWRcXFwiOiB0cnVlLFwiLFwiICAgIC8vIFNob3VsZCBhIG5vdGlmaWNhdGlvbiBldmVudCBiZSB0cmlnZ2VyZWQgd2hlbiBhbiB1cGRhdGUgd2FzIGFwcGxpZWQgdG8gdGhlIHJlbW90ZSBkYXRhIHN0b3JlXCIsXCIgICAgXFxcIm5vdGlmeV9kZWx0YV9yZWNlaXZlZFxcXCI6IHRydWUsXCIsXCIgICAgLy8gU2hvdWxkIGEgbm90aWZpY2F0aW9uIGV2ZW50IGJlIHRyaWdnZXJlZCB3aGVuIGEgZGVsdGEgd2FzIHJlY2VpdmVkIGZyb20gdGhlIHJlbW90ZSBkYXRhIHN0b3JlIGZvciB0aGUgZGF0YXNldCBcIixcIiAgICBcXFwibm90aWZ5X3JlY29yZF9kZWx0YV9yZWNlaXZlZFxcXCI6IHRydWUsXCIsXCIgICAgLy8gU2hvdWxkIGEgbm90aWZpY2F0aW9uIGV2ZW50IGJlIHRyaWdnZXJlZCB3aGVuIGEgZGVsdGEgd2FzIHJlY2VpdmVkIGZyb20gdGhlIHJlbW90ZSBkYXRhIHN0b3JlIGZvciBhIHJlY29yZFwiLFwiICAgIFxcXCJub3RpZnlfc3luY19mYWlsZWRcXFwiOiB0cnVlLFwiLFwiICAgIC8vIFNob3VsZCBhIG5vdGlmaWNhdGlvbiBldmVudCBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgc3luYyBsb29wIGZhaWxlZCB0byBjb21wbGV0ZVwiLFwiICAgIFxcXCJkb19jb25zb2xlX2xvZ1xcXCI6IGZhbHNlLFwiLFwiICAgIC8vIFNob3VsZCBsb2cgc3RhdGVtZW50cyBiZSB3cml0dGVuIHRvIGNvbnNvbGUubG9nXCIsXCIgICAgXFxcImNyYXNoZWRfY291bnRfd2FpdFxcXCIgOiAxMCxcIixcIiAgICAvLyBIb3cgbWFueSBzeW5jcyBzaG91bGQgd2UgY2hlY2sgZm9yIHVwZGF0ZXMgb24gY3Jhc2hlZCBpbiBmbGlnaHQgdXBkYXRlcyBiZWZvcmUgd2UgZ2l2ZSB1cCBzZWFyY2hpbmdcIixcIiAgICBcXFwicmVzZW5kX2NyYXNoZWRfdXBkYXRlc1xcXCIgOiB0cnVlLFwiLFwiICAgIC8vIElmIHdlIGhhdmUgcmVhY2hlZCB0aGUgY3Jhc2hlZF9jb3VudF93YWl0IGxpbWl0LCBzaG91bGQgd2UgcmUtdHJ5IHNlbmRpbmcgdGhlIGNyYXNoZWQgaW4gZmxpZ2h0IHBlbmRpbmcgcmVjb3JkXCIsXCIgICAgXFxcInN5bmNfYWN0aXZlXFxcIiA6IHRydWUsXCIsXCIgICAgLy8gSXMgdGhlIGJhY2tncm91bmQgc3luYyB3aXRoIHRoZSBjbG91ZCBjdXJyZW50bHkgYWN0aXZlXCIsXCIgICAgXFxcInN0b3JhZ2Vfc3RyYXRlZ3lcXFwiIDogXFxcImh0bWw1LWZpbGVzeXN0ZW1cXFwiLFwiLFwiICAgIC8vIFN0b3JhZ2Ugc3RyYXRlZ3kgdG8gdXNlIGZvciBMYXduY2hhaXIgLSBzdXBwb3J0ZWQgc3RyYXRlZ2llcyBhcmUgJ2h0bWw1LWZpbGVzeXN0ZW0nIGFuZCAnZG9tJ1wiLFwiICAgIFxcXCJmaWxlX3N5c3RlbV9xdW90YVxcXCIgOiA1MCAqIDEwMjQgKiAxMjA0XCIsXCIgICAgLy8gQW1vdW50IG9mIHNwYWNlIHRvIHJlcXVlc3QgZnJvbSB0aGUgSFRNTDUgZmlsZXN5c3RlbSBBUEkgd2hlbiBydW5uaW5nIGluIGJyb3dzZXJcIixcIiAgfSxcIixcIlwiLFwiICBub3RpZmljYXRpb25zOiB7XCIsXCIgICAgXFxcIkNMSUVOVF9TVE9SQUdFX0ZBSUxFRFxcXCI6IFxcXCJjbGllbnRfc3RvcmFnZV9mYWlsZWRcXFwiLFwiLFwiICAgIC8vIGxvYWRpbmcvc2F2aW5nIHRvIGNsaWVudCBzdG9yYWdlIGZhaWxlZFwiLFwiICAgIFxcXCJTWU5DX1NUQVJURURcXFwiOiBcXFwic3luY19zdGFydGVkXFxcIixcIixcIiAgICAvLyBBIHN5bmMgY3ljbGUgd2l0aCB0aGUgc2VydmVyIGhhcyBiZWVuIHN0YXJ0ZWRcIixcIiAgICBcXFwiU1lOQ19DT01QTEVURVxcXCI6IFxcXCJzeW5jX2NvbXBsZXRlXFxcIixcIixcIiAgICAvLyBBIHN5bmMgY3ljbGUgd2l0aCB0aGUgc2VydmVyIGhhcyBiZWVuIGNvbXBsZXRlZFwiLFwiICAgIFxcXCJPRkZMSU5FX1VQREFURVxcXCI6IFxcXCJvZmZsaW5lX3VwZGF0ZVxcXCIsXCIsXCIgICAgLy8gQW4gYXR0ZW1wdCB3YXMgbWFkZSB0byB1cGRhdGUgYSByZWNvcmQgd2hpbGUgb2ZmbGluZVwiLFwiICAgIFxcXCJDT0xMSVNJT05fREVURUNURURcXFwiOiBcXFwiY29sbGlzaW9uX2RldGVjdGVkXFxcIixcIixcIiAgICAvL1VwZGF0ZSBGYWlsZWQgZHVlIHRvIGRhdGEgY29sbGlzaW9uXCIsXCIgICAgXFxcIlJFTU9URV9VUERBVEVfRkFJTEVEXFxcIjogXFxcInJlbW90ZV91cGRhdGVfZmFpbGVkXFxcIixcIixcIiAgICAvLyBVcGRhdGUgRmFpbGVkIGZvciBhIHJlYXNvbiBvdGhlciB0aGFuIGRhdGEgY29sbGlzaW9uXCIsXCIgICAgXFxcIlJFTU9URV9VUERBVEVfQVBQTElFRFxcXCI6IFxcXCJyZW1vdGVfdXBkYXRlX2FwcGxpZWRcXFwiLFwiLFwiICAgIC8vIEFuIHVwZGF0ZSB3YXMgYXBwbGllZCB0byB0aGUgcmVtb3RlIGRhdGEgc3RvcmVcIixcIiAgICBcXFwiTE9DQUxfVVBEQVRFX0FQUExJRURcXFwiOiBcXFwibG9jYWxfdXBkYXRlX2FwcGxpZWRcXFwiLFwiLFwiICAgIC8vIEFuIHVwZGF0ZSB3YXMgYXBwbGllZCB0byB0aGUgbG9jYWwgZGF0YSBzdG9yZVwiLFwiICAgIFxcXCJERUxUQV9SRUNFSVZFRFxcXCI6IFxcXCJkZWx0YV9yZWNlaXZlZFxcXCIsXCIsXCIgICAgLy8gQSBkZWx0YSB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgcmVtb3RlIGRhdGEgc3RvcmUgZm9yIHRoZSBkYXRhc2V0IFwiLFwiICAgIFxcXCJSRUNPUkRfREVMVEFfUkVDRUlWRURcXFwiOiBcXFwicmVjb3JkX2RlbHRhX3JlY2VpdmVkXFxcIixcIixcIiAgICAvLyBBIGRlbHRhIHdhcyByZWNlaXZlZCBmcm9tIHRoZSByZW1vdGUgZGF0YSBzdG9yZSBmb3IgdGhlIHJlY29yZCBcIixcIiAgICBcXFwiU1lOQ19GQUlMRURcXFwiOiBcXFwic3luY19mYWlsZWRcXFwiXCIsXCIgICAgLy8gU3luYyBsb29wIGZhaWxlZCB0byBjb21wbGV0ZVwiLFwiICB9LFwiLFwiXCIsXCIgIGRhdGFzZXRzOiB7fSxcIixcIlwiLFwiICAvLyBJbml0aWFsaXNlIGNvbmZpZyB0byBkZWZhdWx0IHZhbHVlcztcIixcIiAgY29uZmlnOiB1bmRlZmluZWQsXCIsXCJcIixcIiAgbm90aWZ5X2NhbGxiYWNrOiB1bmRlZmluZWQsXCIsXCJcIixcIiAgaGFzQ3VzdG9tU3luYyA6IHVuZGVmaW5lZCxcIixcIlwiLFwiICAvLyBQVUJMSUMgRlVOQ1RJT04gSU1QTEVNRU5UQVRJT05TXCIsXCIgIGluaXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcIixcIiAgICBzZWxmLmNvbnNvbGVMb2coJ3N5bmMgLSBpbml0IGNhbGxlZCcpO1wiLFwiXCIsXCIgICAgc2VsZi5jb25maWcgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNlbGYuZGVmYXVsdHMpKTtcIixcIiAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcIixcIiAgICAgIHNlbGYuY29uZmlnW2ldID0gb3B0aW9uc1tpXTtcIixcIiAgICB9XCIsXCJcIixcIiAgICBzZWxmLmRhdGFzZXRNb25pdG9yKCk7XCIsXCIgIH0sXCIsXCJcIixcIiAgbm90aWZ5OiBmdW5jdGlvbihjYWxsYmFjaykge1wiLFwiICAgIHNlbGYubm90aWZ5X2NhbGxiYWNrID0gY2FsbGJhY2s7XCIsXCIgIH0sXCIsXCJcIixcIiAgbWFuYWdlOiBmdW5jdGlvbihkYXRhc2V0X2lkLCBvcHRpb25zLCBxdWVyeV9wYXJhbXMsIG1ldGFfZGF0YSwgY2IpIHtcIixcIiAgICBzZWxmLmNvbnNvbGVMb2coJ21hbmFnZSAtIFNUQVJUJyk7XCIsXCJcIixcIiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XCIsXCJcIixcIiAgICB2YXIgZG9NYW5hZ2UgPSBmdW5jdGlvbihkYXRhc2V0KSB7XCIsXCIgICAgICBzZWxmLmNvbnNvbGVMb2coJ2RvTWFuYWdlIGRhdGFzZXQgOjogaW5pdGlhbGlzZWQgPSAnICsgZGF0YXNldC5pbml0aWFsaXNlZCArIFxcXCIgOjogXFxcIiArIGRhdGFzZXRfaWQgKyAnIDo6ICcgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKSk7XCIsXCJcIixcIiAgICAgIHZhciBkYXRhc2V0Q29uZmlnID0gc2VsZi5zZXRPcHRpb25zKG9wdGlvbnMpO1wiLFwiXCIsXCIgICAgICBkYXRhc2V0LnF1ZXJ5X3BhcmFtcyA9IHF1ZXJ5X3BhcmFtcyB8fCBkYXRhc2V0LnF1ZXJ5X3BhcmFtcyB8fCB7fTtcIixcIiAgICAgIGRhdGFzZXQubWV0YV9kYXRhID0gbWV0YV9kYXRhIHx8IGRhdGFzZXQubWV0YV9kYXRhIHx8IHt9O1wiLFwiICAgICAgZGF0YXNldC5jb25maWcgPSBkYXRhc2V0Q29uZmlnO1wiLFwiICAgICAgZGF0YXNldC5zeW5jUnVubmluZyA9IGZhbHNlO1wiLFwiICAgICAgZGF0YXNldC5zeW5jUGVuZGluZyA9IHRydWU7XCIsXCIgICAgICBkYXRhc2V0LmluaXRpYWxpc2VkID0gdHJ1ZTtcIixcIiAgICAgIGRhdGFzZXQubWV0YSA9IHt9O1wiLFwiXCIsXCIgICAgICBzZWxmLnNhdmVEYXRhU2V0KGRhdGFzZXRfaWQsIGZ1bmN0aW9uKCkge1wiLFwiXCIsXCIgICAgICAgIGlmKCBjYiApIHtcIixcIiAgICAgICAgICBjYigpO1wiLFwiICAgICAgICB9XCIsXCIgICAgICB9KTtcIixcIiAgICB9O1wiLFwiXCIsXCIgICAgLy8gQ2hlY2sgaWYgdGhlIGRhdGFzZXQgaXMgYWxyZWFkeSBsb2FkZWRcIixcIiAgICBzZWxmLmdldERhdGFTZXQoZGF0YXNldF9pZCwgZnVuY3Rpb24oZGF0YXNldCkge1wiLFwiICAgICAgc2VsZi5jb25zb2xlTG9nKCdtYW5hZ2UgLSBkYXRhc2V0IGFscmVhZHkgbG9hZGVkJyk7XCIsXCIgICAgICBkb01hbmFnZShkYXRhc2V0KTtcIixcIiAgICB9LCBmdW5jdGlvbihlcnIpIHtcIixcIiAgICAgIHNlbGYuY29uc29sZUxvZygnbWFuYWdlIC0gZGF0YXNldCBub3QgbG9hZGVkLi4uIHRyeWluZyB0byBsb2FkJyk7XCIsXCJcIixcIiAgICAgIC8vIE5vdCBhbHJlYWR5IGxvYWRlZCwgdHJ5IHRvIGxvYWQgZnJvbSBsb2NhbCBzdG9yYWdlXCIsXCIgICAgICBzZWxmLmxvYWREYXRhU2V0KGRhdGFzZXRfaWQsIGZ1bmN0aW9uKGRhdGFzZXQpIHtcIixcIiAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ21hbmFnZSAtIGRhdGFzZXQgbG9hZGVkIGZyb20gbG9jYWwgc3RvcmFnZScpO1wiLFwiXCIsXCIgICAgICAgICAgLy8gTG9hZGluZyBmcm9tIGxvY2FsIHN0b3JhZ2Ugd29ya2VkXCIsXCJcIixcIiAgICAgICAgICAvLyBGaXJlIHRoZSBsb2NhbCB1cGRhdGUgZXZlbnQgdG8gaW5kaWNhdGUgdGhhdCBkYXRhc2V0IHdhcyBsb2FkZWQgZnJvbSBsb2NhbCBzdG9yYWdlXCIsXCIgICAgICAgICAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCBudWxsLCBzZWxmLm5vdGlmaWNhdGlvbnMuTE9DQUxfVVBEQVRFX0FQUExJRUQsIFxcXCJsb2FkXFxcIik7XCIsXCJcIixcIiAgICAgICAgICAvLyBQdXQgdGhlIGRhdGFldCB1bmRlciB0aGUgbWFuYWdlbWVudCBvZiB0aGUgc3luYyBzZXJ2aWNlXCIsXCIgICAgICAgICAgZG9NYW5hZ2UoZGF0YXNldCk7XCIsXCIgICAgICAgIH0sXCIsXCIgICAgICAgIGZ1bmN0aW9uKGVycikge1wiLFwiICAgICAgICAgIC8vIE5vIGRhdGFzZXQgaW4gbWVtb3J5IG9yIGxvY2FsIHN0b3JhZ2UgLSBjcmVhdGUgYSBuZXcgb25lIGFuZCBwdXQgaXQgaW4gbWVtb3J5XCIsXCIgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCdtYW5hZ2UgLSBDcmVhdGluZyBuZXcgZGF0YXNldCBmb3IgaWQgJyArIGRhdGFzZXRfaWQpO1wiLFwiICAgICAgICAgIHZhciBkYXRhc2V0ID0ge307XCIsXCIgICAgICAgICAgZGF0YXNldC5kYXRhID0ge307XCIsXCIgICAgICAgICAgZGF0YXNldC5wZW5kaW5nID0ge307XCIsXCIgICAgICAgICAgc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXSA9IGRhdGFzZXQ7XCIsXCIgICAgICAgICAgZG9NYW5hZ2UoZGF0YXNldCk7XCIsXCIgICAgICAgIH0pO1wiLFwiICAgIH0pO1wiLFwiICB9LFwiLFwiXCIsXCIgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcIixcIiAgICAvLyBNYWtlIHN1cmUgY29uZmlnIGlzIGluaXRpYWxpc2VkXCIsXCIgICAgaWYoICEgc2VsZi5jb25maWcgKSB7XCIsXCIgICAgICBzZWxmLmNvbmZpZyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2VsZi5kZWZhdWx0cykpO1wiLFwiICAgIH1cIixcIlwiLFwiICAgIHZhciBkYXRhc2V0Q29uZmlnID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzZWxmLmNvbmZpZykpO1wiLFwiICAgIHZhciBvcHRpb25zSW4gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKTtcIixcIiAgICBmb3IgKHZhciBrIGluIG9wdGlvbnNJbikge1wiLFwiICAgICAgZGF0YXNldENvbmZpZ1trXSA9IG9wdGlvbnNJbltrXTtcIixcIiAgICB9XCIsXCJcIixcIiAgICByZXR1cm4gZGF0YXNldENvbmZpZztcIixcIiAgfSxcIixcIlwiLFwiICBsaXN0OiBmdW5jdGlvbihkYXRhc2V0X2lkLCBzdWNjZXNzLCBmYWlsdXJlKSB7XCIsXCIgICAgc2VsZi5nZXREYXRhU2V0KGRhdGFzZXRfaWQsIGZ1bmN0aW9uKGRhdGFzZXQpIHtcIixcIiAgICAgIGlmIChkYXRhc2V0ICZhbXA7JmFtcDsgZGF0YXNldC5kYXRhKSB7XCIsXCIgICAgICAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIGRhdGFzZXQgc28gdXBkYXRlcyB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IG1ha2UgaXQgYmFjayBpbnRvIHRoZSBkYXRhc2V0XCIsXCIgICAgICAgIHZhciByZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGFzZXQuZGF0YSkpO1wiLFwiICAgICAgICBzdWNjZXNzKHJlcyk7XCIsXCIgICAgICB9IGVsc2Uge1wiLFwiICAgICAgICBpZihmYWlsdXJlKSBmYWlsdXJlKCdub19kYXRhJyk7XCIsXCIgICAgICB9XCIsXCIgICAgfSwgZnVuY3Rpb24oY29kZSwgbXNnKSB7XCIsXCIgICAgICBpZihmYWlsdXJlKSBmYWlsdXJlKGNvZGUsIG1zZyk7XCIsXCIgICAgfSk7XCIsXCIgIH0sXCIsXCJcIixcIiAgY3JlYXRlOiBmdW5jdGlvbihkYXRhc2V0X2lkLCBkYXRhLCBzdWNjZXNzLCBmYWlsdXJlKSB7XCIsXCIgICAgc2VsZi5hZGRQZW5kaW5nT2JqKGRhdGFzZXRfaWQsIG51bGwsIGRhdGEsIFxcXCJjcmVhdGVcXFwiLCBzdWNjZXNzLCBmYWlsdXJlKTtcIixcIiAgfSxcIixcIlwiLFwiICByZWFkOiBmdW5jdGlvbihkYXRhc2V0X2lkLCB1aWQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcIixcIiAgICAgIHNlbGYuZ2V0RGF0YVNldChkYXRhc2V0X2lkLCBmdW5jdGlvbihkYXRhc2V0KSB7XCIsXCIgICAgICB2YXIgcmVjID0gZGF0YXNldC5kYXRhW3VpZF07XCIsXCIgICAgICBpZiAoIXJlYykge1wiLFwiICAgICAgICBmYWlsdXJlKFxcXCJ1bmtub3duX3VpZFxcXCIpO1wiLFwiICAgICAgfSBlbHNlIHtcIixcIiAgICAgICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgcmVjb3JkIHNvIHVwZGF0ZXMgd2lsbCBub3QgYXV0b21hdGljYWxseSBtYWtlIGl0IGJhY2sgaW50byB0aGUgZGF0YXNldFwiLFwiICAgICAgICB2YXIgcmVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZWMpKTtcIixcIiAgICAgICAgc3VjY2VzcyhyZXMpO1wiLFwiICAgICAgfVwiLFwiICAgIH0sIGZ1bmN0aW9uKGNvZGUsIG1zZykge1wiLFwiICAgICAgaWYoZmFpbHVyZSkgZmFpbHVyZShjb2RlLCBtc2cpO1wiLFwiICAgIH0pO1wiLFwiICB9LFwiLFwiXCIsXCIgIHVwZGF0ZTogZnVuY3Rpb24oZGF0YXNldF9pZCwgdWlkLCBkYXRhLCBzdWNjZXNzLCBmYWlsdXJlKSB7XCIsXCIgICAgc2VsZi5hZGRQZW5kaW5nT2JqKGRhdGFzZXRfaWQsIHVpZCwgZGF0YSwgXFxcInVwZGF0ZVxcXCIsIHN1Y2Nlc3MsIGZhaWx1cmUpO1wiLFwiICB9LFwiLFwiXCIsXCIgICdkZWxldGUnOiBmdW5jdGlvbihkYXRhc2V0X2lkLCB1aWQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcIixcIiAgICBzZWxmLmFkZFBlbmRpbmdPYmooZGF0YXNldF9pZCwgdWlkLCBudWxsLCBcXFwiZGVsZXRlXFxcIiwgc3VjY2VzcywgZmFpbHVyZSk7XCIsXCIgIH0sXCIsXCJcIixcIiAgZ2V0UGVuZGluZzogZnVuY3Rpb24oZGF0YXNldF9pZCwgY2IpIHtcIixcIiAgICBzZWxmLmdldERhdGFTZXQoZGF0YXNldF9pZCwgZnVuY3Rpb24oZGF0YXNldCkge1wiLFwiICAgICAgdmFyIHJlcztcIixcIiAgICAgIGlmKCBkYXRhc2V0ICkge1wiLFwiICAgICAgICByZXMgPSBkYXRhc2V0LnBlbmRpbmc7XCIsXCIgICAgICB9XCIsXCIgICAgICBjYihyZXMpO1wiLFwiICAgIH0sIGZ1bmN0aW9uKGVyciwgZGF0YXRzZXRfaWQpIHtcIixcIiAgICAgICAgc2VsZi5jb25zb2xlTG9nKGVycik7XCIsXCIgICAgfSk7XCIsXCIgIH0sXCIsXCJcIixcIiAgY2xlYXJQZW5kaW5nOiBmdW5jdGlvbihkYXRhc2V0X2lkLCBjYikge1wiLFwiICAgIHNlbGYuZ2V0RGF0YVNldChkYXRhc2V0X2lkLCBmdW5jdGlvbihkYXRhc2V0KSB7XCIsXCIgICAgICBkYXRhc2V0LnBlbmRpbmcgPSB7fTtcIixcIiAgICAgIHNlbGYuc2F2ZURhdGFTZXQoZGF0YXNldF9pZCwgY2IpO1wiLFwiICAgIH0pO1wiLFwiICB9LFwiLFwiXCIsXCIgIGxpc3RDb2xsaXNpb25zIDogZnVuY3Rpb24oZGF0YXNldF9pZCwgc3VjY2VzcywgZmFpbHVyZSl7XCIsXCIgICAgc2VsZi5nZXREYXRhU2V0KGRhdGFzZXRfaWQsIGZ1bmN0aW9uKGRhdGFzZXQpIHtcIixcIiAgICAgIHNlbGYuZG9DbG91ZENhbGwoe1wiLFwiICAgICAgICBcXFwiZGF0YXNldF9pZFxcXCI6IGRhdGFzZXRfaWQsXCIsXCIgICAgICAgIFxcXCJyZXFcXFwiOiB7XCIsXCIgICAgICAgICAgXFxcImZuXFxcIjogXFxcImxpc3RDb2xsaXNpb25zXFxcIixcIixcIiAgICAgICAgICBcXFwibWV0YV9kYXRhXFxcIiA6IGRhdGFzZXQubWV0YV9kYXRhXCIsXCIgICAgICAgIH1cIixcIiAgICAgIH0sIHN1Y2Nlc3MsIGZhaWx1cmUpO1wiLFwiICAgIH0sIGZhaWx1cmUpO1wiLFwiICB9LFwiLFwiXCIsXCIgIHJlbW92ZUNvbGxpc2lvbjogZnVuY3Rpb24oZGF0YXNldF9pZCwgY29saXNzaW9uSGFzaCwgc3VjY2VzcywgZmFpbHVyZSkge1wiLFwiICAgIHNlbGYuZ2V0RGF0YVNldChkYXRhc2V0X2lkLCBmdW5jdGlvbihkYXRhc2V0KSB7XCIsXCIgICAgICBzZWxmLmRvQ2xvdWRDYWxsKHtcIixcIiAgICAgICAgXFxcImRhdGFzZXRfaWRcXFwiIDogZGF0YXNldF9pZCxcIixcIiAgICAgICAgXFxcInJlcVxcXCI6IHtcIixcIiAgICAgICAgICBcXFwiZm5cXFwiOiBcXFwicmVtb3ZlQ29sbGlzaW9uXFxcIixcIixcIiAgICAgICAgICBcXFwiaGFzaFxcXCI6IGNvbGlzc2lvbkhhc2gsXCIsXCIgICAgICAgICAgbWV0YV9kYXRhOiBkYXRhc2V0Lm1ldGFfZGF0YVwiLFwiICAgICAgICB9XCIsXCIgICAgICB9LCBzdWNjZXNzLCBmYWlsdXJlKTtcIixcIiAgICB9KTtcIixcIiAgfSxcIixcIlwiLFwiXCIsXCIgIC8vIFBSSVZBVEUgRlVOQ1RJT05TXCIsXCIgIGlzT25saW5lOiBmdW5jdGlvbihjYWxsYmFjaykge1wiLFwiICAgIHZhciBvbmxpbmUgPSB0cnVlO1wiLFwiXCIsXCIgICAgLy8gZmlyc3QsIGNoZWNrIGlmIG5hdmlnYXRvci5vbmxpbmUgaXMgYXZhaWxhYmxlXCIsXCIgICAgaWYodHlwZW9mIG5hdmlnYXRvci5vbkxpbmUgIT09IFxcXCJ1bmRlZmluZWRcXFwiKXtcIixcIiAgICAgIG9ubGluZSA9IG5hdmlnYXRvci5vbkxpbmU7XCIsXCIgICAgfVwiLFwiXCIsXCIgICAgLy8gc2Vjb25kLCBjaGVjayBpZiBQaG9uZWdhcCBpcyBhdmFpbGFibGUgYW5kIGhhcyBvbmxpbmUgaW5mb1wiLFwiICAgIGlmKG9ubGluZSl7XCIsXCIgICAgICAvL3VzZSBwaG9uZWdhcCB0byBkZXRlcm1pbiBpZiB0aGUgbmV0d29yayBpcyBhdmFpbGFibGVcIixcIiAgICAgIGlmKHR5cGVvZiBuYXZpZ2F0b3IubmV0d29yayAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJmFtcDsmYW1wOyB0eXBlb2YgbmF2aWdhdG9yLm5ldHdvcmsuY29ubmVjdGlvbiAhPT0gXFxcInVuZGVmaW5lZFxcXCIpe1wiLFwiICAgICAgICB2YXIgbmV0d29ya1R5cGUgPSBuYXZpZ2F0b3IubmV0d29yay5jb25uZWN0aW9uLnR5cGU7XCIsXCIgICAgICAgIGlmKG5ldHdvcmtUeXBlID09PSBcXFwibm9uZVxcXCIgfHwgbmV0d29ya1R5cGUgPT09IG51bGwpIHtcIixcIiAgICAgICAgICBvbmxpbmUgPSBmYWxzZTtcIixcIiAgICAgICAgfVwiLFwiICAgICAgfVwiLFwiICAgIH1cIixcIlwiLFwiICAgIHJldHVybiBjYWxsYmFjayhvbmxpbmUpO1wiLFwiICB9LFwiLFwiXCIsXCIgIGRvTm90aWZ5OiBmdW5jdGlvbihkYXRhc2V0X2lkLCB1aWQsIGNvZGUsIG1lc3NhZ2UpIHtcIixcIlwiLFwiICAgIGlmKCBzZWxmLm5vdGlmeV9jYWxsYmFjayApIHtcIixcIiAgICAgIGlmICggc2VsZi5jb25maWdbJ25vdGlmeV8nICsgY29kZV0gKSB7XCIsXCIgICAgICAgIHZhciBub3RpZmljYXRpb24gPSB7XCIsXCIgICAgICAgICAgXFxcImRhdGFzZXRfaWRcXFwiIDogZGF0YXNldF9pZCxcIixcIiAgICAgICAgICBcXFwidWlkXFxcIiA6IHVpZCxcIixcIiAgICAgICAgICBcXFwiY29kZVxcXCIgOiBjb2RlLFwiLFwiICAgICAgICAgIFxcXCJtZXNzYWdlXFxcIiA6IG1lc3NhZ2VcIixcIiAgICAgICAgfTtcIixcIiAgICAgICAgLy8gbWFrZSBzdXJlIHVzZXIgZG9lc24ndCBibG9ja1wiLFwiICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcIixcIiAgICAgICAgICBzZWxmLm5vdGlmeV9jYWxsYmFjayhub3RpZmljYXRpb24pO1wiLFwiICAgICAgICB9LCAwKTtcIixcIiAgICAgIH1cIixcIiAgICB9XCIsXCIgIH0sXCIsXCJcIixcIiAgZ2V0RGF0YVNldDogZnVuY3Rpb24oZGF0YXNldF9pZCwgc3VjY2VzcywgZmFpbHVyZSkge1wiLFwiICAgIHZhciBkYXRhc2V0ID0gc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXTtcIixcIlwiLFwiICAgIGlmIChkYXRhc2V0KSB7XCIsXCIgICAgICBzdWNjZXNzKGRhdGFzZXQpO1wiLFwiICAgIH0gZWxzZSB7XCIsXCIgICAgICBmYWlsdXJlKCd1bmtub3duX2RhdGFzZXQgJyArIGRhdGFzZXRfaWQsIGRhdGFzZXRfaWQpO1wiLFwiICAgIH1cIixcIiAgfSxcIixcIlwiLFwiICBnZXRRdWVyeVBhcmFtczogZnVuY3Rpb24oZGF0YXNldF9pZCwgc3VjY2VzcywgZmFpbHVyZSkge1wiLFwiICAgIHZhciBkYXRhc2V0ID0gc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXTtcIixcIlwiLFwiICAgIGlmIChkYXRhc2V0KSB7XCIsXCIgICAgICBzdWNjZXNzKGRhdGFzZXQucXVlcnlfcGFyYW1zKTtcIixcIiAgICB9IGVsc2Uge1wiLFwiICAgICAgZmFpbHVyZSgndW5rbm93bl9kYXRhc2V0ICcgKyBkYXRhc2V0X2lkLCBkYXRhc2V0X2lkKTtcIixcIiAgICB9XCIsXCIgIH0sXCIsXCJcIixcIiAgc2V0UXVlcnlQYXJhbXM6IGZ1bmN0aW9uKGRhdGFzZXRfaWQsIHF1ZXJ5UGFyYW1zLCBzdWNjZXNzLCBmYWlsdXJlKSB7XCIsXCIgICAgdmFyIGRhdGFzZXQgPSBzZWxmLmRhdGFzZXRzW2RhdGFzZXRfaWRdO1wiLFwiXCIsXCIgICAgaWYgKGRhdGFzZXQpIHtcIixcIiAgICAgIGRhdGFzZXQucXVlcnlfcGFyYW1zID0gcXVlcnlQYXJhbXM7XCIsXCIgICAgICBzZWxmLnNhdmVEYXRhU2V0KGRhdGFzZXRfaWQpO1wiLFwiICAgICAgaWYoIHN1Y2Nlc3MgKSB7XCIsXCIgICAgICAgIHN1Y2Nlc3MoZGF0YXNldC5xdWVyeV9wYXJhbXMpO1wiLFwiICAgICAgfVwiLFwiICAgIH0gZWxzZSB7XCIsXCIgICAgICBpZiAoIGZhaWx1cmUgKSB7XCIsXCIgICAgICAgIGZhaWx1cmUoJ3Vua25vd25fZGF0YXNldCAnICsgZGF0YXNldF9pZCwgZGF0YXNldF9pZCk7XCIsXCIgICAgICB9XCIsXCIgICAgfVwiLFwiICB9LFwiLFwiXCIsXCIgIGdldE1ldGFEYXRhOiBmdW5jdGlvbihkYXRhc2V0X2lkLCBzdWNjZXNzLCBmYWlsdXJlKSB7XCIsXCIgICAgdmFyIGRhdGFzZXQgPSBzZWxmLmRhdGFzZXRzW2RhdGFzZXRfaWRdO1wiLFwiXCIsXCIgICAgaWYgKGRhdGFzZXQpIHtcIixcIiAgICAgIHN1Y2Nlc3MoZGF0YXNldC5tZXRhX2RhdGEpO1wiLFwiICAgIH0gZWxzZSB7XCIsXCIgICAgICBmYWlsdXJlKCd1bmtub3duX2RhdGFzZXQgJyArIGRhdGFzZXRfaWQsIGRhdGFzZXRfaWQpO1wiLFwiICAgIH1cIixcIiAgfSxcIixcIlwiLFwiICBzZXRNZXRhRGF0YTogZnVuY3Rpb24oZGF0YXNldF9pZCwgbWV0YURhdGEsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcIixcIiAgICB2YXIgZGF0YXNldCA9IHNlbGYuZGF0YXNldHNbZGF0YXNldF9pZF07XCIsXCJcIixcIiAgICBpZiAoZGF0YXNldCkge1wiLFwiICAgICAgZGF0YXNldC5tZXRhX2RhdGEgPSBtZXRhRGF0YTtcIixcIiAgICAgIHNlbGYuc2F2ZURhdGFTZXQoZGF0YXNldF9pZCk7XCIsXCIgICAgICBpZiggc3VjY2VzcyApIHtcIixcIiAgICAgICAgc3VjY2VzcyhkYXRhc2V0Lm1ldGFfZGF0YSk7XCIsXCIgICAgICB9XCIsXCIgICAgfSBlbHNlIHtcIixcIiAgICAgIGlmKCBmYWlsdXJlICkge1wiLFwiICAgICAgICBmYWlsdXJlKCd1bmtub3duX2RhdGFzZXQgJyArIGRhdGFzZXRfaWQsIGRhdGFzZXRfaWQpO1wiLFwiICAgICAgfVwiLFwiICAgIH1cIixcIiAgfSxcIixcIlwiLFwiICBnZXRDb25maWc6IGZ1bmN0aW9uKGRhdGFzZXRfaWQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcIixcIiAgICB2YXIgZGF0YXNldCA9IHNlbGYuZGF0YXNldHNbZGF0YXNldF9pZF07XCIsXCJcIixcIiAgICBpZiAoZGF0YXNldCkge1wiLFwiICAgICAgc3VjY2VzcyhkYXRhc2V0LmNvbmZpZyk7XCIsXCIgICAgfSBlbHNlIHtcIixcIiAgICAgIGZhaWx1cmUoJ3Vua25vd25fZGF0YXNldCAnICsgZGF0YXNldF9pZCwgZGF0YXNldF9pZCk7XCIsXCIgICAgfVwiLFwiICB9LFwiLFwiXCIsXCIgIHNldENvbmZpZzogZnVuY3Rpb24oZGF0YXNldF9pZCwgY29uZmlnLCBzdWNjZXNzLCBmYWlsdXJlKSB7XCIsXCIgICAgdmFyIGRhdGFzZXQgPSBzZWxmLmRhdGFzZXRzW2RhdGFzZXRfaWRdO1wiLFwiXCIsXCIgICAgaWYgKGRhdGFzZXQpIHtcIixcIiAgICAgIHZhciBmdWxsQ29uZmlnID0gc2VsZi5zZXRPcHRpb25zKGNvbmZpZyk7XCIsXCIgICAgICBkYXRhc2V0LmNvbmZpZyA9IGZ1bGxDb25maWc7XCIsXCIgICAgICBzZWxmLnNhdmVEYXRhU2V0KGRhdGFzZXRfaWQpO1wiLFwiICAgICAgaWYoIHN1Y2Nlc3MgKSB7XCIsXCIgICAgICAgIHN1Y2Nlc3MoZGF0YXNldC5jb25maWcpO1wiLFwiICAgICAgfVwiLFwiICAgIH0gZWxzZSB7XCIsXCIgICAgICBpZiggZmFpbHVyZSApIHtcIixcIiAgICAgICAgZmFpbHVyZSgndW5rbm93bl9kYXRhc2V0ICcgKyBkYXRhc2V0X2lkLCBkYXRhc2V0X2lkKTtcIixcIiAgICAgIH1cIixcIiAgICB9XCIsXCIgIH0sXCIsXCJcIixcIiAgc3RvcFN5bmM6IGZ1bmN0aW9uKGRhdGFzZXRfaWQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcIixcIiAgICBzZWxmLnNldENvbmZpZyhkYXRhc2V0X2lkLCB7XFxcInN5bmNfYWN0aXZlXFxcIiA6IGZhbHNlfSwgZnVuY3Rpb24oKSB7XCIsXCIgICAgICBpZiggc3VjY2VzcyApIHtcIixcIiAgICAgICAgc3VjY2VzcygpO1wiLFwiICAgICAgfVwiLFwiICAgIH0sIGZhaWx1cmUpO1wiLFwiICB9LFwiLFwiXCIsXCIgIHN0YXJ0U3luYzogZnVuY3Rpb24oZGF0YXNldF9pZCwgc3VjY2VzcywgZmFpbHVyZSkge1wiLFwiICAgIHNlbGYuc2V0Q29uZmlnKGRhdGFzZXRfaWQsIHtcXFwic3luY19hY3RpdmVcXFwiIDogdHJ1ZX0sIGZ1bmN0aW9uKCkge1wiLFwiICAgICAgaWYoIHN1Y2Nlc3MgKSB7XCIsXCIgICAgICAgIHN1Y2Nlc3MoKTtcIixcIiAgICAgIH1cIixcIiAgICB9LCBmYWlsdXJlKTtcIixcIiAgfSxcIixcIlwiLFwiICBkb1N5bmM6IGZ1bmN0aW9uKGRhdGFzZXRfaWQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcIixcIiAgICB2YXIgZGF0YXNldCA9IHNlbGYuZGF0YXNldHNbZGF0YXNldF9pZF07XCIsXCJcIixcIiAgICBpZiAoZGF0YXNldCkge1wiLFwiICAgICAgZGF0YXNldC5zeW5jUGVuZGluZyA9IHRydWU7XCIsXCIgICAgICBzZWxmLnNhdmVEYXRhU2V0KGRhdGFzZXRfaWQpO1wiLFwiICAgICAgaWYoIHN1Y2Nlc3MgKSB7XCIsXCIgICAgICAgIHN1Y2Nlc3MoKTtcIixcIiAgICAgIH1cIixcIiAgICB9IGVsc2Uge1wiLFwiICAgICAgaWYoIGZhaWx1cmUgKSB7XCIsXCIgICAgICAgIGZhaWx1cmUoJ3Vua25vd25fZGF0YXNldCAnICsgZGF0YXNldF9pZCwgZGF0YXNldF9pZCk7XCIsXCIgICAgICB9XCIsXCIgICAgfVwiLFwiICB9LFwiLFwiXCIsXCIgIGZvcmNlU3luYzogZnVuY3Rpb24oZGF0YXNldF9pZCwgc3VjY2VzcywgZmFpbHVyZSkge1wiLFwiICAgIHZhciBkYXRhc2V0ID0gc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXTtcIixcIlwiLFwiICAgIGlmIChkYXRhc2V0KSB7XCIsXCIgICAgICBkYXRhc2V0LnN5bmNGb3JjZWQgPSB0cnVlO1wiLFwiICAgICAgc2VsZi5zYXZlRGF0YVNldChkYXRhc2V0X2lkKTtcIixcIiAgICAgIGlmKCBzdWNjZXNzICkge1wiLFwiICAgICAgICBzdWNjZXNzKCk7XCIsXCIgICAgICB9XCIsXCIgICAgfSBlbHNlIHtcIixcIiAgICAgIGlmKCBmYWlsdXJlICkge1wiLFwiICAgICAgICBmYWlsdXJlKCd1bmtub3duX2RhdGFzZXQgJyArIGRhdGFzZXRfaWQsIGRhdGFzZXRfaWQpO1wiLFwiICAgICAgfVwiLFwiICAgIH1cIixcIiAgfSxcIixcIlwiLFwiICBzb3J0T2JqZWN0IDogZnVuY3Rpb24ob2JqZWN0KSB7XCIsXCIgICAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFxcXCJvYmplY3RcXFwiIHx8IG9iamVjdCA9PT0gbnVsbCkge1wiLFwiICAgICAgcmV0dXJuIG9iamVjdDtcIixcIiAgICB9XCIsXCJcIixcIiAgICB2YXIgcmVzdWx0ID0gW107XCIsXCJcIixcIiAgICBPYmplY3Qua2V5cyhvYmplY3QpLnNvcnQoKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1wiLFwiICAgICAgcmVzdWx0LnB1c2goe1wiLFwiICAgICAgICBrZXk6IGtleSxcIixcIiAgICAgICAgdmFsdWU6IHNlbGYuc29ydE9iamVjdChvYmplY3Rba2V5XSlcIixcIiAgICAgIH0pO1wiLFwiICAgIH0pO1wiLFwiXCIsXCIgICAgcmV0dXJuIHJlc3VsdDtcIixcIiAgfSxcIixcIlwiLFwiICBzb3J0ZWRTdHJpbmdpZnkgOiBmdW5jdGlvbihvYmopIHtcIixcIlwiLFwiICAgIHZhciBzdHIgPSAnJztcIixcIlwiLFwiICAgIHRyeSB7XCIsXCIgICAgICBzdHIgPSBKU09OLnN0cmluZ2lmeShzZWxmLnNvcnRPYmplY3Qob2JqKSk7XCIsXCIgICAgfSBjYXRjaCAoZSkge1wiLFwiICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc3RyaW5naWZ5aW5nIHNvcnRlZCBvYmplY3Q6JyArIGUpO1wiLFwiICAgIH1cIixcIlwiLFwiICAgIHJldHVybiBzdHI7XCIsXCIgIH0sXCIsXCJcIixcIiAgZ2VuZXJhdGVIYXNoOiBmdW5jdGlvbihvYmplY3QpIHtcIixcIiAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEoc2VsZi5zb3J0ZWRTdHJpbmdpZnkob2JqZWN0KSk7XCIsXCIgICAgcmV0dXJuIGhhc2gudG9TdHJpbmcoKTtcIixcIiAgfSxcIixcIlwiLFwiICBhZGRQZW5kaW5nT2JqOiBmdW5jdGlvbihkYXRhc2V0X2lkLCB1aWQsIGRhdGEsIGFjdGlvbiwgc3VjY2VzcywgZmFpbHVyZSkge1wiLFwiICAgIHNlbGYuaXNPbmxpbmUoZnVuY3Rpb24gKG9ubGluZSkge1wiLFwiICAgICAgaWYgKCFvbmxpbmUpIHtcIixcIiAgICAgICAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCB1aWQsIHNlbGYubm90aWZpY2F0aW9ucy5PRkZMSU5FX1VQREFURSwgYWN0aW9uKTtcIixcIiAgICAgIH1cIixcIiAgICB9KTtcIixcIlwiLFwiICAgIGZ1bmN0aW9uIHN0b3JlUGVuZGluZ09iamVjdChvYmopIHtcIixcIiAgICAgIG9iai5oYXNoID0gc2VsZi5nZW5lcmF0ZUhhc2gob2JqKTtcIixcIlwiLFwiICAgICAgc2VsZi5nZXREYXRhU2V0KGRhdGFzZXRfaWQsIGZ1bmN0aW9uKGRhdGFzZXQpIHtcIixcIlwiLFwiICAgICAgICBkYXRhc2V0LnBlbmRpbmdbb2JqLmhhc2hdID0gb2JqO1wiLFwiXCIsXCIgICAgICAgIHNlbGYudXBkYXRlRGF0YXNldEZyb21Mb2NhbChkYXRhc2V0LCBvYmopO1wiLFwiXCIsXCIgICAgICAgIGlmKHNlbGYuY29uZmlnLmF1dG9fc3luY19sb2NhbF91cGRhdGVzKSB7XCIsXCIgICAgICAgICAgZGF0YXNldC5zeW5jUGVuZGluZyA9IHRydWU7XCIsXCIgICAgICAgIH1cIixcIiAgICAgICAgc2VsZi5zYXZlRGF0YVNldChkYXRhc2V0X2lkKTtcIixcIiAgICAgICAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCB1aWQsIHNlbGYubm90aWZpY2F0aW9ucy5MT0NBTF9VUERBVEVfQVBQTElFRCwgYWN0aW9uKTtcIixcIlwiLFwiICAgICAgICBzdWNjZXNzKG9iaik7XCIsXCIgICAgICB9LCBmdW5jdGlvbihjb2RlLCBtc2cpIHtcIixcIiAgICAgICAgaWYoZmFpbHVyZSkgZmFpbHVyZShjb2RlLCBtc2cpO1wiLFwiICAgICAgfSk7XCIsXCIgICAgfVwiLFwiXCIsXCIgICAgdmFyIHBlbmRpbmdPYmogPSB7fTtcIixcIiAgICBwZW5kaW5nT2JqLmluRmxpZ2h0ID0gZmFsc2U7XCIsXCIgICAgcGVuZGluZ09iai5hY3Rpb24gPSBhY3Rpb247XCIsXCIgICAgcGVuZGluZ09iai5wb3N0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSk7XCIsXCIgICAgcGVuZGluZ09iai5wb3N0SGFzaCA9IHNlbGYuZ2VuZXJhdGVIYXNoKHBlbmRpbmdPYmoucG9zdCk7XCIsXCIgICAgcGVuZGluZ09iai50aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcIixcIiAgICBpZiggXFxcImNyZWF0ZVxcXCIgPT09IGFjdGlvbiApIHtcIixcIiAgICAgIHBlbmRpbmdPYmoudWlkID0gcGVuZGluZ09iai5wb3N0SGFzaDtcIixcIiAgICAgIHN0b3JlUGVuZGluZ09iamVjdChwZW5kaW5nT2JqKTtcIixcIiAgICB9IGVsc2Uge1wiLFwiICAgICAgc2VsZi5yZWFkKGRhdGFzZXRfaWQsIHVpZCwgZnVuY3Rpb24ocmVjKSB7XCIsXCIgICAgICAgIHBlbmRpbmdPYmoudWlkID0gdWlkO1wiLFwiICAgICAgICBwZW5kaW5nT2JqLnByZSA9IHJlYy5kYXRhO1wiLFwiICAgICAgICBwZW5kaW5nT2JqLnByZUhhc2ggPSBzZWxmLmdlbmVyYXRlSGFzaChyZWMuZGF0YSk7XCIsXCIgICAgICAgIHN0b3JlUGVuZGluZ09iamVjdChwZW5kaW5nT2JqKTtcIixcIiAgICAgIH0sIGZ1bmN0aW9uKGNvZGUsIG1zZykge1wiLFwiICAgICAgICBmYWlsdXJlKGNvZGUsIG1zZyk7XCIsXCIgICAgICB9KTtcIixcIiAgICB9XCIsXCIgIH0sXCIsXCJcIixcIiAgc3luY0xvb3A6IGZ1bmN0aW9uKGRhdGFzZXRfaWQpIHtcIixcIiAgICBzZWxmLmdldERhdGFTZXQoZGF0YXNldF9pZCwgZnVuY3Rpb24oZGF0YVNldCkge1wiLFwiICAgIFwiLFwiICAgICAgLy8gVGhlIHN5bmMgbG9vcCBpcyBjdXJyZW50bHkgYWN0aXZlXCIsXCIgICAgICBkYXRhU2V0LnN5bmNQZW5kaW5nID0gZmFsc2U7XCIsXCIgICAgICBkYXRhU2V0LnN5bmNSdW5uaW5nID0gdHJ1ZTtcIixcIiAgICAgIGRhdGFTZXQuc3luY0xvb3BTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1wiLFwiICAgICAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCBudWxsLCBzZWxmLm5vdGlmaWNhdGlvbnMuU1lOQ19TVEFSVEVELCBudWxsKTtcIixcIlwiLFwiICAgICAgc2VsZi5pc09ubGluZShmdW5jdGlvbihvbmxpbmUpIHtcIixcIiAgICAgICAgaWYgKCFvbmxpbmUpIHtcIixcIiAgICAgICAgICBzZWxmLnN5bmNDb21wbGV0ZShkYXRhc2V0X2lkLCBcXFwib2ZmbGluZVxcXCIsIHNlbGYubm90aWZpY2F0aW9ucy5TWU5DX0ZBSUxFRCk7XCIsXCIgICAgICAgIH0gZWxzZSB7XCIsXCIgICAgICAgICAgc2VsZi5jaGVja0hhc0N1c3RvbVN5bmMoZGF0YXNldF9pZCwgZnVuY3Rpb24oKSB7XCIsXCJcIixcIiAgICAgICAgICAgIHZhciBzeW5jTG9vcFBhcmFtcyA9IHt9O1wiLFwiICAgICAgICAgICAgc3luY0xvb3BQYXJhbXMuZm4gPSAnc3luYyc7XCIsXCIgICAgICAgICAgICBzeW5jTG9vcFBhcmFtcy5kYXRhc2V0X2lkID0gZGF0YXNldF9pZDtcIixcIiAgICAgICAgICAgIHN5bmNMb29wUGFyYW1zLnF1ZXJ5X3BhcmFtcyA9IGRhdGFTZXQucXVlcnlfcGFyYW1zO1wiLFwiICAgICAgICAgICAgc3luY0xvb3BQYXJhbXMuY29uZmlnID0gZGF0YVNldC5jb25maWc7XCIsXCIgICAgICAgICAgICBzeW5jTG9vcFBhcmFtcy5tZXRhX2RhdGEgPSBkYXRhU2V0Lm1ldGFfZGF0YTtcIixcIiAgICAgICAgICAgIC8vdmFyIGRhdGFzZXRIYXNoID0gc2VsZi5nZW5lcmF0ZUxvY2FsRGF0YXNldEhhc2goZGF0YVNldCk7XCIsXCIgICAgICAgICAgICBzeW5jTG9vcFBhcmFtcy5kYXRhc2V0X2hhc2ggPSBkYXRhU2V0Lmhhc2g7XCIsXCIgICAgICAgICAgICBzeW5jTG9vcFBhcmFtcy5hY2tub3dsZWRnZW1lbnRzID0gZGF0YVNldC5hY2tub3dsZWRnZW1lbnRzIHx8IFtdO1wiLFwiXCIsXCIgICAgICAgICAgICB2YXIgcGVuZGluZyA9IGRhdGFTZXQucGVuZGluZztcIixcIiAgICAgICAgICAgIHZhciBwZW5kaW5nQXJyYXkgPSBbXTtcIixcIiAgICAgICAgICAgIGZvcih2YXIgaSBpbiBwZW5kaW5nICkge1wiLFwiICAgICAgICAgICAgICAvLyBNYXJrIHRoZSBwZW5kaW5nIHJlY29yZHMgd2UgYXJlIGFib3V0IHRvIHN1Ym1pdCBhcyBpbmZsaWdodCBhbmQgYWRkIHRoZW0gdG8gdGhlIGFycmF5IGZvciBzdWJtaXNzaW9uXCIsXCIgICAgICAgICAgICAgIC8vIERvbid0IHJlLWFkZCBwcmV2aW91cyBpbkZsaWdodCBwZW5kaW5nIHJlY29yZHMgd2hvIHdoYXZlIGNyYXNoZWQgLSBpLmUuIHdobydzIGN1cnJlbnQgc3RhdGUgaXMgdW5rbm93blwiLFwiICAgICAgICAgICAgICAvLyBEb24ndCBhZGQgZGVsYXllZCByZWNvcmRzXCIsXCIgICAgICAgICAgICAgIGlmKCAhcGVuZGluZ1tpXS5pbkZsaWdodCAmYW1wOyZhbXA7ICFwZW5kaW5nW2ldLmNyYXNoZWQgJmFtcDsmYW1wOyAhcGVuZGluZ1tpXS5kZWxheWVkKSB7XCIsXCIgICAgICAgICAgICAgICAgcGVuZGluZ1tpXS5pbkZsaWdodCA9IHRydWU7XCIsXCIgICAgICAgICAgICAgICAgcGVuZGluZ1tpXS5pbkZsaWdodERhdGUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcIixcIiAgICAgICAgICAgICAgICBwZW5kaW5nQXJyYXkucHVzaChwZW5kaW5nW2ldKTtcIixcIiAgICAgICAgICAgICAgfVwiLFwiICAgICAgICAgICAgfVwiLFwiICAgICAgICAgICAgc3luY0xvb3BQYXJhbXMucGVuZGluZyA9IHBlbmRpbmdBcnJheTtcIixcIlwiLFwiICAgICAgICAgICAgaWYoIHBlbmRpbmdBcnJheS5sZW5ndGggJmd0OyAwICkge1wiLFwiICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ1N0YXJ0aW5nIHN5bmMgbG9vcCAtIGdsb2JhbCBoYXNoID0gJyArIGRhdGFTZXQuaGFzaCArICcgOjogcGFyYW1zID0gJyArIEpTT04uc3RyaW5naWZ5KHN5bmNMb29wUGFyYW1zLCBudWxsLCAyKSk7XCIsXCIgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgICB0cnkge1wiLFwiICAgICAgICAgICAgICBzZWxmLmRvQ2xvdWRDYWxsKHtcIixcIiAgICAgICAgICAgICAgICAnZGF0YXNldF9pZCc6IGRhdGFzZXRfaWQsXCIsXCIgICAgICAgICAgICAgICAgJ3JlcSc6IHN5bmNMb29wUGFyYW1zXCIsXCIgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKHJlcykge1wiLFwiICAgICAgICAgICAgICAgIHZhciByZWM7XCIsXCJcIixcIiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzVXBkYXRlcyh1cGRhdGVzLCBub3RpZmljYXRpb24sIGFja25vd2xlZGdlbWVudHMpIHtcIixcIiAgICAgICAgICAgICAgICAgIGlmKCB1cGRhdGVzICkge1wiLFwiICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB1cCBpbiB1cGRhdGVzKSB7XCIsXCIgICAgICAgICAgICAgICAgICAgICAgcmVjID0gdXBkYXRlc1t1cF07XCIsXCIgICAgICAgICAgICAgICAgICAgICAgYWNrbm93bGVkZ2VtZW50cy5wdXNoKHJlYyk7XCIsXCIgICAgICAgICAgICAgICAgICAgICAgaWYoIGRhdGFTZXQucGVuZGluZ1t1cF0gJmFtcDsmYW1wOyBkYXRhU2V0LnBlbmRpbmdbdXBdLmluRmxpZ2h0ICZhbXA7JmFtcDsgIWRhdGFTZXQucGVuZGluZ1t1cF0uY3Jhc2hlZCApIHtcIixcIiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhU2V0LnBlbmRpbmdbdXBdO1wiLFwiICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCByZWMudWlkLCBub3RpZmljYXRpb24sIHJlYyk7XCIsXCIgICAgICAgICAgICAgICAgICAgICAgfVwiLFwiICAgICAgICAgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgICAgICAgfVwiLFwiXCIsXCIgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGFueSBuZXcgcGVuZGluZyByZWNvcmRzIG5lZWQgdG8gYmUgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBjdXJyZW50IHN0YXRlIG9mIHBsYXkuXCIsXCIgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVQZW5kaW5nRnJvbU5ld0RhdGEoZGF0YXNldF9pZCwgZGF0YVNldCwgcmVzKTtcIixcIlwiLFwiICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBhbnkgcHJldmlvdXNseSBjcmFzaGVkIGluZmxpZ2h0IHJlY29yZHMgY2FuIG5vdyBiZSByZXNvbHZlZFwiLFwiICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlQ3Jhc2hlZEluRmxpZ2h0RnJvbU5ld0RhdGEoZGF0YXNldF9pZCwgZGF0YVNldCwgcmVzKTtcIixcIlwiLFwiICAgICAgICAgICAgICAgIC8vQ2hlY2sgdG8gc2VlIGlmIGFueSBkZWxheWVkIHBlbmRpbmcgcmVjb3JkcyBjYW4gbm93IGJlIHNldCB0byByZWFkeVwiLFwiICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlRGVsYXllZEZyb21OZXdEYXRhKGRhdGFzZXRfaWQsIGRhdGFTZXQsIHJlcyk7XCIsXCJcIixcIiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG5ldyBkYXRhc2V0IHdpdGggZGV0YWlscyBvZiBhbnkgaW5mbGlnaHQgdXBkYXRlcyB3aGljaCB3ZSBoYXZlIG5vdCByZWNlaXZlZCBhIHJlc3BvbnNlIG9uXCIsXCIgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVOZXdEYXRhRnJvbUluRmxpZ2h0KGRhdGFzZXRfaWQsIGRhdGFTZXQsIHJlcyk7XCIsXCJcIixcIiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG5ldyBkYXRhc2V0IHdpdGggZGV0YWlscyBvZiBhbnkgcGVuZGluZyB1cGRhdGVzXCIsXCIgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVOZXdEYXRhRnJvbVBlbmRpbmcoZGF0YXNldF9pZCwgZGF0YVNldCwgcmVzKTtcIixcIlwiLFwiXCIsXCJcIixcIiAgICAgICAgICAgICAgICBpZiAocmVzLnJlY29yZHMpIHtcIixcIiAgICAgICAgICAgICAgICAgIC8vIEZ1bGwgRGF0YXNldCByZXR1cm5lZFwiLFwiICAgICAgICAgICAgICAgICAgZGF0YVNldC5kYXRhID0gcmVzLnJlY29yZHM7XCIsXCIgICAgICAgICAgICAgICAgICBkYXRhU2V0Lmhhc2ggPSByZXMuaGFzaDtcIixcIlwiLFwiICAgICAgICAgICAgICAgICAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCByZXMuaGFzaCwgc2VsZi5ub3RpZmljYXRpb25zLkRFTFRBX1JFQ0VJVkVELCAnZnVsbCBkYXRhc2V0Jyk7XCIsXCIgICAgICAgICAgICAgICAgfVwiLFwiXCIsXCIgICAgICAgICAgICAgICAgaWYgKHJlcy51cGRhdGVzKSB7XCIsXCIgICAgICAgICAgICAgICAgICB2YXIgYWNrbm93bGVkZ2VtZW50cyA9IFtdO1wiLFwiICAgICAgICAgICAgICAgICAgcHJvY2Vzc1VwZGF0ZXMocmVzLnVwZGF0ZXMuYXBwbGllZCwgc2VsZi5ub3RpZmljYXRpb25zLlJFTU9URV9VUERBVEVfQVBQTElFRCwgYWNrbm93bGVkZ2VtZW50cyk7XCIsXCIgICAgICAgICAgICAgICAgICBwcm9jZXNzVXBkYXRlcyhyZXMudXBkYXRlcy5mYWlsZWQsIHNlbGYubm90aWZpY2F0aW9ucy5SRU1PVEVfVVBEQVRFX0ZBSUxFRCwgYWNrbm93bGVkZ2VtZW50cyk7XCIsXCIgICAgICAgICAgICAgICAgICBwcm9jZXNzVXBkYXRlcyhyZXMudXBkYXRlcy5jb2xsaXNpb25zLCBzZWxmLm5vdGlmaWNhdGlvbnMuQ09MTElTSU9OX0RFVEVDVEVELCBhY2tub3dsZWRnZW1lbnRzKTtcIixcIiAgICAgICAgICAgICAgICAgIGRhdGFTZXQuYWNrbm93bGVkZ2VtZW50cyA9IGFja25vd2xlZGdlbWVudHM7XCIsXCIgICAgICAgICAgICAgICAgfVwiLFwiXCIsXCIgICAgICAgICAgICAgICAgaWYgKCFyZXMucmVjb3JkcyAmYW1wOyZhbXA7IHJlcy5oYXNoICZhbXA7JmFtcDsgcmVzLmhhc2ggIT09IGRhdGFTZXQuaGFzaCkge1wiLFwiICAgICAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKFxcXCJMb2NhbCBkYXRhc2V0IHN0YWxlIC0gc3luY2luZyByZWNvcmRzIDo6IGxvY2FsIGhhc2g9IFxcXCIgKyBkYXRhU2V0Lmhhc2ggKyBcXFwiIC0gcmVtb3RlSGFzaD1cXFwiICsgcmVzLmhhc2gpO1wiLFwiICAgICAgICAgICAgICAgICAgLy8gRGlmZmVyZW50IGhhc2ggdmFsdWUgcmV0dXJuZWQgLSBTeW5jIGluZGl2aWR1YWwgcmVjb3Jkc1wiLFwiICAgICAgICAgICAgICAgICAgc2VsZi5zeW5jUmVjb3JkcyhkYXRhc2V0X2lkKTtcIixcIiAgICAgICAgICAgICAgICB9IGVsc2Uge1wiLFwiICAgICAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKFxcXCJMb2NhbCBkYXRhc2V0IHVwIHRvIGRhdGVcXFwiKTtcIixcIiAgICAgICAgICAgICAgICAgIHNlbGYuc3luY0NvbXBsZXRlKGRhdGFzZXRfaWQsICBcXFwib25saW5lXFxcIiwgc2VsZi5ub3RpZmljYXRpb25zLlNZTkNfQ09NUExFVEUpO1wiLFwiICAgICAgICAgICAgICAgIH1cIixcIiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24obXNnLCBlcnIpIHtcIixcIiAgICAgICAgICAgICAgICAvLyBUaGUgQUpBWCBjYWxsIGZhaWxlZCB0byBjb21wbGV0ZSBzdWNjZXNmdWxseSwgc28gdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IHBlbmRpbmcgdXBkYXRlcyBpcyB1bmtub3duXCIsXCIgICAgICAgICAgICAgICAgLy8gTWFyayB0aGVtIGFzIFxcXCJjcmFzaGVkXFxcIi4gVGhlIG5leHQgdGltZSBhIHN5bmNMb29wIGNvbXBsZXRldHMgc3VjY2Vzc2Z1bGx5LCB3ZSB3aWxsIHJldmlldyB0aGUgY3Jhc2hlZFwiLFwiICAgICAgICAgICAgICAgIC8vIHJlY29yZHMgdG8gc2VlIGlmIHdlIGNhbiBkZXRlcm1pbmUgdGhlaXIgY3VycmVudCBzdGF0ZS5cIixcIiAgICAgICAgICAgICAgICBzZWxmLm1hcmtJbkZsaWdodEFzQ3Jhc2hlZChkYXRhU2V0KTtcIixcIiAgICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coXFxcInN5bmNMb29wIGZhaWxlZCA6IG1zZz1cXFwiICsgbXNnICsgXFxcIiA6OiBlcnIgPSBcXFwiICsgZXJyKTtcIixcIiAgICAgICAgICAgICAgICBzZWxmLnN5bmNDb21wbGV0ZShkYXRhc2V0X2lkLCBtc2csIHNlbGYubm90aWZpY2F0aW9ucy5TWU5DX0ZBSUxFRCk7XCIsXCIgICAgICAgICAgICAgIH0pO1wiLFwiICAgICAgICAgICAgfVwiLFwiICAgICAgICAgICAgY2F0Y2ggKGUpIHtcIixcIiAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCdFcnJvciBwZXJmb3JtaW5nIHN5bmMgLSAnICsgZSk7XCIsXCIgICAgICAgICAgICAgIHNlbGYuc3luY0NvbXBsZXRlKGRhdGFzZXRfaWQsIGUsIHNlbGYubm90aWZpY2F0aW9ucy5TWU5DX0ZBSUxFRCk7XCIsXCIgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgfSk7XCIsXCIgICAgICAgIH1cIixcIiAgICAgIH0pO1wiLFwiICAgIH0pO1wiLFwiICB9LFwiLFwiXCIsXCIgIHN5bmNSZWNvcmRzOiBmdW5jdGlvbihkYXRhc2V0X2lkKSB7XCIsXCJcIixcIiAgICBzZWxmLmdldERhdGFTZXQoZGF0YXNldF9pZCwgZnVuY3Rpb24oZGF0YVNldCkge1wiLFwiXCIsXCIgICAgICB2YXIgbG9jYWxEYXRhU2V0ID0gZGF0YVNldC5kYXRhIHx8IHt9O1wiLFwiXCIsXCIgICAgICB2YXIgY2xpZW50UmVjcyA9IHt9O1wiLFwiICAgICAgZm9yICh2YXIgaSBpbiBsb2NhbERhdGFTZXQpIHtcIixcIiAgICAgICAgdmFyIHVpZCA9IGk7XCIsXCIgICAgICAgIHZhciBoYXNoID0gbG9jYWxEYXRhU2V0W2ldLmhhc2g7XCIsXCIgICAgICAgIGNsaWVudFJlY3NbdWlkXSA9IGhhc2g7XCIsXCIgICAgICB9XCIsXCJcIixcIiAgICAgIHZhciBzeW5jUmVjUGFyYW1zID0ge307XCIsXCJcIixcIiAgICAgIHN5bmNSZWNQYXJhbXMuZm4gPSAnc3luY1JlY29yZHMnO1wiLFwiICAgICAgc3luY1JlY1BhcmFtcy5kYXRhc2V0X2lkID0gZGF0YXNldF9pZDtcIixcIiAgICAgIHN5bmNSZWNQYXJhbXMucXVlcnlfcGFyYW1zID0gZGF0YVNldC5xdWVyeV9wYXJhbXM7XCIsXCIgICAgICBzeW5jUmVjUGFyYW1zLmNsaWVudFJlY3MgPSBjbGllbnRSZWNzO1wiLFwiXCIsXCIgICAgICBzZWxmLmNvbnNvbGVMb2coXFxcInN5bmNSZWNQYXJhbXMgOjogXFxcIiArIEpTT04uc3RyaW5naWZ5KHN5bmNSZWNQYXJhbXMpKTtcIixcIlwiLFwiICAgICAgc2VsZi5kb0Nsb3VkQ2FsbCh7XCIsXCIgICAgICAgICdkYXRhc2V0X2lkJzogZGF0YXNldF9pZCxcIixcIiAgICAgICAgJ3JlcSc6IHN5bmNSZWNQYXJhbXNcIixcIiAgICAgIH0sIGZ1bmN0aW9uKHJlcykge1wiLFwiICAgICAgICB2YXIgaTtcIixcIlwiLFwiICAgICAgICBpZiAocmVzLmNyZWF0ZSkge1wiLFwiICAgICAgICAgIGZvciAoaSBpbiByZXMuY3JlYXRlKSB7XCIsXCIgICAgICAgICAgICBsb2NhbERhdGFTZXRbaV0gPSB7XFxcImhhc2hcXFwiIDogcmVzLmNyZWF0ZVtpXS5oYXNoLCBcXFwiZGF0YVxcXCIgOiByZXMuY3JlYXRlW2ldLmRhdGF9O1wiLFwiICAgICAgICAgICAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCBpLCBzZWxmLm5vdGlmaWNhdGlvbnMuUkVDT1JEX0RFTFRBX1JFQ0VJVkVELCBcXFwiY3JlYXRlXFxcIik7XCIsXCIgICAgICAgICAgfVwiLFwiICAgICAgICB9XCIsXCIgICAgICAgIGlmIChyZXMudXBkYXRlKSB7XCIsXCIgICAgICAgICAgZm9yIChpIGluIHJlcy51cGRhdGUpIHtcIixcIiAgICAgICAgICAgIGxvY2FsRGF0YVNldFtpXS5oYXNoID0gcmVzLnVwZGF0ZVtpXS5oYXNoO1wiLFwiICAgICAgICAgICAgbG9jYWxEYXRhU2V0W2ldLmRhdGEgPSByZXMudXBkYXRlW2ldLmRhdGE7XCIsXCIgICAgICAgICAgICBzZWxmLmRvTm90aWZ5KGRhdGFzZXRfaWQsIGksIHNlbGYubm90aWZpY2F0aW9ucy5SRUNPUkRfREVMVEFfUkVDRUlWRUQsIFxcXCJ1cGRhdGVcXFwiKTtcIixcIiAgICAgICAgICB9XCIsXCIgICAgICAgIH1cIixcIiAgICAgICAgaWYgKHJlc1snZGVsZXRlJ10pIHtcIixcIiAgICAgICAgICBmb3IgKGkgaW4gcmVzWydkZWxldGUnXSkge1wiLFwiICAgICAgICAgICAgZGVsZXRlIGxvY2FsRGF0YVNldFtpXTtcIixcIiAgICAgICAgICAgIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgaSwgc2VsZi5ub3RpZmljYXRpb25zLlJFQ09SRF9ERUxUQV9SRUNFSVZFRCwgXFxcImRlbGV0ZVxcXCIpO1wiLFwiICAgICAgICAgIH1cIixcIiAgICAgICAgfVwiLFwiXCIsXCIgICAgICAgIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgcmVzLmhhc2gsIHNlbGYubm90aWZpY2F0aW9ucy5ERUxUQV9SRUNFSVZFRCwgJ3BhcnRpYWwgZGF0YXNldCcpO1wiLFwiXCIsXCIgICAgICAgIGRhdGFTZXQuZGF0YSA9IGxvY2FsRGF0YVNldDtcIixcIiAgICAgICAgaWYocmVzLmhhc2gpIHtcIixcIiAgICAgICAgICBkYXRhU2V0Lmhhc2ggPSByZXMuaGFzaDtcIixcIiAgICAgICAgfVwiLFwiICAgICAgICBzZWxmLnN5bmNDb21wbGV0ZShkYXRhc2V0X2lkLCBcXFwib25saW5lXFxcIiwgc2VsZi5ub3RpZmljYXRpb25zLlNZTkNfQ09NUExFVEUpO1wiLFwiICAgICAgfSwgZnVuY3Rpb24obXNnLCBlcnIpIHtcIixcIiAgICAgICAgc2VsZi5jb25zb2xlTG9nKFxcXCJzeW5jUmVjb3JkcyBmYWlsZWQgOiBtc2c9XFxcIiArIG1zZyArIFxcXCIgOjogZXJyPVxcXCIgKyBlcnIpO1wiLFwiICAgICAgICBzZWxmLnN5bmNDb21wbGV0ZShkYXRhc2V0X2lkLCBtc2csIHNlbGYubm90aWZpY2F0aW9ucy5TWU5DX0ZBSUxFRCk7XCIsXCIgICAgICB9KTtcIixcIiAgICB9KTtcIixcIiAgfSxcIixcIlwiLFwiICBzeW5jQ29tcGxldGU6IGZ1bmN0aW9uKGRhdGFzZXRfaWQsIHN0YXR1cywgbm90aWZpY2F0aW9uKSB7XCIsXCJcIixcIiAgICBzZWxmLmdldERhdGFTZXQoZGF0YXNldF9pZCwgZnVuY3Rpb24oZGF0YXNldCkge1wiLFwiICAgICAgZGF0YXNldC5zeW5jUnVubmluZyA9IGZhbHNlO1wiLFwiICAgICAgZGF0YXNldC5zeW5jTG9vcEVuZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1wiLFwiICAgICAgc2VsZi5zYXZlRGF0YVNldChkYXRhc2V0X2lkKTtcIixcIiAgICAgIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgZGF0YXNldC5oYXNoLCBub3RpZmljYXRpb24sIHN0YXR1cyk7XCIsXCIgICAgfSk7XCIsXCIgIH0sXCIsXCJcIixcIiAgY2hlY2tEYXRhc2V0czogZnVuY3Rpb24oKSB7XCIsXCIgICAgZm9yKCB2YXIgZGF0YXNldF9pZCBpbiBzZWxmLmRhdGFzZXRzICkge1wiLFwiICAgICAgaWYoIHNlbGYuZGF0YXNldHMuaGFzT3duUHJvcGVydHkoZGF0YXNldF9pZCkgKSB7XCIsXCIgICAgICAgIHZhciBkYXRhc2V0ID0gc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXTtcIixcIlwiLFwiICAgICAgICBpZiggIWRhdGFzZXQuc3luY1J1bm5pbmcgJmFtcDsmYW1wOyAoZGF0YXNldC5jb25maWcuc3luY19hY3RpdmUgfHwgZGF0YXNldC5zeW5jRm9yY2VkKSkge1wiLFwiICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBpdCBpcyB0aW1lIGZvciB0aGUgc3luYyBsb29wIHRvIHJ1biBhZ2FpblwiLFwiICAgICAgICAgIHZhciBsYXN0U3luY1N0YXJ0ID0gZGF0YXNldC5zeW5jTG9vcFN0YXJ0O1wiLFwiICAgICAgICAgIHZhciBsYXN0U3luY0NtcCA9IGRhdGFzZXQuc3luY0xvb3BFbmQ7XCIsXCIgICAgICAgICAgaWYoIGxhc3RTeW5jU3RhcnQgPT0gbnVsbCApIHtcIixcIiAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZyhkYXRhc2V0X2lkICsnIC0gUGVyZm9ybWluZyBpbml0aWFsIHN5bmMnKTtcIixcIiAgICAgICAgICAgIC8vIERhdGFzZXQgaGFzIG5ldmVyIGJlZW4gc3luY2VkIGJlZm9yZSAtIGRvIGluaXRpYWwgc3luY1wiLFwiICAgICAgICAgICAgZGF0YXNldC5zeW5jUGVuZGluZyA9IHRydWU7XCIsXCIgICAgICAgICAgfSBlbHNlIGlmIChsYXN0U3luY0NtcCAhPSBudWxsKSB7XCIsXCIgICAgICAgICAgICB2YXIgdGltZVNpbmNlTGFzdFN5bmMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGxhc3RTeW5jQ21wO1wiLFwiICAgICAgICAgICAgdmFyIHN5bmNGcmVxdWVuY3kgPSBkYXRhc2V0LmNvbmZpZy5zeW5jX2ZyZXF1ZW5jeSAqIDEwMDA7XCIsXCIgICAgICAgICAgICBpZiggdGltZVNpbmNlTGFzdFN5bmMgJmd0OyBzeW5jRnJlcXVlbmN5ICkge1wiLFwiICAgICAgICAgICAgICAvLyBUaW1lIGJldHdlZW4gc3luYyBsb29wcyBoYXMgcGFzc2VkIC0gZG8gYW5vdGhlciBzeW5jXCIsXCIgICAgICAgICAgICAgIGRhdGFzZXQuc3luY1BlbmRpbmcgPSB0cnVlO1wiLFwiICAgICAgICAgICAgfVwiLFwiICAgICAgICAgIH0gXCIsXCJcIixcIiAgICAgICAgICBpZiggZGF0YXNldC5zeW5jRm9yY2VkICkge1wiLFwiICAgICAgICAgICAgZGF0YXNldC5zeW5jUGVuZGluZyA9IHRydWU7XCIsXCIgICAgICAgICAgfVwiLFwiXCIsXCIgICAgICAgICAgaWYoIGRhdGFzZXQuc3luY1BlbmRpbmcgKSB7XCIsXCIgICAgICAgICAgICAvLyBSZXNldCBzeW5jRm9yY2VkIGluIGNhc2UgaXQgd2FzIHdoYXQgY2F1c2VkIHRoZSBzeW5jIGN5Y2xlIHRvIHJ1bi5cIixcIiAgICAgICAgICAgIGRhdGFzZXQuc3luY0ZvcmNlZCA9IGZhbHNlO1wiLFwiXCIsXCIgICAgICAgICAgICAvLyBJZiB0aGUgZGF0YXNldCByZXF1cmVzIHN5bmNpbmcsIHJ1biB0aGUgc3luYyBsb29wLiBUaGlzIG1heSBiZSBiZWNhdXNlIHRoZSBzeW5jIGludGVydmFsIGhhcyBwYXNzZWRcIixcIiAgICAgICAgICAgIC8vIG9yIGJlY2F1c2UgdGhlIHN5bmNfZnJlcXVlbmN5IGhhcyBiZWVuIGNoYW5nZWQgb3IgYmVjYXVzZSBhIGNoYW5nZSB3YXMgbWFkZSB0byB0aGUgZGF0YXNldCBhbmQgdGhlXCIsXCIgICAgICAgICAgICAvLyBpbW1lZGlhdGVfc3luYyBmbGFnIHNldCB0byB0cnVlXCIsXCIgICAgICAgICAgICBzZWxmLnN5bmNMb29wKGRhdGFzZXRfaWQpO1wiLFwiICAgICAgICAgIH1cIixcIiAgICAgICAgfVwiLFwiICAgICAgfVwiLFwiICAgIH1cIixcIiAgfSxcIixcIlwiLFwiICBjaGVja0hhc0N1c3RvbVN5bmMgOiBmdW5jdGlvbihkYXRhc2V0X2lkLCBjYikge1wiLFwiICAgIGlmKHNlbGYuaGFzQ3VzdG9tU3luYyAhPSBudWxsKSB7XCIsXCIgICAgICByZXR1cm4gY2IoKTtcIixcIiAgICB9XCIsXCIgICAgc2VsZi5jb25zb2xlTG9nKCdzdGFydGluZyBjaGVjayBoYXMgY3VzdG9tIHN5bmMnKTtcIixcIlwiLFwiICAgIGFjdEFQSSh7XCIsXCIgICAgICAnYWN0JyA6IGRhdGFzZXRfaWQsXCIsXCIgICAgICAncmVxJzoge1wiLFwiICAgICAgICAnZm4nOiAnc3luYydcIixcIiAgICAgIH1cIixcIiAgICB9LCBmdW5jdGlvbihyZXMpIHtcIixcIiAgICAgIC8vaWYgdGhlIGN1c3RvbSBzeW5jIGlzIGRlZmluZWQgaW4gdGhlIGNsb3VkLCB0aGlzIGNhbGwgc2hvdWxkIHN1Y2Nlc3MuXCIsXCIgICAgICAvL2lmIGZhaWxlZCwgd2UgdGhpbmsgdGhpcyB0aGUgY3VzdG9tIHN5bmMgaXMgbm90IGRlZmluZWRcIixcIiAgICAgIHNlbGYuY29uc29sZUxvZygnY2hlY2tIYXNDdXN0b21TeW5jIC0gc3VjY2VzcyAtICcsIHJlcyk7XCIsXCIgICAgICBzZWxmLmhhc0N1c3RvbVN5bmMgPSB0cnVlO1wiLFwiICAgICAgcmV0dXJuIGNiKCk7XCIsXCIgICAgfSwgZnVuY3Rpb24obXNnLGVycikge1wiLFwiICAgICAgc2VsZi5jb25zb2xlTG9nKCdjaGVja0hhc0N1c3RvbVN5bmMgLSBmYWlsdXJlIC0gJywgZXJyKTtcIixcIiAgICAgIGlmKGVyci5zdGF0dXMgJmFtcDsmYW1wOyBlcnIuc3RhdHVzID09PSA1MDApe1wiLFwiICAgICAgICAvL2lmIHdlIHJlY2VpdmUgNTAwLCBpdCBjb3VsZCBiZSB0aGF0IHRoZXJlIGlzIGFuIGVycm9yIG9jY3VyZWQgZHVlIHRvIG1pc3NpbmcgcGFyYW1ldGVycyBvciBzaW1pbGFyLFwiLFwiICAgICAgICAvL2J1dCB0aGUgZW5kcG9pbnQgaXMgZGVmaW5lZC5cIixcIiAgICAgICAgc2VsZi5jb25zb2xlTG9nKCdjaGVja0hhc0N1c3RvbVN5bmMgLSBmYWlsZWQgd2l0aCA1MDAsIGVuZHBvaW50IGRvZXMgZXhpc3RzJyk7XCIsXCIgICAgICAgIHNlbGYuaGFzQ3VzdG9tU3luYyA9IHRydWU7XCIsXCIgICAgICB9IGVsc2Uge1wiLFwiICAgICAgICBzZWxmLmhhc0N1c3RvbVN5bmMgPSBmYWxzZTtcIixcIiAgICAgIH1cIixcIiAgICAgIHJldHVybiBjYigpO1wiLFwiICAgIH0pO1wiLFwiICB9LFwiLFwiXCIsXCIgIGRvQ2xvdWRDYWxsOiBmdW5jdGlvbihwYXJhbXMsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcIixcIiAgICBpZiggc2VsZi5oYXNDdXN0b21TeW5jICkge1wiLFwiICAgICAgYWN0QVBJKHtcIixcIiAgICAgICAgJ2FjdCcgOiBwYXJhbXMuZGF0YXNldF9pZCxcIixcIiAgICAgICAgJ3JlcScgOiBwYXJhbXMucmVxXCIsXCIgICAgICB9LCBmdW5jdGlvbihyZXMpIHtcIixcIiAgICAgICAgc3VjY2VzcyhyZXMpO1wiLFwiICAgICAgfSwgZnVuY3Rpb24obXNnLCBlcnIpIHtcIixcIiAgICAgICAgZmFpbHVyZShtc2csIGVycik7XCIsXCIgICAgICB9KTsgICAgICBcIixcIiAgICB9IGVsc2Uge1wiLFwiICAgICAgY2xvdWRBUEkoe1wiLFwiICAgICAgICAncGF0aCcgOiAnL21iYWFzL3N5bmMvJyArIHBhcmFtcy5kYXRhc2V0X2lkLFwiLFwiICAgICAgICAnbWV0aG9kJyA6ICdwb3N0JyxcIixcIiAgICAgICAgJ2RhdGEnIDogcGFyYW1zLnJlcVwiLFwiICAgICAgfSwgZnVuY3Rpb24ocmVzKSB7XCIsXCIgICAgICAgIHN1Y2Nlc3MocmVzKTtcIixcIiAgICAgIH0sIGZ1bmN0aW9uKG1zZywgZXJyKSB7XCIsXCIgICAgICAgIGZhaWx1cmUobXNnLCBlcnIpO1wiLFwiICAgICAgfSlcIixcIiAgICB9XCIsXCIgIH0sXCIsXCJcIixcIiAgZGF0YXNldE1vbml0b3I6IGZ1bmN0aW9uKCkge1wiLFwiICAgIHNlbGYuY2hlY2tEYXRhc2V0cygpO1wiLFwiXCIsXCIgICAgLy8gUmUtZXhlY3V0ZSBkYXRhc2V0TW9uaXRvciBldmVyeSA1MDBtcyBzbyB3ZSBrZWVwIGludm9raW5nIGNoZWNrRGF0YXNldHMoKTtcIixcIiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1wiLFwiICAgICAgc2VsZi5kYXRhc2V0TW9uaXRvcigpO1wiLFwiICAgIH0sIDUwMCk7XCIsXCIgIH0sXCIsXCJcIixcIiAgc2F2ZURhdGFTZXQ6IGZ1bmN0aW9uIChkYXRhc2V0X2lkLCBjYikge1wiLFwiICAgIHZhciBvbkZhaWwgPSAgZnVuY3Rpb24obXNnLCBlcnIpIHtcIixcIiAgICAgIC8vIHNhdmUgZmFpbGVkXCIsXCIgICAgICB2YXIgZXJyTXNnID0gJ3NhdmUgdG8gbG9jYWwgc3RvcmFnZSBmYWlsZWQgIG1zZzonICsgbXNnICsgJyBlcnI6JyArIGVycjtcIixcIiAgICAgIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgbnVsbCwgc2VsZi5ub3RpZmljYXRpb25zLkNMSUVOVF9TVE9SQUdFX0ZBSUxFRCwgZXJyTXNnKTtcIixcIiAgICAgIHNlbGYuY29uc29sZUxvZyhlcnJNc2cpO1wiLFwiICAgIH07XCIsXCIgICAgc2VsZi5nZXREYXRhU2V0KGRhdGFzZXRfaWQsIGZ1bmN0aW9uKGRhdGFzZXQpIHtcIixcIiAgICAgIC8vIHNhdmUgZGF0YXNldCB0byBsb2NhbCBzdG9yYWdlXCIsXCIgICAgICBMYXduY2hhaXIoe2ZhaWw6b25GYWlsLCBhZGFwdGVyOiBzZWxmLmNvbmZpZy5zdG9yYWdlX3N0cmF0ZWd5LCBzaXplOnNlbGYuY29uZmlnLmZpbGVfc3lzdGVtX3F1b3RhfSwgZnVuY3Rpb24gKCl7XCIsXCIgICAgICAgIHRoaXMuc2F2ZSh7a2V5OlxcXCJkYXRhc2V0X1xcXCIgKyBkYXRhc2V0X2lkLCB2YWw6ZGF0YXNldH0sIGZ1bmN0aW9uKCl7XCIsXCIgICAgICAgICAgLy9zYXZlIHN1Y2Nlc3NcIixcIiAgICAgICAgICBpZihjYikgcmV0dXJuIGNiKCk7XCIsXCIgICAgICAgIH0pO1wiLFwiICAgICAgfSk7XCIsXCIgICAgfSk7XCIsXCIgIH0sXCIsXCJcIixcIiAgbG9hZERhdGFTZXQ6IGZ1bmN0aW9uIChkYXRhc2V0X2lkLCBzdWNjZXNzLCBmYWlsdXJlKSB7XCIsXCIgICAgLy8gbG9hZCBkYXRhc2V0IGZyb20gbG9jYWwgc3RvcmFnZVwiLFwiICAgIHZhciBvbkZhaWwgPSBmdW5jdGlvbihtc2csIGVycikge1wiLFwiICAgICAgLy8gbG9hZCBmYWlsZWRcIixcIiAgICAgIHZhciBlcnJNc2cgPSAnbG9hZCBmcm9tIGxvY2FsIHN0b3JhZ2UgZmFpbGVkICBtc2c6JyArIG1zZztcIixcIiAgICAgIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgbnVsbCwgc2VsZi5ub3RpZmljYXRpb25zLkNMSUVOVF9TVE9SQUdFX0ZBSUxFRCwgZXJyTXNnKTtcIixcIiAgICAgIHNlbGYuY29uc29sZUxvZyhlcnJNc2cpO1wiLFwiICAgIH07XCIsXCJcIixcIiAgICAgICAgTGF3bmNoYWlyKHtmYWlsOm9uRmFpbCwgYWRhcHRlcjogc2VsZi5jb25maWcuc3RvcmFnZV9zdHJhdGVneSwgc2l6ZTpzZWxmLmNvbmZpZy5maWxlX3N5c3RlbV9xdW90YX0sZnVuY3Rpb24gKCl7ICAgICAgIHRoaXMuZ2V0KCBcXFwiZGF0YXNldF9cXFwiICsgZGF0YXNldF9pZCwgZnVuY3Rpb24gKGRhdGEpe1wiLFwiICAgICAgICAgaWYgKGRhdGEgJmFtcDsmYW1wOyBkYXRhLnZhbCAhPT0gbnVsbCkge1wiLFwiICAgICAgICAgICAgdmFyIGRhdGFzZXQgPSBkYXRhLnZhbDtcIixcIiAgICAgICAgICAgIGlmKHR5cGVvZiBkYXRhc2V0ID09PSBcXFwic3RyaW5nXFxcIil7XCIsXCIgICAgICAgICAgICAgIGRhdGFzZXQgPSBKU09OLnBhcnNlKGRhdGFzZXQpO1wiLFwiICAgICAgICAgICAgfVwiLFwiICAgICAgICAgICAgLy8gRGF0YXNldHMgc2hvdWxkIG5vdCBiZSBhdXRvIGluaXRpYWxpc2VkIHdoZW4gbG9hZGVkIC0gdGhlIG1hbmdlIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgZm9yIGVhY2ggZGF0YXNldFwiLFwiICAgICAgICAgICAgLy8gdGhlIHVzZXIgd2FudHMgc3luY1wiLFwiICAgICAgICAgICAgZGF0YXNldC5pbml0aWFsaXNlZCA9IGZhbHNlO1wiLFwiICAgICAgICAgICAgc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXSA9IGRhdGFzZXQ7IC8vIFRPRE86IGRvIHdlIG5lZWQgdG8gaGFuZGxlIGJpbmFyeSBkYXRhP1wiLFwiICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCdsb2FkIGZyb20gbG9jYWwgc3RvcmFnZSBzdWNjZXNzIGZvciBkYXRhc2V0X2lkIDonICsgZGF0YXNldF9pZCk7XCIsXCIgICAgICAgICAgICBpZihzdWNjZXNzKSByZXR1cm4gc3VjY2VzcyhkYXRhc2V0KTtcIixcIiAgICAgICAgICB9IGVsc2Uge1wiLFwiICAgICAgICAgICAgLy8gbm8gZGF0YSB5ZXQsIHByb2JhYmx5IGZpcnN0IHRpbWUuIGZhaWx1cmUgY2FsYmFjayBzaG91bGQgaGFuZGxlIHRoaXNcIixcIiAgICAgICAgICAgIGlmKGZhaWx1cmUpIHJldHVybiBmYWlsdXJlKCk7XCIsXCIgICAgICAgICAgfVwiLFwiICAgICAgIH0pO1wiLFwiICAgIH0pO1wiLFwiICB9LFwiLFwiXCIsXCJcIixcIiAgdXBkYXRlRGF0YXNldEZyb21Mb2NhbDogZnVuY3Rpb24oZGF0YXNldCwgcGVuZGluZ1JlYykge1wiLFwiICAgIHZhciBwZW5kaW5nID0gZGF0YXNldC5wZW5kaW5nO1wiLFwiICAgIHZhciBwcmV2aW91c1BlbmRpbmdVaWQ7XCIsXCIgICAgdmFyIHByZXZpb3VzUGVuZGluZztcIixcIlwiLFwiICAgIHZhciB1aWQgPSBwZW5kaW5nUmVjLnVpZDtcIixcIiAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0aW5nIGxvY2FsIGRhdGFzZXQgZm9yIHVpZCAnICsgdWlkICsgJyAtIGFjdGlvbiA9ICcgKyBwZW5kaW5nUmVjLmFjdGlvbik7XCIsXCJcIixcIiAgICBkYXRhc2V0Lm1ldGFbdWlkXSA9IGRhdGFzZXQubWV0YVt1aWRdIHx8IHt9O1wiLFwiXCIsXCIgICAgLy8gQ3JlYXRpbmcgYSBuZXcgcmVjb3JkXCIsXCIgICAgaWYoIHBlbmRpbmdSZWMuYWN0aW9uID09PSBcXFwiY3JlYXRlXFxcIiApIHtcIixcIiAgICAgIGlmKCBkYXRhc2V0LmRhdGFbdWlkXSApIHtcIixcIiAgICAgICAgc2VsZi5jb25zb2xlTG9nKCdkYXRhc2V0IGFscmVhZHkgZXhpc3RzIGZvciB1aWQgaW4gY3JlYXRlIDo6ICcgKyBKU09OLnN0cmluZ2lmeShkYXRhc2V0LmRhdGFbdWlkXSkpO1wiLFwiXCIsXCIgICAgICAgIC8vIFdlIGFyZSB0cnlpbmcgdG8gZG8gYSBjcmVhdGUgdXNpbmcgYSB1aWQgd2hpY2ggYWxyZWFkeSBleGlzdHNcIixcIiAgICAgICAgaWYgKGRhdGFzZXQubWV0YVt1aWRdLmZyb21QZW5kaW5nKSB7XCIsXCIgICAgICAgICAgLy8gV2UgYXJlIHRyeWluZyB0byBjcmVhdGUgb24gdG9wIG9mIGFuIGV4aXN0aW5nIHBlbmRpbmcgcmVjb3JkXCIsXCIgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBwcmV2aW91cyBwZW5kaW5nIHJlY29yZCBhbmQgdXNlIHRoaXMgb25lIGluc3RlYWRcIixcIiAgICAgICAgICBwcmV2aW91c1BlbmRpbmdVaWQgPSBkYXRhc2V0Lm1ldGFbdWlkXS5wZW5kaW5nVWlkO1wiLFwiICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nW3ByZXZpb3VzUGVuZGluZ1VpZF07XCIsXCIgICAgICAgIH1cIixcIiAgICAgIH1cIixcIiAgICAgIGRhdGFzZXQuZGF0YVt1aWRdID0ge307XCIsXCIgICAgfVwiLFwiXCIsXCIgICAgaWYoIHBlbmRpbmdSZWMuYWN0aW9uID09PSBcXFwidXBkYXRlXFxcIiApIHtcIixcIiAgICAgIGlmKCBkYXRhc2V0LmRhdGFbdWlkXSApIHtcIixcIiAgICAgICAgaWYgKGRhdGFzZXQubWV0YVt1aWRdLmZyb21QZW5kaW5nKSB7XCIsXCIgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCd1cGRhdGluZyBhbiBleGlzdGluZyBwZW5kaW5nIHJlY29yZCBmb3IgZGF0YXNldCA6OiAnICsgSlNPTi5zdHJpbmdpZnkoZGF0YXNldC5kYXRhW3VpZF0pKTtcIixcIiAgICAgICAgICAvLyBXZSBhcmUgdHJ5aW5nIHRvIHVwZGF0ZSBhbiBleGlzdGluZyBwZW5kaW5nIHJlY29yZFwiLFwiICAgICAgICAgIHByZXZpb3VzUGVuZGluZ1VpZCA9IGRhdGFzZXQubWV0YVt1aWRdLnBlbmRpbmdVaWQ7XCIsXCIgICAgICAgICAgZGF0YXNldC5tZXRhW3VpZF0ucHJldmlvdXNQZW5kaW5nVWlkID0gcHJldmlvdXNQZW5kaW5nVWlkO1wiLFwiICAgICAgICAgIHByZXZpb3VzUGVuZGluZyA9IHBlbmRpbmdbcHJldmlvdXNQZW5kaW5nVWlkXTtcIixcIiAgICAgICAgICBpZihwcmV2aW91c1BlbmRpbmcpIHtcIixcIiAgICAgICAgICAgIGlmKCFwcmV2aW91c1BlbmRpbmcuaW5GbGlnaHQpe1wiLFwiICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ2V4aXN0aW5nIHByZS1mbGlnaHQgcGVuZGluZyByZWNvcmQgPSAnICsgSlNPTi5zdHJpbmdpZnkocHJldmlvdXNQZW5kaW5nKSk7XCIsXCIgICAgICAgICAgICAgIC8vIFdlIGFyZSB0cnlpbmcgdG8gcGVyZm9ybSBhbiB1cGRhdGUgb24gYW4gZXhpc3RpbmcgcGVuZGluZyByZWNvcmRcIixcIiAgICAgICAgICAgICAgLy8gbW9kaWZ5IHRoZSBvcmlnaW5hbCByZWNvcmQgdG8gaGF2ZSB0aGUgbGF0ZXN0IHZhbHVlIGFuZCBkZWxldGUgdGhlIHBlbmRpbmcgdXBkYXRlXCIsXCIgICAgICAgICAgICAgIHByZXZpb3VzUGVuZGluZy5wb3N0ID0gcGVuZGluZ1JlYy5wb3N0O1wiLFwiICAgICAgICAgICAgICBwcmV2aW91c1BlbmRpbmcucG9zdEhhc2ggPSBwZW5kaW5nUmVjLnBvc3RIYXNoO1wiLFwiICAgICAgICAgICAgICBkZWxldGUgcGVuZGluZ1twZW5kaW5nUmVjLmhhc2hdO1wiLFwiICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgcmVjb3JkIHRvIGhhdmUgdGhlIGhhc2ggb2YgdGhlIHByZXZpb3VzIHJlY29yZCBhcyB0aGlzIGlzIHdoYXQgaXMgbm93IGJlaW5nXCIsXCIgICAgICAgICAgICAgIC8vIG1haW50YWluZWQgaW4gdGhlIHBlbmRpbmcgYXJyYXkgJmFtcDsgaXMgd2hhdCB3ZSB3YW50IGluIHRoZSBtZXRhIHJlY29yZFwiLFwiICAgICAgICAgICAgICBwZW5kaW5nUmVjLmhhc2ggPSBwcmV2aW91c1BlbmRpbmdVaWQ7XCIsXCIgICAgICAgICAgICB9IGVsc2Uge1wiLFwiICAgICAgICAgICAgICAvL3dlIGFyZSBwZXJmb3JtaW5nIGNoYW5nZXMgdG8gYSBwZW5kaW5nIHJlY29yZCB3aGljaCBpcyBpbkZsaWdodC4gVW50aWwgdGhlIHN0YXR1cyBvZiB0aGlzIHBlbmRpbmcgcmVjb3JkIGlzIHJlc29sdmVkLFwiLFwiICAgICAgICAgICAgICAvL3dlIHNob3VsZCBub3Qgc3VibWl0IHRoaXMgcGVuZGluZyByZWNvcmQgdG8gdGhlIGNsb3VkLiBNYXJrIGl0IGFzIGRlbGF5ZWQuXCIsXCIgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygnZXhpc3RpbmcgaW4taW5mbGlnaHQgcGVuZGluZyByZWNvcmQgPSAnICsgSlNPTi5zdHJpbmdpZnkocHJldmlvdXNQZW5kaW5nKSk7XCIsXCIgICAgICAgICAgICAgIHBlbmRpbmdSZWMuZGVsYXllZCA9IHRydWU7XCIsXCIgICAgICAgICAgICAgIHBlbmRpbmdSZWMud2FpdGluZyA9IHByZXZpb3VzUGVuZGluZy5oYXNoO1wiLFwiICAgICAgICAgICAgfVwiLFwiICAgICAgICAgIH1cIixcIiAgICAgICAgfVwiLFwiICAgICAgfVwiLFwiICAgIH1cIixcIlwiLFwiICAgIGlmKCBwZW5kaW5nUmVjLmFjdGlvbiA9PT0gXFxcImRlbGV0ZVxcXCIgKSB7XCIsXCIgICAgICBpZiggZGF0YXNldC5kYXRhW3VpZF0gKSB7XCIsXCIgICAgICAgIGlmIChkYXRhc2V0Lm1ldGFbdWlkXS5mcm9tUGVuZGluZykge1wiLFwiICAgICAgICAgIHNlbGYuY29uc29sZUxvZygnRGVsZXRpbmcgYW4gZXhpc3RpbmcgcGVuZGluZyByZWNvcmQgZm9yIGRhdGFzZXQgOjogJyArIEpTT04uc3RyaW5naWZ5KGRhdGFzZXQuZGF0YVt1aWRdKSk7XCIsXCIgICAgICAgICAgLy8gV2UgYXJlIHRyeWluZyB0byBkZWxldGUgYW4gZXhpc3RpbmcgcGVuZGluZyByZWNvcmRcIixcIiAgICAgICAgICBwcmV2aW91c1BlbmRpbmdVaWQgPSBkYXRhc2V0Lm1ldGFbdWlkXS5wZW5kaW5nVWlkO1wiLFwiICAgICAgICAgIGRhdGFzZXQubWV0YVt1aWRdLnByZXZpb3VzUGVuZGluZ1VpZCA9IHByZXZpb3VzUGVuZGluZ1VpZDtcIixcIiAgICAgICAgICBwcmV2aW91c1BlbmRpbmcgPSBwZW5kaW5nW3ByZXZpb3VzUGVuZGluZ1VpZF07XCIsXCIgICAgICAgICAgaWYoIHByZXZpb3VzUGVuZGluZyApIHtcIixcIiAgICAgICAgICAgIGlmKCFwcmV2aW91c1BlbmRpbmcuaW5GbGlnaHQpe1wiLFwiICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ2V4aXN0aW5nIHBlbmRpbmcgcmVjb3JkID0gJyArIEpTT04uc3RyaW5naWZ5KHByZXZpb3VzUGVuZGluZykpO1wiLFwiICAgICAgICAgICAgICBpZiggcHJldmlvdXNQZW5kaW5nLmFjdGlvbiA9PT0gXFxcImNyZWF0ZVxcXCIgKSB7XCIsXCIgICAgICAgICAgICAgICAgLy8gV2UgYXJlIHRyeWluZyB0byBwZXJmb3JtIGEgZGVsZXRlIG9uIGFuIGV4aXN0aW5nIHBlbmRpbmcgY3JlYXRlXCIsXCIgICAgICAgICAgICAgICAgLy8gVGhlc2UgY2FuY2VsIGVhY2ggb3RoZXIgb3V0IHNvIHJlbW92ZSB0aGVtIGJvdGhcIixcIiAgICAgICAgICAgICAgICBkZWxldGUgcGVuZGluZ1twZW5kaW5nUmVjLmhhc2hdO1wiLFwiICAgICAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nW3ByZXZpb3VzUGVuZGluZ1VpZF07XCIsXCIgICAgICAgICAgICAgIH1cIixcIiAgICAgICAgICAgICAgaWYoIHByZXZpb3VzUGVuZGluZy5hY3Rpb24gPT09IFxcXCJ1cGRhdGVcXFwiICkge1wiLFwiICAgICAgICAgICAgICAgIC8vIFdlIGFyZSB0cnlpbmcgdG8gcGVyZm9ybSBhIGRlbGV0ZSBvbiBhbiBleGlzdGluZyBwZW5kaW5nIHVwZGF0ZVwiLFwiICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgcHJlIHZhbHVlIGZyb20gdGhlIHBlbmRpbmcgdXBkYXRlIGZvciB0aGUgZGVsZXRlIGFuZFwiLFwiICAgICAgICAgICAgICAgIC8vIGdldCByaWQgb2YgdGhlIHBlbmRpbmcgdXBkYXRlXCIsXCIgICAgICAgICAgICAgICAgcGVuZGluZ1JlYy5wcmUgPSBwcmV2aW91c1BlbmRpbmcucHJlO1wiLFwiICAgICAgICAgICAgICAgIHBlbmRpbmdSZWMucHJlSGFzaCA9IHByZXZpb3VzUGVuZGluZy5wcmVIYXNoO1wiLFwiICAgICAgICAgICAgICAgIHBlbmRpbmdSZWMuaW5GbGlnaHQgPSBmYWxzZTtcIixcIiAgICAgICAgICAgICAgICBkZWxldGUgcGVuZGluZ1twcmV2aW91c1BlbmRpbmdVaWRdO1wiLFwiICAgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgICB9IGVsc2Uge1wiLFwiICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ2V4aXN0aW5nIGluLWluZmxpZ2h0IHBlbmRpbmcgcmVjb3JkID0gJyArIEpTT04uc3RyaW5naWZ5KHByZXZpb3VzUGVuZGluZykpO1wiLFwiICAgICAgICAgICAgICBwZW5kaW5nUmVjLmRlbGF5ZWQgPSB0cnVlO1wiLFwiICAgICAgICAgICAgICBwZW5kaW5nUmVjLndhaXRpbmcgPSBwcmV2aW91c1BlbmRpbmcuaGFzaDtcIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgICB9XCIsXCIgICAgICAgIH1cIixcIiAgICAgICAgZGVsZXRlIGRhdGFzZXQuZGF0YVt1aWRdO1wiLFwiICAgICAgfVwiLFwiICAgIH1cIixcIlwiLFwiICAgIGlmKCBkYXRhc2V0LmRhdGFbdWlkXSApIHtcIixcIiAgICAgIGRhdGFzZXQuZGF0YVt1aWRdLmRhdGEgPSBwZW5kaW5nUmVjLnBvc3Q7XCIsXCIgICAgICBkYXRhc2V0LmRhdGFbdWlkXS5oYXNoID0gcGVuZGluZ1JlYy5wb3N0SGFzaDtcIixcIiAgICAgIGRhdGFzZXQubWV0YVt1aWRdLmZyb21QZW5kaW5nID0gdHJ1ZTtcIixcIiAgICAgIGRhdGFzZXQubWV0YVt1aWRdLnBlbmRpbmdVaWQgPSBwZW5kaW5nUmVjLmhhc2g7XCIsXCIgICAgfVwiLFwiICB9LFwiLFwiXCIsXCIgIHVwZGF0ZVBlbmRpbmdGcm9tTmV3RGF0YTogZnVuY3Rpb24oZGF0YXNldF9pZCwgZGF0YXNldCwgbmV3RGF0YSkge1wiLFwiICAgIHZhciBwZW5kaW5nID0gZGF0YXNldC5wZW5kaW5nO1wiLFwiICAgIHZhciBuZXdSZWM7XCIsXCJcIixcIiAgICBpZiggcGVuZGluZyAmYW1wOyZhbXA7IG5ld0RhdGEucmVjb3Jkcykge1wiLFwiICAgICAgZm9yKCB2YXIgcGVuZGluZ0hhc2ggaW4gcGVuZGluZyApIHtcIixcIiAgICAgICAgaWYoIHBlbmRpbmcuaGFzT3duUHJvcGVydHkocGVuZGluZ0hhc2gpICkge1wiLFwiICAgICAgICAgIHZhciBwZW5kaW5nUmVjID0gcGVuZGluZ1twZW5kaW5nSGFzaF07XCIsXCJcIixcIiAgICAgICAgICBkYXRhc2V0Lm1ldGFbcGVuZGluZ1JlYy51aWRdID0gZGF0YXNldC5tZXRhW3BlbmRpbmdSZWMudWlkXSB8fCB7fTtcIixcIlwiLFwiICAgICAgICAgIGlmKCBwZW5kaW5nUmVjLmluRmxpZ2h0ID09PSBmYWxzZSApIHtcIixcIiAgICAgICAgICAgIC8vIFBlbmRpbmcgcmVjb3JkIHRoYXQgaGFzIG5vdCBiZWVuIHN1Ym1pdHRlZFwiLFwiICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCd1cGRhdGVQZW5kaW5nRnJvbU5ld0RhdGEgLSBGb3VuZCBOb24gaW5GbGlnaHQgcmVjb3JkIC0mZ3Q7IGFjdGlvbj0nICsgcGVuZGluZ1JlYy5hY3Rpb24gKycgOjogdWlkPScgKyBwZW5kaW5nUmVjLnVpZCAgKyAnIDo6IGhhc2g9JyArIHBlbmRpbmdSZWMuaGFzaCk7XCIsXCIgICAgICAgICAgICBpZiggcGVuZGluZ1JlYy5hY3Rpb24gPT09IFxcXCJ1cGRhdGVcXFwiIHx8IHBlbmRpbmdSZWMuYWN0aW9uID09PSBcXFwiZGVsZXRlXFxcIikge1wiLFwiICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByZSB2YWx1ZSBvZiBwZW5kaW5nIHJlY29yZCB0byByZWZsZWN0IHRoZSBsYXRlc3QgZGF0YSByZXR1cm5lZCBmcm9tIHN5bmMuXCIsXCIgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBwcmV2ZW50IGEgY29sbGlzaW9uIGJlaW5nIHJlcG9ydGVkIHdoZW4gdGhlIHBlbmRpbmcgcmVjb3JkIGlzIHNlbnQuXCIsXCIgICAgICAgICAgICAgIG5ld1JlYyA9IG5ld0RhdGEucmVjb3Jkc1twZW5kaW5nUmVjLnVpZF07XCIsXCIgICAgICAgICAgICAgIGlmKCBuZXdSZWMgKSB7XCIsXCIgICAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCd1cGRhdGVQZW5kaW5nRnJvbU5ld0RhdGEgLSBVcGRhdGluZyBwcmUgdmFsdWVzIGZvciBleGlzdGluZyBwZW5kaW5nIHJlY29yZCAnICsgcGVuZGluZ1JlYy51aWQpO1wiLFwiICAgICAgICAgICAgICAgIHBlbmRpbmdSZWMucHJlID0gbmV3UmVjLmRhdGE7XCIsXCIgICAgICAgICAgICAgICAgcGVuZGluZ1JlYy5wcmVIYXNoID0gbmV3UmVjLmhhc2g7XCIsXCIgICAgICAgICAgICAgIH1cIixcIiAgICAgICAgICAgICAgZWxzZSB7XCIsXCIgICAgICAgICAgICAgICAgLy8gVGhlIHVwZGF0ZS9kZWxldGUgbWF5IGJlIGZvciBhIG5ld2x5IGNyZWF0ZWQgcmVjb3JkIGluIHdoaWNoIGNhc2UgdGhlIHVpZCB3aWxsIGhhdmUgY2hhbmdlZC5cIixcIiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNQZW5kaW5nVWlkID0gZGF0YXNldC5tZXRhW3BlbmRpbmdSZWMudWlkXS5wcmV2aW91c1BlbmRpbmdVaWQ7XCIsXCIgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzUGVuZGluZyA9IHBlbmRpbmdbcHJldmlvdXNQZW5kaW5nVWlkXTtcIixcIiAgICAgICAgICAgICAgICBpZiggcHJldmlvdXNQZW5kaW5nICkge1wiLFwiICAgICAgICAgICAgICAgICAgaWYoIG5ld0RhdGEgJmFtcDsmYW1wOyBuZXdEYXRhLnVwZGF0ZXMgJmFtcDsmYW1wOyAgbmV3RGF0YS51cGRhdGVzLmFwcGxpZWQgJmFtcDsmYW1wOyBuZXdEYXRhLnVwZGF0ZXMuYXBwbGllZFtwcmV2aW91c1BlbmRpbmcuaGFzaF0gKSB7XCIsXCIgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGFuIHVwZGF0ZSBpbiBmcm9tIGEgcHJldmlvdXMgcGVuZGluZyBhY3Rpb25cIixcIiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1VpZCA9IG5ld0RhdGEudXBkYXRlcy5hcHBsaWVkW3ByZXZpb3VzUGVuZGluZy5oYXNoXS51aWQ7XCIsXCIgICAgICAgICAgICAgICAgICAgIG5ld1JlYyA9IG5ld0RhdGEucmVjb3Jkc1tuZXdVaWRdO1wiLFwiICAgICAgICAgICAgICAgICAgICBpZiggbmV3UmVjICkge1wiLFwiICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygndXBkYXRlUGVuZGluZ0Zyb21OZXdEYXRhIC0gVXBkYXRpbmcgcHJlIHZhbHVlcyBmb3IgZXhpc3RpbmcgcGVuZGluZyByZWNvcmQgd2hpY2ggd2FzIHByZXZpb3VzbHkgYSBjcmVhdGUgJyArIHBlbmRpbmdSZWMudWlkICsgJyA9PSZndDsgJyArIG5ld1VpZCk7XCIsXCIgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1JlYy5wcmUgPSBuZXdSZWMuZGF0YTtcIixcIiAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLnByZUhhc2ggPSBuZXdSZWMuaGFzaDtcIixcIiAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLnVpZCA9IG5ld1VpZDtcIixcIiAgICAgICAgICAgICAgICAgICAgfVwiLFwiICAgICAgICAgICAgICAgICAgfVwiLFwiICAgICAgICAgICAgICAgIH1cIixcIiAgICAgICAgICAgICAgfVwiLFwiICAgICAgICAgICAgfVwiLFwiXCIsXCIgICAgICAgICAgICBpZiggcGVuZGluZ1JlYy5hY3Rpb24gPT09IFxcXCJjcmVhdGVcXFwiICkge1wiLFwiICAgICAgICAgICAgICBpZiggbmV3RGF0YSAmYW1wOyZhbXA7IG5ld0RhdGEudXBkYXRlcyAmYW1wOyZhbXA7ICBuZXdEYXRhLnVwZGF0ZXMuYXBwbGllZCAmYW1wOyZhbXA7IG5ld0RhdGEudXBkYXRlcy5hcHBsaWVkW3BlbmRpbmdIYXNoXSApIHtcIixcIiAgICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0ZVBlbmRpbmdGcm9tTmV3RGF0YSAtIEZvdW5kIGFuIHVwZGF0ZSBmb3IgYSBwZW5kaW5nIGNyZWF0ZSAnICsgSlNPTi5zdHJpbmdpZnkobmV3RGF0YS51cGRhdGVzLmFwcGxpZWRbcGVuZGluZ0hhc2hdKSk7XCIsXCIgICAgICAgICAgICAgICAgbmV3UmVjID0gbmV3RGF0YS5yZWNvcmRzW25ld0RhdGEudXBkYXRlcy5hcHBsaWVkW3BlbmRpbmdIYXNoXS51aWRdO1wiLFwiICAgICAgICAgICAgICAgIGlmKCBuZXdSZWMgKSB7XCIsXCIgICAgICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0ZVBlbmRpbmdGcm9tTmV3RGF0YSAtIENoYW5naW5nIHBlbmRpbmcgY3JlYXRlIHRvIGFuIHVwZGF0ZSBiYXNlZCBvbiBuZXcgcmVjb3JkICAnICsgSlNPTi5zdHJpbmdpZnkobmV3UmVjKSk7XCIsXCJcIixcIiAgICAgICAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgcGVuZGluZyBjcmVhdGUgYXMgYW4gdXBkYXRlXCIsXCIgICAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLmFjdGlvbiA9IFxcXCJ1cGRhdGVcXFwiO1wiLFwiICAgICAgICAgICAgICAgICAgcGVuZGluZ1JlYy5wcmUgPSBuZXdSZWMuZGF0YTtcIixcIiAgICAgICAgICAgICAgICAgIHBlbmRpbmdSZWMucHJlSGFzaCA9IG5ld1JlYy5oYXNoO1wiLFwiICAgICAgICAgICAgICAgICAgcGVuZGluZ1JlYy51aWQgPSBuZXdEYXRhLnVwZGF0ZXMuYXBwbGllZFtwZW5kaW5nSGFzaF0udWlkO1wiLFwiICAgICAgICAgICAgICAgIH1cIixcIiAgICAgICAgICAgICAgfVwiLFwiICAgICAgICAgICAgfVwiLFwiICAgICAgICAgIH1cIixcIiAgICAgICAgfVwiLFwiICAgICAgfVwiLFwiICAgIH1cIixcIiAgfSxcIixcIlwiLFwiICB1cGRhdGVOZXdEYXRhRnJvbUluRmxpZ2h0OiBmdW5jdGlvbihkYXRhc2V0X2lkLCBkYXRhc2V0LCBuZXdEYXRhKSB7XCIsXCIgICAgdmFyIHBlbmRpbmcgPSBkYXRhc2V0LnBlbmRpbmc7XCIsXCJcIixcIiAgICBpZiggcGVuZGluZyAmYW1wOyZhbXA7IG5ld0RhdGEucmVjb3Jkcykge1wiLFwiICAgICAgZm9yKCB2YXIgcGVuZGluZ0hhc2ggaW4gcGVuZGluZyApIHtcIixcIiAgICAgICAgaWYoIHBlbmRpbmcuaGFzT3duUHJvcGVydHkocGVuZGluZ0hhc2gpICkge1wiLFwiICAgICAgICAgIHZhciBwZW5kaW5nUmVjID0gcGVuZGluZ1twZW5kaW5nSGFzaF07XCIsXCJcIixcIiAgICAgICAgICBpZiggcGVuZGluZ1JlYy5pbkZsaWdodCApIHtcIixcIiAgICAgICAgICAgIHZhciB1cGRhdGVSZWNlaXZlZEZvclBlbmRpbmcgPSAobmV3RGF0YSAmYW1wOyZhbXA7IG5ld0RhdGEudXBkYXRlcyAmYW1wOyZhbXA7ICBuZXdEYXRhLnVwZGF0ZXMuaGFzaGVzICZhbXA7JmFtcDsgbmV3RGF0YS51cGRhdGVzLmhhc2hlc1twZW5kaW5nSGFzaF0pID8gdHJ1ZSA6IGZhbHNlO1wiLFwiXCIsXCIgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0ZU5ld0RhdGFGcm9tSW5GbGlnaHQgLSBGb3VuZCBpbmZsaWdodCBwZW5kaW5nIFJlY29yZCAtIGFjdGlvbiA9ICcgKyBwZW5kaW5nUmVjLmFjdGlvbiArICcgOjogaGFzaCA9ICcgKyBwZW5kaW5nSGFzaCArICcgOjogdXBkYXRlUmVjZWl2ZWRGb3JQZW5kaW5nPScgKyB1cGRhdGVSZWNlaXZlZEZvclBlbmRpbmcpO1wiLFwiXCIsXCIgICAgICAgICAgICBpZiggISB1cGRhdGVSZWNlaXZlZEZvclBlbmRpbmcgKSB7XCIsXCIgICAgICAgICAgICAgIHZhciBuZXdSZWMgPSBuZXdEYXRhLnJlY29yZHNbcGVuZGluZ1JlYy51aWRdO1wiLFwiXCIsXCIgICAgICAgICAgICAgIGlmKCBwZW5kaW5nUmVjLmFjdGlvbiA9PT0gXFxcInVwZGF0ZVxcXCIgJmFtcDsmYW1wOyBuZXdSZWMpIHtcIixcIiAgICAgICAgICAgICAgICAvLyBNb2RpZnkgdGhlIG5ldyBSZWNvcmQgdG8gaGF2ZSB0aGUgdXBkYXRlcyBmcm9tIHRoZSBwZW5kaW5nIHJlY29yZCBzbyB0aGUgbG9jYWwgZGF0YXNldCBpcyBjb25zaXN0ZW50XCIsXCIgICAgICAgICAgICAgICAgbmV3UmVjLmRhdGEgPSBwZW5kaW5nUmVjLnBvc3Q7XCIsXCIgICAgICAgICAgICAgICAgbmV3UmVjLmhhc2ggPSBwZW5kaW5nUmVjLnBvc3RIYXNoO1wiLFwiICAgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgICAgIGVsc2UgaWYoIHBlbmRpbmdSZWMuYWN0aW9uID09PSBcXFwiZGVsZXRlXFxcIiAmYW1wOyZhbXA7IG5ld1JlYykge1wiLFwiICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgcmVjb3JkIGZyb20gdGhlIG5ldyBkYXRhc2V0IHNvIHRoZSBsb2NhbCBkYXRhc2V0IGlzIGNvbnNpc3RlbnRcIixcIiAgICAgICAgICAgICAgICBkZWxldGUgbmV3RGF0YS5yZWNvcmRzW3BlbmRpbmdSZWMudWlkXTtcIixcIiAgICAgICAgICAgICAgfVwiLFwiICAgICAgICAgICAgICBlbHNlIGlmKCBwZW5kaW5nUmVjLmFjdGlvbiA9PT0gXFxcImNyZWF0ZVxcXCIgKSB7XCIsXCIgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBwZW5kaW5nIGNyZWF0ZSBpbnRvIHRoZSBuZXcgZGF0YXNldCBzbyBpdCBpcyBub3QgbG9zdCBmcm9tIHRoZSBVSVwiLFwiICAgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygndXBkYXRlTmV3RGF0YUZyb21JbkZsaWdodCAtIHJlIGFkZGluZyBwZW5kaW5nIGNyZWF0ZSB0byBpbmNvbW1pbmcgZGF0YXNldCcpO1wiLFwiICAgICAgICAgICAgICAgIHZhciBuZXdQZW5kaW5nQ3JlYXRlID0ge1wiLFwiICAgICAgICAgICAgICAgICAgZGF0YTogcGVuZGluZ1JlYy5wb3N0LFwiLFwiICAgICAgICAgICAgICAgICAgaGFzaDogcGVuZGluZ1JlYy5wb3N0SGFzaFwiLFwiICAgICAgICAgICAgICAgIH07XCIsXCIgICAgICAgICAgICAgICAgbmV3RGF0YS5yZWNvcmRzW3BlbmRpbmdSZWMudWlkXSA9IG5ld1BlbmRpbmdDcmVhdGU7XCIsXCIgICAgICAgICAgICAgIH1cIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgICB9XCIsXCIgICAgICAgIH1cIixcIiAgICAgIH1cIixcIiAgICB9XCIsXCIgIH0sXCIsXCJcIixcIiAgdXBkYXRlTmV3RGF0YUZyb21QZW5kaW5nOiBmdW5jdGlvbihkYXRhc2V0X2lkLCBkYXRhc2V0LCBuZXdEYXRhKSB7XCIsXCIgICAgdmFyIHBlbmRpbmcgPSBkYXRhc2V0LnBlbmRpbmc7XCIsXCJcIixcIiAgICBpZiggcGVuZGluZyAmYW1wOyZhbXA7IG5ld0RhdGEucmVjb3Jkcykge1wiLFwiICAgICAgZm9yKCB2YXIgcGVuZGluZ0hhc2ggaW4gcGVuZGluZyApIHtcIixcIiAgICAgICAgaWYoIHBlbmRpbmcuaGFzT3duUHJvcGVydHkocGVuZGluZ0hhc2gpICkge1wiLFwiICAgICAgICAgIHZhciBwZW5kaW5nUmVjID0gcGVuZGluZ1twZW5kaW5nSGFzaF07XCIsXCJcIixcIiAgICAgICAgICBpZiggcGVuZGluZ1JlYy5pbkZsaWdodCA9PT0gZmFsc2UgKSB7XCIsXCIgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0ZU5ld0RhdGFGcm9tUGVuZGluZyAtIEZvdW5kIE5vbiBpbkZsaWdodCByZWNvcmQgLSZndDsgYWN0aW9uPScgKyBwZW5kaW5nUmVjLmFjdGlvbiArJyA6OiB1aWQ9JyArIHBlbmRpbmdSZWMudWlkICArICcgOjogaGFzaD0nICsgcGVuZGluZ1JlYy5oYXNoKTtcIixcIiAgICAgICAgICAgIHZhciBuZXdSZWMgPSBuZXdEYXRhLnJlY29yZHNbcGVuZGluZ1JlYy51aWRdO1wiLFwiICAgICAgICAgICAgaWYoIHBlbmRpbmdSZWMuYWN0aW9uID09PSBcXFwidXBkYXRlXFxcIiAmYW1wOyZhbXA7IG5ld1JlYykge1wiLFwiICAgICAgICAgICAgICAvLyBNb2RpZnkgdGhlIG5ldyBSZWNvcmQgdG8gaGF2ZSB0aGUgdXBkYXRlcyBmcm9tIHRoZSBwZW5kaW5nIHJlY29yZCBzbyB0aGUgbG9jYWwgZGF0YXNldCBpcyBjb25zaXN0ZW50XCIsXCIgICAgICAgICAgICAgIG5ld1JlYy5kYXRhID0gcGVuZGluZ1JlYy5wb3N0O1wiLFwiICAgICAgICAgICAgICBuZXdSZWMuaGFzaCA9IHBlbmRpbmdSZWMucG9zdEhhc2g7XCIsXCIgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgICBlbHNlIGlmKCBwZW5kaW5nUmVjLmFjdGlvbiA9PT0gXFxcImRlbGV0ZVxcXCIgJmFtcDsmYW1wOyBuZXdSZWMpIHtcIixcIiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSByZWNvcmQgZnJvbSB0aGUgbmV3IGRhdGFzZXQgc28gdGhlIGxvY2FsIGRhdGFzZXQgaXMgY29uc2lzdGVudFwiLFwiICAgICAgICAgICAgICBkZWxldGUgbmV3RGF0YS5yZWNvcmRzW3BlbmRpbmdSZWMudWlkXTtcIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgICAgIGVsc2UgaWYoIHBlbmRpbmdSZWMuYWN0aW9uID09PSBcXFwiY3JlYXRlXFxcIiApIHtcIixcIiAgICAgICAgICAgICAgLy8gQWRkIHRoZSBwZW5kaW5nIGNyZWF0ZSBpbnRvIHRoZSBuZXcgZGF0YXNldCBzbyBpdCBpcyBub3QgbG9zdCBmcm9tIHRoZSBVSVwiLFwiICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0ZU5ld0RhdGFGcm9tUGVuZGluZyAtIHJlIGFkZGluZyBwZW5kaW5nIGNyZWF0ZSB0byBpbmNvbW1pbmcgZGF0YXNldCcpO1wiLFwiICAgICAgICAgICAgICB2YXIgbmV3UGVuZGluZ0NyZWF0ZSA9IHtcIixcIiAgICAgICAgICAgICAgICBkYXRhOiBwZW5kaW5nUmVjLnBvc3QsXCIsXCIgICAgICAgICAgICAgICAgaGFzaDogcGVuZGluZ1JlYy5wb3N0SGFzaFwiLFwiICAgICAgICAgICAgICB9O1wiLFwiICAgICAgICAgICAgICBuZXdEYXRhLnJlY29yZHNbcGVuZGluZ1JlYy51aWRdID0gbmV3UGVuZGluZ0NyZWF0ZTtcIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgICB9XCIsXCIgICAgICAgIH1cIixcIiAgICAgIH1cIixcIiAgICB9XCIsXCIgIH0sXCIsXCJcIixcIiAgdXBkYXRlQ3Jhc2hlZEluRmxpZ2h0RnJvbU5ld0RhdGE6IGZ1bmN0aW9uKGRhdGFzZXRfaWQsIGRhdGFzZXQsIG5ld0RhdGEpIHtcIixcIiAgICB2YXIgdXBkYXRlTm90aWZpY2F0aW9ucyA9IHtcIixcIiAgICAgIGFwcGxpZWQ6IHNlbGYubm90aWZpY2F0aW9ucy5SRU1PVEVfVVBEQVRFX0FQUExJRUQsXCIsXCIgICAgICBmYWlsZWQ6IHNlbGYubm90aWZpY2F0aW9ucy5SRU1PVEVfVVBEQVRFX0ZBSUxFRCxcIixcIiAgICAgIGNvbGxpc2lvbnM6IHNlbGYubm90aWZpY2F0aW9ucy5DT0xMSVNJT05fREVURUNURURcIixcIiAgICB9O1wiLFwiXCIsXCIgICAgdmFyIHBlbmRpbmcgPSBkYXRhc2V0LnBlbmRpbmc7XCIsXCIgICAgdmFyIHJlc29sdmVkQ3Jhc2hlcyA9IHt9O1wiLFwiICAgIHZhciBwZW5kaW5nSGFzaDtcIixcIiAgICB2YXIgcGVuZGluZ1JlYztcIixcIlwiLFwiXCIsXCIgICAgaWYoIHBlbmRpbmcgKSB7XCIsXCIgICAgICBmb3IoIHBlbmRpbmdIYXNoIGluIHBlbmRpbmcgKSB7XCIsXCIgICAgICAgIGlmKCBwZW5kaW5nLmhhc093blByb3BlcnR5KHBlbmRpbmdIYXNoKSApIHtcIixcIiAgICAgICAgICBwZW5kaW5nUmVjID0gcGVuZGluZ1twZW5kaW5nSGFzaF07XCIsXCJcIixcIiAgICAgICAgICBpZiggcGVuZGluZ1JlYy5pbkZsaWdodCAmYW1wOyZhbXA7IHBlbmRpbmdSZWMuY3Jhc2hlZCkge1wiLFwiICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCd1cGRhdGVDcmFzaGVkSW5GbGlnaHRGcm9tTmV3RGF0YSAtIEZvdW5kIGNyYXNoZWQgaW5GbGlnaHQgcGVuZGluZyByZWNvcmQgdWlkPScgKyBwZW5kaW5nUmVjLnVpZCArICcgOjogaGFzaD0nICsgcGVuZGluZ1JlYy5oYXNoICk7XCIsXCIgICAgICAgICAgICBpZiggbmV3RGF0YSAmYW1wOyZhbXA7IG5ld0RhdGEudXBkYXRlcyAmYW1wOyZhbXA7IG5ld0RhdGEudXBkYXRlcy5oYXNoZXMpIHtcIixcIlwiLFwiICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgdXBkYXRlcyByZWNlaXZlZCBjb250YWluIGFueSBpbmZvIGFib3V0IHRoZSBjcmFzaGVkIGluIGZsaWdodCB1cGRhdGVcIixcIiAgICAgICAgICAgICAgdmFyIGNyYXNoZWRVcGRhdGUgPSBuZXdEYXRhLnVwZGF0ZXMuaGFzaGVzW3BlbmRpbmdIYXNoXTtcIixcIiAgICAgICAgICAgICAgaWYoIGNyYXNoZWRVcGRhdGUgKSB7XCIsXCIgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBmb3VuZCBhbiB1cGRhdGUgb24gb25lIG9mIG91ciBpbiBmbGlnaHQgY3Jhc2hlZCByZWNvcmRzXCIsXCJcIixcIiAgICAgICAgICAgICAgICByZXNvbHZlZENyYXNoZXNbY3Jhc2hlZFVwZGF0ZS51aWRdID0gY3Jhc2hlZFVwZGF0ZTtcIixcIlwiLFwiICAgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygndXBkYXRlQ3Jhc2hlZEluRmxpZ2h0RnJvbU5ld0RhdGEgLSBSZXNvbHZpbmcgc3RhdHVzIGZvciBjcmFzaGVkIGluZmxpZ2h0IHBlbmRpbmcgcmVjb3JkICcgKyBKU09OLnN0cmluZ2lmeShjcmFzaGVkVXBkYXRlKSk7XCIsXCJcIixcIiAgICAgICAgICAgICAgICBpZiggY3Jhc2hlZFVwZGF0ZS50eXBlID09PSAnZmFpbGVkJyApIHtcIixcIiAgICAgICAgICAgICAgICAgIC8vIENyYXNoZWQgdXBkYXRlIGZhaWxlZCAtIHJldmVydCBsb2NhbCBkYXRhc2V0XCIsXCIgICAgICAgICAgICAgICAgICBpZiggY3Jhc2hlZFVwZGF0ZS5hY3Rpb24gPT09ICdjcmVhdGUnICkge1wiLFwiICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0ZUNyYXNoZWRJbkZsaWdodEZyb21OZXdEYXRhIC0gRGVsZXRpbmcgZmFpbGVkIGNyZWF0ZSBmcm9tIGRhdGFzZXQnKTtcIixcIiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFzZXQuZGF0YVtjcmFzaGVkVXBkYXRlLnVpZF07XCIsXCIgICAgICAgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgICAgICAgICBlbHNlIGlmICggY3Jhc2hlZFVwZGF0ZS5hY3Rpb24gPT09ICd1cGRhdGUnIHx8IGNyYXNoZWRVcGRhdGUuYWN0aW9uID09PSAnZGVsZXRlJyApIHtcIixcIiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCd1cGRhdGVDcmFzaGVkSW5GbGlnaHRGcm9tTmV3RGF0YSAtIFJldmVydGluZyBmYWlsZWQgJyArIGNyYXNoZWRVcGRhdGUuYWN0aW9uICsgJyBpbiBkYXRhc2V0Jyk7XCIsXCIgICAgICAgICAgICAgICAgICAgIGRhdGFzZXQuZGF0YVtjcmFzaGVkVXBkYXRlLnVpZF0gPSB7XCIsXCIgICAgICAgICAgICAgICAgICAgICAgZGF0YSA6IHBlbmRpbmdSZWMucHJlLFwiLFwiICAgICAgICAgICAgICAgICAgICAgIGhhc2ggOiBwZW5kaW5nUmVjLnByZUhhc2hcIixcIiAgICAgICAgICAgICAgICAgICAgfTtcIixcIiAgICAgICAgICAgICAgICAgIH1cIixcIiAgICAgICAgICAgICAgICB9XCIsXCJcIixcIiAgICAgICAgICAgICAgICBkZWxldGUgcGVuZGluZ1twZW5kaW5nSGFzaF07XCIsXCIgICAgICAgICAgICAgICAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCBjcmFzaGVkVXBkYXRlLnVpZCwgdXBkYXRlTm90aWZpY2F0aW9uc1tjcmFzaGVkVXBkYXRlLnR5cGVdLCBjcmFzaGVkVXBkYXRlKTtcIixcIiAgICAgICAgICAgICAgfVwiLFwiICAgICAgICAgICAgICBlbHNlIHtcIixcIiAgICAgICAgICAgICAgICAvLyBObyB3b3JkIG9uIG91ciBjcmFzaGVkIHVwZGF0ZSAtIGluY3JlbWVudCBhIGNvdW50ZXIgdG8gcmVmbGVjdCBhbm90aGVyIHN5bmMgdGhhdCBkaWQgbm90IGdpdmUgdXNcIixcIiAgICAgICAgICAgICAgICAvLyBhbnkgdXBkYXRlIG9uIG91ciBjcmFzaGVkIHJlY29yZC5cIixcIiAgICAgICAgICAgICAgICBpZiggcGVuZGluZ1JlYy5jcmFzaGVkQ291bnQgKSB7XCIsXCIgICAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLmNyYXNoZWRDb3VudCsrO1wiLFwiICAgICAgICAgICAgICAgIH1cIixcIiAgICAgICAgICAgICAgICBlbHNlIHtcIixcIiAgICAgICAgICAgICAgICAgIHBlbmRpbmdSZWMuY3Jhc2hlZENvdW50ID0gMTtcIixcIiAgICAgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgICAgIH1cIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgICAgIGVsc2Uge1wiLFwiICAgICAgICAgICAgICAvLyBObyB3b3JkIG9uIG91ciBjcmFzaGVkIHVwZGF0ZSAtIGluY3JlbWVudCBhIGNvdW50ZXIgdG8gcmVmbGVjdCBhbm90aGVyIHN5bmMgdGhhdCBkaWQgbm90IGdpdmUgdXNcIixcIiAgICAgICAgICAgICAgLy8gYW55IHVwZGF0ZSBvbiBvdXIgY3Jhc2hlZCByZWNvcmQuXCIsXCIgICAgICAgICAgICAgIGlmKCBwZW5kaW5nUmVjLmNyYXNoZWRDb3VudCApIHtcIixcIiAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLmNyYXNoZWRDb3VudCsrO1wiLFwiICAgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgICAgIGVsc2Uge1wiLFwiICAgICAgICAgICAgICAgIHBlbmRpbmdSZWMuY3Jhc2hlZENvdW50ID0gMTtcIixcIiAgICAgICAgICAgICAgfVwiLFwiICAgICAgICAgICAgfVwiLFwiICAgICAgICAgIH1cIixcIiAgICAgICAgfVwiLFwiICAgICAgfVwiLFwiXCIsXCIgICAgICBmb3IoIHBlbmRpbmdIYXNoIGluIHBlbmRpbmcgKSB7XCIsXCIgICAgICAgIGlmKCBwZW5kaW5nLmhhc093blByb3BlcnR5KHBlbmRpbmdIYXNoKSApIHtcIixcIiAgICAgICAgICBwZW5kaW5nUmVjID0gcGVuZGluZ1twZW5kaW5nSGFzaF07XCIsXCJcIixcIiAgICAgICAgICBpZiggcGVuZGluZ1JlYy5pbkZsaWdodCAmYW1wOyZhbXA7IHBlbmRpbmdSZWMuY3Jhc2hlZCkge1wiLFwiICAgICAgICAgICAgaWYoIHBlbmRpbmdSZWMuY3Jhc2hlZENvdW50ICZndDsgZGF0YXNldC5jb25maWcuY3Jhc2hlZF9jb3VudF93YWl0ICkge1wiLFwiICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0ZUNyYXNoZWRJbkZsaWdodEZyb21OZXdEYXRhIC0gQ3Jhc2hlZCBpbmZsaWdodCBwZW5kaW5nIHJlY29yZCBoYXMgcmVhY2hlZCBjcmFzaGVkX2NvdW50X3dhaXQgbGltaXQgOiAnICsgSlNPTi5zdHJpbmdpZnkocGVuZGluZ1JlYykpO1wiLFwiICAgICAgICAgICAgICBpZiggZGF0YXNldC5jb25maWcucmVzZW5kX2NyYXNoZWRfdXBkYXRlcyApIHtcIixcIiAgICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0ZUNyYXNoZWRJbkZsaWdodEZyb21OZXdEYXRhIC0gUmV0cnlpZyBjcmFzaGVkIGluZmxpZ2h0IHBlbmRpbmcgcmVjb3JkJyk7XCIsXCIgICAgICAgICAgICAgICAgcGVuZGluZ1JlYy5jcmFzaGVkID0gZmFsc2U7XCIsXCIgICAgICAgICAgICAgICAgcGVuZGluZ1JlYy5pbkZsaWdodCA9IGZhbHNlO1wiLFwiICAgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgICAgIGVsc2Uge1wiLFwiICAgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygndXBkYXRlQ3Jhc2hlZEluRmxpZ2h0RnJvbU5ld0RhdGEgLSBEZWxldGluZyBjcmFzaGVkIGluZmxpZ2h0IHBlbmRpbmcgcmVjb3JkJyk7XCIsXCIgICAgICAgICAgICAgICAgZGVsZXRlIHBlbmRpbmdbcGVuZGluZ0hhc2hdO1wiLFwiICAgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgfVwiLFwiICAgICAgICAgIGVsc2UgaWYgKCFwZW5kaW5nUmVjLmluRmxpZ2h0ICZhbXA7JmFtcDsgcGVuZGluZ1JlYy5jcmFzaGVkICkge1wiLFwiICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCd1cGRhdGVDcmFzaGVkSW5GbGlnaHRGcm9tTmV3RGF0YSAtIFRyeWluZyB0byByZXNvbHZlIGlzc3VlcyB3aXRoIGNyYXNoZWQgbm9uIGluIGZsaWdodCByZWNvcmQgLSB1aWQgPSAnICsgcGVuZGluZ1JlYy51aWQpO1wiLFwiICAgICAgICAgICAgLy8gU3RhbGxlZCBwZW5kaW5nIHJlY29yZCBiZWNhdXNlIGEgcHJldmlvdXMgcGVuZGluZyB1cGRhdGUgb24gdGhlIHNhbWUgcmVjb3JkIGNyYXNoZWRcIixcIiAgICAgICAgICAgIHZhciBjcmFzaGVkUmVmID0gcmVzb2x2ZWRDcmFzaGVzW3BlbmRpbmdSZWMudWlkXTtcIixcIiAgICAgICAgICAgIGlmKCBjcmFzaGVkUmVmICkge1wiLFwiICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0ZUNyYXNoZWRJbkZsaWdodEZyb21OZXdEYXRhIC0gRm91bmQgYSBzdGFsbGVkIHBlbmRpbmcgcmVjb3JkIGJhY2tlZCB1cCBiZWhpbmQgYSByZXNvbHZlZCBjcmFzaCB1aWQ9JyArIHBlbmRpbmdSZWMudWlkICsgJyA6OiBoYXNoPScgKyBwZW5kaW5nUmVjLmhhc2gpO1wiLFwiICAgICAgICAgICAgICBwZW5kaW5nUmVjLmNyYXNoZWQgPSBmYWxzZTtcIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgICB9XCIsXCIgICAgICAgIH1cIixcIiAgICAgIH1cIixcIiAgICB9XCIsXCIgIH0sXCIsXCJcIixcIiAgdXBkYXRlRGVsYXllZEZyb21OZXdEYXRhOiBmdW5jdGlvbihkYXRhc2V0X2lkLCBkYXRhc2V0LCBuZXdEYXRhKXtcIixcIiAgICB2YXIgcGVuZGluZyA9IGRhdGFzZXQucGVuZGluZztcIixcIiAgICB2YXIgcGVuZGluZ0hhc2g7XCIsXCIgICAgdmFyIHBlbmRpbmdSZWM7XCIsXCIgICAgaWYocGVuZGluZyl7XCIsXCIgICAgICBmb3IoIHBlbmRpbmdIYXNoIGluIHBlbmRpbmcgKXtcIixcIiAgICAgICAgaWYoIHBlbmRpbmcuaGFzT3duUHJvcGVydHkocGVuZGluZ0hhc2gpICl7XCIsXCIgICAgICAgICAgcGVuZGluZ1JlYyA9IHBlbmRpbmdbcGVuZGluZ0hhc2hdO1wiLFwiICAgICAgICAgIGlmKCBwZW5kaW5nUmVjLmRlbGF5ZWQgJmFtcDsmYW1wOyBwZW5kaW5nUmVjLndhaXRpbmcgKXtcIixcIiAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygndXBkYXRlRGVsYXllZEZyb21OZXdEYXRhIC0gRm91bmQgZGVsYXllZCBwZW5kaW5nIHJlY29yZCB1aWQ9JyArIHBlbmRpbmdSZWMudWlkICsgJyA6OiBoYXNoPScgKyBwZW5kaW5nUmVjLmhhc2ggKyAnIDo6IHdhaXRpbmc9JyArIHBlbmRpbmdSZWMud2FpdGluZyk7XCIsXCIgICAgICAgICAgICBpZiggbmV3RGF0YSAmYW1wOyZhbXA7IG5ld0RhdGEudXBkYXRlcyAmYW1wOyZhbXA7IG5ld0RhdGEudXBkYXRlcy5oYXNoZXMgKXtcIixcIiAgICAgICAgICAgICAgdmFyIHdhaXRpbmdSZWMgPSBuZXdEYXRhLnVwZGF0ZXMuaGFzaGVzW3BlbmRpbmdSZWMud2FpdGluZ107XCIsXCIgICAgICAgICAgICAgIGlmKHdhaXRpbmdSZWMpe1wiLFwiICAgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygndXBkYXRlRGVsYXllZEZyb21OZXdEYXRhIC0gV2FpdGluZyBwZW5kaW5nIHJlY29yZCBpcyByZXNvbHZlZCByZWM9JyArIEpTT04uc3RyaW5naWZ5KHdhaXRpbmdSZWMpKTtcIixcIiAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLmRlbGF5ZWQgPSBmYWxzZTtcIixcIiAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLndhaXRpbmcgPSB1bmRlZmluZWQ7XCIsXCIgICAgICAgICAgICAgIH1cIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgICB9XCIsXCIgICAgICAgIH1cIixcIiAgICAgIH1cIixcIiAgICB9XCIsXCIgIH0sXCIsXCJcIixcIlwiLFwiICBtYXJrSW5GbGlnaHRBc0NyYXNoZWQgOiBmdW5jdGlvbihkYXRhc2V0KSB7XCIsXCIgICAgdmFyIHBlbmRpbmcgPSBkYXRhc2V0LnBlbmRpbmc7XCIsXCIgICAgdmFyIHBlbmRpbmdIYXNoO1wiLFwiICAgIHZhciBwZW5kaW5nUmVjO1wiLFwiXCIsXCIgICAgaWYoIHBlbmRpbmcgKSB7XCIsXCIgICAgICB2YXIgY3Jhc2hlZFJlY29yZHMgPSB7fTtcIixcIiAgICAgIGZvciggcGVuZGluZ0hhc2ggaW4gcGVuZGluZyApIHtcIixcIiAgICAgICAgaWYoIHBlbmRpbmcuaGFzT3duUHJvcGVydHkocGVuZGluZ0hhc2gpICkge1wiLFwiICAgICAgICAgIHBlbmRpbmdSZWMgPSBwZW5kaW5nW3BlbmRpbmdIYXNoXTtcIixcIlwiLFwiICAgICAgICAgIGlmKCBwZW5kaW5nUmVjLmluRmxpZ2h0ICkge1wiLFwiICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCdNYXJraW5nIGluIGZsaWdodCBwZW5kaW5nIHJlY29yZCBhcyBjcmFzaGVkIDogJyArIHBlbmRpbmdIYXNoKTtcIixcIiAgICAgICAgICAgIHBlbmRpbmdSZWMuY3Jhc2hlZCA9IHRydWU7XCIsXCIgICAgICAgICAgICBjcmFzaGVkUmVjb3Jkc1twZW5kaW5nUmVjLnVpZF0gPSBwZW5kaW5nUmVjO1wiLFwiICAgICAgICAgIH1cIixcIiAgICAgICAgfVwiLFwiICAgICAgfVwiLFwiXCIsXCIgICAgICAvLyBDaGVjayBmb3IgYW55IHBlbmRpbmcgdXBkYXRlcyB0aGF0IHdvdWxkIGJlIG1vZGlmeWluZyBhIGNyYXNoZWQgcmVjb3JkLiBUaGVzZSBjYW4gbm90IGdvIG91dCB1bnRpbCB0aGVcIixcIiAgICAgIC8vIHN0YXR1cyBvZiB0aGUgY3Jhc2hlZCByZWNvcmQgaXMgZGV0ZXJtaW5lZFwiLFwiICAgICAgZm9yKCBwZW5kaW5nSGFzaCBpbiBwZW5kaW5nICkge1wiLFwiICAgICAgICBpZiggcGVuZGluZy5oYXNPd25Qcm9wZXJ0eShwZW5kaW5nSGFzaCkgKSB7XCIsXCIgICAgICAgICAgcGVuZGluZ1JlYyA9IHBlbmRpbmdbcGVuZGluZ0hhc2hdO1wiLFwiXCIsXCIgICAgICAgICAgaWYoICEgcGVuZGluZ1JlYy5pbkZsaWdodCAmYW1wOyZhbXA7ICEgcGVuZGluZ1JlYy5kZWxheWVkICkge1wiLFwiICAgICAgICAgICAgdmFyIGNyYXNoZWRSZWYgPSBjcmFzaGVkUmVjb3Jkc1twZW5kaW5nUmVjLnVpZF07XCIsXCIgICAgICAgICAgICBpZiggY3Jhc2hlZFJlZiApIHtcIixcIiAgICAgICAgICAgICAgcGVuZGluZ1JlYy5jcmFzaGVkID0gdHJ1ZTtcIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgICB9XCIsXCIgICAgICAgIH1cIixcIiAgICAgIH1cIixcIiAgICB9XCIsXCIgIH0sXCIsXCJcIixcIiAgY29uc29sZUxvZzogZnVuY3Rpb24obXNnKSB7XCIsXCIgICAgaWYoIHNlbGYuY29uZmlnLmRvX2NvbnNvbGVfbG9nICkge1wiLFwiICAgICAgY29uc29sZS5sb2cobXNnKTtcIixcIiAgICB9XCIsXCIgIH1cIixcIn07XCIsXCJcIixcIihmdW5jdGlvbigpIHtcIixcIiAgc2VsZi5jb25maWcgPSBzZWxmLmRlZmF1bHRzO1wiLFwiICAvL0luaXRpYWxzZSB0aGUgc3luYyBzZXJ2aWNlIHdpdGggZGVmYXVsdCBjb25maWdcIixcIiAgLy9zZWxmLmluaXQoe30pO1wiLFwifSkoKTtcIixcIlwiLFwibW9kdWxlLmV4cG9ydHMgPSB7XCIsXCIgIGluaXQ6IHNlbGYuaW5pdCxcIixcIiAgbWFuYWdlOiBzZWxmLm1hbmFnZSxcIixcIiAgbm90aWZ5OiBzZWxmLm5vdGlmeSxcIixcIiAgZG9MaXN0OiBzZWxmLmxpc3QsXCIsXCIgIGRvQ3JlYXRlOiBzZWxmLmNyZWF0ZSxcIixcIiAgZG9SZWFkOiBzZWxmLnJlYWQsXCIsXCIgIGRvVXBkYXRlOiBzZWxmLnVwZGF0ZSxcIixcIiAgZG9EZWxldGU6IHNlbGZbJ2RlbGV0ZSddLFwiLFwiICBsaXN0Q29sbGlzaW9uczogc2VsZi5saXN0Q29sbGlzaW9ucyxcIixcIiAgcmVtb3ZlQ29sbGlzaW9uOiBzZWxmLnJlbW92ZUNvbGxpc2lvbixcIixcIiAgZ2V0UGVuZGluZyA6IHNlbGYuZ2V0UGVuZGluZyxcIixcIiAgY2xlYXJQZW5kaW5nIDogc2VsZi5jbGVhclBlbmRpbmcsXCIsXCIgIGdldERhdGFzZXQgOiBzZWxmLmdldERhdGFTZXQsXCIsXCIgIGdldFF1ZXJ5UGFyYW1zOiBzZWxmLmdldFF1ZXJ5UGFyYW1zLFwiLFwiICBzZXRRdWVyeVBhcmFtczogc2VsZi5zZXRRdWVyeVBhcmFtcyxcIixcIiAgZ2V0TWV0YURhdGE6IHNlbGYuZ2V0TWV0YURhdGEsXCIsXCIgIHNldE1ldGFEYXRhOiBzZWxmLnNldE1ldGFEYXRhLFwiLFwiICBnZXRDb25maWc6IHNlbGYuZ2V0Q29uZmlnLFwiLFwiICBzZXRDb25maWc6IHNlbGYuc2V0Q29uZmlnLFwiLFwiICBzdGFydFN5bmM6IHNlbGYuc3RhcnRTeW5jLFwiLFwiICBzdG9wU3luYzogc2VsZi5zdG9wU3luYyxcIixcIiAgZG9TeW5jOiBzZWxmLmRvU3luYyxcIixcIiAgZm9yY2VTeW5jOiBzZWxmLmZvcmNlU3luYyxcIixcIiAgZ2VuZXJhdGVIYXNoOiBzZWxmLmdlbmVyYXRlSGFzaFwiLFwifTtcIl07XG4iLCIvKiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBKU0NvdmVyYWdlIC0gZG8gbm90IGVkaXQgKi9cbmlmICh0eXBlb2YgXyRqc2NvdmVyYWdlID09PSAndW5kZWZpbmVkJykgXyRqc2NvdmVyYWdlID0ge307XG5pZiAoISBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvdXVpZC5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy91dWlkLmpzJ10gPSBbXTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3V1aWQuanMnXVsxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy91dWlkLmpzJ11bNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvdXVpZC5qcyddWzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3V1aWQuanMnXVs3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy91dWlkLmpzJ11bOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvdXVpZC5qcyddWzEwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy91dWlkLmpzJ11bMTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3V1aWQuanMnXVsxMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvdXVpZC5qcyddWzEzXSA9IDA7XG59XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvdXVpZC5qcyddWzFdKys7XG5tb2R1bGUuZXhwb3J0cyA9IHtjcmVhdGVVVUlEOiAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvdXVpZC5qcyddWzVdKys7XG4gIHZhciBzID0gW107XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy91dWlkLmpzJ11bNl0rKztcbiAgdmFyIGhleERpZ2l0YWxzID0gXCIwMTIzNDU2Nzg5QUJDREVGXCI7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy91dWlkLmpzJ11bN10rKztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3V1aWQuanMnXVs4XSsrO1xuICAgIHNbaV0gPSBoZXhEaWdpdGFscy5zdWJzdHIoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTYpLCAxKTtcbn1cbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3V1aWQuanMnXVsxMF0rKztcbiAgc1sxMl0gPSBcIjRcIjtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3V1aWQuanMnXVsxMV0rKztcbiAgc1sxNl0gPSBoZXhEaWdpdGFscy5zdWJzdHIoKHNbMTZdICYgMykgfCA4LCAxKTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3V1aWQuanMnXVsxMl0rKztcbiAgdmFyIHV1aWQgPSBzLmpvaW4oXCJcIik7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy91dWlkLmpzJ11bMTNdKys7XG4gIHJldHVybiB1dWlkO1xufSl9O1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL3V1aWQuanMnXS5zb3VyY2UgPSBbXCJtb2R1bGUuZXhwb3J0cyA9IHtcIixcIiAgY3JlYXRlVVVJRCA6IGZ1bmN0aW9uICgpIHtcIixcIiAgICAvL2Zyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0XCIsXCIgICAgLy9iYXNlZCBvbiBSRkMgNDEyMiwgc2VjdGlvbiA0LjQgKEFsZ29yaXRobXMgZm9yIGNyZWF0aW5nIFVVSUQgZnJvbSB0cnVlbHkgcmFuZG9tIHByIHBzZXVkby1yYW5kb20gbnVtYmVyKVwiLFwiICAgIHZhciBzID0gW107XCIsXCIgICAgdmFyIGhleERpZ2l0YWxzID0gXFxcIjAxMjM0NTY3ODlBQkNERUZcXFwiO1wiLFwiICAgIGZvciAodmFyIGkgPSAwOyBpICZsdDsgMzI7IGkrKykge1wiLFwiICAgICAgc1tpXSA9IGhleERpZ2l0YWxzLnN1YnN0cihNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDEwKSwgMSk7XCIsXCIgICAgfVwiLFwiICAgIHNbMTJdID0gXFxcIjRcXFwiO1wiLFwiICAgIHNbMTZdID0gaGV4RGlnaXRhbHMuc3Vic3RyKChzWzE2XSAmYW1wOyAweDMpIHwgMHg4LCAxKTtcIixcIiAgICB2YXIgdXVpZCA9IHMuam9pbihcXFwiXFxcIik7XCIsXCIgICAgcmV0dXJuIHV1aWQ7XCIsXCIgIH1cIixcIn07XCJdO1xuIiwiLyogYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgSlNDb3ZlcmFnZSAtIGRvIG5vdCBlZGl0ICovXG5pZiAodHlwZW9mIF8kanNjb3ZlcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIF8kanNjb3ZlcmFnZSA9IHt9O1xuaWYgKCEgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzEyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVsxM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzE3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVsxOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMjBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzIxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVsyM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMjRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzI1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVsyNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMjddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzI4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVsyOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzMyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVszM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMzRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzQxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs0Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bNDVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzQ2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs0N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bNDhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzUwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs1NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bNTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzU4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs1OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bNjNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzY0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs2NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bNjZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzY3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs2OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bNzNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzc0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs3NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bNzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzc4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs4MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bODVdID0gMDtcbn1cbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVsxXSsrO1xudmFyIGluaXRpYWxpemVyID0gcmVxdWlyZShcIi4vaW5pdGlhbGl6ZXJcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMl0rKztcbnZhciBldmVudHMgPSByZXF1aXJlKFwiLi9ldmVudHNcIik7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bM10rKztcbnZhciBDbG91ZEhvc3QgPSByZXF1aXJlKFwiLi9ob3N0c1wiKTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs0XSsrO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs1XSsrO1xudmFyIGxvZ2dlciA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs5XSsrO1xudmFyIGNsb3VkX2hvc3Q7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMTFdKys7XG52YXIgaXNfaW5pdGlhbGlzaW5nID0gZmFsc2U7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMTJdKys7XG52YXIgaXNfY2xvdWRfcmVhZHkgPSBmYWxzZTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVsxM10rKztcbnZhciBpbml0X2Vycm9yID0gbnVsbDtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVsxNl0rKztcbnZhciByZWFkeSA9IChmdW5jdGlvbiAoY2IpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzE3XSsrO1xuICBpZiAoaXNfY2xvdWRfcmVhZHkpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMThdKys7XG4gICAgcmV0dXJuIGNiKG51bGwsIHtob3N0OiBnZXRDbG91ZEhvc3RVcmwoKX0pO1xuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVsyMF0rKztcbiAgICBldmVudHMub25jZShjb25zdGFudHMuSU5JVF9FVkVOVCwgKGZ1bmN0aW9uIChlcnIsIGhvc3QpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzIxXSsrO1xuICByZXR1cm4gY2IoZXJyLCBob3N0KTtcbn0pKTtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMjNdKys7XG4gICAgaWYgKCEgaXNfaW5pdGlhbGlzaW5nKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMjRdKys7XG4gICAgICBpc19pbml0aWFsaXNpbmcgPSB0cnVlO1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzI1XSsrO1xuICAgICAgaW5pdGlhbGl6ZXIuaW5pdCgoZnVuY3Rpb24gKGVyciwgaW5pdFJlcykge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMjZdKys7XG4gIGlzX2luaXRpYWxpc2luZyA9IGZhbHNlO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMjddKys7XG4gIGlmIChlcnIpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMjhdKys7XG4gICAgaW5pdF9lcnJvciA9IGVycjtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMjldKys7XG4gICAgcmV0dXJuIGV2ZW50cy5lbWl0KGNvbnN0YW50cy5JTklUX0VWRU5ULCBlcnIpO1xuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVszMV0rKztcbiAgICBpbml0X2Vycm9yID0gbnVsbDtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMzJdKys7XG4gICAgaXNfY2xvdWRfcmVhZHkgPSB0cnVlO1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVszM10rKztcbiAgICBjbG91ZF9ob3N0ID0gbmV3IENsb3VkSG9zdChpbml0UmVzLmNsb3VkKTtcbiAgICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bMzRdKys7XG4gICAgcmV0dXJuIGV2ZW50cy5lbWl0KGNvbnN0YW50cy5JTklUX0VWRU5ULCBudWxsLCB7aG9zdDogZ2V0Q2xvdWRIb3N0VXJsKCl9KTtcbiAgfVxufSkpO1xuICAgIH1cbiAgfVxufSk7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bNDFdKys7XG52YXIgZ2V0Q2xvdWRIb3N0ID0gKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzQyXSsrO1xuICByZXR1cm4gY2xvdWRfaG9zdDtcbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzQ1XSsrO1xudmFyIGdldENsb3VkSG9zdFVybCA9IChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs0Nl0rKztcbiAgaWYgKHR5cGVvZiBjbG91ZF9ob3N0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzQ3XSsrO1xuICAgIHZhciBhcHBQcm9wcyA9IHJlcXVpcmUoXCIuL2FwcFByb3BzXCIpLmdldEFwcFByb3BzKCk7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzQ4XSsrO1xuICAgIHJldHVybiBjbG91ZF9ob3N0LmdldEhvc3QoYXBwUHJvcHMubW9kZSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzUwXSsrO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzU0XSsrO1xudmFyIGlzUmVhZHkgPSAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bNTVdKys7XG4gIHJldHVybiBpc19jbG91ZF9yZWFkeTtcbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzU4XSsrO1xudmFyIGdldEluaXRFcnJvciA9IChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs1OV0rKztcbiAgcmV0dXJuIGluaXRfZXJyb3I7XG59KTtcbl8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs2M10rKztcbnZhciByZXNldCA9IChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs2NF0rKztcbiAgaXNfY2xvdWRfcmVhZHkgPSBmYWxzZTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzY1XSsrO1xuICBpc19pbml0aWFsaXNpbmcgPSBmYWxzZTtcbiAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzY2XSsrO1xuICBjbG91ZF9ob3N0ID0gdW5kZWZpbmVkO1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bNjddKys7XG4gIGluaXRfZXJyb3IgPSB1bmRlZmluZWQ7XG4gIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs2OF0rKztcbiAgcmVhZHkoKGZ1bmN0aW9uICgpIHtcbn0pKTtcbn0pO1xuXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzczXSsrO1xucmVhZHkoKGZ1bmN0aW9uIChlcnJvciwgaG9zdCkge1xuICBfJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bNzRdKys7XG4gIGlmIChlcnJvcikge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs3NV0rKztcbiAgICBpZiAoZXJyb3IubWVzc2FnZSAhPT0gXCJhcHBfY29uZmlnX21pc3NpbmdcIikge1xuICAgICAgXyRqc2NvdmVyYWdlWydtb2R1bGVzL3dhaXRGb3JDbG91ZC5qcyddWzc2XSsrO1xuICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGluaXRpYWxpc2UgZmguXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs3OF0rKztcbiAgICAgIGxvZ2dlci5pbmZvKFwiTm8gZmggY29uZmlnIGZpbGVcIik7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnbW9kdWxlcy93YWl0Rm9yQ2xvdWQuanMnXVs4MV0rKztcbiAgICBsb2dnZXIuaW5mbyhcImZoIGNsb3VkIGlzIHJlYWR5XCIpO1xuICB9XG59KSk7XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ11bODVdKys7XG5tb2R1bGUuZXhwb3J0cyA9IHtyZWFkeTogcmVhZHksIGlzUmVhZHk6IGlzUmVhZHksIGdldENsb3VkSG9zdDogZ2V0Q2xvdWRIb3N0LCBnZXRDbG91ZEhvc3RVcmw6IGdldENsb3VkSG9zdFVybCwgZ2V0SW5pdEVycm9yOiBnZXRJbml0RXJyb3IsIHJlc2V0OiByZXNldH07XG5fJGpzY292ZXJhZ2VbJ21vZHVsZXMvd2FpdEZvckNsb3VkLmpzJ10uc291cmNlID0gW1widmFyIGluaXRpYWxpemVyID0gcmVxdWlyZShcXFwiLi9pbml0aWFsaXplclxcXCIpO1wiLFwidmFyIGV2ZW50cyA9IHJlcXVpcmUoXFxcIi4vZXZlbnRzXFxcIik7XCIsXCJ2YXIgQ2xvdWRIb3N0ID0gcmVxdWlyZShcXFwiLi9ob3N0c1xcXCIpO1wiLFwidmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXFxcIi4vY29uc3RhbnRzXFxcIik7XCIsXCJ2YXIgbG9nZ2VyID0gcmVxdWlyZShcXFwiLi9sb2dnZXJcXFwiKTtcIixcIlwiLFwiXCIsXCIvL3RoZSBjbG91ZCBjb25maWd1cmF0aW9uc1wiLFwidmFyIGNsb3VkX2hvc3Q7XCIsXCJcIixcInZhciBpc19pbml0aWFsaXNpbmcgPSBmYWxzZTtcIixcInZhciBpc19jbG91ZF9yZWFkeSA9IGZhbHNlO1wiLFwidmFyIGluaXRfZXJyb3IgPSBudWxsO1wiLFwiXCIsXCJcIixcInZhciByZWFkeSA9IGZ1bmN0aW9uKGNiKXtcIixcIiAgaWYoaXNfY2xvdWRfcmVhZHkpe1wiLFwiICAgIHJldHVybiBjYihudWxsLCB7aG9zdDogZ2V0Q2xvdWRIb3N0VXJsKCl9KTtcIixcIiAgfSBlbHNlIHtcIixcIiAgICBldmVudHMub25jZShjb25zdGFudHMuSU5JVF9FVkVOVCwgZnVuY3Rpb24oZXJyLCBob3N0KXtcIixcIiAgICAgIHJldHVybiBjYihlcnIsIGhvc3QpO1wiLFwiICAgIH0pO1wiLFwiICAgIGlmKCFpc19pbml0aWFsaXNpbmcpe1wiLFwiICAgICAgaXNfaW5pdGlhbGlzaW5nID0gdHJ1ZTtcIixcIiAgICAgIGluaXRpYWxpemVyLmluaXQoZnVuY3Rpb24oZXJyLCBpbml0UmVzKXtcIixcIiAgICAgICAgaXNfaW5pdGlhbGlzaW5nID0gZmFsc2U7XCIsXCIgICAgICAgIGlmKGVycil7XCIsXCIgICAgICAgICAgaW5pdF9lcnJvciA9IGVycjtcIixcIiAgICAgICAgICByZXR1cm4gZXZlbnRzLmVtaXQoY29uc3RhbnRzLklOSVRfRVZFTlQsIGVycik7XCIsXCIgICAgICAgIH0gZWxzZSB7XCIsXCIgICAgICAgICAgaW5pdF9lcnJvciA9IG51bGw7XCIsXCIgICAgICAgICAgaXNfY2xvdWRfcmVhZHkgPSB0cnVlO1wiLFwiICAgICAgICAgIGNsb3VkX2hvc3QgPSBuZXcgQ2xvdWRIb3N0KGluaXRSZXMuY2xvdWQpO1wiLFwiICAgICAgICAgIHJldHVybiBldmVudHMuZW1pdChjb25zdGFudHMuSU5JVF9FVkVOVCwgbnVsbCwge2hvc3Q6IGdldENsb3VkSG9zdFVybCgpfSk7XCIsXCIgICAgICAgIH1cIixcIiAgICAgIH0pO1wiLFwiICAgIH1cIixcIiAgfVwiLFwifVwiLFwiXCIsXCJ2YXIgZ2V0Q2xvdWRIb3N0ID0gZnVuY3Rpb24oKXtcIixcIiAgcmV0dXJuIGNsb3VkX2hvc3Q7XCIsXCJ9XCIsXCJcIixcInZhciBnZXRDbG91ZEhvc3RVcmwgPSBmdW5jdGlvbigpe1wiLFwiICBpZih0eXBlb2YgY2xvdWRfaG9zdCAhPT0gXFxcInVuZGVmaW5lZFxcXCIpe1wiLFwiICAgIHZhciBhcHBQcm9wcyA9IHJlcXVpcmUoXFxcIi4vYXBwUHJvcHNcXFwiKS5nZXRBcHBQcm9wcygpO1wiLFwiICAgIHJldHVybiBjbG91ZF9ob3N0LmdldEhvc3QoYXBwUHJvcHMubW9kZSk7XCIsXCIgIH0gZWxzZSB7XCIsXCIgICAgcmV0dXJuIHVuZGVmaW5lZDtcIixcIiAgfVwiLFwifVwiLFwiXCIsXCJ2YXIgaXNSZWFkeSA9IGZ1bmN0aW9uKCl7XCIsXCIgIHJldHVybiBpc19jbG91ZF9yZWFkeTtcIixcIn1cIixcIlwiLFwidmFyIGdldEluaXRFcnJvciA9IGZ1bmN0aW9uKCl7XCIsXCIgIHJldHVybiBpbml0X2Vycm9yO1wiLFwifVwiLFwiXCIsXCIvL2ZvciB0ZXN0XCIsXCJ2YXIgcmVzZXQgPSBmdW5jdGlvbigpe1wiLFwiICBpc19jbG91ZF9yZWFkeSA9IGZhbHNlO1wiLFwiICBpc19pbml0aWFsaXNpbmcgPSBmYWxzZTtcIixcIiAgY2xvdWRfaG9zdCA9IHVuZGVmaW5lZDtcIixcIiAgaW5pdF9lcnJvciA9IHVuZGVmaW5lZDtcIixcIiAgcmVhZHkoZnVuY3Rpb24oKXtcIixcIiAgICBcIixcIiAgfSk7XCIsXCJ9XCIsXCJcIixcInJlYWR5KGZ1bmN0aW9uKGVycm9yLCBob3N0KXtcIixcIiAgaWYoZXJyb3Ipe1wiLFwiICAgIGlmKGVycm9yLm1lc3NhZ2UgIT09IFxcXCJhcHBfY29uZmlnX21pc3NpbmdcXFwiKXtcIixcIiAgICAgIGxvZ2dlci5lcnJvcihcXFwiRmFpbGVkIHRvIGluaXRpYWxpc2UgZmguXFxcIik7XCIsXCIgICAgfSBlbHNlIHtcIixcIiAgICAgIGxvZ2dlci5pbmZvKFxcXCJObyBmaCBjb25maWcgZmlsZVxcXCIpO1wiLFwiICAgIH1cIixcIiAgfSBlbHNlIHtcIixcIiAgICBsb2dnZXIuaW5mbyhcXFwiZmggY2xvdWQgaXMgcmVhZHlcXFwiKTtcIixcIiAgfVwiLFwifSk7XCIsXCJcIixcIm1vZHVsZS5leHBvcnRzID0ge1wiLFwiICByZWFkeTogcmVhZHksXCIsXCIgIGlzUmVhZHk6IGlzUmVhZHksXCIsXCIgIGdldENsb3VkSG9zdDogZ2V0Q2xvdWRIb3N0LFwiLFwiICBnZXRDbG91ZEhvc3RVcmw6IGdldENsb3VkSG9zdFVybCxcIixcIiAgZ2V0SW5pdEVycm9yOiBnZXRJbml0RXJyb3IsXCIsXCIgIHJlc2V0OiByZXNldFwiLFwifVwiXTtcbiIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2NvbnN0YW50c1wiKTtcbnZhciBsb2dnZXIgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2xvZ2dlclwiKTtcbnZhciBhamF4ID0gcmVxdWlyZShcIi4vbW9kdWxlcy9hamF4XCIpO1xudmFyIGV2ZW50cyA9IHJlcXVpcmUoXCIuL21vZHVsZXMvZXZlbnRzXCIpO1xudmFyIGNsb3VkID0gcmVxdWlyZShcIi4vbW9kdWxlcy93YWl0Rm9yQ2xvdWRcIik7XG52YXIgYXBpX2FjdCA9IHJlcXVpcmUoXCIuL21vZHVsZXMvYXBpX2FjdFwiKTtcbnZhciBhcGlfYXV0aCA9IHJlcXVpcmUoXCIuL21vZHVsZXMvYXBpX2F1dGhcIik7XG52YXIgYXBpX3NlYyA9IHJlcXVpcmUoXCIuL21vZHVsZXMvYXBpX3NlY1wiKTtcbnZhciBhcGlfaGFzaCA9IHJlcXVpcmUoXCIuL21vZHVsZXMvYXBpX2hhc2hcIik7XG52YXIgYXBpX3N5bmMgPSByZXF1aXJlKFwiLi9tb2R1bGVzL3N5bmMtY2xpXCIpO1xudmFyIGFwaV9tYmFhcyA9IHJlcXVpcmUoXCIuL21vZHVsZXMvYXBpX21iYWFzXCIpO1xudmFyIGFwaV9jbG91ZCA9IHJlcXVpcmUoXCIuL21vZHVsZXMvYXBpX2Nsb3VkXCIpO1xudmFyIGZocGFyYW1zID0gcmVxdWlyZShcIi4vbW9kdWxlcy9maHBhcmFtc1wiKTtcbnZhciBhcHBQcm9wcyA9IHJlcXVpcmUoXCIuL21vZHVsZXMvYXBwUHJvcHNcIik7XG52YXIgZGV2aWNlID0gcmVxdWlyZShcIi4vbW9kdWxlcy9kZXZpY2VcIik7XG5cbnZhciBkZWZhdWx0RmFpbCA9IGZ1bmN0aW9uKG1zZywgZXJyb3Ipe1xuICBsb2dnZXIuZXJyb3IobXNnICsgXCI6XCIgKyBKU09OLnN0cmluZ2lmeShlcnJvcikpO1xufTtcblxudmFyIGFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpe1xuICBldmVudHMuYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICBpZih0eXBlID09PSBjb25zdGFudHMuSU5JVF9FVkVOVCl7XG4gICAgLy9mb3IgZmhpbml0IGV2ZW50LCBuZWVkIHRvIGNoZWNrIHRoZSBzdGF0dXMgb2YgY2xvdWQgYW5kIG1heSBuZWVkIHRvIGZpcmUgdGhlIGxpc3RlbmVyIGltbWVkaWF0ZWx5LlxuICAgIGlmKGNsb3VkLmlzUmVhZHkoKSl7XG4gICAgICBsaXN0ZW5lcihudWxsLCB7aG9zdDogY2xvdWQuZ2V0Q2xvdWRIb3N0VXJsKCl9KTtcbiAgICB9IGVsc2UgaWYoY2xvdWQuZ2V0SW5pdEVycm9yKCkpe1xuICAgICAgbGlzdGVuZXIoY2xvdWQuZ2V0SW5pdEVycm9yKCkpO1xuICAgIH1cbiAgfSBcbn07XG5cbnZhciBvbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpe1xuICBpZih0eXBlID09PSBjb25zdGFudHMuSU5JVF9FVkVOVCAmJiBjbG91ZC5pc1JlYWR5KCkpe1xuICAgIGxpc3RlbmVyKG51bGwsIHtob3N0OiBjbG91ZC5nZXRDbG91ZEhvc3RVcmwoKX0pO1xuICB9IGVsc2UgaWYodHlwZSA9PT0gY29uc3RhbnRzLklOSVRfRVZFTlQgJiYgY2xvdWQuZ2V0SW5pdEVycm9yKCkpe1xuICAgIGxpc3RlbmVyKGNsb3VkLmdldEluaXRFcnJvcigpKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMub25jZSh0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbn07XG5cbi8vTGVnYWN5IHNoaW0uIEluaXQgaGFwZW5zIGJhc2VkIG9uIGZoY29uZmlnLmpzb24gb3IsIGZvciB2MiwgZ2xvYmFsIHZhciBjYWxsZWQgZmhfYXBwX3Byb3BzIHdoaWNoIGlzIGluamVjdGVkIGFzIHBhcnQgb2YgdGhlIGluZGV4Lmh0bWwgd3JhcHBlclxudmFyIGluaXQgPSBmdW5jdGlvbihvcHRzLCBzdWNjZXNzLCBmYWlsKXtcbiAgbG9nZ2VyLndhcm4oXCIkZmguaW5pdCB3aWxsIGJlIGRlcHJlY2F0ZWQgc29vblwiKTtcbiAgY2xvdWQucmVhZHkoZnVuY3Rpb24oZXJyLCBob3N0KXtcbiAgICBpZihlcnIpe1xuICAgICAgaWYodHlwZW9mIGZhaWwgPT09IFwiZnVuY3Rpb25cIil7XG4gICAgICAgIHJldHVybiBmYWlsKGVycik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKHR5cGVvZiBzdWNjZXNzID09PSBcImZ1bmN0aW9uXCIpe1xuICAgICAgICBzdWNjZXNzKGhvc3QuaG9zdCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBmaCA9IHdpbmRvdy4kZmggfHwge307XG5maC5pbml0ID0gaW5pdDtcbmZoLmFjdCA9IGFwaV9hY3Q7XG5maC5hdXRoID0gYXBpX2F1dGg7XG5maC5jbG91ZCA9IGFwaV9jbG91ZDtcbmZoLnNlYyA9IGFwaV9zZWM7XG5maC5oYXNoID0gYXBpX2hhc2g7XG5maC5zeW5jID0gYXBpX3N5bmM7XG5maC5hamF4ID0gZmguX19hamF4ID0gYWpheDtcbmZoLm1iYWFzID0gYXBpX21iYWFzO1xuZmguX2dldERldmljZUlkID0gZGV2aWNlLmdldERldmljZUlkO1xuXG5maC5nZXRDbG91ZFVSTCA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBjbG91ZC5nZXRDbG91ZEhvc3RVcmwoKTtcbn07XG5cbmZoLmdldEZIUGFyYW1zID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZocGFyYW1zLmJ1aWxkRkhQYXJhbXMoKTtcbn07XG5cbi8vZXZlbnRzXG5maC5hZGRMaXN0ZW5lciA9IGFkZExpc3RlbmVyO1xuZmgub24gPSBhZGRMaXN0ZW5lcjtcbmZoLm9uY2UgPSBvbmNlO1xudmFyIG1ldGhvZHMgPSBbXCJyZW1vdmVMaXN0ZW5lclwiLCBcInJlbW92ZUFsbExpc3RlbmVyc1wiLCBcInNldE1heExpc3RlbmVyc1wiLCBcImxpc3RlbmVyc1wiLCBcImVtaXRcIl07XG5mb3IodmFyIGk9MDtpPG1ldGhvZHMubGVuZ3RoO2krKyl7XG4gIGZoW21ldGhvZHNbaV1dID0gZXZlbnRzW21ldGhvZHNbaV1dO1xufVxuXG4vL2tlZXAgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuZmgub24oY29uc3RhbnRzLklOSVRfRVZFTlQsIGZ1bmN0aW9uKGVyciwgaG9zdCl7XG4gIGlmKGVycil7XG4gICAgZmguY2xvdWRfcHJvcHMgPSB7fTtcbiAgICBmaC5hcHBfcHJvcHMgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBmaC5jbG91ZF9wcm9wcyA9IHtob3N0czoge3VybDogaG9zdC5ob3N0fX07XG4gICAgZmguYXBwX3Byb3BzID0gYXBwUHJvcHMuZ2V0QXBwUHJvcHMoKTtcbiAgfVxufSk7XG5cbi8vZm9yIHRlc3RcbmZoLnJlc2V0ID0gY2xvdWQucmVzZXQ7XG4vL3dlIHNob3VsZCByZWFsbHkgc3RvcCBwb2xsdXRpbmcgZ2xvYmFsIG5hbWUgc3BhY2UuIElkZWFsbHkgd2Ugc2hvdWxkIGFzayBicm93c2VyaWZ5IHRvIHVzZSBcIiRmaFwiIHdoZW4gdW1kLWZ5IHRoZSBtb2R1bGUuIEhvd2V2ZXIsIFwiJFwiIGlzIG5vdCBhbGxvd2VkIGFzIHRoZSBzdGFuZGFyZCBtb2R1bGUgbmFtZS5cbi8vU28sIHdlIGFzc2lnbiAkZmggdG8gdGhlIHdpbmRvdyBuYW1lIHNwYWNlIGRpcmVjdGx5IGhlcmUuIChvdGhlcndpc2UsIHdlIGhhdmUgdG8gZm9yayB0aGUgZ3J1bnQgYnJvd3NlcmlmeSBwbHVnaW4sIHRoZW4gZm9yayBicm93ZXJpZnkgYW5kIHRoZSBkZXBlbmRlbnQgdW1kIG1vZHVsZSwgcmVhbGx5IG5vdCB3b3J0aGluZyB0aGUgZWZmb3J0KS5cbndpbmRvdy4kZmggPSBmaDtcbm1vZHVsZS5leHBvcnRzID0gZmg7XG5cblxuXG5cblxuIiwidmFyIFhEb21haW5SZXF1ZXN0V3JhcHBlciA9IGZ1bmN0aW9uKHhkcil7XG4gIHRoaXMueGRyID0geGRyO1xuICB0aGlzLmlzV3JhcHBlciA9IHRydWU7XG4gIHRoaXMucmVhZHlTdGF0ZSA9IDA7XG4gIHRoaXMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgdGhpcy5zdGF0dXMgPSAwO1xuICB0aGlzLnN0YXR1c1RleHQgPSBcIlwiO1xuICB0aGlzLnJlc3BvbnNlVGV4dCA9IFwiXCI7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy54ZHIub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYucmVhZHlTdGF0ZSA9IDQ7XG4gICAgICBzZWxmLnN0YXR1cyA9IDIwMDtcbiAgICAgIHNlbGYuc3RhdHVzVGV4dCA9IFwiXCI7XG4gICAgICBzZWxmLnJlc3BvbnNlVGV4dCA9IHNlbGYueGRyLnJlc3BvbnNlVGV4dDtcbiAgICAgIGlmKHNlbGYub25yZWFkeXN0YXRlY2hhbmdlKXtcbiAgICAgICAgICBzZWxmLm9ucmVhZHlzdGF0ZWNoYW5nZSgpO1xuICAgICAgfVxuICB9O1xuICB0aGlzLnhkci5vbmVycm9yID0gZnVuY3Rpb24oKXtcbiAgICAgIGlmKHNlbGYub25lcnJvcil7XG4gICAgICAgICAgc2VsZi5vbmVycm9yKCk7XG4gICAgICB9XG4gICAgICBzZWxmLnJlYWR5U3RhdGUgPSA0O1xuICAgICAgc2VsZi5zdGF0dXMgPSAwO1xuICAgICAgc2VsZi5zdGF0dXNUZXh0ID0gXCJcIjtcbiAgICAgIGlmKHNlbGYub25yZWFkeXN0YXRlY2hhbmdlKXtcbiAgICAgICAgICBzZWxmLm9ucmVhZHlzdGF0ZWNoYW5nZSgpO1xuICAgICAgfVxuICB9O1xuICB0aGlzLnhkci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpe1xuICAgICAgc2VsZi5yZWFkeVN0YXRlID0gNDtcbiAgICAgIHNlbGYuc3RhdHVzID0gNDA4O1xuICAgICAgc2VsZi5zdGF0dXNUZXh0ID0gXCJ0aW1lb3V0XCI7XG4gICAgICBpZihzZWxmLm9ucmVhZHlzdGF0ZWNoYW5nZSl7XG4gICAgICAgICAgc2VsZi5vbnJlYWR5c3RhdGVjaGFuZ2UoKTtcbiAgICAgIH1cbiAgfTtcbn07XG5cblhEb21haW5SZXF1ZXN0V3JhcHBlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBhc3luKXtcbiAgdGhpcy54ZHIub3BlbihtZXRob2QsIHVybCk7XG59O1xuXG5YRG9tYWluUmVxdWVzdFdyYXBwZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy54ZHIuc2VuZChkYXRhKTtcbn07XG5cblhEb21haW5SZXF1ZXN0V3JhcHBlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuICB0aGlzLnhkci5hYm9ydCgpO1xufTtcblxuWERvbWFpblJlcXVlc3RXcmFwcGVyLnByb3RvdHlwZS5zZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24obiwgdil7XG4gIC8vbm90IHN1cHBvcnRlZCBieSB4ZHJcbiAgLy9Hb29kIGRvYyBvbiBsaW1pdGF0aW9ucyBvZiBYRG9tYWluUmVxdWVzdCBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG4gIC8vWERvbWFpblJlcXVlc3QgZG9lc24ndCBhbGxvdyBzZXR0aW5nIGN1c3RvbSByZXF1ZXN0IGhlYWRlcnMuIEJ1dCBpdCBpcyB0aGUgb25seSBhdmFpbGFibGUgb3B0aW9uIHRvIGRvIENPUlMgcmVxdWVzdHMgaW4gSUU4ICYgOS4gSW4gSUUxMCwgdGhleSBmaW5hbGx5IHN0YXJ0IHRvIHVzZSBzdGFuZGFyZCBYTUxIdHRwUmVxdWVzdC5cbiAgLy9UbyBzdXBwb3J0IEZIIGF1dGggdG9rZW5zIGluIElFOCY5LCB3ZSBoYXZlIHRvIGZpbmQgYSBkaWZmZXJlbnQgd2F5IG9mIGRvaW5nIGl0LlxufTtcblxuWERvbWFpblJlcXVlc3RXcmFwcGVyLnByb3RvdHlwZS5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uKG4pe1xuICAvL25vdCBzdXBwb3J0ZWQgYnkgeGRyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhEb21haW5SZXF1ZXN0V3JhcHBlcjtcbiIsIi8vYSBzaGFtZWxlc3MgY29weSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9Gb3JiZXNMaW5kZXNheS9hamF4L2Jsb2IvbWFzdGVyL2luZGV4LmpzLiBcbi8vaXQgaGFzIHRoZSBzYW1lIG1ldGhvZHMgYW5kIGNvbmZpZyBvcHRpb25zIGFzIGpRdWVyeS96ZXB0b2pzIGJ1dCB2ZXJ5IGxpZ2h0IHdlaWdodC4gc2VlIGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9qUXVlcnkuYWpheC9cbi8vYSBmZXcgc21hbGwgY2hhbmdlcyBhcmUgbWFkZSBmb3Igc3VwcG9ydGluZyBJRSA4IGFuZCBvdGhlciBmZWF0dXJlczpcbi8vMS4gdXNlIGdldFhociBmdW5jdGlvbiB0byByZXBsYWNlIHRoZSBkZWZhdWx0IFhNTEh0dHBSZXF1ZXN0IGltcGxlbWVudGF0aW9uIGZvciBzdXBwb3J0aW5nIElFOFxuLy8yLiBJbnRlZ3JhdGUgd2l0aCBldmVudHMgZW1pdHRlci4gU28gdG8gc3Vic2NyaWJlIGFqYXggZXZlbnRzLCB5b3UgY2FuIGRvICRmaC5vbihcImFqYXhTdGFydFwiLCBoYW5kbGVyKS4gU2VlIGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9BamF4X0V2ZW50cy8gZm9yIGZ1bGwgbGlzdCBvZiBldmVudHNcbi8vMy4gYWxsb3cgcGFzc2luZyB4aHIgZmFjdG9yeSBtZXRob2QgdGhyb3VnaCBvcHRpb25zOiBlLmcuICRmaC5hamF4KHt4aHI6IGZ1bmN0aW9uKCl7Lypvd24gaW1wbGVtZW50YXRpb24gb2YgeGhyKi99fSk7IFxuLy80LiBVc2UgZmhfdGltZW91dCB2YWx1ZSBhcyB0aGUgZGVmYXVsdCB0aW1lb3V0XG4vLzUuIGFuIGV4dHJhIG9wdGlvbiBjYWxsZWQgXCJ0cnlKU09OUFwiIHRvIGFsbG93IHRyeSB0aGUgc2FtZSBjYWxsIHdpdGggSlNPTlAgaWYgbm9ybWFsIENPUlMgZmFpbGVkIC0gc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnRlcm5hbGx5XG4vLzYuIGZvciBqc29ucCwgYWxsb3cgdG8gc3BlY2lmeSB0aGUgY2FsbGJhY2sgcXVlcnkgcGFyYW0gbmFtZSB1c2luZyB0aGUgXCJqc29ucFwiIG9wdGlvblxuXG52YXIgZXZlbnRzSGFuZGxlciA9IHJlcXVpcmUoXCIuL2V2ZW50c1wiKTtcbnZhciBYRG9tYWluUmVxdWVzdFdyYXBwZXIgPSByZXF1aXJlKFwiLi9YRG9tYWluUmVxdWVzdFdyYXBwZXJcIik7XG52YXIgY29uc3RzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIGxvZ2dlciA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcblxudmFyIHR5cGVcbnRyeSB7XG4gIHR5cGUgPSByZXF1aXJlKCd0eXBlLW9mJylcbn0gY2F0Y2ggKGV4KSB7XG4gIC8vaGlkZSBmcm9tIGJyb3dzZXJpZnlcbiAgdmFyIHIgPSByZXF1aXJlXG4gIHR5cGUgPSByKCd0eXBlJylcbn1cblxudmFyIGpzb25wSUQgPSAwLFxuICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcbiAga2V5LFxuICBuYW1lLFxuICByc2NyaXB0ID0gLzxzY3JpcHRcXGJbXjxdKig/Oig/ITxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcL3NjcmlwdD4vZ2ksXG4gIHNjcmlwdFR5cGVSRSA9IC9eKD86dGV4dHxhcHBsaWNhdGlvbilcXC9qYXZhc2NyaXB0L2ksXG4gIHhtbFR5cGVSRSA9IC9eKD86dGV4dHxhcHBsaWNhdGlvbilcXC94bWwvaSxcbiAganNvblR5cGUgPSAnYXBwbGljYXRpb24vanNvbicsXG4gIGh0bWxUeXBlID0gJ3RleHQvaHRtbCcsXG4gIGJsYW5rUkUgPSAvXlxccyokLztcblxudmFyIGFqYXggPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBzZXR0aW5ncyA9IGV4dGVuZCh7fSwgb3B0aW9ucyB8fCB7fSlcbiAgZm9yIChrZXkgaW4gYWpheC5zZXR0aW5ncylcbiAgICBpZiAoc2V0dGluZ3Nba2V5XSA9PT0gdW5kZWZpbmVkKSBzZXR0aW5nc1trZXldID0gYWpheC5zZXR0aW5nc1trZXldXG5cbiAgYWpheFN0YXJ0KHNldHRpbmdzKVxuXG4gIGlmICghc2V0dGluZ3MuY3Jvc3NEb21haW4pIHNldHRpbmdzLmNyb3NzRG9tYWluID0gL14oW1xcdy1dKzopP1xcL1xcLyhbXlxcL10rKS8udGVzdChzZXR0aW5ncy51cmwpICYmXG4gICAgUmVnRXhwLiQyICE9IHdpbmRvdy5sb2NhdGlvbi5ob3N0XG5cbiAgdmFyIGRhdGFUeXBlID0gc2V0dGluZ3MuZGF0YVR5cGUsXG4gICAgaGFzUGxhY2Vob2xkZXIgPSAvPVxcPy8udGVzdChzZXR0aW5ncy51cmwpXG4gICAgaWYgKGRhdGFUeXBlID09ICdqc29ucCcgfHwgaGFzUGxhY2Vob2xkZXIpIHtcbiAgICAgIGlmICghaGFzUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgc2V0dGluZ3MudXJsID0gYXBwZW5kUXVlcnkoc2V0dGluZ3MudXJsLCAoc2V0dGluZ3MuanNvbnA/IHNldHRpbmdzLmpzb25wOiAnX2NhbGxiYWNrJykgKyAnPT8nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhamF4LkpTT05QKHNldHRpbmdzKVxuICAgIH1cblxuICBpZiAoIXNldHRpbmdzLnVybCkgc2V0dGluZ3MudXJsID0gd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKClcbiAgc2VyaWFsaXplRGF0YShzZXR0aW5ncylcblxuICB2YXIgbWltZSA9IHNldHRpbmdzLmFjY2VwdHNbZGF0YVR5cGVdLFxuICAgIGJhc2VIZWFkZXJzID0ge30sXG4gICAgcHJvdG9jb2wgPSAvXihbXFx3LV0rOilcXC9cXC8vLnRlc3Qoc2V0dGluZ3MudXJsKSA/IFJlZ0V4cC4kMSA6IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCxcbiAgICB4aHIgPSBzZXR0aW5ncy54aHIoc2V0dGluZ3MuY3Jvc3NEb21haW4pLFxuICAgIGFib3J0VGltZW91dFxuXG4gIGlmICghc2V0dGluZ3MuY3Jvc3NEb21haW4pIGJhc2VIZWFkZXJzWydYLVJlcXVlc3RlZC1XaXRoJ10gPSAnWE1MSHR0cFJlcXVlc3QnXG4gIGlmIChtaW1lKSB7XG4gICAgYmFzZUhlYWRlcnNbJ0FjY2VwdCddID0gbWltZVxuICAgIGlmIChtaW1lLmluZGV4T2YoJywnKSA+IC0xKSBtaW1lID0gbWltZS5zcGxpdCgnLCcsIDIpWzBdXG4gICAgeGhyLm92ZXJyaWRlTWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUobWltZSlcbiAgfVxuICBpZiAoc2V0dGluZ3MuY29udGVudFR5cGUgfHwgKHNldHRpbmdzLmRhdGEgJiYgIXNldHRpbmdzLmZvcm1kYXRhICYmIHNldHRpbmdzLnR5cGUudG9VcHBlckNhc2UoKSAhPSAnR0VUJykpXG4gICAgYmFzZUhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gKHNldHRpbmdzLmNvbnRlbnRUeXBlIHx8ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKVxuICBzZXR0aW5ncy5oZWFkZXJzID0gZXh0ZW5kKGJhc2VIZWFkZXJzLCBzZXR0aW5ncy5oZWFkZXJzIHx8IHt9KVxuXG4gIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgIGNsZWFyVGltZW91dChhYm9ydFRpbWVvdXQpXG4gICAgICB2YXIgcmVzdWx0LCBlcnJvciA9IGZhbHNlXG4gICAgICBpZihzZXR0aW5ncy50cnlKU09OUCl7XG4gICAgICAgIC8vY2hlY2sgaWYgdGhlIHJlcXVlc3QgaGFzIGZhaWwuIEluIHNvbWUgY2FzZXMsIHdlIG1heSB3YW50IHRvIHRyeSBqc29ucCBhcyB3ZWxsLiBBZ2FpbiwgRkggb25seS4uLlxuICAgICAgICBpZih4aHIuc3RhdHVzID09PSAwICYmIHNldHRpbmdzLmNyb3NzRG9tYWluICYmICF4aHIuaXNUaW1lb3V0ICYmICBwcm90b2NvbCAhPSAnZmlsZTonKXtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoXCJyZXRyeSBhamF4IGNhbGwgd2l0aCBqc29ucFwiKVxuICAgICAgICAgIHNldHRpbmdzLnR5cGUgPSBcIkdFVFwiO1xuICAgICAgICAgIHNldHRpbmdzLmRhdGFUeXBlID0gXCJqc29ucFwiO1xuICAgICAgICAgIHNldHRpbmdzLmRhdGEgPSBcIl9qc29ucGRhdGE9XCIgKyBzZXR0aW5ncy5kYXRhO1xuICAgICAgICAgIHJldHVybiBhamF4KHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09IDMwNCB8fCAoeGhyLnN0YXR1cyA9PSAwICYmIHByb3RvY29sID09ICdmaWxlOicpKSB7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUgfHwgbWltZVRvRGF0YVR5cGUoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKSlcbiAgICAgICAgcmVzdWx0ID0geGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICBsb2dnZXIuZGVidWcoXCJhamF4IHJlc3BvbnNlIDo6IHN0YXR1cyA9IFwiICsgeGhyLnN0YXR1cyArIFwiIDo6IGJvZHkgPSBcIiArIHJlc3VsdClcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChkYXRhVHlwZSA9PSAnc2NyaXB0JykoMSwgZXZhbCkocmVzdWx0KVxuICAgICAgICAgIGVsc2UgaWYgKGRhdGFUeXBlID09ICd4bWwnKSByZXN1bHQgPSB4aHIucmVzcG9uc2VYTUxcbiAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PSAnanNvbicpIHJlc3VsdCA9IGJsYW5rUkUudGVzdChyZXN1bHQpID8gbnVsbCA6IEpTT04ucGFyc2UocmVzdWx0KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZXJyb3IgPSBlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoXCJhamF4IGVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICBhamF4RXJyb3IoZXJyb3IsICdwYXJzZXJlcnJvcicsIHhociwgc2V0dGluZ3MpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBhamF4U3VjY2VzcyhyZXN1bHQsIHhociwgc2V0dGluZ3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhamF4RXJyb3IobnVsbCwgJ2Vycm9yJywgeGhyLCBzZXR0aW5ncylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYXN5bmMgPSAnYXN5bmMnIGluIHNldHRpbmdzID8gc2V0dGluZ3MuYXN5bmMgOiB0cnVlXG4gIGxvZ2dlci5kZWJ1ZyhcImFqYXggY2FsbCBzZXR0aW5nc1wiLCBzZXR0aW5ncylcbiAgeGhyLm9wZW4oc2V0dGluZ3MudHlwZSwgc2V0dGluZ3MudXJsLCBhc3luYylcblxuICBmb3IgKG5hbWUgaW4gc2V0dGluZ3MuaGVhZGVycykgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgc2V0dGluZ3MuaGVhZGVyc1tuYW1lXSlcblxuICBpZiAoYWpheEJlZm9yZVNlbmQoeGhyLCBzZXR0aW5ncykgPT09IGZhbHNlKSB7XG4gICAgbG9nZ2VyLmRlYnVnKFwiYWpheCBjYWxsIGlzIGFib3J0ZWQgZHVlIHRvIGFqYXhCZWZvcmVTZW5kXCIpXG4gICAgeGhyLmFib3J0KClcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChzZXR0aW5ncy50aW1lb3V0ID4gMCkgYWJvcnRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgbG9nZ2VyLmRlYnVnKFwiYWpheCBjYWxsIHRpbWVkIG91dFwiKVxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eVxuICAgIHhoci5hYm9ydCgpXG4gICAgeGhyLmlzVGltZW91dCA9IHRydWVcbiAgICBhamF4RXJyb3IobnVsbCwgJ3RpbWVvdXQnLCB4aHIsIHNldHRpbmdzKVxuICB9LCBzZXR0aW5ncy50aW1lb3V0KVxuXG4gIC8vIGF2b2lkIHNlbmRpbmcgZW1wdHkgc3RyaW5nICgjMzE5KVxuICB4aHIuc2VuZChzZXR0aW5ncy5kYXRhID8gc2V0dGluZ3MuZGF0YSA6IG51bGwpXG4gIHJldHVybiB4aHJcbn1cblxuXG4vLyB0cmlnZ2VyIGEgY3VzdG9tIGV2ZW50IGFuZCByZXR1cm4gdHJ1ZVxuZnVuY3Rpb24gdHJpZ2dlckFuZFJldHVybihjb250ZXh0LCBldmVudE5hbWUsIGRhdGEpIHtcbiAgZXZlbnRzSGFuZGxlci5lbWl0KGV2ZW50TmFtZSwgZGF0YSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyB0cmlnZ2VyIGFuIEFqYXggXCJnbG9iYWxcIiBldmVudFxuZnVuY3Rpb24gdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgZXZlbnROYW1lLCBkYXRhKSB7XG4gIGlmIChzZXR0aW5ncy5nbG9iYWwpIHJldHVybiB0cmlnZ2VyQW5kUmV0dXJuKGNvbnRleHQgfHwgZG9jdW1lbnQsIGV2ZW50TmFtZSwgZGF0YSlcbn1cblxuLy8gTnVtYmVyIG9mIGFjdGl2ZSBBamF4IHJlcXVlc3RzXG5hamF4LmFjdGl2ZSA9IDBcblxuZnVuY3Rpb24gYWpheFN0YXJ0KHNldHRpbmdzKSB7XG4gIGlmIChzZXR0aW5ncy5nbG9iYWwgJiYgYWpheC5hY3RpdmUrKyA9PT0gMCkgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgbnVsbCwgJ2FqYXhTdGFydCcpXG59XG5cbmZ1bmN0aW9uIGFqYXhTdG9wKHNldHRpbmdzKSB7XG4gIGlmIChzZXR0aW5ncy5nbG9iYWwgJiYgISgtLWFqYXguYWN0aXZlKSkgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgbnVsbCwgJ2FqYXhTdG9wJylcbn1cblxuLy8gdHJpZ2dlcnMgYW4gZXh0cmEgZ2xvYmFsIGV2ZW50IFwiYWpheEJlZm9yZVNlbmRcIiB0aGF0J3MgbGlrZSBcImFqYXhTZW5kXCIgYnV0IGNhbmNlbGFibGVcbmZ1bmN0aW9uIGFqYXhCZWZvcmVTZW5kKHhociwgc2V0dGluZ3MpIHtcbiAgdmFyIGNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0XG4gIGlmIChzZXR0aW5ncy5iZWZvcmVTZW5kLmNhbGwoY29udGV4dCwgeGhyLCBzZXR0aW5ncykgPT09IGZhbHNlKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsICdhamF4U2VuZCcsIFt4aHIsIHNldHRpbmdzXSlcbn1cblxuZnVuY3Rpb24gYWpheFN1Y2Nlc3MoZGF0YSwgeGhyLCBzZXR0aW5ncykge1xuICB2YXIgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHQsXG4gICAgc3RhdHVzID0gJ3N1Y2Nlc3MnXG4gIHNldHRpbmdzLnN1Y2Nlc3MuY2FsbChjb250ZXh0LCBkYXRhLCBzdGF0dXMsIHhocilcbiAgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgJ2FqYXhTdWNjZXNzJywgW3hociwgc2V0dGluZ3MsIGRhdGFdKVxuICBhamF4Q29tcGxldGUoc3RhdHVzLCB4aHIsIHNldHRpbmdzKVxufVxuLy8gdHlwZTogXCJ0aW1lb3V0XCIsIFwiZXJyb3JcIiwgXCJhYm9ydFwiLCBcInBhcnNlcmVycm9yXCJcbmZ1bmN0aW9uIGFqYXhFcnJvcihlcnJvciwgdHlwZSwgeGhyLCBzZXR0aW5ncykge1xuICB2YXIgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHRcbiAgc2V0dGluZ3MuZXJyb3IuY2FsbChjb250ZXh0LCB4aHIsIHR5cGUsIGVycm9yKVxuICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCAnYWpheEVycm9yJywgW3hociwgc2V0dGluZ3MsIGVycm9yXSlcbiAgYWpheENvbXBsZXRlKHR5cGUsIHhociwgc2V0dGluZ3MpXG59XG4vLyBzdGF0dXM6IFwic3VjY2Vzc1wiLCBcIm5vdG1vZGlmaWVkXCIsIFwiZXJyb3JcIiwgXCJ0aW1lb3V0XCIsIFwiYWJvcnRcIiwgXCJwYXJzZXJlcnJvclwiXG5mdW5jdGlvbiBhamF4Q29tcGxldGUoc3RhdHVzLCB4aHIsIHNldHRpbmdzKSB7XG4gIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dFxuICBzZXR0aW5ncy5jb21wbGV0ZS5jYWxsKGNvbnRleHQsIHhociwgc3RhdHVzKVxuICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCAnYWpheENvbXBsZXRlJywgW3hociwgc2V0dGluZ3NdKVxuICBhamF4U3RvcChzZXR0aW5ncylcbn1cblxuLy8gRW1wdHkgZnVuY3Rpb24sIHVzZWQgYXMgZGVmYXVsdCBjYWxsYmFja1xuZnVuY3Rpb24gZW1wdHkoKSB7fVxuXG5hamF4LkpTT05QID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKCEoJ3R5cGUnIGluIG9wdGlvbnMpKSByZXR1cm4gYWpheChvcHRpb25zKVxuXG4gIHZhciBjYWxsYmFja05hbWUgPSAnanNvbnAnICsgKCsranNvbnBJRCksXG4gICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksXG4gICAgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvL3RvZG86IHJlbW92ZSBzY3JpcHRcbiAgICAgIC8vJChzY3JpcHQpLnJlbW92ZSgpXG4gICAgICBpZiAoY2FsbGJhY2tOYW1lIGluIHdpbmRvdykgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBlbXB0eVxuICAgICAgYWpheENvbXBsZXRlKCdhYm9ydCcsIHhociwgb3B0aW9ucylcbiAgICB9LFxuICAgIHhociA9IHtcbiAgICAgIGFib3J0OiBhYm9ydFxuICAgIH0sIGFib3J0VGltZW91dCxcbiAgICBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuXG4gIGlmIChvcHRpb25zLmVycm9yKSBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB4aHIuYWJvcnQoKVxuICAgIG9wdGlvbnMuZXJyb3IoKVxuICB9XG5cbiAgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGNsZWFyVGltZW91dChhYm9ydFRpbWVvdXQpXG4gICAgLy90b2RvOiByZW1vdmUgc2NyaXB0XG4gICAgLy8kKHNjcmlwdCkucmVtb3ZlKClcbiAgICBkZWxldGUgd2luZG93W2NhbGxiYWNrTmFtZV1cbiAgICBhamF4U3VjY2VzcyhkYXRhLCB4aHIsIG9wdGlvbnMpXG4gIH1cblxuICBzZXJpYWxpemVEYXRhKG9wdGlvbnMpXG4gIHNjcmlwdC5zcmMgPSBvcHRpb25zLnVybC5yZXBsYWNlKC89XFw/LywgJz0nICsgY2FsbGJhY2tOYW1lKVxuXG4gIC8vIFVzZSBpbnNlcnRCZWZvcmUgaW5zdGVhZCBvZiBhcHBlbmRDaGlsZCB0byBjaXJjdW12ZW50IGFuIElFNiBidWcuXG4gIC8vIFRoaXMgYXJpc2VzIHdoZW4gYSBiYXNlIG5vZGUgaXMgdXNlZCAoc2VlIGpRdWVyeSBidWdzICMyNzA5IGFuZCAjNDM3OCkuXG4gIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcblxuICBpZiAob3B0aW9ucy50aW1lb3V0ID4gMCkgYWJvcnRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgeGhyLmFib3J0KClcbiAgICBhamF4Q29tcGxldGUoJ3RpbWVvdXQnLCB4aHIsIG9wdGlvbnMpXG4gIH0sIG9wdGlvbnMudGltZW91dClcblxuICByZXR1cm4geGhyXG59XG5cbmZ1bmN0aW9uIGlzSUUoKXtcbiAgdmFyIGllID0gZmFsc2U7XG4gIGlmKG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRVwiKSA+PTAgKXtcbiAgICBpZSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGllO1xufVxuXG5mdW5jdGlvbiBnZXRYaHIoY3Jvc3NEb21haW4pe1xuICB2YXIgeGhyID0gbnVsbDtcbiAgLy9hbHdheXMgdXNlIFhNTEh0dHBSZXF1ZXN0IGlmIGF2YWlsYWJsZVxuICBpZih3aW5kb3cuWE1MSHR0cFJlcXVlc3Qpe1xuICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB9XG4gIC8vZm9yIElFOFxuICBpZihpc0lFKCkgJiYgKGNyb3NzRG9tYWluID09PSB0cnVlKSAmJiB0eXBlb2Ygd2luZG93LlhEb21haW5SZXF1ZXN0ICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICB4aHIgPSBuZXcgWERvbWFpblJlcXVlc3RXcmFwcGVyKG5ldyBYRG9tYWluUmVxdWVzdCgpKTtcbiAgfVxuICByZXR1cm4geGhyO1xufVxuXG5hamF4LnNldHRpbmdzID0ge1xuICAvLyBEZWZhdWx0IHR5cGUgb2YgcmVxdWVzdFxuICB0eXBlOiAnR0VUJyxcbiAgLy8gQ2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCBiZWZvcmUgcmVxdWVzdFxuICBiZWZvcmVTZW5kOiBlbXB0eSxcbiAgLy8gQ2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCBpZiB0aGUgcmVxdWVzdCBzdWNjZWVkc1xuICBzdWNjZXNzOiBlbXB0eSxcbiAgLy8gQ2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCB0aGUgdGhlIHNlcnZlciBkcm9wcyBlcnJvclxuICBlcnJvcjogZW1wdHksXG4gIC8vIENhbGxiYWNrIHRoYXQgaXMgZXhlY3V0ZWQgb24gcmVxdWVzdCBjb21wbGV0ZSAoYm90aDogZXJyb3IgYW5kIHN1Y2Nlc3MpXG4gIGNvbXBsZXRlOiBlbXB0eSxcbiAgLy8gVGhlIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3NcbiAgY29udGV4dDogbnVsbCxcbiAgLy8gV2hldGhlciB0byB0cmlnZ2VyIFwiZ2xvYmFsXCIgQWpheCBldmVudHNcbiAgZ2xvYmFsOiB0cnVlLFxuICAvLyBUcmFuc3BvcnRcbiAgeGhyOiBnZXRYaHIsXG4gIC8vIE1JTUUgdHlwZXMgbWFwcGluZ1xuICBhY2NlcHRzOiB7XG4gICAgc2NyaXB0OiAndGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcbiAgICBqc29uOiBqc29uVHlwZSxcbiAgICB4bWw6ICdhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sJyxcbiAgICBodG1sOiBodG1sVHlwZSxcbiAgICB0ZXh0OiAndGV4dC9wbGFpbidcbiAgfSxcbiAgLy8gV2hldGhlciB0aGUgcmVxdWVzdCBpcyB0byBhbm90aGVyIGRvbWFpblxuICBjcm9zc0RvbWFpbjogZmFsc2UsXG4gIC8vIERlZmF1bHQgdGltZW91dFxuICB0aW1lb3V0OiBjb25zdHMuZmhfdGltZW91dFxufVxuXG5mdW5jdGlvbiBtaW1lVG9EYXRhVHlwZShtaW1lKSB7XG4gIHJldHVybiBtaW1lICYmIChtaW1lID09IGh0bWxUeXBlID8gJ2h0bWwnIDpcbiAgICBtaW1lID09IGpzb25UeXBlID8gJ2pzb24nIDpcbiAgICBzY3JpcHRUeXBlUkUudGVzdChtaW1lKSA/ICdzY3JpcHQnIDpcbiAgICB4bWxUeXBlUkUudGVzdChtaW1lKSAmJiAneG1sJykgfHwgJ3RleHQnXG59XG5cbmZ1bmN0aW9uIGFwcGVuZFF1ZXJ5KHVybCwgcXVlcnkpIHtcbiAgcmV0dXJuICh1cmwgKyAnJicgKyBxdWVyeSkucmVwbGFjZSgvWyY/XXsxLDJ9LywgJz8nKVxufVxuXG4vLyBzZXJpYWxpemUgcGF5bG9hZCBhbmQgYXBwZW5kIGl0IHRvIHRoZSBVUkwgZm9yIEdFVCByZXF1ZXN0c1xuZnVuY3Rpb24gc2VyaWFsaXplRGF0YShvcHRpb25zKSB7XG4gIGlmICh0eXBlKG9wdGlvbnMuZGF0YSkgPT09ICdvYmplY3QnKSB7XG4gICAgaWYodHlwZW9mIG9wdGlvbnMuZGF0YS5hcHBlbmQgPT09IFwiZnVuY3Rpb25cIil7XG4gICAgICAvL3dlIGFyZSBkZWFsaW5nIHdpdGggRm9ybURhdGEsIGRvIG5vdCBzZXJpYWxpemVcbiAgICAgIG9wdGlvbnMuZm9ybWRhdGEgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmRhdGEgPSBwYXJhbShvcHRpb25zLmRhdGEpXG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLmRhdGEgJiYgKCFvcHRpb25zLnR5cGUgfHwgb3B0aW9ucy50eXBlLnRvVXBwZXJDYXNlKCkgPT0gJ0dFVCcpKVxuICAgIG9wdGlvbnMudXJsID0gYXBwZW5kUXVlcnkob3B0aW9ucy51cmwsIG9wdGlvbnMuZGF0YSlcbn1cblxuYWpheC5nZXQgPSBmdW5jdGlvbiAodXJsLCBzdWNjZXNzKSB7XG4gIHJldHVybiBhamF4KHtcbiAgICB1cmw6IHVybCxcbiAgICBzdWNjZXNzOiBzdWNjZXNzXG4gIH0pXG59XG5cbmFqYXgucG9zdCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIHN1Y2Nlc3MsIGRhdGFUeXBlKSB7XG4gIGlmICh0eXBlKGRhdGEpID09PSAnZnVuY3Rpb24nKSBkYXRhVHlwZSA9IGRhdGFUeXBlIHx8IHN1Y2Nlc3MsIHN1Y2Nlc3MgPSBkYXRhLCBkYXRhID0gbnVsbFxuICByZXR1cm4gYWpheCh7XG4gICAgdHlwZTogJ1BPU1QnLFxuICAgIHVybDogdXJsLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICBkYXRhVHlwZTogZGF0YVR5cGVcbiAgfSlcbn1cblxuYWpheC5nZXRKU09OID0gZnVuY3Rpb24gKHVybCwgc3VjY2Vzcykge1xuICByZXR1cm4gYWpheCh7XG4gICAgdXJsOiB1cmwsXG4gICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICBkYXRhVHlwZTogJ2pzb24nXG4gIH0pXG59XG5cbnZhciBlc2NhcGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShwYXJhbXMsIG9iaiwgdHJhZGl0aW9uYWwsIHNjb3BlKSB7XG4gIHZhciBhcnJheSA9IHR5cGUob2JqKSA9PT0gJ2FycmF5JztcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgaWYgKHNjb3BlKSBrZXkgPSB0cmFkaXRpb25hbCA/IHNjb3BlIDogc2NvcGUgKyAnWycgKyAoYXJyYXkgPyAnJyA6IGtleSkgKyAnXSdcbiAgICAvLyBoYW5kbGUgZGF0YSBpbiBzZXJpYWxpemVBcnJheSgpIGZvcm1hdFxuICAgIGlmICghc2NvcGUgJiYgYXJyYXkpIHBhcmFtcy5hZGQodmFsdWUubmFtZSwgdmFsdWUudmFsdWUpXG4gICAgLy8gcmVjdXJzZSBpbnRvIG5lc3RlZCBvYmplY3RzXG4gICAgZWxzZSBpZiAodHJhZGl0aW9uYWwgPyAodHlwZSh2YWx1ZSkgPT09ICdhcnJheScpIDogKHR5cGUodmFsdWUpID09PSAnb2JqZWN0JykpXG4gICAgICBzZXJpYWxpemUocGFyYW1zLCB2YWx1ZSwgdHJhZGl0aW9uYWwsIGtleSlcbiAgICBlbHNlIHBhcmFtcy5hZGQoa2V5LCB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJhbShvYmosIHRyYWRpdGlvbmFsKSB7XG4gIHZhciBwYXJhbXMgPSBbXVxuICBwYXJhbXMuYWRkID0gZnVuY3Rpb24gKGssIHYpIHtcbiAgICB0aGlzLnB1c2goZXNjYXBlKGspICsgJz0nICsgZXNjYXBlKHYpKVxuICB9XG4gIHNlcmlhbGl6ZShwYXJhbXMsIG9iaiwgdHJhZGl0aW9uYWwpXG4gIHJldHVybiBwYXJhbXMuam9pbignJicpLnJlcGxhY2UoJyUyMCcsICcrJylcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCkge1xuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKS5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBmb3IgKGtleSBpbiBzb3VyY2UpXG4gICAgICBpZiAoc291cmNlW2tleV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICB9KVxuICByZXR1cm4gdGFyZ2V0XG59IiwidmFyIGxvZ2dlciA9cmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xudmFyIGNsb3VkID0gcmVxdWlyZShcIi4vd2FpdEZvckNsb3VkXCIpO1xudmFyIGZocGFyYW1zID0gcmVxdWlyZShcIi4vZmhwYXJhbXNcIik7XG52YXIgYWpheCA9IHJlcXVpcmUoXCIuL2FqYXhcIik7XG52YXIgSlNPTiA9IHJlcXVpcmUoXCJKU09OXCIpO1xudmFyIGhhbmRsZUVycm9yID0gcmVxdWlyZShcIi4vaGFuZGxlRXJyb3JcIik7XG5cbmZ1bmN0aW9uIGRvQWN0Q2FsbChvcHRzLCBzdWNjZXNzLCBmYWlsKXtcbiAgdmFyIGNsb3VkX2hvc3QgPSBjbG91ZC5nZXRDbG91ZEhvc3QoKTtcbiAgdmFyIHVybCA9IGNsb3VkX2hvc3QuZ2V0QWN0VXJsKG9wdHMuYWN0KTtcbiAgdmFyIHBhcmFtcyA9IG9wdHMucmVxIHx8IHt9O1xuICBwYXJhbXMgPSBmaHBhcmFtcy5hZGRGSFBhcmFtcyhwYXJhbXMpO1xuICByZXR1cm4gYWpheCh7XG4gICAgXCJ1cmxcIjogdXJsLFxuICAgIFwidHJ5SlNPTlBcIjogdHJ1ZSxcbiAgICBcInR5cGVcIjogXCJQT1NUXCIsXG4gICAgXCJkYXRhVHlwZVwiOiBcImpzb25cIixcbiAgICBcImRhdGFcIjogSlNPTi5zdHJpbmdpZnkocGFyYW1zKSxcbiAgICBcImNvbnRlbnRUeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIFwidGltZW91dFwiOiBvcHRzLnRpbWVvdXQsXG4gICAgXCJzdWNjZXNzXCI6IHN1Y2Nlc3MsXG4gICAgXCJlcnJvclwiOiBmdW5jdGlvbihyZXEsIHN0YXR1c1RleHQsIGVycm9yKXtcbiAgICAgIHJldHVybiBoYW5kbGVFcnJvcihmYWlsLCByZXEsIHN0YXR1c1RleHQsIGVycm9yKTtcbiAgICB9XG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cywgc3VjY2VzcywgZmFpbCl7XG4gIGxvZ2dlci5kZWJ1ZyhcImFjdCBpcyBjYWxsZWRcIik7XG4gIGlmKCFmYWlsKXtcbiAgICBmYWlsID0gZnVuY3Rpb24obXNnLCBlcnJvcil7XG4gICAgICBsb2dnZXIuZGVidWcobXNnICsgXCI6XCIgKyBKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuICAgIH07XG4gIH1cblxuICBpZighb3B0cy5hY3Qpe1xuICAgIHJldHVybiBmYWlsKCdhY3Rfbm9fYWN0aW9uJywge30pO1xuICB9XG5cbiAgY2xvdWQucmVhZHkoZnVuY3Rpb24oZXJyLCBjbG91ZEhvc3Qpe1xuICAgIGxvZ2dlci5kZWJ1ZyhcIkNhbGxpbmcgZmhhY3Qgbm93XCIpO1xuICAgIGlmKGVycil7XG4gICAgICByZXR1cm4gZmFpbChlcnIubWVzc2FnZSwgZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9BY3RDYWxsKG9wdHMsIHN1Y2Nlc3MsIGZhaWwpO1xuICAgIH1cbiAgfSlcbn0iLCJ2YXIgbG9nZ2VyID1yZXF1aXJlKFwiLi9sb2dnZXJcIik7XG52YXIgY2xvdWQgPSByZXF1aXJlKFwiLi93YWl0Rm9yQ2xvdWRcIik7XG52YXIgZmhwYXJhbXMgPSByZXF1aXJlKFwiLi9maHBhcmFtc1wiKTtcbnZhciBhamF4ID0gcmVxdWlyZShcIi4vYWpheFwiKTtcbnZhciBKU09OID0gcmVxdWlyZShcIkpTT05cIik7XG52YXIgaGFuZGxlRXJyb3IgPSByZXF1aXJlKFwiLi9oYW5kbGVFcnJvclwiKTtcbnZhciBkZXZpY2UgPSByZXF1aXJlKFwiLi9kZXZpY2VcIik7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIGNoZWNrQXV0aCA9IHJlcXVpcmUoXCIuL2NoZWNrQXV0aFwiKTtcbnZhciBhcHBQcm9wcyA9IHJlcXVpcmUoXCIuL2FwcFByb3BzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdHMsIHN1Y2Nlc3MsIGZhaWwpe1xuICBpZighZmFpbCl7XG4gICAgZmFpbCA9IGZ1bmN0aW9uKG1zZywgZXJyb3Ipe1xuICAgICAgbG9nZ2VyLmRlYnVnKG1zZyArIFwiOlwiICsgSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcbiAgICB9O1xuICB9XG4gIGlmICghb3B0cy5wb2xpY3lJZCkge1xuICAgIHJldHVybiBmYWlsKCdhdXRoX25vX3BvbGljeUlkJywge30pO1xuICB9XG4gIGlmICghb3B0cy5jbGllbnRUb2tlbikge1xuICAgIHJldHVybiBmYWlsKCdhdXRoX25vX2NsaWVudFRva2VuJywge30pO1xuICB9XG5cbiAgY2xvdWQucmVhZHkoZnVuY3Rpb24oZXJyLCBkYXRhKXtcbiAgICBpZihlcnIpe1xuICAgICAgcmV0dXJuIGZhaWwoZXJyLm1lc3NhZ2UsIGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXEgPSB7fTtcbiAgICAgIHJlcS5wb2xpY3lJZCA9IG9wdHMucG9saWN5SWQ7XG4gICAgICByZXEuY2xpZW50VG9rZW4gPSBvcHRzLmNsaWVudFRva2VuO1xuICAgICAgaWYgKG9wdHMuZW5kUmVkaXJlY3RVcmwpIHtcbiAgICAgICAgcmVxLmVuZFJlZGlyZWN0VXJsID0gb3B0cy5lbmRSZWRpcmVjdFVybDtcbiAgICAgICAgaWYgKG9wdHMuYXV0aENhbGxiYWNrKSB7XG4gICAgICAgICAgcmVxLmVuZFJlZGlyZWN0VXJsICs9ICgvXFw/Ly50ZXN0KHJlcS5lbmRSZWRpcmVjdFVybCkgPyBcIiZcIiA6IFwiP1wiKSArIFwiX2ZoQXV0aENhbGxiYWNrPVwiICsgb3B0cy5hdXRoQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcS5wYXJhbXMgPSB7fTtcbiAgICAgIGlmIChvcHRzLnBhcmFtcykge1xuICAgICAgICByZXEucGFyYW1zID0gb3B0cy5wYXJhbXM7XG4gICAgICB9XG4gICAgICB2YXIgZW5kdXJsID0gb3B0cy5lbmRSZWRpcmVjdFVybCB8fCBcInN0YXR1cz1jb21wbGV0ZVwiO1xuICAgICAgcmVxLmRldmljZSA9IGRldmljZS5nZXREZXZpY2VJZCgpO1xuICAgICAgdmFyIGFwcF9wcm9wcyA9IGFwcFByb3BzLmdldEFwcFByb3BzKCk7XG4gICAgICB2YXIgcGF0aCA9IGFwcF9wcm9wcy5ob3N0ICsgY29uc3RhbnRzLmJveHByZWZpeCArIFwiYWRtaW4vYXV0aHBvbGljeS9hdXRoXCI7XG4gICAgICByZXEgPSBmaHBhcmFtcy5hZGRGSFBhcmFtcyhyZXEpO1xuXG4gICAgICBhamF4KHtcbiAgICAgICAgXCJ1cmxcIjogcGF0aCxcbiAgICAgICAgXCJ0eXBlXCI6IFwiUE9TVFwiLFxuICAgICAgICBcInRyeUpTT05QXCI6IHRydWUsXG4gICAgICAgIFwiZGF0YVwiOiBKU09OLnN0cmluZ2lmeShyZXEpLFxuICAgICAgICBcImRhdGFUeXBlXCI6IFwianNvblwiLFxuICAgICAgICBcImNvbnRlbnRUeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcInRpbWVvdXRcIiA6IG9wdHMudGltZW91dCB8fCBhcHBfcHJvcHMudGltZW91dCB8fCBjb25zdGFudHMuZmhfdGltZW91dCxcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgY2hlY2tBdXRoLmhhbmRsZUF1dGhSZXNwb25zZShlbmR1cmwsIHJlcywgc3VjY2VzcywgZmFpbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbihyZXEsIHN0YXR1c1RleHQsIGVycm9yKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZmFpbCwgcmVxLCBzdGF0dXNUZXh0LCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59IiwidmFyIGxvZ2dlciA9cmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xudmFyIGNsb3VkID0gcmVxdWlyZShcIi4vd2FpdEZvckNsb3VkXCIpO1xudmFyIGZocGFyYW1zID0gcmVxdWlyZShcIi4vZmhwYXJhbXNcIik7XG52YXIgYWpheCA9IHJlcXVpcmUoXCIuL2FqYXhcIik7XG52YXIgSlNPTiA9IHJlcXVpcmUoXCJKU09OXCIpO1xudmFyIGhhbmRsZUVycm9yID0gcmVxdWlyZShcIi4vaGFuZGxlRXJyb3JcIik7XG5cbmZ1bmN0aW9uIGRvQ2xvdWRDYWxsKG9wdHMsIHN1Y2Nlc3MsIGZhaWwpe1xuICB2YXIgY2xvdWRfaG9zdCA9IGNsb3VkLmdldENsb3VkSG9zdCgpO1xuICB2YXIgdXJsID0gY2xvdWRfaG9zdC5nZXRDbG91ZFVybChvcHRzLnBhdGgpO1xuICB2YXIgcGFyYW1zID0gb3B0cy5kYXRhIHx8IHt9O1xuICBwYXJhbXMgPSBmaHBhcmFtcy5hZGRGSFBhcmFtcyhwYXJhbXMpO1xuICByZXR1cm4gYWpheCh7XG4gICAgXCJ1cmxcIjogdXJsLFxuICAgIFwidHlwZVwiOiBvcHRzLm1ldGhvZCB8fCBcIlBPU1RcIixcbiAgICBcImRhdGFUeXBlXCI6IG9wdHMuZGF0YVR5cGUgfHwgXCJqc29uXCIsXG4gICAgXCJkYXRhXCI6IEpTT04uc3RyaW5naWZ5KHBhcmFtcyksXG4gICAgXCJjb250ZW50VHlwZVwiOiBvcHRzLmNvbnRlbnRUeXBlIHx8IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIFwidGltZW91dFwiOiBvcHRzLnRpbWVvdXQsXG4gICAgXCJzdWNjZXNzXCI6IHN1Y2Nlc3MsXG4gICAgXCJlcnJvclwiOiBmdW5jdGlvbihyZXEsIHN0YXR1c1RleHQsIGVycm9yKXtcbiAgICAgIHJldHVybiBoYW5kbGVFcnJvcihmYWlsLCByZXEsIHN0YXR1c1RleHQsIGVycm9yKTtcbiAgICB9XG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cywgc3VjY2VzcywgZmFpbCl7XG4gIGxvZ2dlci5kZWJ1ZyhcImNsb3VkIGlzIGNhbGxlZFwiKTtcbiAgaWYoIWZhaWwpe1xuICAgIGZhaWwgPSBmdW5jdGlvbihtc2csIGVycm9yKXtcbiAgICAgIGxvZ2dlci5kZWJ1Zyhtc2cgKyBcIjpcIiArIEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gICAgfTtcbiAgfVxuXG4gIGNsb3VkLnJlYWR5KGZ1bmN0aW9uKGVyciwgY2xvdWRIb3N0KXtcbiAgICBsb2dnZXIuZGVidWcoXCJDYWxsaW5nIGZoYWN0IG5vd1wiKTtcbiAgICBpZihlcnIpe1xuICAgICAgcmV0dXJuIGZhaWwoZXJyLm1lc3NhZ2UsIGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvQ2xvdWRDYWxsKG9wdHMsIHN1Y2Nlc3MsIGZhaWwpO1xuICAgIH1cbiAgfSlcbn0iLCJ2YXIgaGFzaEltcGwgPSByZXF1aXJlKFwiLi9zZWN1cml0eS9oYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHAsIHMsIGYpe1xuICB2YXIgcGFyYW1zID0ge307XG4gIGlmKHR5cGVvZiBwLmFsZ29yaXRobSA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgcC5hbGdvcml0aG0gPSBcIk1ENVwiO1xuICB9XG4gIHBhcmFtcy5hY3QgPSBcImhhc2hcIjtcbiAgcGFyYW1zLnBhcmFtcyA9IHA7XG4gIGhhc2hJbXBsKHBhcmFtcywgcywgZik7XG59OyIsInZhciBsb2dnZXIgPXJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcbnZhciBjbG91ZCA9IHJlcXVpcmUoXCIuL3dhaXRGb3JDbG91ZFwiKTtcbnZhciBmaHBhcmFtcyA9IHJlcXVpcmUoXCIuL2ZocGFyYW1zXCIpO1xudmFyIGFqYXggPSByZXF1aXJlKFwiLi9hamF4XCIpO1xudmFyIEpTT04gPSByZXF1aXJlKFwiSlNPTlwiKTtcbnZhciBoYW5kbGVFcnJvciA9IHJlcXVpcmUoXCIuL2hhbmRsZUVycm9yXCIpO1xudmFyIGNvbnN0cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdHMsIHN1Y2Nlc3MsIGZhaWwpe1xuICBsb2dnZXIuZGVidWcoXCJtYmFhcyBpcyBjYWxsZWQuXCIpO1xuICBpZighZmFpbCl7XG4gICAgZmFpbCA9IGZ1bmN0aW9uKG1zZywgZXJyb3Ipe1xuICAgICAgY29uc29sZS5kZWJ1Zyhtc2cgKyBcIjpcIiArIEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBtYmFhcyA9IG9wdHMuc2VydmljZTtcbiAgdmFyIHBhcmFtcyA9IG9wdHMucGFyYW1zO1xuXG4gIGNsb3VkLnJlYWR5KGZ1bmN0aW9uKGVyciwgY2xvdWRIb3N0KXtcbiAgICBsb2dnZXIuZGVidWcoXCJDYWxsaW5nIG1iYWFzIG5vd1wiKTtcbiAgICBpZihlcnIpe1xuICAgICAgcmV0dXJuIGZhaWwoZXJyLm1lc3NhZ2UsIGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjbG91ZF9ob3N0ID0gY2xvdWQuZ2V0Q2xvdWRIb3N0KCk7XG4gICAgICB2YXIgdXJsID0gY2xvdWRfaG9zdC5nZXRNQkFBU1VybChtYmFhcyk7XG4gICAgICBwYXJhbXMgPSBmaHBhcmFtcy5hZGRGSFBhcmFtcyhwYXJhbXMpO1xuICAgICAgcmV0dXJuIGFqYXgoe1xuICAgICAgICBcInVybFwiOiB1cmwsXG4gICAgICAgIFwidHJ5SlNPTlBcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImRhdGFUeXBlXCI6IFwianNvblwiLFxuICAgICAgICBcImRhdGFcIjogSlNPTi5zdHJpbmdpZnkocGFyYW1zKSxcbiAgICAgICAgXCJjb250ZW50VHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgXCJ0aW1lb3V0XCI6IG9wdHMudGltZW91dCB8fCBjb25zdHMuZmhfdGltZW91dCxcbiAgICAgICAgXCJzdWNjZXNzXCI6IHN1Y2Nlc3MsXG4gICAgICAgIFwiZXJyb3JcIjogZnVuY3Rpb24ocmVxLCBzdGF0dXNUZXh0LCBlcnJvcil7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKGZhaWwsIHJlcSwgc3RhdHVzVGV4dCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufSBcbiIsInZhciBrZXlnZW4gPSByZXF1aXJlKFwiLi9zZWN1cml0eS9hZXMta2V5Z2VuXCIpO1xudmFyIGFlcyA9IHJlcXVpcmUoXCIuL3NlY3VyaXR5L2Flcy1ub2RlXCIpO1xudmFyIHJzYSA9IHJlcXVpcmUoXCIuL3NlY3VyaXR5L3JzYS1ub2RlXCIpO1xudmFyIGhhc2ggPSByZXF1aXJlKFwiLi9zZWN1cml0eS9oYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHAsIHMsIGYpe1xuICBpZiAoIXAuYWN0KSB7XG4gICAgZignYmFkX2FjdCcsIHt9LCBwKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFwLnBhcmFtcykge1xuICAgIGYoJ25vX3BhcmFtcycsIHt9LCBwKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFwLnBhcmFtcy5hbGdvcml0aG0pIHtcbiAgICBmKCdub19wYXJhbXNfYWxnb3JpdGhtJywge30sIHApO1xuICAgIHJldHVybjtcbiAgfVxuICBwLnBhcmFtcy5hbGdvcml0aG0gPSBwLnBhcmFtcy5hbGdvcml0aG0udG9Mb3dlckNhc2UoKTtcbiAgaWYocC5hY3QgPT09IFwiaGFzaFwiKXtcbiAgICByZXR1cm4gaGFzaChwLCBzLCBmKTtcbiAgfSBlbHNlIGlmKHAuYWN0ID09PSBcImVuY3J5cHRcIil7XG4gICAgaWYocC5wYXJhbXMuYWxnb3JpdGhtID09PSBcImFlc1wiKXtcbiAgICAgIHJldHVybiBhZXMuZW5jcnlwdChwLCBzLCBmKTtcbiAgICB9IGVsc2UgaWYocC5wYXJhbXMuYWxnb3JpdGhtID09PSBcInJzYVwiKXtcbiAgICAgIHJldHVybiByc2EuZW5jcnlwdChwLCBzLCBmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGYoJ2VuY3J5cHRfYmFkX2FsZ29yaXRobTonICsgcC5wYXJhbXMuYWxnb3JpdGhtLCB7fSwgcCk7XG4gICAgfVxuICB9IGVsc2UgaWYocC5hY3QgPT09IFwiZGVjcnlwdFwiKXtcbiAgICBpZihwLnBhcmFtcy5hbGdvcml0aG0gPT09IFwiYWVzXCIpe1xuICAgICAgcmV0dXJuIGFlcy5kZWNyeXB0KHAsIHMsIGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZignZGVjcnlwdF9iYWRfYWxnb3JpdGhtOicgKyBwLnBhcmFtcy5hbGdvcml0aG0sIHt9LCBwKTtcbiAgICB9XG4gIH0gZWxzZSBpZihwLmFjdCA9PT0gXCJrZXlnZW5cIil7XG4gICAgaWYocC5wYXJhbXMuYWxnb3JpdGhtID09PSBcImFlc1wiKXtcbiAgICAgIHJldHVybiBrZXlnZW4ocCwgcywgZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmKCdrZXlnZW5fYmFkX2FsZ29yaXRobTonICsgcC5wYXJhbXMuYWxnb3JpdGhtLCB7fSwgcCk7XG4gICAgfVxuICB9XG59IiwidmFyIGNvbnN0cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBhamF4ID0gcmVxdWlyZShcIi4vYWpheFwiKTtcbnZhciBsb2dnZXIgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XG52YXIgcXMgPSByZXF1aXJlKFwiLi9xdWVyeU1hcFwiKTtcblxudmFyIGFwcF9wcm9wcyA9IG51bGw7XG5cbnZhciBsb2FkID0gZnVuY3Rpb24oY2IpIHtcbiAgdmFyIGRvY191cmwgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuICB2YXIgdXJsX3BhcmFtcyA9IHFzKGRvY191cmwpO1xuICB2YXIgbG9jYWwgPSAodHlwZW9mIHVybF9wYXJhbXMudXJsICE9PSAndW5kZWZpbmVkJyk7XG5cbiAgLy8gRm9yIGxvY2FsIGVudmlyb25tZW50cywgbm8gaW5pdCBuZWVkZWRcbiAgaWYgKGxvY2FsKSB7XG4gICAgYXBwX3Byb3BzID0ge307XG4gICAgYXBwX3Byb3BzLmxvY2FsID0gdHJ1ZTtcbiAgICBhcHBfcHJvcHMuaG9zdCA9IHVybF9wYXJhbXMudXJsO1xuICAgIGFwcF9wcm9wcy5hcHBpZCA9IFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4gICAgYXBwX3Byb3BzLmFwcGtleSA9IFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIGFwcF9wcm9wcy5wcm9qZWN0aWQgPSBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIGFwcF9wcm9wcy5jb25uZWN0aW9udGFnID0gXCIwLjAuMVwiO1xuICAgIGFwcF9wcm9wcy5sb2dsZXZlbCA9IHVybF9wYXJhbXMubG9nbGV2ZWw7XG4gICAgcmV0dXJuIGNiKG51bGwsIGFwcF9wcm9wcyk7XG4gIH1cblxuICB2YXIgY29uZmlnX3VybCA9IHVybF9wYXJhbXMuZmhjb25maWcgfHwgY29uc3RzLmNvbmZpZ19qcztcbiAgYWpheCh7XG4gICAgdXJsOiBjb25maWdfdXJsLFxuICAgIGRhdGFUeXBlOiBcImpzb25cIixcbiAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBsb2dnZXIuZGVidWcoXCJmaGNvbmZpZyA9IFwiICsgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgLy93aGVuIGxvYWQgdGhlIGNvbmZpZyBmaWxlIG9uIGRldmljZSwgYmVjYXVzZSBmaWxlOi8vIHByb3RvY29sIGlzIHVzZWQsIGl0IHdpbGwgbmV2ZXIgY2FsbCBmYWlsIGNhbGwgYmFjay4gVGhlIHN1Y2Nlc3MgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYnV0IHRoZSBkYXRhIHZhbHVlIHdpbGwgYmUgbnVsbC5cbiAgICAgIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoXCJhcHBfY29uZmlnX21pc3NpbmdcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwX3Byb3BzID0gZGF0YTtcblxuICAgICAgICBjYihudWxsLCBhcHBfcHJvcHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXJyb3I6IGZ1bmN0aW9uKHJlcSwgc3RhdHVzVGV4dCwgZXJyb3IpIHtcbiAgICAgIC8vZmggdjIgb25seVxuICAgICAgaWYod2luZG93LmZoX2FwcF9wcm9wcyl7XG4gICAgICAgIHJldHVybiBjYihudWxsLCB3aW5kb3cuZmhfYXBwX3Byb3BzKTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5lcnJvcihjb25zdHMuY29uZmlnX2pzICsgXCIgTm90IEZvdW5kXCIpO1xuICAgICAgY2IobmV3IEVycm9yKFwiYXBwX2NvbmZpZ19taXNzaW5nXCIpKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIHNldEFwcFByb3BzID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgYXBwX3Byb3BzID0gcHJvcHM7XG59O1xuXG52YXIgZ2V0QXBwUHJvcHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGFwcF9wcm9wcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb2FkOiBsb2FkLFxuICBnZXRBcHBQcm9wczogZ2V0QXBwUHJvcHMsXG4gIHNldEFwcFByb3BzOiBzZXRBcHBQcm9wc1xufTsiLCJ2YXIgbG9nZ2VyID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xudmFyIHF1ZXJ5TWFwID0gcmVxdWlyZShcIi4vcXVlcnlNYXBcIik7XG52YXIgSlNPTiA9IHJlcXVpcmUoXCJKU09OXCIpO1xudmFyIGZocGFyYW1zID0gcmVxdWlyZShcIi4vZmhwYXJhbXNcIik7XG5cbnZhciBjaGVja0F1dGggPSBmdW5jdGlvbih1cmwpIHtcbiAgaWYgKC9cXF9maEF1dGhDYWxsYmFjay8udGVzdCh1cmwpKSB7XG4gICAgdmFyIHFtYXAgPSBxdWVyeU1hcCh1cmwpO1xuICAgIGlmIChxbWFwKSB7XG4gICAgICB2YXIgZmhDYWxsYmFjayA9IHFtYXBbXCJfZmhBdXRoQ2FsbGJhY2tcIl07XG4gICAgICBpZiAoZmhDYWxsYmFjaykge1xuICAgICAgICBpZiAocW1hcFsncmVzdWx0J10gJiYgcW1hcFsncmVzdWx0J10gPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgIHZhciBzdWNSZXMgPSB7J3Nlc3Npb25Ub2tlbic6IHFtYXBbJ2ZoX2F1dGhfc2Vzc2lvbiddLCAnYXV0aFJlc3BvbnNlJyA6IEpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudChxbWFwWydhdXRoUmVzcG9uc2UnXSkpKX07XG4gICAgICAgICAgZmhwYXJhbXMuc2V0QXV0aFNlc3Npb25Ub2tlbihxbWFwWydmaF9hdXRoX3Nlc3Npb24nXSk7XG4gICAgICAgICAgd2luZG93W2ZoQ2FsbGJhY2tdKG51bGwsIHN1Y1Jlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93W2ZoQ2FsbGJhY2tdKHsnbWVzc2FnZSc6cW1hcFsnbWVzc2FnZSddfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBoYW5kbGVBdXRoUmVzcG9uc2UgPSBmdW5jdGlvbihlbmR1cmwsIHJlcywgc3VjY2VzcywgZmFpbCl7XG4gIGlmKHJlcy5zdGF0dXMgJiYgcmVzLnN0YXR1cyA9PT0gXCJva1wiKXtcblxuICAgIHZhciBvbkNvbXBsZXRlID0gZnVuY3Rpb24ocmVzKXtcbiAgICAgIGlmKHJlcy5zZXNzaW9uVG9rZW4pe1xuICAgICAgICBmaHBhcmFtcy5zZXRBdXRoU2Vzc2lvblRva2VuKHJlcy5zZXNzaW9uVG9rZW4pO1xuICAgICAgfVxuICAgICAgc3VjY2VzcyhyZXMpO1xuICAgIH07XG4gICAgLy9mb3IgT0F1dGgsIGEgdXJsIHdpbGwgYmUgcmV0dXJuZWQgd2hpY2ggbWVhbnMgdGhlIHVzZXIgc2hvdWxkIGJlIGRpcmVjdGVkIHRvIHRoYXQgdXJsIHRvIGF1dGhlbnRpY2F0ZS5cbiAgICAvL3dlIHRyeSB0byB1c2UgdGhlIENoaWxkQnJvd2VyIHBsdWdpbiBpZiBpdCBjYW4gYmUgZm91bmQuIE90aGVyd2lzZSBzZW5kIHRoZSB1cmwgdG8gdGhlIHN1Y2Nlc3MgZnVuY3Rpb24gdG8gYWxsb3cgZGV2ZWxvcGVyIHRvIGhhbmRsZSBpdC5cbiAgICBpZihyZXMudXJsKXtcbiAgICAgIHZhciBpbmFwcEJyb3dzZXJXaW5kb3cgPSBudWxsO1xuICAgICAgdmFyIGxvY2F0aW9uQ2hhbmdlID0gZnVuY3Rpb24obmV3X3VybCl7XG4gICAgICAgIGlmKG5ld191cmwuaW5kZXhPZihlbmR1cmwpID4gLTEpe1xuICAgICAgICAgIGlmKGluYXBwQnJvd3NlcldpbmRvdyl7XG4gICAgICAgICAgICBpbmFwcEJyb3dzZXJXaW5kb3cuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHFtYXAgPSBxdWVyeU1hcChuZXdfdXJsKTtcbiAgICAgICAgICBpZihxbWFwKSB7XG4gICAgICAgICAgICBpZihxbWFwWydyZXN1bHQnXSAmJiBxbWFwWydyZXN1bHQnXSA9PT0gJ3N1Y2Nlc3MnKXtcbiAgICAgICAgICAgICAgdmFyIHN1Y1JlcyA9IHsnc2Vzc2lvblRva2VuJzogcW1hcFsnZmhfYXV0aF9zZXNzaW9uJ10sICdhdXRoUmVzcG9uc2UnIDogSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHFtYXBbJ2F1dGhSZXNwb25zZSddKSkpfTtcbiAgICAgICAgICAgICAgb25Db21wbGV0ZShzdWNSZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYoZmFpbCl7XG4gICAgICAgICAgICAgICAgZmFpbChcImF1dGhfZmFpbGVkXCIsIHsnbWVzc2FnZSc6cW1hcFsnbWVzc2FnZSddfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoZmFpbCl7XG4gICAgICAgICAgICAgICAgZmFpbChcImF1dGhfZmFpbGVkXCIsIHsnbWVzc2FnZSc6cW1hcFsnbWVzc2FnZSddfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYod2luZG93LlBob25lR2FwIHx8IHdpbmRvdy5jb3Jkb3ZhKXtcbiAgICAgICAgaWYod2luZG93LnBsdWdpbnMgJiYgd2luZG93LnBsdWdpbnMuY2hpbGRCcm93c2VyKXtcbiAgICAgICAgICAvL2ZvdW5kIGNoaWxkYnJvd3NlciBwbHVnaW4sYWRkIHRoZSBldmVudCBsaXN0ZW5lciBhbmQgbG9hZCBpdFxuICAgICAgICAgIC8vd2UgbmVlZCB0byBrbm93IHdoZW4gdGhlIE9BdXRoIHByb2Nlc3MgaXMgZmluaXNoZWQgYnkgY2hlY2tpbmcgZm9yIHRoZSBwcmVzZW5jZSBvZiBlbmR1cmwuIElmIHRoZSBlbmR1cmwgaXMgZm91bmQsIGl0IG1lYW5zIHRoZSBhdXRoZW50aWNhdGlvbiBmaW5pc2hlZCBhbmQgd2Ugc2hvdWxkIGZpbmQgaWYgaXQncyBzdWNjZXNzZnVsLlxuICAgICAgICAgIGlmKHR5cGVvZiB3aW5kb3cucGx1Z2lucy5jaGlsZEJyb3dzZXIuc2hvd1dlYlBhZ2UgPT09IFwiZnVuY3Rpb25cIil7XG4gICAgICAgICAgICB3aW5kb3cucGx1Z2lucy5jaGlsZEJyb3dzZXIub25Mb2NhdGlvbkNoYW5nZSA9IGxvY2F0aW9uQ2hhbmdlO1xuICAgICAgICAgICAgd2luZG93LnBsdWdpbnMuY2hpbGRCcm93c2VyLnNob3dXZWJQYWdlKHJlcy51cmwpO1xuICAgICAgICAgICAgaW5hcHBCcm93c2VyV2luZG93ID0gd2luZG93LnBsdWdpbnMuY2hpbGRCcm93c2VyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5hcHBCcm93c2VyV2luZG93ID0gd2luZG93Lm9wZW4ocmVzLnVybCwgXCJfYmxhbmtcIiwgJ2xvY2F0aW9uPXllcycpO1xuICAgICAgICAgICAgaW5hcHBCcm93c2VyV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2Fkc3RhcnRcIiwgZnVuY3Rpb24oZXYpe1xuICAgICAgICAgICAgICBsb2NhdGlvbkNoYW5nZShldi51cmwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwiSW5BcHBCcm93c2VyIHBsdWdpbiBpcyBub3QgaW50YWxsZWQuXCIpO1xuICAgICAgICAgICAgb25Db21wbGV0ZShyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICBkb2N1bWVudC5sb2NhdGlvbi5ocmVmID0gcmVzLnVybDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25Db21wbGV0ZShyZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZihmYWlsKXtcbiAgICAgIGZhaWwoXCJhdXRoX2ZhaWxlZFwiLCByZXMpO1xuICAgIH1cbiAgfVxufTtcblxuLy9UaGlzIGlzIG1haW5seSBmb3IgdXNpbmcgJGZoLmF1dGggaW5zaWRlIGJyb3dzZXJzLiBJZiB0aGUgYXV0aGVudGljYXRpb24gbWV0aG9kIGlzIE9BdXRoLCBhdCB0aGUgZW5kIG9mIHRoZSBwcm9jZXNzLCB0aGUgdXNlciB3aWxsIGJlIHJlLWRpcmVjdGVkIHRvXG4vL2EgdXJsIHRoYXQgd2Ugc3BlY2lmaWVkIGZvciBjaGVja2luZyBpZiB0aGUgYXV0aCBpcyBzdWNjZXNzZnVsLiBTbyB3ZSBhbHdheXMgY2hlY2sgdGhlIHVybCB0byBzZWUgaWYgd2UgYXJlIG9uIHRoZSByZS1kaXJlY3RlZCBwYWdlLlxuaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKXtcbiAgICBjaGVja0F1dGgod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICB9LCBmYWxzZSk7IC8vVzNDXG59IGVsc2Uge1xuICB3aW5kb3cuYXR0YWNoRXZlbnQoJ29ubG9hZCcsIGZ1bmN0aW9uKCl7XG4gICAgY2hlY2tBdXRoKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgfSk7IC8vSUVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFwiaGFuZGxlQXV0aFJlc3BvbnNlXCI6IGhhbmRsZUF1dGhSZXNwb25zZVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBcImZoX3RpbWVvdXRcIjogMjAwMDAsXG4gIFwiYm94cHJlZml4XCI6IFwiL2JveC9zcnYvMS4xL1wiLFxuICBcInNka192ZXJzaW9uXCI6IFwiQlVJTERfVkVSU0lPTlwiLFxuICBcImNvbmZpZ19qc1wiOiBcImZoY29uZmlnLmpzb25cIixcbiAgXCJJTklUX0VWRU5UXCI6IFwiZmhpbml0XCJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlYWRDb29raWVWYWx1ZSAgOiBmdW5jdGlvbiAoY29va2llX25hbWUpIHtcbiAgICB2YXIgbmFtZV9zdHIgPSBjb29raWVfbmFtZSArIFwiPVwiO1xuICAgIHZhciBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KFwiO1wiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb2tpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY29va2llc1tpXTtcbiAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PT0gJyAnKSB7XG4gICAgICAgIGMgPSBjLnN1YnN0cmluZygxLCBjLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoYy5pbmRleE9mKG5hbWVfc3RyKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYy5zdWJzdHJpbmcobmFtZV9zdHIubGVuZ3RoLCBjLmxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIGNyZWF0ZUNvb2tpZSA6IGZ1bmN0aW9uIChjb29raWVfbmFtZSwgY29va2llX3ZhbHVlKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIDM2NTAwICogMjQgKiA2MCAqIDYwICogMTAwMCk7IC8vMTAwIHllYXJzXG4gICAgdmFyIGV4cGlyZXMgPSBcIjsgZXhwaXJlcz1cIiArIGRhdGUudG9HTVRTdHJpbmcoKTtcbiAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWVfbmFtZSArIFwiPVwiICsgY29va2llX3ZhbHVlICsgZXhwaXJlcyArIFwiOyBwYXRoID0gL1wiO1xuICB9XG59O1xuIiwidmFyIGNvb2tpZXMgPSByZXF1aXJlKFwiLi9jb29raWVzXCIpO1xudmFyIHV1aWRNb2R1bGUgPSByZXF1aXJlKFwiLi91dWlkXCIpO1xudmFyIGxvZ2dlciA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vdHJ5IHRvIGdldCB0aGUgdW5pcXVlIGRldmljZSBpZGVudGlmaWVyXG4gIFwiZ2V0RGV2aWNlSWRcIjogZnVuY3Rpb24oKXtcbiAgICAvL2NoZWNrIGZvciBjb3Jkb3ZhL3Bob25lZ2FwIGZpcnN0XG4gICAgaWYodHlwZW9mIHdpbmRvdy5maGRldmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmZoZGV2aWNlLnV1aWQgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgcmV0dXJuIHdpbmRvdy5maGRldmljZS51dWlkO1xuICAgIH0gZWxzZSBpZih0eXBlb2Ygd2luZG93LmRldmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRldmljZS51dWlkICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgIHJldHVybiB3aW5kb3cuZGV2aWNlLnV1aWQ7XG4gICAgfSAgZWxzZSBpZih0eXBlb2YgbmF2aWdhdG9yLmRldmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbmF2aWdhdG9yLmRldmljZS51dWlkICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgIHJldHVybiBuYXZpZ2F0b3IuZGV2aWNlLnV1aWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfbW9ja191dWlkX2Nvb2tpZV9uYW1lID0gXCJtb2NrX3V1aWRcIjtcbiAgICAgIHZhciB1dWlkID0gY29va2llcy5yZWFkQ29va2llVmFsdWUoX21vY2tfdXVpZF9jb29raWVfbmFtZSk7XG4gICAgICBpZihudWxsID09IHV1aWQpe1xuICAgICAgICAgIHV1aWQgPSB1dWlkTW9kdWxlLmNyZWF0ZVVVSUQoKTtcbiAgICAgICAgICBjb29raWVzLmNyZWF0ZUNvb2tpZShfbW9ja191dWlkX2Nvb2tpZV9uYW1lLCB1dWlkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1dWlkO1xuICAgIH1cbiAgfSxcblxuICAvL3RoaXMgaXMgZm9yIGZpeGluZyBhbmFseXRpY3MgaXNzdWVzIHdoZW4gdXBncmFkaW5nIGZyb20gaW82IHRvIGlvczcuIFByb2JhYmx5IGNhbiBiZSBkZXByZWNhdGVkIG5vd1xuICBcImdldEN1aWRNYXBcIjogZnVuY3Rpb24oKXtcbiAgICBpZih0eXBlb2Ygd2luZG93LmZoZGV2aWNlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZmhkZXZpY2UuY3VpZE1hcCAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICByZXR1cm4gd2luZG93LmZoZGV2aWNlLmN1aWRNYXA7XG4gICAgfSBlbHNlIGlmKHR5cGVvZiB3aW5kb3cuZGV2aWNlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZGV2aWNlLmN1aWRNYXAgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgcmV0dXJuIHdpbmRvdy5kZXZpY2UuY3VpZE1hcDtcbiAgICB9ICBlbHNlIGlmKHR5cGVvZiBuYXZpZ2F0b3IuZGV2aWNlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBuYXZpZ2F0b3IuZGV2aWNlLmN1aWRNYXAgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgcmV0dXJuIG5hdmlnYXRvci5kZXZpY2UuY3VpZE1hcDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBcImdldERlc3RpbmF0aW9uXCI6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICB2YXIgcGxhdGZvcm1zVG9UZXN0ID0gcmVxdWlyZShcIi4vcGxhdGZvcm1zTWFwXCIpO1xuXG5cbiAgICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICAgIHZhciBkZXN0X292ZXJyaWRlID0gZG9jdW1lbnQubG9jYXRpb24uc2VhcmNoLnNwbGl0KFwiZmhfZGVzdGluYXRpb25fY29kZT1cIik7XG4gICAgaWYgKGRlc3Rfb3ZlcnJpZGUubGVuZ3RoID4gMSkge1xuICAgICBkZXN0aW5hdGlvbiA9IGRlc3Rfb3ZlcnJpZGVbMV07XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93LmZoX2Rlc3RpbmF0aW9uX2NvZGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZXN0aW5hdGlvbiA9IHdpbmRvdy5maF9kZXN0aW5hdGlvbl9jb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbGF0Zm9ybXNUb1Rlc3QuZm9yRWFjaChmdW5jdGlvbih0ZXN0RGVzdGluYXRpb24pe1xuICAgICAgICB0ZXN0RGVzdGluYXRpb24udGVzdC5mb3JFYWNoKGZ1bmN0aW9uKGRlc3RpbmF0aW9uVGVzdCl7XG4gICAgICAgICAgaWYodXNlckFnZW50LmluZGV4T2YoZGVzdGluYXRpb25UZXN0KSA+IC0xKXtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gdGVzdERlc3RpbmF0aW9uLmRlc3RpbmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZihkZXN0aW5hdGlvbiA9PSBudWxsKXsgLy9ObyB1c2VyIGFnZW50cyB3ZXJlIGZvdW5kLCBzZXQgdG8gZGVmYXVsdCB3ZWJcbiAgICAgIGRlc3RpbmF0aW9uID0gXCJ3ZWJcIjtcbiAgICB9XG5cbiAgICBsb2dnZXIuZGVidWcoXCJkZXN0aW5hdGlvbiA9IFwiICsgZGVzdGluYXRpb24pO1xuXG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICB9XG59XG4iLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbmVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKDApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtaXR0ZXI7IiwidmFyIGRldmljZSA9IHJlcXVpcmUoXCIuL2RldmljZVwiKTtcbnZhciBzZGt2ZXJzaW9uID0gcmVxdWlyZShcIi4vc2RrdmVyc2lvblwiKTtcbnZhciBhcHBQcm9wcyA9IHJlcXVpcmUoXCIuL2FwcFByb3BzXCIpO1xudmFyIGxvZ2dlciA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcblxudmFyIGRlZmF1bHRQYXJhbXMgPSBudWxsO1xudmFyIGF1dGhTZXNzaW9uVG9rZW4gPSBudWxsO1xuLy9UT0RPOiByZXZpZXcgdGhlc2Ugb3B0aW9ucywgd2UgcHJvYmFibHkgb25seSBuZWVkcyBhbGwgb2YgdGhlbSBmb3IgaW5pdCBjYWxscywgYnV0IHdlIHNob3VsZG4ndCBuZWVkIGFsbCBvZiB0aGVtIGZvciBhY3QgY2FsbHNcbnZhciBidWlsZEZIUGFyYW1zID0gZnVuY3Rpb24oKXtcbiAgaWYoZGVmYXVsdFBhcmFtcyl7XG4gICAgcmV0dXJuIGRlZmF1bHRQYXJhbXM7XG4gIH1cbiAgdmFyIGZocGFyYW1zID0ge307XG4gIGZocGFyYW1zLmN1aWQgPSBkZXZpY2UuZ2V0RGV2aWNlSWQoKTtcbiAgZmhwYXJhbXMuY3VpZE1hcCA9IGRldmljZS5nZXRDdWlkTWFwKCk7XG4gIGZocGFyYW1zLmRlc3RpbmF0aW9uID0gZGV2aWNlLmdldERlc3RpbmF0aW9uKCk7XG4gIFxuICBpZih3aW5kb3cuZGV2aWNlIHx8IG5hdmlnYXRvci5kZXZpY2Upe1xuICAgIGZocGFyYW1zLmRldmljZSA9IHdpbmRvdy5kZXZpY2UgfHwgbmF2aWdhdG9yLmRldmljZTtcbiAgfVxuXG4gIC8vYmFja3dhcmQgY29tcGF0aWJsZVxuICBpZiAodHlwZW9mIHdpbmRvdy5maF9hcHBfdmVyc2lvbiAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgIGZocGFyYW1zLmFwcF92ZXJzaW9uID0gZmhfYXBwX3ZlcnNpb247XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cuZmhfcHJvamVjdF92ZXJzaW9uICE9PSAndW5kZWZpbmVkJyl7XG4gICAgZmhwYXJhbXMucHJvamVjdF92ZXJzaW9uID0gZmhfcHJvamVjdF92ZXJzaW9uO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93LmZoX3Byb2plY3RfYXBwX3ZlcnNpb24gIT09ICd1bmRlZmluZWQnKXtcbiAgICBmaHBhcmFtcy5wcm9qZWN0X2FwcF92ZXJzaW9uID0gZmhfcHJvamVjdF9hcHBfdmVyc2lvbjtcbiAgfVxuICBmaHBhcmFtcy5zZGtfdmVyc2lvbiA9IHNka3ZlcnNpb24oKTtcbiAgaWYoYXV0aFNlc3Npb25Ub2tlbil7XG4gICAgZmhwYXJhbXMuc2Vzc2lvblRva2VuID0gYXV0aFNlc3Npb25Ub2tlbjtcbiAgfVxuXG4gIHZhciBhcHBfcHJvcHMgPSBhcHBQcm9wcy5nZXRBcHBQcm9wcygpO1xuICBpZihhcHBfcHJvcHMpe1xuICAgIGZocGFyYW1zLmFwcGlkID0gYXBwX3Byb3BzLmFwcGlkO1xuICAgIGZocGFyYW1zLmFwcGtleSA9IGFwcF9wcm9wcy5hcHBrZXk7XG4gICAgZmhwYXJhbXMucHJvamVjdGlkID0gYXBwX3Byb3BzLnByb2plY3RpZDtcbiAgICBmaHBhcmFtcy5hbmFseXRpY3NUYWcgPSAgYXBwX3Byb3BzLmFuYWx5dGljc1RhZztcbiAgICBmaHBhcmFtcy5jb25uZWN0aW9udGFnID0gYXBwX3Byb3BzLmNvbm5lY3Rpb250YWc7XG4gICAgaWYoYXBwX3Byb3BzLmluaXQpe1xuICAgICAgZmhwYXJhbXMuaW5pdCA9IHR5cGVvZihhcHBfcHJvcHMuaW5pdCkgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKGFwcF9wcm9wcy5pbml0KSA6IGFwcF9wcm9wcy5pbml0O1xuICAgIH1cbiAgfVxuICBcbiAgZGVmYXVsdFBhcmFtcyA9IGZocGFyYW1zO1xuICBsb2dnZXIuZGVidWcoXCJmaHBhcmFtcyA9IFwiLCBkZWZhdWx0UGFyYW1zKTtcbiAgcmV0dXJuIGZocGFyYW1zO1xufVxuXG52YXIgYWRkRkhQYXJhbXMgPSBmdW5jdGlvbihwYXJhbXMpe1xuICB2YXIgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBwYXJhbXMuX19maCA9IGJ1aWxkRkhQYXJhbXMoKTtcbiAgcmV0dXJuIHBhcmFtcztcbn1cblxudmFyIHNldEF1dGhTZXNzaW9uVG9rZW4gPSBmdW5jdGlvbihzZXNzaW9uVG9rZW4pe1xuICBhdXRoU2Vzc2lvblRva2VuID0gc2Vzc2lvblRva2VuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCJidWlsZEZIUGFyYW1zXCI6IGJ1aWxkRkhQYXJhbXMsXG4gIFwiYWRkRkhQYXJhbXNcIjogYWRkRkhQYXJhbXMsXG4gIFwic2V0QXV0aFNlc3Npb25Ub2tlblwiOnNldEF1dGhTZXNzaW9uVG9rZW5cbn1cbiIsInZhciBKU09OID0gcmVxdWlyZShcIkpTT05cIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZmFpbCwgcmVxLCByZXNTdGF0dXMsIGVycm9yKXtcbiAgdmFyIGVycnJhdztcbiAgdmFyIHN0YXR1c0NvZGUgPSAwO1xuICBpZihyZXEpe1xuICAgIHRyeXtcbiAgICAgIHN0YXR1c0NvZGUgPSByZXEuc3RhdHVzO1xuICAgICAgdmFyIHJlcyA9IEpTT04ucGFyc2UocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICBlcnJyYXcgPSByZXMuZXJyb3IgfHwgcmVzLm1zZztcbiAgICAgIGlmIChlcnJyYXcgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBlcnJyYXcgPSBlcnJyYXcuam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIGVycnJhdyA9IHJlcS5yZXNwb25zZVRleHQ7XG4gICAgfVxuICB9XG4gIGlmKGZhaWwpe1xuICAgIGZhaWwoZXJycmF3LCB7XG4gICAgICBzdGF0dXM6IHN0YXR1c0NvZGUsXG4gICAgICBtZXNzYWdlOiByZXNTdGF0dXMsXG4gICAgICBlcnJvcjogZXJyb3JcbiAgICB9KTtcbiAgfVxufTtcbiIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgYXBwUHJvcHMgPSByZXF1aXJlKFwiLi9hcHBQcm9wc1wiKTtcblxuZnVuY3Rpb24gcmVtb3ZlRW5kU2xhc2goaW5wdXQpe1xuICB2YXIgcmV0ID0gaW5wdXQ7XG4gIGlmKHJldC5jaGFyQXQocmV0Lmxlbmd0aCAtIDEpID09PSBcIi9cIil7XG4gICAgcmV0ID0gcmV0LnN1YnN0cmluZygwLCByZXQubGVuZ3RoLTEpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0YXJ0U2xhc2goaW5wdXQpe1xuICB2YXIgcmV0ID0gaW5wdXQ7XG4gIGlmKHJldC5sZW5ndGggPiAxICYmIHJldC5jaGFyQXQoMCkgPT09IFwiL1wiKXtcbiAgICByZXQgPSByZXQuc3Vic3RyaW5nKDEsIHJldC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIENsb3VkSG9zdChjbG91ZF9wcm9wcyl7XG4gIHRoaXMuY2xvdWRfcHJvcHMgPSBjbG91ZF9wcm9wcztcbiAgdGhpcy5jbG91ZF9ob3N0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmlzTGVnYWN5ID0gZmFsc2U7XG59XG5cbkNsb3VkSG9zdC5wcm90b3R5cGUuZ2V0SG9zdCA9IGZ1bmN0aW9uKGFwcFR5cGUpe1xuICBpZih0aGlzLmNsb3VkX2hvc3Qpe1xuICAgIHJldHVybiB0aGlzLmNsb3VkX2hvc3Q7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHVybDtcbiAgICB2YXIgYXBwX3R5cGU7XG4gICAgaWYodGhpcy5jbG91ZF9wcm9wcyAmJiB0aGlzLmNsb3VkX3Byb3BzLmhvc3RzKXtcbiAgICAgIHVybCA9IHRoaXMuY2xvdWRfcHJvcHMuaG9zdHMudXJsO1xuXG4gICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gcmVzb2x2ZSB1cmwgdGhlIG9sZCB3YXkgaS5lLiBkZXBlbmRpbmcgb25cbiAgICAgICAgLy8gLWJ1cm50IGluIGFwcCBtb2RlXG4gICAgICAgIC8vIC1yZXR1cm5lZCBkZXYgb3IgbGl2ZSB1cmxcbiAgICAgICAgLy8gLXJldHVybmVkIGRldiBvciBsaXZlIHR5cGUgKG5vZGUgb3IgZmgocmhpbm8gb3IgcHJveHlpbmcpKVxuICAgICAgICB2YXIgY2xvdWRfaG9zdCA9IHRoaXMuY2xvdWRfcHJvcHMuaG9zdHMucmVsZWFzZUNsb3VkVXJsO1xuICAgICAgICBhcHBfdHlwZSA9IHRoaXMuY2xvdWRfcHJvcHMuaG9zdHMucmVsZWFzZUNsb3VkVHlwZTtcblxuICAgICAgICBpZih0eXBlb2YgYXBwVHlwZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcHBUeXBlLmluZGV4T2YoXCJkZXZcIikgPiAtMSl7XG4gICAgICAgICAgY2xvdWRfaG9zdCA9IHRoaXMuY2xvdWRfcHJvcHMuaG9zdHMuZGVidWdDbG91ZFVybDtcbiAgICAgICAgICBhcHBfdHlwZSA9IHRoaXMuY2xvdWRfcHJvcHMuaG9zdHMuZGVidWdDbG91ZFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gY2xvdWRfaG9zdDtcbiAgICAgIH1cbiAgICB9XG4gICAgdXJsID0gcmVtb3ZlRW5kU2xhc2godXJsKTtcbiAgICB0aGlzLmNsb3VkX2hvc3QgPSB1cmw7XG4gICAgaWYoYXBwX3R5cGUgPT09IFwiZmhcIil7XG4gICAgICB0aGlzLmlzTGVnYWN5ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfVxufVxuXG5DbG91ZEhvc3QucHJvdG90eXBlLmdldEFjdFVybCA9IGZ1bmN0aW9uKGFjdCl7XG4gIHZhciBhcHBfcHJvcHMgPSBhcHBQcm9wcy5nZXRBcHBQcm9wcygpIHx8IHt9O1xuICBpZih0eXBlb2YgdGhpcy5jbG91ZF9ob3N0ID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICB0aGlzLmdldEhvc3QoYXBwX3Byb3BzLm1vZGUpO1xuICB9XG4gIGlmKHRoaXMuaXNMZWdhY3kpe1xuICAgIHJldHVybiB0aGlzLmNsb3VkX2hvc3QgKyBjb25zdGFudHMuYm94cHJlZml4ICsgXCJhY3QvXCIgKyB0aGlzLmNsb3VkX3Byb3BzLmRvbWFpbiArIFwiL1wiICsgYXBwX3Byb3BzLmFwcGlkICsgXCIvXCIgKyBhY3QgKyBcIi9cIiArIGFwcF9wcm9wcy5hcHBpZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5jbG91ZF9ob3N0ICsgXCIvY2xvdWQvXCIgKyBhY3Q7XG4gIH1cbn1cblxuQ2xvdWRIb3N0LnByb3RvdHlwZS5nZXRNQkFBU1VybCA9IGZ1bmN0aW9uKHNlcnZpY2Upe1xuICB2YXIgYXBwX3Byb3BzID0gYXBwUHJvcHMuZ2V0QXBwUHJvcHMoKSB8fCB7fTtcbiAgaWYodHlwZW9mIHRoaXMuY2xvdWRfaG9zdCA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgdGhpcy5nZXRIb3N0KGFwcF9wcm9wcy5tb2RlKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jbG91ZF9ob3N0ICsgXCIvbWJhYXMvXCIgKyBzZXJ2aWNlO1xufVxuXG5DbG91ZEhvc3QucHJvdG90eXBlLmdldENsb3VkVXJsID0gZnVuY3Rpb24ocGF0aCl7XG4gIHZhciBhcHBfcHJvcHMgPSBhcHBQcm9wcy5nZXRBcHBQcm9wcygpIHx8IHt9O1xuICBpZih0eXBlb2YgdGhpcy5jbG91ZF9ob3N0ID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICB0aGlzLmdldEhvc3QoYXBwX3Byb3BzLm1vZGUpO1xuICB9XG4gIHJldHVybiB0aGlzLmNsb3VkX2hvc3QgKyBcIi9cIiArIHJlbW92ZVN0YXJ0U2xhc2gocGF0aCk7XG59XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IENsb3VkSG9zdDsiLCJ2YXIgbG9hZFNjcmlwdCA9IHJlcXVpcmUoXCIuL2xvYWRTY3JpcHRcIik7XG52YXIgTGF3bmNoYWlyID0gcmVxdWlyZSgnLi4vLi4vbGlicy9nZW5lcmF0ZWQvbGF3bmNoYWlyJyk7XG52YXIgbGF3bmNoYWlyZXh0ID0gcmVxdWlyZSgnLi9sYXduY2hhaXItZXh0Jyk7XG52YXIgY29uc3RzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIGZocGFyYW1zID0gcmVxdWlyZShcIi4vZmhwYXJhbXNcIik7XG52YXIgYWpheCA9IHJlcXVpcmUoXCIuL2FqYXhcIik7XG52YXIgaGFuZGxlRXJyb3IgPSByZXF1aXJlKFwiLi9oYW5kbGVFcnJvclwiKTtcbnZhciBsb2dnZXIgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XG52YXIgSlNPTiA9IHJlcXVpcmUoXCJKU09OXCIpO1xudmFyIGhhc2hGdW5jID0gcmVxdWlyZShcIi4vc2VjdXJpdHkvaGFzaFwiKTtcbnZhciBhcHBQcm9wcyA9IHJlcXVpcmUoXCIuL2FwcFByb3BzXCIpO1xuXG52YXIgaW5pdCA9IGZ1bmN0aW9uKGNiKSB7XG4gIGFwcFByb3BzLmxvYWQoZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgcmV0dXJuIGxvYWRDbG91ZFByb3BzKGRhdGEsIGNiKTtcbiAgfSk7XG59XG5cbnZhciBsb2FkQ2xvdWRQcm9wcyA9IGZ1bmN0aW9uKGFwcF9wcm9wcywgY2FsbGJhY2spIHtcbiAgaWYoYXBwX3Byb3BzLmxvZ2xldmVsKXtcbiAgICBsb2dnZXIuc2V0TGV2ZWwoYXBwX3Byb3BzLmxvZ2xldmVsKTtcbiAgfVxuICAvLyBJZiBsb2NhbCAtIHNob3J0Y2lyY3VpdCB0aGUgaW5pdCAtIGp1c3QgcmV0dXJuIHRoZSBob3N0XG4gIGlmIChhcHBfcHJvcHMubG9jYWwpIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgXCJkb21haW5cIjogXCJsb2NhbFwiLFxuICAgICAgXCJmaXJzdFRpbWVcIjogZmFsc2UsXG4gICAgICBcImhvc3RzXCI6IHtcbiAgICAgICAgXCJkZWJ1Z0Nsb3VkVHlwZVwiOiBcIm5vZGVcIixcbiAgICAgICAgXCJkZWJ1Z0Nsb3VkVXJsXCI6IGFwcF9wcm9wcy5ob3N0LFxuICAgICAgICBcInJlbGVhc2VDbG91ZFR5cGVcIjogXCJub2RlXCIsXG4gICAgICAgIFwicmVsZWFzZUNsb3VkVXJsXCI6IGFwcF9wcm9wcy5ob3N0LFxuICAgICAgICBcInR5cGVcIjogXCJjbG91ZF9ub2RlanNcIixcbiAgICAgICAgXCJ1cmxcIjogYXBwX3Byb3BzLmhvc3RcbiAgICAgIH0sXG4gICAgICBcImluaXRcIjoge1xuICAgICAgICBcInRyYWNrSWRcIjogXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIlxuICAgICAgfSxcbiAgICAgIFwic3RhdHVzXCI6IFwib2tcIlxuICAgIH07XG5cbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge1xuICAgICAgY2xvdWQ6IHJlc1xuICAgIH0pO1xuICB9XG5cblxuICAvL25vdyB3ZSBoYXZlIGFwcCBwcm9wcywgYWRkIHRoZSBmaWxlU3RvcmFnZUFkYXB0ZXJcbiAgbGF3bmNoYWlyZXh0LmFkZEFkYXB0ZXIoYXBwX3Byb3BzLCBoYXNoRnVuYyk7XG4gIC8vZG9tIGFkYXB0ZXIgZG9lbnMndCB3b3JrIG9uIHdpbmRvd3MgcGhvbmUsIHNvIGRvbid0IHNwZWNpZnkgdGhlIGFkYXB0ZXIgaWYgdGhlIGRvbSBvbmUgZmFpbGVkXG4gIC8vd2Ugc3BlY2lmeSB0aGUgb3JkZXIgb2YgbGF3bmNoYWlyIGFkYXB0ZXJzIHRvIHVzZSwgbGF3bmNoYWlyIHdpbGwgZmluZCB0aGUgcmlnaHQgb25lIHRvIHVzZSwgdG8ga2VlcCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBrZWVwIHRoZSBvcmRlclxuICAvL2FzIGRvbSwgd2Via2l0LXNxbGl0ZSwgbG9jYWxGaWxlU3RvcmFnZSwgd2luZG93LW5hbWVcbiAgdmFyIGxjQ29uZiA9IHtcbiAgICBuYW1lOiBcImZoX2luaXRfc3RvcmFnZVwiLFxuICAgIGFkYXB0ZXI6IFtcImRvbVwiLCBcIndlYmtpdC1zcWxpdGVcIiwgXCJsb2NhbEZpbGVTdG9yYWdlXCIsIFwid2luZG93LW5hbWVcIl0sXG4gICAgZmFpbDogZnVuY3Rpb24obXNnLCBlcnIpIHtcbiAgICAgIHZhciBlcnJvcl9tZXNzYWdlID0gJ3JlYWQvc2F2ZSBmcm9tL3RvIGxvY2FsIHN0b3JhZ2UgZmFpbGVkICBtc2c6JyArIG1zZyArICcgZXJyOicgKyBlcnI7XG4gICAgICByZXR1cm4gZmFpbChlcnJvcl9tZXNzYWdlLCB7fSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBzdG9yYWdlID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBzdG9yYWdlID0gbmV3IExhd25jaGFpcihsY0NvbmYsIGZ1bmN0aW9uKCkge30pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy93aGVuIGRvbSBhZGFwdGVyIGZhaWxlZCwgTGF3bmNoYWlyIHRocm93cyBhbiBlcnJvclxuICAgIC8vc2hvdWRuJ3QgZ28gaW4gaGVyZSBhbnltb3JlXG4gICAgbGNDb25mLmFkYXB0ZXIgPSB1bmRlZmluZWQ7XG4gICAgc3RvcmFnZSA9IG5ldyBMYXduY2hhaXIobGNDb25mLCBmdW5jdGlvbigpIHt9KTtcbiAgfVxuXG4gIHZhciBwYXRoID0gYXBwX3Byb3BzLmhvc3QgKyBjb25zdHMuYm94cHJlZml4ICsgXCJhcHAvaW5pdFwiO1xuXG4gIHN0b3JhZ2UuZ2V0KCdmaF9pbml0JywgZnVuY3Rpb24oc3RvcmFnZV9yZXMpIHtcbiAgICB2YXIgc2F2ZWRIb3N0ID0gbnVsbDtcbiAgICBpZiAoc3RvcmFnZV9yZXMgJiYgc3RvcmFnZV9yZXMudmFsdWUgIT09IG51bGwgJiYgdHlwZW9mKHN0b3JhZ2VfcmVzLnZhbHVlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzdG9yYWdlX3JlcyAhPT0gXCJcIikge1xuICAgICAgc3RvcmFnZV9yZXMgPSB0eXBlb2Yoc3RvcmFnZV9yZXMpID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShzdG9yYWdlX3JlcykgOiBzdG9yYWdlX3JlcztcbiAgICAgIHN0b3JhZ2VfcmVzLnZhbHVlID0gdHlwZW9mKHN0b3JhZ2VfcmVzLnZhbHVlKSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2Uoc3RvcmFnZV9yZXMudmFsdWUpIDogc3RvcmFnZV9yZXMudmFsdWU7XG4gICAgICBpZiAoc3RvcmFnZV9yZXMudmFsdWUuaW5pdCkge1xuICAgICAgICBhcHBfcHJvcHMuaW5pdCA9IHN0b3JhZ2VfcmVzLnZhbHVlLmluaXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2tlZXAgaXQgYmFja3dhcmQgY29tcGF0aWJsZS5cbiAgICAgICAgYXBwX3Byb3BzLmluaXQgPSB0eXBlb2Yoc3RvcmFnZV9yZXMudmFsdWUpID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShzdG9yYWdlX3Jlcy52YWx1ZSkgOiBzdG9yYWdlX3Jlcy52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdG9yYWdlX3Jlcy52YWx1ZS5ob3N0cykge1xuICAgICAgICBzYXZlZEhvc3QgPSBzdG9yYWdlX3Jlcy52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGRhdGEgPSBmaHBhcmFtcy5idWlsZEZIUGFyYW1zKCk7XG5cbiAgICBhamF4KHtcbiAgICAgIFwidXJsXCI6IHBhdGgsXG4gICAgICBcInR5cGVcIjogXCJQT1NUXCIsXG4gICAgICBcInRyeUpTT05QXCI6IHRydWUsXG4gICAgICBcImRhdGFUeXBlXCI6IFwianNvblwiLFxuICAgICAgXCJjb250ZW50VHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFwiZGF0YVwiOiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgIFwidGltZW91dFwiOiBhcHBfcHJvcHMudGltZW91dCB8fCBjb25zdHMuZmhfdGltZW91dCxcbiAgICAgIFwic3VjY2Vzc1wiOiBmdW5jdGlvbihpbml0UmVzKSB7XG4gICAgICAgIHN0b3JhZ2Uuc2F2ZSh7XG4gICAgICAgICAga2V5OiBcImZoX2luaXRcIixcbiAgICAgICAgICB2YWx1ZTogaW5pdFJlc1xuICAgICAgICB9LCBmdW5jdGlvbigpIHt9KTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgY2xvdWQ6IGluaXRSZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZXJyb3JcIjogZnVuY3Rpb24ocmVxLCBzdGF0dXNUZXh0LCBlcnJvcikge1xuICAgICAgICAvL3VzZSB0aGUgY2FjaGVkIGhvc3QgaWYgd2UgaGF2ZSBhIGNvcHlcbiAgICAgICAgaWYgKHNhdmVkSG9zdCkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgICBjbG91ZDogc2F2ZWRIb3N0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZnVuY3Rpb24obXNnLCBlcnIpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2dcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVxLCBzdGF0dXNUZXh0LCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCJpbml0XCI6IGluaXQsXG4gIFwibG9hZENsb3VkUHJvcHNcIjogbG9hZENsb3VkUHJvcHNcbn0iLCJ2YXIgTGF3bmNoYWlyID0gcmVxdWlyZSgnLi4vLi4vbGlicy9nZW5lcmF0ZWQvbGF3bmNoYWlyJyk7XG5cbnZhciBmaWxlU3RvcmFnZUFkYXB0ZXIgPSBmdW5jdGlvbiAoYXBwX3Byb3BzLCBoYXNoRnVuYykge1xuICAvLyBwcml2YXRlIG1ldGhvZHNcblxuICBmdW5jdGlvbiBkb0xvZyhtZXNzKXtcbiAgICBpZihjb25zb2xlKXtcbiAgICAgIGNvbnNvbGUubG9nKG1lc3MpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmYWlsID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICBpZihjb25zb2xlKSBjb25zb2xlLmxvZygnZXJyb3IgaW4gZmlsZSBzeXN0ZW0gYWRhcHRlciAhJywgZSwgaSk7XG4gICAgZWxzZSB0aHJvdyBlO1xuICB9O1xuXG5cbiAgZnVuY3Rpb24gZmlsZW5hbWVGb3JLZXkoa2V5LCBjYikge1xuICAgIGtleSA9IGFwcF9wcm9wcy5hcHBpZCArIGtleTtcblxuICAgIGhhc2hGdW5jKHtcbiAgICAgIGFsZ29yaXRobTogXCJNRDVcIixcbiAgICAgIHRleHQ6IGtleVxuICAgIH0sIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgdmFyIGZpbGVuYW1lID0gcmVzdWx0Lmhhc2h2YWx1ZSArICcudHh0JztcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yLmV4dGVybmFsc3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBuYXZpZ2F0b3IuZXh0ZXJuYWxzdG9yYWdlLmVuYWJsZShmdW5jdGlvbiBoYW5kbGVTdWNjZXNzKHJlcyl7XG4gICAgICAgICAgdmFyIHBhdGggPSBmaWxlbmFtZTtcbiAgICAgICAgICBpZihyZXMucGF0aCApIHtcbiAgICAgICAgICAgIHBhdGggPSByZXMucGF0aDtcbiAgICAgICAgICAgIGlmKCFwYXRoLm1hdGNoKC9cXC8kLykpIHtcbiAgICAgICAgICAgICAgcGF0aCArPSAnLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRoICs9IGZpbGVuYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaWxlbmFtZSA9IHBhdGg7XG4gICAgICAgICAgcmV0dXJuIGNiKGZpbGVuYW1lKTtcbiAgICAgICAgfSxmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIpe1xuICAgICAgICAgIHJldHVybiBjYihmaWxlbmFtZSk7XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb0xvZygnZmlsZW5hbWVGb3JLZXkga2V5PScgKyBrZXkrICcgLCBGaWxlbmFtZTogJyArIGZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIGNiKGZpbGVuYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG5cbiAgICB2YWxpZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gISEod2luZG93LnJlcXVlc3RGaWxlU3lzdGVtKSB9LFxuXG4gICAgaW5pdCA6IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjayl7XG4gICAgICAvL2NhbGxzIHRoZSBwYXJlbnQgZnVuY3Rpb24gZm4gYW5kIGFwcGxpZXMgdGhpcyBzY29wZVxuICAgICAgaWYob3B0aW9ucyAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2Ygb3B0aW9ucy5mYWlsICkgZmFpbCA9IG9wdGlvbnMuZmFpbDtcbiAgICAgIGlmIChjYWxsYmFjaykgdGhpcy5mbih0aGlzLm5hbWUsIGNhbGxiYWNrKS5jYWxsKHRoaXMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBrZXlzOiBmdW5jdGlvbiAoY2FsbGJhY2spe1xuICAgICAgdGhyb3cgXCJDdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiO1xuICAgIH0sXG5cbiAgICBzYXZlIDogZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spe1xuICAgICAgdmFyIGtleSA9IG9iai5rZXk7XG4gICAgICB2YXIgdmFsdWUgPSBvYmoudmFsfHxvYmoudmFsdWU7XG4gICAgICBmaWxlbmFtZUZvcktleShrZXksIGZ1bmN0aW9uKGhhc2gpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtKExvY2FsRmlsZVN5c3RlbS5QRVJTSVNURU5ULCAwLCBmdW5jdGlvbiBnb3RGUyhmaWxlU3lzdGVtKSB7XG5cbiAgICAgICAgICBmaWxlU3lzdGVtLnJvb3QuZ2V0RmlsZShoYXNoLCB7XG4gICAgICAgICAgICBjcmVhdGU6IHRydWVcbiAgICAgICAgICB9LCBmdW5jdGlvbiBnb3RGaWxlRW50cnkoZmlsZUVudHJ5KSB7XG4gICAgICAgICAgICBmaWxlRW50cnkuY3JlYXRlV3JpdGVyKGZ1bmN0aW9uIGdvdEZpbGVXcml0ZXIod3JpdGVyKSB7XG4gICAgICAgICAgICAgIHdyaXRlci5vbndyaXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgdmFsOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB3cml0ZXIud3JpdGUodmFsdWUpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGZhaWwoJ1tzYXZlXSBGYWlsZWQgdG8gY3JlYXRlIGZpbGUgd3JpdGVyJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZhaWwoJ1tzYXZlXSBGYWlsZWQgdG8gZ2V0RmlsZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmYWlsKCdbc2F2ZV0gRmFpbGVkIHRvIHJlcXVlc3RGaWxlU3lzdGVtJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGJhdGNoIDogZnVuY3Rpb24gKHJlY29yZHMsIGNhbGxiYWNrKXtcbiAgICAgIHRocm93IFwiQ3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIjtcbiAgICB9LFxuXG4gICAgZ2V0IDogZnVuY3Rpb24gKGtleSwgY2FsbGJhY2spe1xuICAgICAgZmlsZW5hbWVGb3JLZXkoa2V5LCBmdW5jdGlvbihoYXNoKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0RmlsZVN5c3RlbShMb2NhbEZpbGVTeXN0ZW0uUEVSU0lTVEVOVCwgMCwgZnVuY3Rpb24gZ290RlMoZmlsZVN5c3RlbSkge1xuICAgICAgICAgIGZpbGVTeXN0ZW0ucm9vdC5nZXRGaWxlKGhhc2gsIHt9LCBmdW5jdGlvbiBnb3RGaWxlRW50cnkoZmlsZUVudHJ5KSB7XG4gICAgICAgICAgICBmaWxlRW50cnkuZmlsZShmdW5jdGlvbiBnb3RGaWxlKGZpbGUpIHtcbiAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBldnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgVVJMZW5jb2RlZFxuICAgICAgICAgICAgICAgIC8vIFBHIDIuMiBidWcgaW4gcmVhZEFzVGV4dCgpXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRleHQgPSBkZWNvZGVVUklDb21wb25lbnQodGV4dCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgLy8gU3dhbGxvdyBleGNlcHRpb24gaWYgbm90IFVSTGVuY29kZWRcbiAgICAgICAgICAgICAgICAgIC8vIEp1c3QgdXNlIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgdmFsOiB0ZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGZhaWwoJ1tsb2FkXSBGYWlsZWQgdG8gZ2V0RmlsZScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBTdWNjZXNzIGNhbGxiYWNrIG9uIGtleSBsb2FkIGZhaWx1cmVcbiAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgIHZhbDogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZhaWwoJ1tsb2FkXSBGYWlsZWQgdG8gZ2V0IGZpbGVTeXN0ZW0nKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZXhpc3RzIDogZnVuY3Rpb24gKGtleSwgY2FsbGJhY2spe1xuICAgICAgZmlsZW5hbWVGb3JLZXkoa2V5LGZ1bmN0aW9uIChoYXNoKXtcbiAgICAgICAgd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtKExvY2FsRmlsZVN5c3RlbS5QRVJTSVNURU5ULCAwLCBmdW5jdGlvbiBnb3RGUyhmaWxlU3lzdGVtKSB7XG4gICAgICAgICAgZmlsZVN5c3RlbS5yb290LmdldEZpbGUoaGFzaCwge30sXG4gICAgICAgICAgICBmdW5jdGlvbiBnb3RGaWxlRW50cnkoZmlsZUVudHJ5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpe1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFsbCA6IGZ1bmN0aW9uIChjYWxsYmFjayl7XG4gICAgICB0aHJvdyBcIkN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXCI7XG4gICAgfSxcblxuICAgIHJlbW92ZSA6IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrKXtcbiAgICAgIGZpbGVuYW1lRm9yS2V5KGtleSwgZnVuY3Rpb24oaGFzaCkge1xuXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0RmlsZVN5c3RlbShMb2NhbEZpbGVTeXN0ZW0uUEVSU0lTVEVOVCwgMCwgZnVuY3Rpb24gZ290RlMoZmlsZVN5c3RlbSkge1xuICAgICAgICAgIGZpbGVTeXN0ZW0ucm9vdC5nZXRGaWxlKGhhc2gsIHt9LCBmdW5jdGlvbiBnb3RGaWxlRW50cnkoZmlsZUVudHJ5KSB7XG5cbiAgICAgICAgICAgIGZpbGVFbnRyeS5yZW1vdmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGZhaWwoJ1tyZW1vdmVdIEZhaWxlZCB0byByZW1vdmUgZmlsZScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmYWlsKCdbcmVtb3ZlXSBGYWlsZWQgdG8gZ2V0RmlsZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmYWlsKCdbcmVtb3ZlXSBGYWlsZWQgdG8gZ2V0IGZpbGVTeXN0ZW0nKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgbnVrZSA6IGZ1bmN0aW9uIChjYWxsYmFjayl7XG4gICAgICB0aHJvdyBcIkN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXCI7XG4gICAgfVxuXG5cbiAgfTtcbn1cblxudmFyIGFkZEFkYXB0ZXIgPSBmdW5jdGlvbihhcHBfcHJvcHMsIGhhc2hGdW5jKXtcbiAgTGF3bmNoYWlyLmFkYXB0ZXIoJ2xvY2FsRmlsZVN0b3JhZ2UnLCBmaWxlU3RvcmFnZUFkYXB0ZXIoYXBwX3Byb3BzLCBoYXNoRnVuYykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkQWRhcHRlcjogYWRkQWRhcHRlclxufSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2spIHtcbiAgdmFyIHNjcmlwdDtcbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gIHNjcmlwdC5hc3luYyA9IFwiYXN5bmNcIjtcbiAgc2NyaXB0LnNyYyA9IHVybDtcbiAgc2NyaXB0LnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xuICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjcmlwdC5yZWFkeVN0YXRlIHx8IC9sb2FkZWR8Y29tcGxldGUvLnRlc3Qoc2NyaXB0LnJlYWR5U3RhdGUpKSB7XG4gICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICBpZiAoaGVhZCAmJiBzY3JpcHQucGFyZW50Tm9kZSkge1xuICAgICAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICB9XG4gICAgICBzY3JpcHQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcbn07XG4iLCJ2YXIgY29uc29sZSA9IHJlcXVpcmUoJ2NvbnNvbGUnKTtcbnZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpO1xuXG5sb2cuc2V0TGV2ZWwoJ2luZm8nKTtcblxuLyoqXG4gKiBBUElzOlxuICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbC5cbiAqIEluIHNob3J0LCB5b3UgY2FuIHVzZTpcbiAqIGxvZy5zZXRMZXZlbChsb2dsZXZlbCkgLSBkZWZhdWx0IHRvIGluZm9cbiAqIGxvZy5lbmFibGVBbGwoKSAtIGVuYWJsZSBhbGwgbG9nIG1lc3NhZ2VzXG4gKiBsb2cuZGlzYWJsZUFsbCgpIC0gZGlzYWJsZSBhbGwgbG9nIG1lc3NhZ2VzXG4gKlxuICogbG9nLnRyYWNlKG1zZylcbiAqIGxvZy5kZWJ1Zyhtc2cpXG4gKiBsb2cuaW5mbyhtc2cpXG4gKiBsb2cud2Fybihtc2cpXG4gKiBsb2cuZXJyb3IobXNnKVxuICpcbiAqIEF2YWlsYWJsZSBsZXZlbHM6IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMywgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fVxuICogVXNlIGVpdGhlciBzdHJpbmcgb3IgaW50ZWdlciB2YWx1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGxvZzsiLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAge1xuICAgIFwiZGVzdGluYXRpb25cIiA6XCJpcGFkXCIsXG4gICAgXCJ0ZXN0XCI6IFtcImlQYWRcIl1cbiAgfSxcbiAge1xuICAgIFwiZGVzdGluYXRpb25cIiA6XCJpcGhvbmVcIixcbiAgICBcInRlc3RcIjogW1wiaVBob25lXCJdXG4gIH0sXG4gIHtcbiAgICBcImRlc3RpbmF0aW9uXCIgOlwiYW5kcm9pZFwiLFxuICAgIFwidGVzdFwiOiBbXCJBbmRyb2lkXCJdXG4gIH0sXG4gIHtcbiAgICBcImRlc3RpbmF0aW9uXCIgOlwiYmxhY2tiZXJyeVwiLFxuICAgIFwidGVzdFwiOiBbXCJCbGFja0JlcnJ5XCIsIFwiQkIxMFwiLCBcIlJJTSBUYWJsZXQgT1NcIl0vL0JsYWNrYmVycnkgMTAgZG9lcyBub3QgY29udGFpbiBcIkJsYWNrYmVycnlcIlxuICB9LFxuICB7XG4gICAgXCJkZXN0aW5hdGlvblwiIDpcIndpbmRvd3NwaG9uZVwiLFxuICAgIFwidGVzdFwiOiBbXCJXaW5kb3dzIFBob25lIDhcIl1cbiAgfSxcbiAge1xuICAgIFwiZGVzdGluYXRpb25cIiA6XCJ3aW5kb3dzcGhvbmU3XCIsXG4gICAgXCJ0ZXN0XCI6IFtcIldpbmRvd3MgUGhvbmUgT1MgN1wiXVxuICB9XG5dO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwpIHtcbiAgdmFyIHFtYXAgPSB7fTtcbiAgdmFyIGkgPSB1cmwuc3BsaXQoXCI/XCIpO1xuICBpZiAoaS5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcXVlcnlTdHJpbmcgPSBpWzFdO1xuICAgIHZhciBwYWlycyA9IHF1ZXJ5U3RyaW5nLnNwbGl0KFwiJlwiKTtcbiAgICBxbWFwID0ge307XG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwYWlycy5sZW5ndGg7IHArKykge1xuICAgICAgdmFyIHEgPSBwYWlyc1twXTtcbiAgICAgIHZhciBxcCA9IHEuc3BsaXQoXCI9XCIpO1xuICAgICAgcW1hcFtxcFswXV0gPSBxcFsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHFtYXA7XG59OyIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlID0gXCJGSF9KU19TREtcIjtcbiAgaWYgKHR5cGVvZiB3aW5kb3cuZmhfZGVzdGluYXRpb25fY29kZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0eXBlID0gXCJGSF9IWUJSSURfU0RLXCI7XG4gIH0gZWxzZSBpZih3aW5kb3cuUGhvbmVHYXAgfHwgd2luZG93LmNvcmRvdmEpIHtcbiAgICB0eXBlID0gXCJGSF9QSE9ORUdBUF9TREtcIjtcbiAgfVxuICByZXR1cm4gdHlwZSArIFwiL1wiICsgY29uc3RhbnRzLnNka192ZXJzaW9uO1xufTtcbiIsInZhciByc2EgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGlicy9yc2FcIik7XG52YXIgU2VjdXJlUmFuZG9tID0gcnNhLlNlY3VyZVJhbmRvbTtcbnZhciBieXRlMkhleCA9IHJzYS5ieXRlMkhleDtcblxudmFyIGdlbmVyYXRlUmFuZG9tS2V5ID0gZnVuY3Rpb24oa2V5c2l6ZSl7XG4gIHZhciByID0gbmV3IFNlY3VyZVJhbmRvbSgpO1xuICB2YXIga2V5ID0gbmV3IEFycmF5KGtleXNpemUpO1xuICByLm5leHRCeXRlcyhrZXkpO1xuICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgZm9yKHZhciBpPTA7aTxrZXkubGVuZ3RoO2krKyl7XG4gICAgcmVzdWx0ICs9IGJ5dGUySGV4KGtleVtpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBhZXNfa2V5Z2VuID0gZnVuY3Rpb24ocCwgcywgZil7XG4gIGlmICghcC5wYXJhbXMua2V5c2l6ZSkge1xuICAgIGYoJ25vX3BhcmFtc19rZXlzaXplJywge30sIHApO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocC5wYXJhbXMuYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkgIT09IFwiYWVzXCIpIHtcbiAgICBmKCdrZXlnZW5fYmFkX2FsZ29yaXRobScsIHt9LCBwKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGtleXNpemUgPSBwYXJzZUludChwLnBhcmFtcy5rZXlzaXplLCAxMCk7XG4gIC8va2V5c2l6ZSBpcyBpbiBiaXQsIG5lZWQgdG8gY29udmVydCB0byBieXRlcyB0byBnZW5lcmF0ZSByYW5kb20ga2V5XG4gIC8vYnV0IHRoZSBsZWdhY3kgY29kZSBoYXMgYSBidWcsIGl0IGRvZXNuJ3QgZG8gdGhlIGNvbnZlcnQsIHNvIGlmIHRoZSBrZXlzaXplIGlzIGxlc3MgdGhhbiAxMDAsIGRvbid0IGNvbnZlcnRcbiAgaWYoa2V5c2l6ZSA+IDEwMCl7XG4gICAga2V5c2l6ZSA9IGtleXNpemUvODtcbiAgfVxuICBpZih0eXBlb2YgU2VjdXJlUmFuZG9tID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICByZXR1cm4gZihcInNlY3VyaXR5IGxpYnJhcnkgaXMgbm90IGxvYWRlZC5cIik7XG4gIH1cbiAgcmV0dXJuIHMoe1xuICAgICdhbGdvcml0aG0nOiAnQUVTJyxcbiAgICAnc2VjcmV0a2V5JzogZ2VuZXJhdGVSYW5kb21LZXkoa2V5c2l6ZSksXG4gICAgJ2l2JzogZ2VuZXJhdGVSYW5kb21LZXkoa2V5c2l6ZSlcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWVzX2tleWdlbjsiLCJ2YXIgQ3J5cHRvSlMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGlicy9nZW5lcmF0ZWQvY3J5cHRvXCIpO1xuXG52YXIgZW5jcnlwdCA9IGZ1bmN0aW9uKHAsIHMsIGYpe1xuICB2YXIgZmllbGRzID0gWydrZXknLCAncGxhaW50ZXh0JywgJ2l2J107XG4gIGlmKHAucGFyYW1zLmFsZ29yaXRobS50b0xvd2VyQ2FzZSgpICE9PSBcImFlc1wiKXtcbiAgICByZXR1cm4gZignZW5jcnlwdF9iYWRfYWxnb3JpdGhtJywge30sIHApO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzOyBpKyspIHtcbiAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgaWYgKCFwLnBhcmFtc1tmaWVsZF0pIHtcbiAgICAgIHJldHVybiBmKCdub19wYXJhbXNfJyArIGZpZWxkLCB7fSwgcCk7XG4gICAgfVxuICB9XG4gIHZhciBlbmNyeXB0ZWQgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdChwLnBhcmFtcy5wbGFpbnRleHQsIENyeXB0b0pTLmVuYy5IZXgucGFyc2UocC5wYXJhbXMua2V5KSwge2l2OiBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKHAucGFyYW1zLml2KX0pO1xuICBjaXBoZXJfdGV4dCA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KGVuY3J5cHRlZC5jaXBoZXJ0ZXh0KTtcbiAgcmV0dXJuIHMoe2NpcGhlcnRleHQ6IGNpcGhlcl90ZXh0fSk7XG59XG5cbnZhciBkZWNyeXB0ID0gZnVuY3Rpb24ocCwgcywgZil7XG4gIHZhciBmaWVsZHMgPSBbJ2tleScsICdjaXBoZXJ0ZXh0JywgJ2l2J107XG4gIGlmKHAucGFyYW1zLmFsZ29yaXRobS50b0xvd2VyQ2FzZSgpICE9PSBcImFlc1wiKXtcbiAgICByZXR1cm4gZignZGVjcnlwdF9iYWRfYWxnb3JpdGhtJywge30sIHApO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzOyBpKyspIHtcbiAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgaWYgKCFwLnBhcmFtc1tmaWVsZF0pIHtcbiAgICAgIHJldHVybiBmKCdub19wYXJhbXNfJyArIGZpZWxkLCB7fSwgcCk7XG4gICAgfVxuICB9XG4gIHZhciBkYXRhID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShwLnBhcmFtcy5jaXBoZXJ0ZXh0KTtcbiAgdmFyIGVuY29kZURhdGEgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeShkYXRhKTtcbiAgdmFyIGRlY3J5cHRlZCA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KGVuY29kZURhdGEsIENyeXB0b0pTLmVuYy5IZXgucGFyc2UocC5wYXJhbXMua2V5KSwge2l2OiBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKHAucGFyYW1zLml2KX0pO1xuICBwbGFpbl90ZXh0ID0gZGVjcnlwdGVkLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcbiAgcmV0dXJuIHMoe3BsYWludGV4dDpwbGFpbl90ZXh0fSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNyeXB0OiBlbmNyeXB0LFxuICBkZWNyeXB0OiBkZWNyeXB0XG59IiwidmFyIENyeXB0b0pTID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYnMvZ2VuZXJhdGVkL2NyeXB0b1wiKTtcblxuXG52YXIgaGFzaCA9IGZ1bmN0aW9uKHAsIHMsIGYpe1xuICBpZiAoIXAucGFyYW1zLnRleHQpIHtcbiAgICBmKCdoYXNoX25vX3RleHQnLCB7fSwgcCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBoYXNoVmFsdWU7XG4gIGlmIChwLnBhcmFtcy5hbGdvcml0aG0udG9Mb3dlckNhc2UoKSA9PT0gXCJtZDVcIikge1xuICAgIGhhc2hWYWx1ZSA9IENyeXB0b0pTLk1ENShwLnBhcmFtcy50ZXh0KS50b1N0cmluZyhDcnlwdG9KUy5lbmMuSGV4KTtcbiAgfSBlbHNlIGlmKHAucGFyYW1zLmFsZ29yaXRobS50b0xvd2VyQ2FzZSgpID09PSBcInNoYTFcIil7XG4gICAgaGFzaFZhbHVlID0gQ3J5cHRvSlMuU0hBMShwLnBhcmFtcy50ZXh0KS50b1N0cmluZyhDcnlwdG9KUy5lbmMuSGV4KTtcbiAgfSBlbHNlIGlmKHAucGFyYW1zLmFsZ29yaXRobS50b0xvd2VyQ2FzZSgpID09PSBcInNoYTI1NlwiKXtcbiAgICBoYXNoVmFsdWUgPSBDcnlwdG9KUy5TSEEyNTYocC5wYXJhbXMudGV4dCkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLkhleCk7XG4gIH0gZWxzZSBpZihwLnBhcmFtcy5hbGdvcml0aG0udG9Mb3dlckNhc2UoKSA9PT0gXCJzaGE1MTJcIil7XG4gICAgaGFzaFZhbHVlID0gQ3J5cHRvSlMuU0hBNTEyKHAucGFyYW1zLnRleHQpLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5IZXgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmKFwiaGFzaF91bnN1cHBvcnRlZF9hbGdvcml0aG06IFwiICsgcC5wYXJhbXMuYWxnb3JpdGhtKTtcbiAgfVxuICByZXR1cm4gcyh7XCJoYXNodmFsdWVcIjogaGFzaFZhbHVlfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaDsiLCJ2YXIgcnNhID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYnMvcnNhXCIpO1xudmFyIFJTQUtleSA9IHJzYS5SU0FLZXk7XG5cbnZhciBlbmNyeXB0ID0gZnVuY3Rpb24ocCwgcywgZil7XG4gIHZhciBmaWVsZHMgPSBbJ21vZHVsdScsICdwbGFpbnRleHQnXTtcbiAgaWYocC5wYXJhbXMuYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkgIT09IFwicnNhXCIpe1xuICAgIHJldHVybiBmKCdlbmNyeXB0X2JhZF9hbGdvcml0aG0nLCB7fSwgcCk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHM7IGkrKykge1xuICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICBpZiAoIXAucGFyYW1zW2ZpZWxkXSkge1xuICAgICAgcmV0dXJuIGYoJ25vX3BhcmFtc18nICsgZmllbGQsIHt9LCBwKTtcbiAgICB9XG4gIH1cbiAgdmFyIGtleSA9IG5ldyBSU0FLZXkoKTtcbiAga2V5LnNldFB1YmxpYyhwLnBhcmFtcy5tb2R1bHUsIFwiMTAwMDFcIik7XG4gIHZhciBvcmlfdGV4dCA9IHAucGFyYW1zLnBsYWludGV4dDtcbiAgY2lwaGVyX3RleHQgPSBrZXkuZW5jcnlwdChvcmlfdGV4dCk7XG4gIHJldHVybiBzKHtjaXBoZXJ0ZXh0OmNpcGhlcl90ZXh0fSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNyeXB0OiBlbmNyeXB0XG59IiwidmFyIEpTT04gPSByZXF1aXJlKFwiSlNPTlwiKTtcbnZhciBhY3RBUEkgPSByZXF1aXJlKFwiLi9hcGlfYWN0XCIpO1xudmFyIGNsb3VkQVBJID0gcmVxdWlyZShcIi4vYXBpX2Nsb3VkXCIpO1xudmFyIENyeXB0b0pTID0gcmVxdWlyZShcIi4uLy4uL2xpYnMvZ2VuZXJhdGVkL2NyeXB0b1wiKTtcbnZhciBMYXduY2hhaXIgPSByZXF1aXJlKCcuLi8uLi9saWJzL2dlbmVyYXRlZC9sYXduY2hhaXInKTtcblxudmFyIHNlbGYgPSB7XG5cbiAgLy8gQ09ORklHXG4gIGRlZmF1bHRzOiB7XG4gICAgXCJzeW5jX2ZyZXF1ZW5jeVwiOiAxMCxcbiAgICAvLyBIb3cgb2Z0ZW4gdG8gc3luY2hyb25pc2UgZGF0YSB3aXRoIHRoZSBjbG91ZCBpbiBzZWNvbmRzLlxuICAgIFwiYXV0b19zeW5jX2xvY2FsX3VwZGF0ZXNcIjogdHJ1ZSxcbiAgICAvLyBTaG91bGQgbG9jYWwgY2hhZ2VzIGJlIHN5bmVkIHRvIHRoZSBjbG91ZCBpbW1lZGlhdGVseSwgb3Igc2hvdWxkIHRoZXkgd2FpdCBmb3IgdGhlIG5leHQgc3luYyBpbnRlcnZhbFxuICAgIFwibm90aWZ5X2NsaWVudF9zdG9yYWdlX2ZhaWxlZFwiOiB0cnVlLFxuICAgIC8vIFNob3VsZCBhIG5vdGlmaWNhdGlvbiBldmVudCBiZSB0cmlnZ2VyZWQgd2hlbiBsb2FkaW5nL3NhdmluZyB0byBjbGllbnQgc3RvcmFnZSBmYWlsc1xuICAgIFwibm90aWZ5X3N5bmNfc3RhcnRlZFwiOiB0cnVlLFxuICAgIC8vIFNob3VsZCBhIG5vdGlmaWNhdGlvbiBldmVudCBiZSB0cmlnZ2VyZWQgd2hlbiBhIHN5bmMgY3ljbGUgd2l0aCB0aGUgc2VydmVyIGhhcyBiZWVuIHN0YXJ0ZWRcbiAgICBcIm5vdGlmeV9zeW5jX2NvbXBsZXRlXCI6IHRydWUsXG4gICAgLy8gU2hvdWxkIGEgbm90aWZpY2F0aW9uIGV2ZW50IGJlIHRyaWdnZXJlZCB3aGVuIGEgc3luYyBjeWNsZSB3aXRoIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gY29tcGxldGVkXG4gICAgXCJub3RpZnlfb2ZmbGluZV91cGRhdGVcIjogdHJ1ZSxcbiAgICAvLyBTaG91bGQgYSBub3RpZmljYXRpb24gZXZlbnQgYmUgdHJpZ2dlcmVkIHdoZW4gYW4gYXR0ZW1wdCB3YXMgbWFkZSB0byB1cGRhdGUgYSByZWNvcmQgd2hpbGUgb2ZmbGluZVxuICAgIFwibm90aWZ5X2NvbGxpc2lvbl9kZXRlY3RlZFwiOiB0cnVlLFxuICAgIC8vIFNob3VsZCBhIG5vdGlmaWNhdGlvbiBldmVudCBiZSB0cmlnZ2VyZWQgd2hlbiBhbiB1cGRhdGUgZmFpbGVkIGR1ZSB0byBkYXRhIGNvbGxpc2lvblxuICAgIFwibm90aWZ5X3JlbW90ZV91cGRhdGVfZmFpbGVkXCI6IHRydWUsXG4gICAgLy8gU2hvdWxkIGEgbm90aWZpY2F0aW9uIGV2ZW50IGJlIHRyaWdnZXJlZCB3aGVuIGFuIHVwZGF0ZSBmYWlsZWQgZm9yIGEgcmVhc29uIG90aGVyIHRoYW4gZGF0YSBjb2xsaXNpb25cbiAgICBcIm5vdGlmeV9sb2NhbF91cGRhdGVfYXBwbGllZFwiOiB0cnVlLFxuICAgIC8vIFNob3VsZCBhIG5vdGlmaWNhdGlvbiBldmVudCBiZSB0cmlnZ2VyZWQgd2hlbiBhbiB1cGRhdGUgd2FzIGFwcGxpZWQgdG8gdGhlIGxvY2FsIGRhdGEgc3RvcmVcbiAgICBcIm5vdGlmeV9yZW1vdGVfdXBkYXRlX2FwcGxpZWRcIjogdHJ1ZSxcbiAgICAvLyBTaG91bGQgYSBub3RpZmljYXRpb24gZXZlbnQgYmUgdHJpZ2dlcmVkIHdoZW4gYW4gdXBkYXRlIHdhcyBhcHBsaWVkIHRvIHRoZSByZW1vdGUgZGF0YSBzdG9yZVxuICAgIFwibm90aWZ5X2RlbHRhX3JlY2VpdmVkXCI6IHRydWUsXG4gICAgLy8gU2hvdWxkIGEgbm90aWZpY2F0aW9uIGV2ZW50IGJlIHRyaWdnZXJlZCB3aGVuIGEgZGVsdGEgd2FzIHJlY2VpdmVkIGZyb20gdGhlIHJlbW90ZSBkYXRhIHN0b3JlIGZvciB0aGUgZGF0YXNldCBcbiAgICBcIm5vdGlmeV9yZWNvcmRfZGVsdGFfcmVjZWl2ZWRcIjogdHJ1ZSxcbiAgICAvLyBTaG91bGQgYSBub3RpZmljYXRpb24gZXZlbnQgYmUgdHJpZ2dlcmVkIHdoZW4gYSBkZWx0YSB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgcmVtb3RlIGRhdGEgc3RvcmUgZm9yIGEgcmVjb3JkXG4gICAgXCJub3RpZnlfc3luY19mYWlsZWRcIjogdHJ1ZSxcbiAgICAvLyBTaG91bGQgYSBub3RpZmljYXRpb24gZXZlbnQgYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIHN5bmMgbG9vcCBmYWlsZWQgdG8gY29tcGxldGVcbiAgICBcImRvX2NvbnNvbGVfbG9nXCI6IGZhbHNlLFxuICAgIC8vIFNob3VsZCBsb2cgc3RhdGVtZW50cyBiZSB3cml0dGVuIHRvIGNvbnNvbGUubG9nXG4gICAgXCJjcmFzaGVkX2NvdW50X3dhaXRcIiA6IDEwLFxuICAgIC8vIEhvdyBtYW55IHN5bmNzIHNob3VsZCB3ZSBjaGVjayBmb3IgdXBkYXRlcyBvbiBjcmFzaGVkIGluIGZsaWdodCB1cGRhdGVzIGJlZm9yZSB3ZSBnaXZlIHVwIHNlYXJjaGluZ1xuICAgIFwicmVzZW5kX2NyYXNoZWRfdXBkYXRlc1wiIDogdHJ1ZSxcbiAgICAvLyBJZiB3ZSBoYXZlIHJlYWNoZWQgdGhlIGNyYXNoZWRfY291bnRfd2FpdCBsaW1pdCwgc2hvdWxkIHdlIHJlLXRyeSBzZW5kaW5nIHRoZSBjcmFzaGVkIGluIGZsaWdodCBwZW5kaW5nIHJlY29yZFxuICAgIFwic3luY19hY3RpdmVcIiA6IHRydWUsXG4gICAgLy8gSXMgdGhlIGJhY2tncm91bmQgc3luYyB3aXRoIHRoZSBjbG91ZCBjdXJyZW50bHkgYWN0aXZlXG4gICAgXCJzdG9yYWdlX3N0cmF0ZWd5XCIgOiBcImh0bWw1LWZpbGVzeXN0ZW1cIixcbiAgICAvLyBTdG9yYWdlIHN0cmF0ZWd5IHRvIHVzZSBmb3IgTGF3bmNoYWlyIC0gc3VwcG9ydGVkIHN0cmF0ZWdpZXMgYXJlICdodG1sNS1maWxlc3lzdGVtJyBhbmQgJ2RvbSdcbiAgICBcImZpbGVfc3lzdGVtX3F1b3RhXCIgOiA1MCAqIDEwMjQgKiAxMjA0XG4gICAgLy8gQW1vdW50IG9mIHNwYWNlIHRvIHJlcXVlc3QgZnJvbSB0aGUgSFRNTDUgZmlsZXN5c3RlbSBBUEkgd2hlbiBydW5uaW5nIGluIGJyb3dzZXJcbiAgfSxcblxuICBub3RpZmljYXRpb25zOiB7XG4gICAgXCJDTElFTlRfU1RPUkFHRV9GQUlMRURcIjogXCJjbGllbnRfc3RvcmFnZV9mYWlsZWRcIixcbiAgICAvLyBsb2FkaW5nL3NhdmluZyB0byBjbGllbnQgc3RvcmFnZSBmYWlsZWRcbiAgICBcIlNZTkNfU1RBUlRFRFwiOiBcInN5bmNfc3RhcnRlZFwiLFxuICAgIC8vIEEgc3luYyBjeWNsZSB3aXRoIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gc3RhcnRlZFxuICAgIFwiU1lOQ19DT01QTEVURVwiOiBcInN5bmNfY29tcGxldGVcIixcbiAgICAvLyBBIHN5bmMgY3ljbGUgd2l0aCB0aGUgc2VydmVyIGhhcyBiZWVuIGNvbXBsZXRlZFxuICAgIFwiT0ZGTElORV9VUERBVEVcIjogXCJvZmZsaW5lX3VwZGF0ZVwiLFxuICAgIC8vIEFuIGF0dGVtcHQgd2FzIG1hZGUgdG8gdXBkYXRlIGEgcmVjb3JkIHdoaWxlIG9mZmxpbmVcbiAgICBcIkNPTExJU0lPTl9ERVRFQ1RFRFwiOiBcImNvbGxpc2lvbl9kZXRlY3RlZFwiLFxuICAgIC8vVXBkYXRlIEZhaWxlZCBkdWUgdG8gZGF0YSBjb2xsaXNpb25cbiAgICBcIlJFTU9URV9VUERBVEVfRkFJTEVEXCI6IFwicmVtb3RlX3VwZGF0ZV9mYWlsZWRcIixcbiAgICAvLyBVcGRhdGUgRmFpbGVkIGZvciBhIHJlYXNvbiBvdGhlciB0aGFuIGRhdGEgY29sbGlzaW9uXG4gICAgXCJSRU1PVEVfVVBEQVRFX0FQUExJRURcIjogXCJyZW1vdGVfdXBkYXRlX2FwcGxpZWRcIixcbiAgICAvLyBBbiB1cGRhdGUgd2FzIGFwcGxpZWQgdG8gdGhlIHJlbW90ZSBkYXRhIHN0b3JlXG4gICAgXCJMT0NBTF9VUERBVEVfQVBQTElFRFwiOiBcImxvY2FsX3VwZGF0ZV9hcHBsaWVkXCIsXG4gICAgLy8gQW4gdXBkYXRlIHdhcyBhcHBsaWVkIHRvIHRoZSBsb2NhbCBkYXRhIHN0b3JlXG4gICAgXCJERUxUQV9SRUNFSVZFRFwiOiBcImRlbHRhX3JlY2VpdmVkXCIsXG4gICAgLy8gQSBkZWx0YSB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgcmVtb3RlIGRhdGEgc3RvcmUgZm9yIHRoZSBkYXRhc2V0IFxuICAgIFwiUkVDT1JEX0RFTFRBX1JFQ0VJVkVEXCI6IFwicmVjb3JkX2RlbHRhX3JlY2VpdmVkXCIsXG4gICAgLy8gQSBkZWx0YSB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgcmVtb3RlIGRhdGEgc3RvcmUgZm9yIHRoZSByZWNvcmQgXG4gICAgXCJTWU5DX0ZBSUxFRFwiOiBcInN5bmNfZmFpbGVkXCJcbiAgICAvLyBTeW5jIGxvb3AgZmFpbGVkIHRvIGNvbXBsZXRlXG4gIH0sXG5cbiAgZGF0YXNldHM6IHt9LFxuXG4gIC8vIEluaXRpYWxpc2UgY29uZmlnIHRvIGRlZmF1bHQgdmFsdWVzO1xuICBjb25maWc6IHVuZGVmaW5lZCxcblxuICBub3RpZnlfY2FsbGJhY2s6IHVuZGVmaW5lZCxcblxuICBoYXNDdXN0b21TeW5jIDogdW5kZWZpbmVkLFxuXG4gIC8vIFBVQkxJQyBGVU5DVElPTiBJTVBMRU1FTlRBVElPTlNcbiAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHNlbGYuY29uc29sZUxvZygnc3luYyAtIGluaXQgY2FsbGVkJyk7XG5cbiAgICBzZWxmLmNvbmZpZyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2VsZi5kZWZhdWx0cykpO1xuICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgICAgc2VsZi5jb25maWdbaV0gPSBvcHRpb25zW2ldO1xuICAgIH1cblxuICAgIHNlbGYuZGF0YXNldE1vbml0b3IoKTtcbiAgfSxcblxuICBub3RpZnk6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgc2VsZi5ub3RpZnlfY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfSxcblxuICBtYW5hZ2U6IGZ1bmN0aW9uKGRhdGFzZXRfaWQsIG9wdGlvbnMsIHF1ZXJ5X3BhcmFtcywgbWV0YV9kYXRhLCBjYikge1xuICAgIHNlbGYuY29uc29sZUxvZygnbWFuYWdlIC0gU1RBUlQnKTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBkb01hbmFnZSA9IGZ1bmN0aW9uKGRhdGFzZXQpIHtcbiAgICAgIHNlbGYuY29uc29sZUxvZygnZG9NYW5hZ2UgZGF0YXNldCA6OiBpbml0aWFsaXNlZCA9ICcgKyBkYXRhc2V0LmluaXRpYWxpc2VkICsgXCIgOjogXCIgKyBkYXRhc2V0X2lkICsgJyA6OiAnICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucykpO1xuXG4gICAgICB2YXIgZGF0YXNldENvbmZpZyA9IHNlbGYuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgZGF0YXNldC5xdWVyeV9wYXJhbXMgPSBxdWVyeV9wYXJhbXMgfHwgZGF0YXNldC5xdWVyeV9wYXJhbXMgfHwge307XG4gICAgICBkYXRhc2V0Lm1ldGFfZGF0YSA9IG1ldGFfZGF0YSB8fCBkYXRhc2V0Lm1ldGFfZGF0YSB8fCB7fTtcbiAgICAgIGRhdGFzZXQuY29uZmlnID0gZGF0YXNldENvbmZpZztcbiAgICAgIGRhdGFzZXQuc3luY1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgIGRhdGFzZXQuc3luY1BlbmRpbmcgPSB0cnVlO1xuICAgICAgZGF0YXNldC5pbml0aWFsaXNlZCA9IHRydWU7XG4gICAgICBkYXRhc2V0Lm1ldGEgPSB7fTtcblxuICAgICAgc2VsZi5zYXZlRGF0YVNldChkYXRhc2V0X2lkLCBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiggY2IgKSB7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBkYXRhc2V0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgc2VsZi5nZXREYXRhU2V0KGRhdGFzZXRfaWQsIGZ1bmN0aW9uKGRhdGFzZXQpIHtcbiAgICAgIHNlbGYuY29uc29sZUxvZygnbWFuYWdlIC0gZGF0YXNldCBhbHJlYWR5IGxvYWRlZCcpO1xuICAgICAgZG9NYW5hZ2UoZGF0YXNldCk7XG4gICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBzZWxmLmNvbnNvbGVMb2coJ21hbmFnZSAtIGRhdGFzZXQgbm90IGxvYWRlZC4uLiB0cnlpbmcgdG8gbG9hZCcpO1xuXG4gICAgICAvLyBOb3QgYWxyZWFkeSBsb2FkZWQsIHRyeSB0byBsb2FkIGZyb20gbG9jYWwgc3RvcmFnZVxuICAgICAgc2VsZi5sb2FkRGF0YVNldChkYXRhc2V0X2lkLCBmdW5jdGlvbihkYXRhc2V0KSB7XG4gICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCdtYW5hZ2UgLSBkYXRhc2V0IGxvYWRlZCBmcm9tIGxvY2FsIHN0b3JhZ2UnKTtcblxuICAgICAgICAgIC8vIExvYWRpbmcgZnJvbSBsb2NhbCBzdG9yYWdlIHdvcmtlZFxuXG4gICAgICAgICAgLy8gRmlyZSB0aGUgbG9jYWwgdXBkYXRlIGV2ZW50IHRvIGluZGljYXRlIHRoYXQgZGF0YXNldCB3YXMgbG9hZGVkIGZyb20gbG9jYWwgc3RvcmFnZVxuICAgICAgICAgIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgbnVsbCwgc2VsZi5ub3RpZmljYXRpb25zLkxPQ0FMX1VQREFURV9BUFBMSUVELCBcImxvYWRcIik7XG5cbiAgICAgICAgICAvLyBQdXQgdGhlIGRhdGFldCB1bmRlciB0aGUgbWFuYWdlbWVudCBvZiB0aGUgc3luYyBzZXJ2aWNlXG4gICAgICAgICAgZG9NYW5hZ2UoZGF0YXNldCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIC8vIE5vIGRhdGFzZXQgaW4gbWVtb3J5IG9yIGxvY2FsIHN0b3JhZ2UgLSBjcmVhdGUgYSBuZXcgb25lIGFuZCBwdXQgaXQgaW4gbWVtb3J5XG4gICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCdtYW5hZ2UgLSBDcmVhdGluZyBuZXcgZGF0YXNldCBmb3IgaWQgJyArIGRhdGFzZXRfaWQpO1xuICAgICAgICAgIHZhciBkYXRhc2V0ID0ge307XG4gICAgICAgICAgZGF0YXNldC5kYXRhID0ge307XG4gICAgICAgICAgZGF0YXNldC5wZW5kaW5nID0ge307XG4gICAgICAgICAgc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXSA9IGRhdGFzZXQ7XG4gICAgICAgICAgZG9NYW5hZ2UoZGF0YXNldCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAvLyBNYWtlIHN1cmUgY29uZmlnIGlzIGluaXRpYWxpc2VkXG4gICAgaWYoICEgc2VsZi5jb25maWcgKSB7XG4gICAgICBzZWxmLmNvbmZpZyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2VsZi5kZWZhdWx0cykpO1xuICAgIH1cblxuICAgIHZhciBkYXRhc2V0Q29uZmlnID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzZWxmLmNvbmZpZykpO1xuICAgIHZhciBvcHRpb25zSW4gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKTtcbiAgICBmb3IgKHZhciBrIGluIG9wdGlvbnNJbikge1xuICAgICAgZGF0YXNldENvbmZpZ1trXSA9IG9wdGlvbnNJbltrXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YXNldENvbmZpZztcbiAgfSxcblxuICBsaXN0OiBmdW5jdGlvbihkYXRhc2V0X2lkLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgc2VsZi5nZXREYXRhU2V0KGRhdGFzZXRfaWQsIGZ1bmN0aW9uKGRhdGFzZXQpIHtcbiAgICAgIGlmIChkYXRhc2V0ICYmIGRhdGFzZXQuZGF0YSkge1xuICAgICAgICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBkYXRhc2V0IHNvIHVwZGF0ZXMgd2lsbCBub3QgYXV0b21hdGljYWxseSBtYWtlIGl0IGJhY2sgaW50byB0aGUgZGF0YXNldFxuICAgICAgICB2YXIgcmVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhc2V0LmRhdGEpKTtcbiAgICAgICAgc3VjY2VzcyhyZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoZmFpbHVyZSkgZmFpbHVyZSgnbm9fZGF0YScpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uKGNvZGUsIG1zZykge1xuICAgICAgaWYoZmFpbHVyZSkgZmFpbHVyZShjb2RlLCBtc2cpO1xuICAgIH0pO1xuICB9LFxuXG4gIGNyZWF0ZTogZnVuY3Rpb24oZGF0YXNldF9pZCwgZGF0YSwgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgIHNlbGYuYWRkUGVuZGluZ09iaihkYXRhc2V0X2lkLCBudWxsLCBkYXRhLCBcImNyZWF0ZVwiLCBzdWNjZXNzLCBmYWlsdXJlKTtcbiAgfSxcblxuICByZWFkOiBmdW5jdGlvbihkYXRhc2V0X2lkLCB1aWQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICAgIHNlbGYuZ2V0RGF0YVNldChkYXRhc2V0X2lkLCBmdW5jdGlvbihkYXRhc2V0KSB7XG4gICAgICB2YXIgcmVjID0gZGF0YXNldC5kYXRhW3VpZF07XG4gICAgICBpZiAoIXJlYykge1xuICAgICAgICBmYWlsdXJlKFwidW5rbm93bl91aWRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSByZWNvcmQgc28gdXBkYXRlcyB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IG1ha2UgaXQgYmFjayBpbnRvIHRoZSBkYXRhc2V0XG4gICAgICAgIHZhciByZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlYykpO1xuICAgICAgICBzdWNjZXNzKHJlcyk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24oY29kZSwgbXNnKSB7XG4gICAgICBpZihmYWlsdXJlKSBmYWlsdXJlKGNvZGUsIG1zZyk7XG4gICAgfSk7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbihkYXRhc2V0X2lkLCB1aWQsIGRhdGEsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICBzZWxmLmFkZFBlbmRpbmdPYmooZGF0YXNldF9pZCwgdWlkLCBkYXRhLCBcInVwZGF0ZVwiLCBzdWNjZXNzLCBmYWlsdXJlKTtcbiAgfSxcblxuICAnZGVsZXRlJzogZnVuY3Rpb24oZGF0YXNldF9pZCwgdWlkLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgc2VsZi5hZGRQZW5kaW5nT2JqKGRhdGFzZXRfaWQsIHVpZCwgbnVsbCwgXCJkZWxldGVcIiwgc3VjY2VzcywgZmFpbHVyZSk7XG4gIH0sXG5cbiAgZ2V0UGVuZGluZzogZnVuY3Rpb24oZGF0YXNldF9pZCwgY2IpIHtcbiAgICBzZWxmLmdldERhdGFTZXQoZGF0YXNldF9pZCwgZnVuY3Rpb24oZGF0YXNldCkge1xuICAgICAgdmFyIHJlcztcbiAgICAgIGlmKCBkYXRhc2V0ICkge1xuICAgICAgICByZXMgPSBkYXRhc2V0LnBlbmRpbmc7XG4gICAgICB9XG4gICAgICBjYihyZXMpO1xuICAgIH0sIGZ1bmN0aW9uKGVyciwgZGF0YXRzZXRfaWQpIHtcbiAgICAgICAgc2VsZi5jb25zb2xlTG9nKGVycik7XG4gICAgfSk7XG4gIH0sXG5cbiAgY2xlYXJQZW5kaW5nOiBmdW5jdGlvbihkYXRhc2V0X2lkLCBjYikge1xuICAgIHNlbGYuZ2V0RGF0YVNldChkYXRhc2V0X2lkLCBmdW5jdGlvbihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnBlbmRpbmcgPSB7fTtcbiAgICAgIHNlbGYuc2F2ZURhdGFTZXQoZGF0YXNldF9pZCwgY2IpO1xuICAgIH0pO1xuICB9LFxuXG4gIGxpc3RDb2xsaXNpb25zIDogZnVuY3Rpb24oZGF0YXNldF9pZCwgc3VjY2VzcywgZmFpbHVyZSl7XG4gICAgc2VsZi5nZXREYXRhU2V0KGRhdGFzZXRfaWQsIGZ1bmN0aW9uKGRhdGFzZXQpIHtcbiAgICAgIHNlbGYuZG9DbG91ZENhbGwoe1xuICAgICAgICBcImRhdGFzZXRfaWRcIjogZGF0YXNldF9pZCxcbiAgICAgICAgXCJyZXFcIjoge1xuICAgICAgICAgIFwiZm5cIjogXCJsaXN0Q29sbGlzaW9uc1wiLFxuICAgICAgICAgIFwibWV0YV9kYXRhXCIgOiBkYXRhc2V0Lm1ldGFfZGF0YVxuICAgICAgICB9XG4gICAgICB9LCBzdWNjZXNzLCBmYWlsdXJlKTtcbiAgICB9LCBmYWlsdXJlKTtcbiAgfSxcblxuICByZW1vdmVDb2xsaXNpb246IGZ1bmN0aW9uKGRhdGFzZXRfaWQsIGNvbGlzc2lvbkhhc2gsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICBzZWxmLmdldERhdGFTZXQoZGF0YXNldF9pZCwgZnVuY3Rpb24oZGF0YXNldCkge1xuICAgICAgc2VsZi5kb0Nsb3VkQ2FsbCh7XG4gICAgICAgIFwiZGF0YXNldF9pZFwiIDogZGF0YXNldF9pZCxcbiAgICAgICAgXCJyZXFcIjoge1xuICAgICAgICAgIFwiZm5cIjogXCJyZW1vdmVDb2xsaXNpb25cIixcbiAgICAgICAgICBcImhhc2hcIjogY29saXNzaW9uSGFzaCxcbiAgICAgICAgICBtZXRhX2RhdGE6IGRhdGFzZXQubWV0YV9kYXRhXG4gICAgICAgIH1cbiAgICAgIH0sIHN1Y2Nlc3MsIGZhaWx1cmUpO1xuICAgIH0pO1xuICB9LFxuXG5cbiAgLy8gUFJJVkFURSBGVU5DVElPTlNcbiAgaXNPbmxpbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIG9ubGluZSA9IHRydWU7XG5cbiAgICAvLyBmaXJzdCwgY2hlY2sgaWYgbmF2aWdhdG9yLm9ubGluZSBpcyBhdmFpbGFibGVcbiAgICBpZih0eXBlb2YgbmF2aWdhdG9yLm9uTGluZSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICBvbmxpbmUgPSBuYXZpZ2F0b3Iub25MaW5lO1xuICAgIH1cblxuICAgIC8vIHNlY29uZCwgY2hlY2sgaWYgUGhvbmVnYXAgaXMgYXZhaWxhYmxlIGFuZCBoYXMgb25saW5lIGluZm9cbiAgICBpZihvbmxpbmUpe1xuICAgICAgLy91c2UgcGhvbmVnYXAgdG8gZGV0ZXJtaW4gaWYgdGhlIG5ldHdvcmsgaXMgYXZhaWxhYmxlXG4gICAgICBpZih0eXBlb2YgbmF2aWdhdG9yLm5ldHdvcmsgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG5hdmlnYXRvci5uZXR3b3JrLmNvbm5lY3Rpb24gIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICB2YXIgbmV0d29ya1R5cGUgPSBuYXZpZ2F0b3IubmV0d29yay5jb25uZWN0aW9uLnR5cGU7XG4gICAgICAgIGlmKG5ldHdvcmtUeXBlID09PSBcIm5vbmVcIiB8fCBuZXR3b3JrVHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG9ubGluZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGxiYWNrKG9ubGluZSk7XG4gIH0sXG5cbiAgZG9Ob3RpZnk6IGZ1bmN0aW9uKGRhdGFzZXRfaWQsIHVpZCwgY29kZSwgbWVzc2FnZSkge1xuXG4gICAgaWYoIHNlbGYubm90aWZ5X2NhbGxiYWNrICkge1xuICAgICAgaWYgKCBzZWxmLmNvbmZpZ1snbm90aWZ5XycgKyBjb2RlXSApIHtcbiAgICAgICAgdmFyIG5vdGlmaWNhdGlvbiA9IHtcbiAgICAgICAgICBcImRhdGFzZXRfaWRcIiA6IGRhdGFzZXRfaWQsXG4gICAgICAgICAgXCJ1aWRcIiA6IHVpZCxcbiAgICAgICAgICBcImNvZGVcIiA6IGNvZGUsXG4gICAgICAgICAgXCJtZXNzYWdlXCIgOiBtZXNzYWdlXG4gICAgICAgIH07XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB1c2VyIGRvZXNuJ3QgYmxvY2tcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5ub3RpZnlfY2FsbGJhY2sobm90aWZpY2F0aW9uKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldERhdGFTZXQ6IGZ1bmN0aW9uKGRhdGFzZXRfaWQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICB2YXIgZGF0YXNldCA9IHNlbGYuZGF0YXNldHNbZGF0YXNldF9pZF07XG5cbiAgICBpZiAoZGF0YXNldCkge1xuICAgICAgc3VjY2VzcyhkYXRhc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmFpbHVyZSgndW5rbm93bl9kYXRhc2V0ICcgKyBkYXRhc2V0X2lkLCBkYXRhc2V0X2lkKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0UXVlcnlQYXJhbXM6IGZ1bmN0aW9uKGRhdGFzZXRfaWQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICB2YXIgZGF0YXNldCA9IHNlbGYuZGF0YXNldHNbZGF0YXNldF9pZF07XG5cbiAgICBpZiAoZGF0YXNldCkge1xuICAgICAgc3VjY2VzcyhkYXRhc2V0LnF1ZXJ5X3BhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhaWx1cmUoJ3Vua25vd25fZGF0YXNldCAnICsgZGF0YXNldF9pZCwgZGF0YXNldF9pZCk7XG4gICAgfVxuICB9LFxuXG4gIHNldFF1ZXJ5UGFyYW1zOiBmdW5jdGlvbihkYXRhc2V0X2lkLCBxdWVyeVBhcmFtcywgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgIHZhciBkYXRhc2V0ID0gc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXTtcblxuICAgIGlmIChkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnF1ZXJ5X3BhcmFtcyA9IHF1ZXJ5UGFyYW1zO1xuICAgICAgc2VsZi5zYXZlRGF0YVNldChkYXRhc2V0X2lkKTtcbiAgICAgIGlmKCBzdWNjZXNzICkge1xuICAgICAgICBzdWNjZXNzKGRhdGFzZXQucXVlcnlfcGFyYW1zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCBmYWlsdXJlICkge1xuICAgICAgICBmYWlsdXJlKCd1bmtub3duX2RhdGFzZXQgJyArIGRhdGFzZXRfaWQsIGRhdGFzZXRfaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBnZXRNZXRhRGF0YTogZnVuY3Rpb24oZGF0YXNldF9pZCwgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgIHZhciBkYXRhc2V0ID0gc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXTtcblxuICAgIGlmIChkYXRhc2V0KSB7XG4gICAgICBzdWNjZXNzKGRhdGFzZXQubWV0YV9kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmFpbHVyZSgndW5rbm93bl9kYXRhc2V0ICcgKyBkYXRhc2V0X2lkLCBkYXRhc2V0X2lkKTtcbiAgICB9XG4gIH0sXG5cbiAgc2V0TWV0YURhdGE6IGZ1bmN0aW9uKGRhdGFzZXRfaWQsIG1ldGFEYXRhLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgdmFyIGRhdGFzZXQgPSBzZWxmLmRhdGFzZXRzW2RhdGFzZXRfaWRdO1xuXG4gICAgaWYgKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQubWV0YV9kYXRhID0gbWV0YURhdGE7XG4gICAgICBzZWxmLnNhdmVEYXRhU2V0KGRhdGFzZXRfaWQpO1xuICAgICAgaWYoIHN1Y2Nlc3MgKSB7XG4gICAgICAgIHN1Y2Nlc3MoZGF0YXNldC5tZXRhX2RhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiggZmFpbHVyZSApIHtcbiAgICAgICAgZmFpbHVyZSgndW5rbm93bl9kYXRhc2V0ICcgKyBkYXRhc2V0X2lkLCBkYXRhc2V0X2lkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZ2V0Q29uZmlnOiBmdW5jdGlvbihkYXRhc2V0X2lkLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgdmFyIGRhdGFzZXQgPSBzZWxmLmRhdGFzZXRzW2RhdGFzZXRfaWRdO1xuXG4gICAgaWYgKGRhdGFzZXQpIHtcbiAgICAgIHN1Y2Nlc3MoZGF0YXNldC5jb25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmYWlsdXJlKCd1bmtub3duX2RhdGFzZXQgJyArIGRhdGFzZXRfaWQsIGRhdGFzZXRfaWQpO1xuICAgIH1cbiAgfSxcblxuICBzZXRDb25maWc6IGZ1bmN0aW9uKGRhdGFzZXRfaWQsIGNvbmZpZywgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgIHZhciBkYXRhc2V0ID0gc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXTtcblxuICAgIGlmIChkYXRhc2V0KSB7XG4gICAgICB2YXIgZnVsbENvbmZpZyA9IHNlbGYuc2V0T3B0aW9ucyhjb25maWcpO1xuICAgICAgZGF0YXNldC5jb25maWcgPSBmdWxsQ29uZmlnO1xuICAgICAgc2VsZi5zYXZlRGF0YVNldChkYXRhc2V0X2lkKTtcbiAgICAgIGlmKCBzdWNjZXNzICkge1xuICAgICAgICBzdWNjZXNzKGRhdGFzZXQuY29uZmlnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoIGZhaWx1cmUgKSB7XG4gICAgICAgIGZhaWx1cmUoJ3Vua25vd25fZGF0YXNldCAnICsgZGF0YXNldF9pZCwgZGF0YXNldF9pZCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHN0b3BTeW5jOiBmdW5jdGlvbihkYXRhc2V0X2lkLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgc2VsZi5zZXRDb25maWcoZGF0YXNldF9pZCwge1wic3luY19hY3RpdmVcIiA6IGZhbHNlfSwgZnVuY3Rpb24oKSB7XG4gICAgICBpZiggc3VjY2VzcyApIHtcbiAgICAgICAgc3VjY2VzcygpO1xuICAgICAgfVxuICAgIH0sIGZhaWx1cmUpO1xuICB9LFxuXG4gIHN0YXJ0U3luYzogZnVuY3Rpb24oZGF0YXNldF9pZCwgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgIHNlbGYuc2V0Q29uZmlnKGRhdGFzZXRfaWQsIHtcInN5bmNfYWN0aXZlXCIgOiB0cnVlfSwgZnVuY3Rpb24oKSB7XG4gICAgICBpZiggc3VjY2VzcyApIHtcbiAgICAgICAgc3VjY2VzcygpO1xuICAgICAgfVxuICAgIH0sIGZhaWx1cmUpO1xuICB9LFxuXG4gIGRvU3luYzogZnVuY3Rpb24oZGF0YXNldF9pZCwgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgIHZhciBkYXRhc2V0ID0gc2VsZi5kYXRhc2V0c1tkYXRhc2V0X2lkXTtcblxuICAgIGlmIChkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnN5bmNQZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHNlbGYuc2F2ZURhdGFTZXQoZGF0YXNldF9pZCk7XG4gICAgICBpZiggc3VjY2VzcyApIHtcbiAgICAgICAgc3VjY2VzcygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiggZmFpbHVyZSApIHtcbiAgICAgICAgZmFpbHVyZSgndW5rbm93bl9kYXRhc2V0ICcgKyBkYXRhc2V0X2lkLCBkYXRhc2V0X2lkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZm9yY2VTeW5jOiBmdW5jdGlvbihkYXRhc2V0X2lkLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgdmFyIGRhdGFzZXQgPSBzZWxmLmRhdGFzZXRzW2RhdGFzZXRfaWRdO1xuXG4gICAgaWYgKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQuc3luY0ZvcmNlZCA9IHRydWU7XG4gICAgICBzZWxmLnNhdmVEYXRhU2V0KGRhdGFzZXRfaWQpO1xuICAgICAgaWYoIHN1Y2Nlc3MgKSB7XG4gICAgICAgIHN1Y2Nlc3MoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoIGZhaWx1cmUgKSB7XG4gICAgICAgIGZhaWx1cmUoJ3Vua25vd25fZGF0YXNldCAnICsgZGF0YXNldF9pZCwgZGF0YXNldF9pZCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHNvcnRPYmplY3QgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gXCJvYmplY3RcIiB8fCBvYmplY3QgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgT2JqZWN0LmtleXMob2JqZWN0KS5zb3J0KCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiBzZWxmLnNvcnRPYmplY3Qob2JqZWN0W2tleV0pXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgc29ydGVkU3RyaW5naWZ5IDogZnVuY3Rpb24ob2JqKSB7XG5cbiAgICB2YXIgc3RyID0gJyc7XG5cbiAgICB0cnkge1xuICAgICAgc3RyID0gSlNPTi5zdHJpbmdpZnkoc2VsZi5zb3J0T2JqZWN0KG9iaikpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN0cmluZ2lmeWluZyBzb3J0ZWQgb2JqZWN0OicgKyBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9LFxuXG4gIGdlbmVyYXRlSGFzaDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKHNlbGYuc29ydGVkU3RyaW5naWZ5KG9iamVjdCkpO1xuICAgIHJldHVybiBoYXNoLnRvU3RyaW5nKCk7XG4gIH0sXG5cbiAgYWRkUGVuZGluZ09iajogZnVuY3Rpb24oZGF0YXNldF9pZCwgdWlkLCBkYXRhLCBhY3Rpb24sIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICBzZWxmLmlzT25saW5lKGZ1bmN0aW9uIChvbmxpbmUpIHtcbiAgICAgIGlmICghb25saW5lKSB7XG4gICAgICAgIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgdWlkLCBzZWxmLm5vdGlmaWNhdGlvbnMuT0ZGTElORV9VUERBVEUsIGFjdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBzdG9yZVBlbmRpbmdPYmplY3Qob2JqKSB7XG4gICAgICBvYmouaGFzaCA9IHNlbGYuZ2VuZXJhdGVIYXNoKG9iaik7XG5cbiAgICAgIHNlbGYuZ2V0RGF0YVNldChkYXRhc2V0X2lkLCBmdW5jdGlvbihkYXRhc2V0KSB7XG5cbiAgICAgICAgZGF0YXNldC5wZW5kaW5nW29iai5oYXNoXSA9IG9iajtcblxuICAgICAgICBzZWxmLnVwZGF0ZURhdGFzZXRGcm9tTG9jYWwoZGF0YXNldCwgb2JqKTtcblxuICAgICAgICBpZihzZWxmLmNvbmZpZy5hdXRvX3N5bmNfbG9jYWxfdXBkYXRlcykge1xuICAgICAgICAgIGRhdGFzZXQuc3luY1BlbmRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuc2F2ZURhdGFTZXQoZGF0YXNldF9pZCk7XG4gICAgICAgIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgdWlkLCBzZWxmLm5vdGlmaWNhdGlvbnMuTE9DQUxfVVBEQVRFX0FQUExJRUQsIGFjdGlvbik7XG5cbiAgICAgICAgc3VjY2VzcyhvYmopO1xuICAgICAgfSwgZnVuY3Rpb24oY29kZSwgbXNnKSB7XG4gICAgICAgIGlmKGZhaWx1cmUpIGZhaWx1cmUoY29kZSwgbXNnKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBwZW5kaW5nT2JqID0ge307XG4gICAgcGVuZGluZ09iai5pbkZsaWdodCA9IGZhbHNlO1xuICAgIHBlbmRpbmdPYmouYWN0aW9uID0gYWN0aW9uO1xuICAgIHBlbmRpbmdPYmoucG9zdCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIHBlbmRpbmdPYmoucG9zdEhhc2ggPSBzZWxmLmdlbmVyYXRlSGFzaChwZW5kaW5nT2JqLnBvc3QpO1xuICAgIHBlbmRpbmdPYmoudGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgaWYoIFwiY3JlYXRlXCIgPT09IGFjdGlvbiApIHtcbiAgICAgIHBlbmRpbmdPYmoudWlkID0gcGVuZGluZ09iai5wb3N0SGFzaDtcbiAgICAgIHN0b3JlUGVuZGluZ09iamVjdChwZW5kaW5nT2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5yZWFkKGRhdGFzZXRfaWQsIHVpZCwgZnVuY3Rpb24ocmVjKSB7XG4gICAgICAgIHBlbmRpbmdPYmoudWlkID0gdWlkO1xuICAgICAgICBwZW5kaW5nT2JqLnByZSA9IHJlYy5kYXRhO1xuICAgICAgICBwZW5kaW5nT2JqLnByZUhhc2ggPSBzZWxmLmdlbmVyYXRlSGFzaChyZWMuZGF0YSk7XG4gICAgICAgIHN0b3JlUGVuZGluZ09iamVjdChwZW5kaW5nT2JqKTtcbiAgICAgIH0sIGZ1bmN0aW9uKGNvZGUsIG1zZykge1xuICAgICAgICBmYWlsdXJlKGNvZGUsIG1zZyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgc3luY0xvb3A6IGZ1bmN0aW9uKGRhdGFzZXRfaWQpIHtcbiAgICBzZWxmLmdldERhdGFTZXQoZGF0YXNldF9pZCwgZnVuY3Rpb24oZGF0YVNldCkge1xuICAgIFxuICAgICAgLy8gVGhlIHN5bmMgbG9vcCBpcyBjdXJyZW50bHkgYWN0aXZlXG4gICAgICBkYXRhU2V0LnN5bmNQZW5kaW5nID0gZmFsc2U7XG4gICAgICBkYXRhU2V0LnN5bmNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgIGRhdGFTZXQuc3luY0xvb3BTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCBudWxsLCBzZWxmLm5vdGlmaWNhdGlvbnMuU1lOQ19TVEFSVEVELCBudWxsKTtcblxuICAgICAgc2VsZi5pc09ubGluZShmdW5jdGlvbihvbmxpbmUpIHtcbiAgICAgICAgaWYgKCFvbmxpbmUpIHtcbiAgICAgICAgICBzZWxmLnN5bmNDb21wbGV0ZShkYXRhc2V0X2lkLCBcIm9mZmxpbmVcIiwgc2VsZi5ub3RpZmljYXRpb25zLlNZTkNfRkFJTEVEKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmNoZWNrSGFzQ3VzdG9tU3luYyhkYXRhc2V0X2lkLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyIHN5bmNMb29wUGFyYW1zID0ge307XG4gICAgICAgICAgICBzeW5jTG9vcFBhcmFtcy5mbiA9ICdzeW5jJztcbiAgICAgICAgICAgIHN5bmNMb29wUGFyYW1zLmRhdGFzZXRfaWQgPSBkYXRhc2V0X2lkO1xuICAgICAgICAgICAgc3luY0xvb3BQYXJhbXMucXVlcnlfcGFyYW1zID0gZGF0YVNldC5xdWVyeV9wYXJhbXM7XG4gICAgICAgICAgICBzeW5jTG9vcFBhcmFtcy5jb25maWcgPSBkYXRhU2V0LmNvbmZpZztcbiAgICAgICAgICAgIHN5bmNMb29wUGFyYW1zLm1ldGFfZGF0YSA9IGRhdGFTZXQubWV0YV9kYXRhO1xuICAgICAgICAgICAgLy92YXIgZGF0YXNldEhhc2ggPSBzZWxmLmdlbmVyYXRlTG9jYWxEYXRhc2V0SGFzaChkYXRhU2V0KTtcbiAgICAgICAgICAgIHN5bmNMb29wUGFyYW1zLmRhdGFzZXRfaGFzaCA9IGRhdGFTZXQuaGFzaDtcbiAgICAgICAgICAgIHN5bmNMb29wUGFyYW1zLmFja25vd2xlZGdlbWVudHMgPSBkYXRhU2V0LmFja25vd2xlZGdlbWVudHMgfHwgW107XG5cbiAgICAgICAgICAgIHZhciBwZW5kaW5nID0gZGF0YVNldC5wZW5kaW5nO1xuICAgICAgICAgICAgdmFyIHBlbmRpbmdBcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBpIGluIHBlbmRpbmcgKSB7XG4gICAgICAgICAgICAgIC8vIE1hcmsgdGhlIHBlbmRpbmcgcmVjb3JkcyB3ZSBhcmUgYWJvdXQgdG8gc3VibWl0IGFzIGluZmxpZ2h0IGFuZCBhZGQgdGhlbSB0byB0aGUgYXJyYXkgZm9yIHN1Ym1pc3Npb25cbiAgICAgICAgICAgICAgLy8gRG9uJ3QgcmUtYWRkIHByZXZpb3VzIGluRmxpZ2h0IHBlbmRpbmcgcmVjb3JkcyB3aG8gd2hhdmUgY3Jhc2hlZCAtIGkuZS4gd2hvJ3MgY3VycmVudCBzdGF0ZSBpcyB1bmtub3duXG4gICAgICAgICAgICAgIC8vIERvbid0IGFkZCBkZWxheWVkIHJlY29yZHNcbiAgICAgICAgICAgICAgaWYoICFwZW5kaW5nW2ldLmluRmxpZ2h0ICYmICFwZW5kaW5nW2ldLmNyYXNoZWQgJiYgIXBlbmRpbmdbaV0uZGVsYXllZCkge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdbaV0uaW5GbGlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdbaV0uaW5GbGlnaHREYXRlID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgcGVuZGluZ0FycmF5LnB1c2gocGVuZGluZ1tpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN5bmNMb29wUGFyYW1zLnBlbmRpbmcgPSBwZW5kaW5nQXJyYXk7XG5cbiAgICAgICAgICAgIGlmKCBwZW5kaW5nQXJyYXkubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCdTdGFydGluZyBzeW5jIGxvb3AgLSBnbG9iYWwgaGFzaCA9ICcgKyBkYXRhU2V0Lmhhc2ggKyAnIDo6IHBhcmFtcyA9ICcgKyBKU09OLnN0cmluZ2lmeShzeW5jTG9vcFBhcmFtcywgbnVsbCwgMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc2VsZi5kb0Nsb3VkQ2FsbCh7XG4gICAgICAgICAgICAgICAgJ2RhdGFzZXRfaWQnOiBkYXRhc2V0X2lkLFxuICAgICAgICAgICAgICAgICdyZXEnOiBzeW5jTG9vcFBhcmFtc1xuICAgICAgICAgICAgICB9LCBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZXModXBkYXRlcywgbm90aWZpY2F0aW9uLCBhY2tub3dsZWRnZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICBpZiggdXBkYXRlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdXAgaW4gdXBkYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgIHJlYyA9IHVwZGF0ZXNbdXBdO1xuICAgICAgICAgICAgICAgICAgICAgIGFja25vd2xlZGdlbWVudHMucHVzaChyZWMpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmKCBkYXRhU2V0LnBlbmRpbmdbdXBdICYmIGRhdGFTZXQucGVuZGluZ1t1cF0uaW5GbGlnaHQgJiYgIWRhdGFTZXQucGVuZGluZ1t1cF0uY3Jhc2hlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhU2V0LnBlbmRpbmdbdXBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCByZWMudWlkLCBub3RpZmljYXRpb24sIHJlYyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGFueSBuZXcgcGVuZGluZyByZWNvcmRzIG5lZWQgdG8gYmUgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBjdXJyZW50IHN0YXRlIG9mIHBsYXkuXG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVQZW5kaW5nRnJvbU5ld0RhdGEoZGF0YXNldF9pZCwgZGF0YVNldCwgcmVzKTtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBhbnkgcHJldmlvdXNseSBjcmFzaGVkIGluZmxpZ2h0IHJlY29yZHMgY2FuIG5vdyBiZSByZXNvbHZlZFxuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlQ3Jhc2hlZEluRmxpZ2h0RnJvbU5ld0RhdGEoZGF0YXNldF9pZCwgZGF0YVNldCwgcmVzKTtcblxuICAgICAgICAgICAgICAgIC8vQ2hlY2sgdG8gc2VlIGlmIGFueSBkZWxheWVkIHBlbmRpbmcgcmVjb3JkcyBjYW4gbm93IGJlIHNldCB0byByZWFkeVxuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlRGVsYXllZEZyb21OZXdEYXRhKGRhdGFzZXRfaWQsIGRhdGFTZXQsIHJlcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG5ldyBkYXRhc2V0IHdpdGggZGV0YWlscyBvZiBhbnkgaW5mbGlnaHQgdXBkYXRlcyB3aGljaCB3ZSBoYXZlIG5vdCByZWNlaXZlZCBhIHJlc3BvbnNlIG9uXG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVOZXdEYXRhRnJvbUluRmxpZ2h0KGRhdGFzZXRfaWQsIGRhdGFTZXQsIHJlcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG5ldyBkYXRhc2V0IHdpdGggZGV0YWlscyBvZiBhbnkgcGVuZGluZyB1cGRhdGVzXG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVOZXdEYXRhRnJvbVBlbmRpbmcoZGF0YXNldF9pZCwgZGF0YVNldCwgcmVzKTtcblxuXG5cbiAgICAgICAgICAgICAgICBpZiAocmVzLnJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEZ1bGwgRGF0YXNldCByZXR1cm5lZFxuICAgICAgICAgICAgICAgICAgZGF0YVNldC5kYXRhID0gcmVzLnJlY29yZHM7XG4gICAgICAgICAgICAgICAgICBkYXRhU2V0Lmhhc2ggPSByZXMuaGFzaDtcblxuICAgICAgICAgICAgICAgICAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCByZXMuaGFzaCwgc2VsZi5ub3RpZmljYXRpb25zLkRFTFRBX1JFQ0VJVkVELCAnZnVsbCBkYXRhc2V0Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlcy51cGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYWNrbm93bGVkZ2VtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgcHJvY2Vzc1VwZGF0ZXMocmVzLnVwZGF0ZXMuYXBwbGllZCwgc2VsZi5ub3RpZmljYXRpb25zLlJFTU9URV9VUERBVEVfQVBQTElFRCwgYWNrbm93bGVkZ2VtZW50cyk7XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzVXBkYXRlcyhyZXMudXBkYXRlcy5mYWlsZWQsIHNlbGYubm90aWZpY2F0aW9ucy5SRU1PVEVfVVBEQVRFX0ZBSUxFRCwgYWNrbm93bGVkZ2VtZW50cyk7XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzVXBkYXRlcyhyZXMudXBkYXRlcy5jb2xsaXNpb25zLCBzZWxmLm5vdGlmaWNhdGlvbnMuQ09MTElTSU9OX0RFVEVDVEVELCBhY2tub3dsZWRnZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgIGRhdGFTZXQuYWNrbm93bGVkZ2VtZW50cyA9IGFja25vd2xlZGdlbWVudHM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXMucmVjb3JkcyAmJiByZXMuaGFzaCAmJiByZXMuaGFzaCAhPT0gZGF0YVNldC5oYXNoKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coXCJMb2NhbCBkYXRhc2V0IHN0YWxlIC0gc3luY2luZyByZWNvcmRzIDo6IGxvY2FsIGhhc2g9IFwiICsgZGF0YVNldC5oYXNoICsgXCIgLSByZW1vdGVIYXNoPVwiICsgcmVzLmhhc2gpO1xuICAgICAgICAgICAgICAgICAgLy8gRGlmZmVyZW50IGhhc2ggdmFsdWUgcmV0dXJuZWQgLSBTeW5jIGluZGl2aWR1YWwgcmVjb3Jkc1xuICAgICAgICAgICAgICAgICAgc2VsZi5zeW5jUmVjb3JkcyhkYXRhc2V0X2lkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKFwiTG9jYWwgZGF0YXNldCB1cCB0byBkYXRlXCIpO1xuICAgICAgICAgICAgICAgICAgc2VsZi5zeW5jQ29tcGxldGUoZGF0YXNldF9pZCwgIFwib25saW5lXCIsIHNlbGYubm90aWZpY2F0aW9ucy5TWU5DX0NPTVBMRVRFKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKG1zZywgZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIEFKQVggY2FsbCBmYWlsZWQgdG8gY29tcGxldGUgc3VjY2VzZnVsbHksIHNvIHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBwZW5kaW5nIHVwZGF0ZXMgaXMgdW5rbm93blxuICAgICAgICAgICAgICAgIC8vIE1hcmsgdGhlbSBhcyBcImNyYXNoZWRcIi4gVGhlIG5leHQgdGltZSBhIHN5bmNMb29wIGNvbXBsZXRldHMgc3VjY2Vzc2Z1bGx5LCB3ZSB3aWxsIHJldmlldyB0aGUgY3Jhc2hlZFxuICAgICAgICAgICAgICAgIC8vIHJlY29yZHMgdG8gc2VlIGlmIHdlIGNhbiBkZXRlcm1pbmUgdGhlaXIgY3VycmVudCBzdGF0ZS5cbiAgICAgICAgICAgICAgICBzZWxmLm1hcmtJbkZsaWdodEFzQ3Jhc2hlZChkYXRhU2V0KTtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coXCJzeW5jTG9vcCBmYWlsZWQgOiBtc2c9XCIgKyBtc2cgKyBcIiA6OiBlcnIgPSBcIiArIGVycik7XG4gICAgICAgICAgICAgICAgc2VsZi5zeW5jQ29tcGxldGUoZGF0YXNldF9pZCwgbXNnLCBzZWxmLm5vdGlmaWNhdGlvbnMuU1lOQ19GQUlMRUQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygnRXJyb3IgcGVyZm9ybWluZyBzeW5jIC0gJyArIGUpO1xuICAgICAgICAgICAgICBzZWxmLnN5bmNDb21wbGV0ZShkYXRhc2V0X2lkLCBlLCBzZWxmLm5vdGlmaWNhdGlvbnMuU1lOQ19GQUlMRUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICBzeW5jUmVjb3JkczogZnVuY3Rpb24oZGF0YXNldF9pZCkge1xuXG4gICAgc2VsZi5nZXREYXRhU2V0KGRhdGFzZXRfaWQsIGZ1bmN0aW9uKGRhdGFTZXQpIHtcblxuICAgICAgdmFyIGxvY2FsRGF0YVNldCA9IGRhdGFTZXQuZGF0YSB8fCB7fTtcblxuICAgICAgdmFyIGNsaWVudFJlY3MgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgaW4gbG9jYWxEYXRhU2V0KSB7XG4gICAgICAgIHZhciB1aWQgPSBpO1xuICAgICAgICB2YXIgaGFzaCA9IGxvY2FsRGF0YVNldFtpXS5oYXNoO1xuICAgICAgICBjbGllbnRSZWNzW3VpZF0gPSBoYXNoO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3luY1JlY1BhcmFtcyA9IHt9O1xuXG4gICAgICBzeW5jUmVjUGFyYW1zLmZuID0gJ3N5bmNSZWNvcmRzJztcbiAgICAgIHN5bmNSZWNQYXJhbXMuZGF0YXNldF9pZCA9IGRhdGFzZXRfaWQ7XG4gICAgICBzeW5jUmVjUGFyYW1zLnF1ZXJ5X3BhcmFtcyA9IGRhdGFTZXQucXVlcnlfcGFyYW1zO1xuICAgICAgc3luY1JlY1BhcmFtcy5jbGllbnRSZWNzID0gY2xpZW50UmVjcztcblxuICAgICAgc2VsZi5jb25zb2xlTG9nKFwic3luY1JlY1BhcmFtcyA6OiBcIiArIEpTT04uc3RyaW5naWZ5KHN5bmNSZWNQYXJhbXMpKTtcblxuICAgICAgc2VsZi5kb0Nsb3VkQ2FsbCh7XG4gICAgICAgICdkYXRhc2V0X2lkJzogZGF0YXNldF9pZCxcbiAgICAgICAgJ3JlcSc6IHN5bmNSZWNQYXJhbXNcbiAgICAgIH0sIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBpZiAocmVzLmNyZWF0ZSkge1xuICAgICAgICAgIGZvciAoaSBpbiByZXMuY3JlYXRlKSB7XG4gICAgICAgICAgICBsb2NhbERhdGFTZXRbaV0gPSB7XCJoYXNoXCIgOiByZXMuY3JlYXRlW2ldLmhhc2gsIFwiZGF0YVwiIDogcmVzLmNyZWF0ZVtpXS5kYXRhfTtcbiAgICAgICAgICAgIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgaSwgc2VsZi5ub3RpZmljYXRpb25zLlJFQ09SRF9ERUxUQV9SRUNFSVZFRCwgXCJjcmVhdGVcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMudXBkYXRlKSB7XG4gICAgICAgICAgZm9yIChpIGluIHJlcy51cGRhdGUpIHtcbiAgICAgICAgICAgIGxvY2FsRGF0YVNldFtpXS5oYXNoID0gcmVzLnVwZGF0ZVtpXS5oYXNoO1xuICAgICAgICAgICAgbG9jYWxEYXRhU2V0W2ldLmRhdGEgPSByZXMudXBkYXRlW2ldLmRhdGE7XG4gICAgICAgICAgICBzZWxmLmRvTm90aWZ5KGRhdGFzZXRfaWQsIGksIHNlbGYubm90aWZpY2F0aW9ucy5SRUNPUkRfREVMVEFfUkVDRUlWRUQsIFwidXBkYXRlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzWydkZWxldGUnXSkge1xuICAgICAgICAgIGZvciAoaSBpbiByZXNbJ2RlbGV0ZSddKSB7XG4gICAgICAgICAgICBkZWxldGUgbG9jYWxEYXRhU2V0W2ldO1xuICAgICAgICAgICAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCBpLCBzZWxmLm5vdGlmaWNhdGlvbnMuUkVDT1JEX0RFTFRBX1JFQ0VJVkVELCBcImRlbGV0ZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmRvTm90aWZ5KGRhdGFzZXRfaWQsIHJlcy5oYXNoLCBzZWxmLm5vdGlmaWNhdGlvbnMuREVMVEFfUkVDRUlWRUQsICdwYXJ0aWFsIGRhdGFzZXQnKTtcblxuICAgICAgICBkYXRhU2V0LmRhdGEgPSBsb2NhbERhdGFTZXQ7XG4gICAgICAgIGlmKHJlcy5oYXNoKSB7XG4gICAgICAgICAgZGF0YVNldC5oYXNoID0gcmVzLmhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5zeW5jQ29tcGxldGUoZGF0YXNldF9pZCwgXCJvbmxpbmVcIiwgc2VsZi5ub3RpZmljYXRpb25zLlNZTkNfQ09NUExFVEUpO1xuICAgICAgfSwgZnVuY3Rpb24obXNnLCBlcnIpIHtcbiAgICAgICAgc2VsZi5jb25zb2xlTG9nKFwic3luY1JlY29yZHMgZmFpbGVkIDogbXNnPVwiICsgbXNnICsgXCIgOjogZXJyPVwiICsgZXJyKTtcbiAgICAgICAgc2VsZi5zeW5jQ29tcGxldGUoZGF0YXNldF9pZCwgbXNnLCBzZWxmLm5vdGlmaWNhdGlvbnMuU1lOQ19GQUlMRUQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgc3luY0NvbXBsZXRlOiBmdW5jdGlvbihkYXRhc2V0X2lkLCBzdGF0dXMsIG5vdGlmaWNhdGlvbikge1xuXG4gICAgc2VsZi5nZXREYXRhU2V0KGRhdGFzZXRfaWQsIGZ1bmN0aW9uKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQuc3luY1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgIGRhdGFzZXQuc3luY0xvb3BFbmQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHNlbGYuc2F2ZURhdGFTZXQoZGF0YXNldF9pZCk7XG4gICAgICBzZWxmLmRvTm90aWZ5KGRhdGFzZXRfaWQsIGRhdGFzZXQuaGFzaCwgbm90aWZpY2F0aW9uLCBzdGF0dXMpO1xuICAgIH0pO1xuICB9LFxuXG4gIGNoZWNrRGF0YXNldHM6IGZ1bmN0aW9uKCkge1xuICAgIGZvciggdmFyIGRhdGFzZXRfaWQgaW4gc2VsZi5kYXRhc2V0cyApIHtcbiAgICAgIGlmKCBzZWxmLmRhdGFzZXRzLmhhc093blByb3BlcnR5KGRhdGFzZXRfaWQpICkge1xuICAgICAgICB2YXIgZGF0YXNldCA9IHNlbGYuZGF0YXNldHNbZGF0YXNldF9pZF07XG5cbiAgICAgICAgaWYoICFkYXRhc2V0LnN5bmNSdW5uaW5nICYmIChkYXRhc2V0LmNvbmZpZy5zeW5jX2FjdGl2ZSB8fCBkYXRhc2V0LnN5bmNGb3JjZWQpKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGl0IGlzIHRpbWUgZm9yIHRoZSBzeW5jIGxvb3AgdG8gcnVuIGFnYWluXG4gICAgICAgICAgdmFyIGxhc3RTeW5jU3RhcnQgPSBkYXRhc2V0LnN5bmNMb29wU3RhcnQ7XG4gICAgICAgICAgdmFyIGxhc3RTeW5jQ21wID0gZGF0YXNldC5zeW5jTG9vcEVuZDtcbiAgICAgICAgICBpZiggbGFzdFN5bmNTdGFydCA9PSBudWxsICkge1xuICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKGRhdGFzZXRfaWQgKycgLSBQZXJmb3JtaW5nIGluaXRpYWwgc3luYycpO1xuICAgICAgICAgICAgLy8gRGF0YXNldCBoYXMgbmV2ZXIgYmVlbiBzeW5jZWQgYmVmb3JlIC0gZG8gaW5pdGlhbCBzeW5jXG4gICAgICAgICAgICBkYXRhc2V0LnN5bmNQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RTeW5jQ21wICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB0aW1lU2luY2VMYXN0U3luYyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbGFzdFN5bmNDbXA7XG4gICAgICAgICAgICB2YXIgc3luY0ZyZXF1ZW5jeSA9IGRhdGFzZXQuY29uZmlnLnN5bmNfZnJlcXVlbmN5ICogMTAwMDtcbiAgICAgICAgICAgIGlmKCB0aW1lU2luY2VMYXN0U3luYyA+IHN5bmNGcmVxdWVuY3kgKSB7XG4gICAgICAgICAgICAgIC8vIFRpbWUgYmV0d2VlbiBzeW5jIGxvb3BzIGhhcyBwYXNzZWQgLSBkbyBhbm90aGVyIHN5bmNcbiAgICAgICAgICAgICAgZGF0YXNldC5zeW5jUGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBcblxuICAgICAgICAgIGlmKCBkYXRhc2V0LnN5bmNGb3JjZWQgKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnN5bmNQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggZGF0YXNldC5zeW5jUGVuZGluZyApIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IHN5bmNGb3JjZWQgaW4gY2FzZSBpdCB3YXMgd2hhdCBjYXVzZWQgdGhlIHN5bmMgY3ljbGUgdG8gcnVuLlxuICAgICAgICAgICAgZGF0YXNldC5zeW5jRm9yY2VkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkYXRhc2V0IHJlcXVyZXMgc3luY2luZywgcnVuIHRoZSBzeW5jIGxvb3AuIFRoaXMgbWF5IGJlIGJlY2F1c2UgdGhlIHN5bmMgaW50ZXJ2YWwgaGFzIHBhc3NlZFxuICAgICAgICAgICAgLy8gb3IgYmVjYXVzZSB0aGUgc3luY19mcmVxdWVuY3kgaGFzIGJlZW4gY2hhbmdlZCBvciBiZWNhdXNlIGEgY2hhbmdlIHdhcyBtYWRlIHRvIHRoZSBkYXRhc2V0IGFuZCB0aGVcbiAgICAgICAgICAgIC8vIGltbWVkaWF0ZV9zeW5jIGZsYWcgc2V0IHRvIHRydWVcbiAgICAgICAgICAgIHNlbGYuc3luY0xvb3AoZGF0YXNldF9pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNoZWNrSGFzQ3VzdG9tU3luYyA6IGZ1bmN0aW9uKGRhdGFzZXRfaWQsIGNiKSB7XG4gICAgaWYoc2VsZi5oYXNDdXN0b21TeW5jICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjYigpO1xuICAgIH1cbiAgICBzZWxmLmNvbnNvbGVMb2coJ3N0YXJ0aW5nIGNoZWNrIGhhcyBjdXN0b20gc3luYycpO1xuXG4gICAgYWN0QVBJKHtcbiAgICAgICdhY3QnIDogZGF0YXNldF9pZCxcbiAgICAgICdyZXEnOiB7XG4gICAgICAgICdmbic6ICdzeW5jJ1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uKHJlcykge1xuICAgICAgLy9pZiB0aGUgY3VzdG9tIHN5bmMgaXMgZGVmaW5lZCBpbiB0aGUgY2xvdWQsIHRoaXMgY2FsbCBzaG91bGQgc3VjY2Vzcy5cbiAgICAgIC8vaWYgZmFpbGVkLCB3ZSB0aGluayB0aGlzIHRoZSBjdXN0b20gc3luYyBpcyBub3QgZGVmaW5lZFxuICAgICAgc2VsZi5jb25zb2xlTG9nKCdjaGVja0hhc0N1c3RvbVN5bmMgLSBzdWNjZXNzIC0gJywgcmVzKTtcbiAgICAgIHNlbGYuaGFzQ3VzdG9tU3luYyA9IHRydWU7XG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9LCBmdW5jdGlvbihtc2csZXJyKSB7XG4gICAgICBzZWxmLmNvbnNvbGVMb2coJ2NoZWNrSGFzQ3VzdG9tU3luYyAtIGZhaWx1cmUgLSAnLCBlcnIpO1xuICAgICAgaWYoZXJyLnN0YXR1cyAmJiBlcnIuc3RhdHVzID09PSA1MDApe1xuICAgICAgICAvL2lmIHdlIHJlY2VpdmUgNTAwLCBpdCBjb3VsZCBiZSB0aGF0IHRoZXJlIGlzIGFuIGVycm9yIG9jY3VyZWQgZHVlIHRvIG1pc3NpbmcgcGFyYW1ldGVycyBvciBzaW1pbGFyLFxuICAgICAgICAvL2J1dCB0aGUgZW5kcG9pbnQgaXMgZGVmaW5lZC5cbiAgICAgICAgc2VsZi5jb25zb2xlTG9nKCdjaGVja0hhc0N1c3RvbVN5bmMgLSBmYWlsZWQgd2l0aCA1MDAsIGVuZHBvaW50IGRvZXMgZXhpc3RzJyk7XG4gICAgICAgIHNlbGYuaGFzQ3VzdG9tU3luYyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmhhc0N1c3RvbVN5bmMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYigpO1xuICAgIH0pO1xuICB9LFxuXG4gIGRvQ2xvdWRDYWxsOiBmdW5jdGlvbihwYXJhbXMsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICBpZiggc2VsZi5oYXNDdXN0b21TeW5jICkge1xuICAgICAgYWN0QVBJKHtcbiAgICAgICAgJ2FjdCcgOiBwYXJhbXMuZGF0YXNldF9pZCxcbiAgICAgICAgJ3JlcScgOiBwYXJhbXMucmVxXG4gICAgICB9LCBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgc3VjY2VzcyhyZXMpO1xuICAgICAgfSwgZnVuY3Rpb24obXNnLCBlcnIpIHtcbiAgICAgICAgZmFpbHVyZShtc2csIGVycik7XG4gICAgICB9KTsgICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvdWRBUEkoe1xuICAgICAgICAncGF0aCcgOiAnL21iYWFzL3N5bmMvJyArIHBhcmFtcy5kYXRhc2V0X2lkLFxuICAgICAgICAnbWV0aG9kJyA6ICdwb3N0JyxcbiAgICAgICAgJ2RhdGEnIDogcGFyYW1zLnJlcVxuICAgICAgfSwgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIHN1Y2Nlc3MocmVzKTtcbiAgICAgIH0sIGZ1bmN0aW9uKG1zZywgZXJyKSB7XG4gICAgICAgIGZhaWx1cmUobXNnLCBlcnIpO1xuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgZGF0YXNldE1vbml0b3I6IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuY2hlY2tEYXRhc2V0cygpO1xuXG4gICAgLy8gUmUtZXhlY3V0ZSBkYXRhc2V0TW9uaXRvciBldmVyeSA1MDBtcyBzbyB3ZSBrZWVwIGludm9raW5nIGNoZWNrRGF0YXNldHMoKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5kYXRhc2V0TW9uaXRvcigpO1xuICAgIH0sIDUwMCk7XG4gIH0sXG5cbiAgc2F2ZURhdGFTZXQ6IGZ1bmN0aW9uIChkYXRhc2V0X2lkLCBjYikge1xuICAgIHZhciBvbkZhaWwgPSAgZnVuY3Rpb24obXNnLCBlcnIpIHtcbiAgICAgIC8vIHNhdmUgZmFpbGVkXG4gICAgICB2YXIgZXJyTXNnID0gJ3NhdmUgdG8gbG9jYWwgc3RvcmFnZSBmYWlsZWQgIG1zZzonICsgbXNnICsgJyBlcnI6JyArIGVycjtcbiAgICAgIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgbnVsbCwgc2VsZi5ub3RpZmljYXRpb25zLkNMSUVOVF9TVE9SQUdFX0ZBSUxFRCwgZXJyTXNnKTtcbiAgICAgIHNlbGYuY29uc29sZUxvZyhlcnJNc2cpO1xuICAgIH07XG4gICAgc2VsZi5nZXREYXRhU2V0KGRhdGFzZXRfaWQsIGZ1bmN0aW9uKGRhdGFzZXQpIHtcbiAgICAgIC8vIHNhdmUgZGF0YXNldCB0byBsb2NhbCBzdG9yYWdlXG4gICAgICBMYXduY2hhaXIoe2ZhaWw6b25GYWlsLCBhZGFwdGVyOiBzZWxmLmNvbmZpZy5zdG9yYWdlX3N0cmF0ZWd5LCBzaXplOnNlbGYuY29uZmlnLmZpbGVfc3lzdGVtX3F1b3RhfSwgZnVuY3Rpb24gKCl7XG4gICAgICAgIHRoaXMuc2F2ZSh7a2V5OlwiZGF0YXNldF9cIiArIGRhdGFzZXRfaWQsIHZhbDpkYXRhc2V0fSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAvL3NhdmUgc3VjY2Vzc1xuICAgICAgICAgIGlmKGNiKSByZXR1cm4gY2IoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICBsb2FkRGF0YVNldDogZnVuY3Rpb24gKGRhdGFzZXRfaWQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICAvLyBsb2FkIGRhdGFzZXQgZnJvbSBsb2NhbCBzdG9yYWdlXG4gICAgdmFyIG9uRmFpbCA9IGZ1bmN0aW9uKG1zZywgZXJyKSB7XG4gICAgICAvLyBsb2FkIGZhaWxlZFxuICAgICAgdmFyIGVyck1zZyA9ICdsb2FkIGZyb20gbG9jYWwgc3RvcmFnZSBmYWlsZWQgIG1zZzonICsgbXNnO1xuICAgICAgc2VsZi5kb05vdGlmeShkYXRhc2V0X2lkLCBudWxsLCBzZWxmLm5vdGlmaWNhdGlvbnMuQ0xJRU5UX1NUT1JBR0VfRkFJTEVELCBlcnJNc2cpO1xuICAgICAgc2VsZi5jb25zb2xlTG9nKGVyck1zZyk7XG4gICAgfTtcblxuICAgICAgICBMYXduY2hhaXIoe2ZhaWw6b25GYWlsLCBhZGFwdGVyOiBzZWxmLmNvbmZpZy5zdG9yYWdlX3N0cmF0ZWd5LCBzaXplOnNlbGYuY29uZmlnLmZpbGVfc3lzdGVtX3F1b3RhfSxmdW5jdGlvbiAoKXsgICAgICAgdGhpcy5nZXQoIFwiZGF0YXNldF9cIiArIGRhdGFzZXRfaWQsIGZ1bmN0aW9uIChkYXRhKXtcbiAgICAgICAgIGlmIChkYXRhICYmIGRhdGEudmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YXNldCA9IGRhdGEudmFsO1xuICAgICAgICAgICAgaWYodHlwZW9mIGRhdGFzZXQgPT09IFwic3RyaW5nXCIpe1xuICAgICAgICAgICAgICBkYXRhc2V0ID0gSlNPTi5wYXJzZShkYXRhc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERhdGFzZXRzIHNob3VsZCBub3QgYmUgYXV0byBpbml0aWFsaXNlZCB3aGVuIGxvYWRlZCAtIHRoZSBtYW5nZSBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGZvciBlYWNoIGRhdGFzZXRcbiAgICAgICAgICAgIC8vIHRoZSB1c2VyIHdhbnRzIHN5bmNcbiAgICAgICAgICAgIGRhdGFzZXQuaW5pdGlhbGlzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYuZGF0YXNldHNbZGF0YXNldF9pZF0gPSBkYXRhc2V0OyAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRvIGhhbmRsZSBiaW5hcnkgZGF0YT9cbiAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygnbG9hZCBmcm9tIGxvY2FsIHN0b3JhZ2Ugc3VjY2VzcyBmb3IgZGF0YXNldF9pZCA6JyArIGRhdGFzZXRfaWQpO1xuICAgICAgICAgICAgaWYoc3VjY2VzcykgcmV0dXJuIHN1Y2Nlc3MoZGF0YXNldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIGRhdGEgeWV0LCBwcm9iYWJseSBmaXJzdCB0aW1lLiBmYWlsdXJlIGNhbGJhY2sgc2hvdWxkIGhhbmRsZSB0aGlzXG4gICAgICAgICAgICBpZihmYWlsdXJlKSByZXR1cm4gZmFpbHVyZSgpO1xuICAgICAgICAgIH1cbiAgICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuXG4gIHVwZGF0ZURhdGFzZXRGcm9tTG9jYWw6IGZ1bmN0aW9uKGRhdGFzZXQsIHBlbmRpbmdSZWMpIHtcbiAgICB2YXIgcGVuZGluZyA9IGRhdGFzZXQucGVuZGluZztcbiAgICB2YXIgcHJldmlvdXNQZW5kaW5nVWlkO1xuICAgIHZhciBwcmV2aW91c1BlbmRpbmc7XG5cbiAgICB2YXIgdWlkID0gcGVuZGluZ1JlYy51aWQ7XG4gICAgc2VsZi5jb25zb2xlTG9nKCd1cGRhdGluZyBsb2NhbCBkYXRhc2V0IGZvciB1aWQgJyArIHVpZCArICcgLSBhY3Rpb24gPSAnICsgcGVuZGluZ1JlYy5hY3Rpb24pO1xuXG4gICAgZGF0YXNldC5tZXRhW3VpZF0gPSBkYXRhc2V0Lm1ldGFbdWlkXSB8fCB7fTtcblxuICAgIC8vIENyZWF0aW5nIGEgbmV3IHJlY29yZFxuICAgIGlmKCBwZW5kaW5nUmVjLmFjdGlvbiA9PT0gXCJjcmVhdGVcIiApIHtcbiAgICAgIGlmKCBkYXRhc2V0LmRhdGFbdWlkXSApIHtcbiAgICAgICAgc2VsZi5jb25zb2xlTG9nKCdkYXRhc2V0IGFscmVhZHkgZXhpc3RzIGZvciB1aWQgaW4gY3JlYXRlIDo6ICcgKyBKU09OLnN0cmluZ2lmeShkYXRhc2V0LmRhdGFbdWlkXSkpO1xuXG4gICAgICAgIC8vIFdlIGFyZSB0cnlpbmcgdG8gZG8gYSBjcmVhdGUgdXNpbmcgYSB1aWQgd2hpY2ggYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKGRhdGFzZXQubWV0YVt1aWRdLmZyb21QZW5kaW5nKSB7XG4gICAgICAgICAgLy8gV2UgYXJlIHRyeWluZyB0byBjcmVhdGUgb24gdG9wIG9mIGFuIGV4aXN0aW5nIHBlbmRpbmcgcmVjb3JkXG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBwcmV2aW91cyBwZW5kaW5nIHJlY29yZCBhbmQgdXNlIHRoaXMgb25lIGluc3RlYWRcbiAgICAgICAgICBwcmV2aW91c1BlbmRpbmdVaWQgPSBkYXRhc2V0Lm1ldGFbdWlkXS5wZW5kaW5nVWlkO1xuICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nW3ByZXZpb3VzUGVuZGluZ1VpZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRhdGFzZXQuZGF0YVt1aWRdID0ge307XG4gICAgfVxuXG4gICAgaWYoIHBlbmRpbmdSZWMuYWN0aW9uID09PSBcInVwZGF0ZVwiICkge1xuICAgICAgaWYoIGRhdGFzZXQuZGF0YVt1aWRdICkge1xuICAgICAgICBpZiAoZGF0YXNldC5tZXRhW3VpZF0uZnJvbVBlbmRpbmcpIHtcbiAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0aW5nIGFuIGV4aXN0aW5nIHBlbmRpbmcgcmVjb3JkIGZvciBkYXRhc2V0IDo6ICcgKyBKU09OLnN0cmluZ2lmeShkYXRhc2V0LmRhdGFbdWlkXSkpO1xuICAgICAgICAgIC8vIFdlIGFyZSB0cnlpbmcgdG8gdXBkYXRlIGFuIGV4aXN0aW5nIHBlbmRpbmcgcmVjb3JkXG4gICAgICAgICAgcHJldmlvdXNQZW5kaW5nVWlkID0gZGF0YXNldC5tZXRhW3VpZF0ucGVuZGluZ1VpZDtcbiAgICAgICAgICBkYXRhc2V0Lm1ldGFbdWlkXS5wcmV2aW91c1BlbmRpbmdVaWQgPSBwcmV2aW91c1BlbmRpbmdVaWQ7XG4gICAgICAgICAgcHJldmlvdXNQZW5kaW5nID0gcGVuZGluZ1twcmV2aW91c1BlbmRpbmdVaWRdO1xuICAgICAgICAgIGlmKHByZXZpb3VzUGVuZGluZykge1xuICAgICAgICAgICAgaWYoIXByZXZpb3VzUGVuZGluZy5pbkZsaWdodCl7XG4gICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygnZXhpc3RpbmcgcHJlLWZsaWdodCBwZW5kaW5nIHJlY29yZCA9ICcgKyBKU09OLnN0cmluZ2lmeShwcmV2aW91c1BlbmRpbmcpKTtcbiAgICAgICAgICAgICAgLy8gV2UgYXJlIHRyeWluZyB0byBwZXJmb3JtIGFuIHVwZGF0ZSBvbiBhbiBleGlzdGluZyBwZW5kaW5nIHJlY29yZFxuICAgICAgICAgICAgICAvLyBtb2RpZnkgdGhlIG9yaWdpbmFsIHJlY29yZCB0byBoYXZlIHRoZSBsYXRlc3QgdmFsdWUgYW5kIGRlbGV0ZSB0aGUgcGVuZGluZyB1cGRhdGVcbiAgICAgICAgICAgICAgcHJldmlvdXNQZW5kaW5nLnBvc3QgPSBwZW5kaW5nUmVjLnBvc3Q7XG4gICAgICAgICAgICAgIHByZXZpb3VzUGVuZGluZy5wb3N0SGFzaCA9IHBlbmRpbmdSZWMucG9zdEhhc2g7XG4gICAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nW3BlbmRpbmdSZWMuaGFzaF07XG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcGVuZGluZyByZWNvcmQgdG8gaGF2ZSB0aGUgaGFzaCBvZiB0aGUgcHJldmlvdXMgcmVjb3JkIGFzIHRoaXMgaXMgd2hhdCBpcyBub3cgYmVpbmdcbiAgICAgICAgICAgICAgLy8gbWFpbnRhaW5lZCBpbiB0aGUgcGVuZGluZyBhcnJheSAmIGlzIHdoYXQgd2Ugd2FudCBpbiB0aGUgbWV0YSByZWNvcmRcbiAgICAgICAgICAgICAgcGVuZGluZ1JlYy5oYXNoID0gcHJldmlvdXNQZW5kaW5nVWlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy93ZSBhcmUgcGVyZm9ybWluZyBjaGFuZ2VzIHRvIGEgcGVuZGluZyByZWNvcmQgd2hpY2ggaXMgaW5GbGlnaHQuIFVudGlsIHRoZSBzdGF0dXMgb2YgdGhpcyBwZW5kaW5nIHJlY29yZCBpcyByZXNvbHZlZCxcbiAgICAgICAgICAgICAgLy93ZSBzaG91bGQgbm90IHN1Ym1pdCB0aGlzIHBlbmRpbmcgcmVjb3JkIHRvIHRoZSBjbG91ZC4gTWFyayBpdCBhcyBkZWxheWVkLlxuICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ2V4aXN0aW5nIGluLWluZmxpZ2h0IHBlbmRpbmcgcmVjb3JkID0gJyArIEpTT04uc3RyaW5naWZ5KHByZXZpb3VzUGVuZGluZykpO1xuICAgICAgICAgICAgICBwZW5kaW5nUmVjLmRlbGF5ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBwZW5kaW5nUmVjLndhaXRpbmcgPSBwcmV2aW91c1BlbmRpbmcuaGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggcGVuZGluZ1JlYy5hY3Rpb24gPT09IFwiZGVsZXRlXCIgKSB7XG4gICAgICBpZiggZGF0YXNldC5kYXRhW3VpZF0gKSB7XG4gICAgICAgIGlmIChkYXRhc2V0Lm1ldGFbdWlkXS5mcm9tUGVuZGluZykge1xuICAgICAgICAgIHNlbGYuY29uc29sZUxvZygnRGVsZXRpbmcgYW4gZXhpc3RpbmcgcGVuZGluZyByZWNvcmQgZm9yIGRhdGFzZXQgOjogJyArIEpTT04uc3RyaW5naWZ5KGRhdGFzZXQuZGF0YVt1aWRdKSk7XG4gICAgICAgICAgLy8gV2UgYXJlIHRyeWluZyB0byBkZWxldGUgYW4gZXhpc3RpbmcgcGVuZGluZyByZWNvcmRcbiAgICAgICAgICBwcmV2aW91c1BlbmRpbmdVaWQgPSBkYXRhc2V0Lm1ldGFbdWlkXS5wZW5kaW5nVWlkO1xuICAgICAgICAgIGRhdGFzZXQubWV0YVt1aWRdLnByZXZpb3VzUGVuZGluZ1VpZCA9IHByZXZpb3VzUGVuZGluZ1VpZDtcbiAgICAgICAgICBwcmV2aW91c1BlbmRpbmcgPSBwZW5kaW5nW3ByZXZpb3VzUGVuZGluZ1VpZF07XG4gICAgICAgICAgaWYoIHByZXZpb3VzUGVuZGluZyApIHtcbiAgICAgICAgICAgIGlmKCFwcmV2aW91c1BlbmRpbmcuaW5GbGlnaHQpe1xuICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ2V4aXN0aW5nIHBlbmRpbmcgcmVjb3JkID0gJyArIEpTT04uc3RyaW5naWZ5KHByZXZpb3VzUGVuZGluZykpO1xuICAgICAgICAgICAgICBpZiggcHJldmlvdXNQZW5kaW5nLmFjdGlvbiA9PT0gXCJjcmVhdGVcIiApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgdHJ5aW5nIHRvIHBlcmZvcm0gYSBkZWxldGUgb24gYW4gZXhpc3RpbmcgcGVuZGluZyBjcmVhdGVcbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBjYW5jZWwgZWFjaCBvdGhlciBvdXQgc28gcmVtb3ZlIHRoZW0gYm90aFxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nW3BlbmRpbmdSZWMuaGFzaF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBlbmRpbmdbcHJldmlvdXNQZW5kaW5nVWlkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiggcHJldmlvdXNQZW5kaW5nLmFjdGlvbiA9PT0gXCJ1cGRhdGVcIiApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgdHJ5aW5nIHRvIHBlcmZvcm0gYSBkZWxldGUgb24gYW4gZXhpc3RpbmcgcGVuZGluZyB1cGRhdGVcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHByZSB2YWx1ZSBmcm9tIHRoZSBwZW5kaW5nIHVwZGF0ZSBmb3IgdGhlIGRlbGV0ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyBnZXQgcmlkIG9mIHRoZSBwZW5kaW5nIHVwZGF0ZVxuICAgICAgICAgICAgICAgIHBlbmRpbmdSZWMucHJlID0gcHJldmlvdXNQZW5kaW5nLnByZTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLnByZUhhc2ggPSBwcmV2aW91c1BlbmRpbmcucHJlSGFzaDtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLmluRmxpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBlbmRpbmdbcHJldmlvdXNQZW5kaW5nVWlkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCdleGlzdGluZyBpbi1pbmZsaWdodCBwZW5kaW5nIHJlY29yZCA9ICcgKyBKU09OLnN0cmluZ2lmeShwcmV2aW91c1BlbmRpbmcpKTtcbiAgICAgICAgICAgICAgcGVuZGluZ1JlYy5kZWxheWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcGVuZGluZ1JlYy53YWl0aW5nID0gcHJldmlvdXNQZW5kaW5nLmhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBkYXRhc2V0LmRhdGFbdWlkXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggZGF0YXNldC5kYXRhW3VpZF0gKSB7XG4gICAgICBkYXRhc2V0LmRhdGFbdWlkXS5kYXRhID0gcGVuZGluZ1JlYy5wb3N0O1xuICAgICAgZGF0YXNldC5kYXRhW3VpZF0uaGFzaCA9IHBlbmRpbmdSZWMucG9zdEhhc2g7XG4gICAgICBkYXRhc2V0Lm1ldGFbdWlkXS5mcm9tUGVuZGluZyA9IHRydWU7XG4gICAgICBkYXRhc2V0Lm1ldGFbdWlkXS5wZW5kaW5nVWlkID0gcGVuZGluZ1JlYy5oYXNoO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGVQZW5kaW5nRnJvbU5ld0RhdGE6IGZ1bmN0aW9uKGRhdGFzZXRfaWQsIGRhdGFzZXQsIG5ld0RhdGEpIHtcbiAgICB2YXIgcGVuZGluZyA9IGRhdGFzZXQucGVuZGluZztcbiAgICB2YXIgbmV3UmVjO1xuXG4gICAgaWYoIHBlbmRpbmcgJiYgbmV3RGF0YS5yZWNvcmRzKSB7XG4gICAgICBmb3IoIHZhciBwZW5kaW5nSGFzaCBpbiBwZW5kaW5nICkge1xuICAgICAgICBpZiggcGVuZGluZy5oYXNPd25Qcm9wZXJ0eShwZW5kaW5nSGFzaCkgKSB7XG4gICAgICAgICAgdmFyIHBlbmRpbmdSZWMgPSBwZW5kaW5nW3BlbmRpbmdIYXNoXTtcblxuICAgICAgICAgIGRhdGFzZXQubWV0YVtwZW5kaW5nUmVjLnVpZF0gPSBkYXRhc2V0Lm1ldGFbcGVuZGluZ1JlYy51aWRdIHx8IHt9O1xuXG4gICAgICAgICAgaWYoIHBlbmRpbmdSZWMuaW5GbGlnaHQgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgLy8gUGVuZGluZyByZWNvcmQgdGhhdCBoYXMgbm90IGJlZW4gc3VibWl0dGVkXG4gICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0ZVBlbmRpbmdGcm9tTmV3RGF0YSAtIEZvdW5kIE5vbiBpbkZsaWdodCByZWNvcmQgLT4gYWN0aW9uPScgKyBwZW5kaW5nUmVjLmFjdGlvbiArJyA6OiB1aWQ9JyArIHBlbmRpbmdSZWMudWlkICArICcgOjogaGFzaD0nICsgcGVuZGluZ1JlYy5oYXNoKTtcbiAgICAgICAgICAgIGlmKCBwZW5kaW5nUmVjLmFjdGlvbiA9PT0gXCJ1cGRhdGVcIiB8fCBwZW5kaW5nUmVjLmFjdGlvbiA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByZSB2YWx1ZSBvZiBwZW5kaW5nIHJlY29yZCB0byByZWZsZWN0IHRoZSBsYXRlc3QgZGF0YSByZXR1cm5lZCBmcm9tIHN5bmMuXG4gICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBwcmV2ZW50IGEgY29sbGlzaW9uIGJlaW5nIHJlcG9ydGVkIHdoZW4gdGhlIHBlbmRpbmcgcmVjb3JkIGlzIHNlbnQuXG4gICAgICAgICAgICAgIG5ld1JlYyA9IG5ld0RhdGEucmVjb3Jkc1twZW5kaW5nUmVjLnVpZF07XG4gICAgICAgICAgICAgIGlmKCBuZXdSZWMgKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCd1cGRhdGVQZW5kaW5nRnJvbU5ld0RhdGEgLSBVcGRhdGluZyBwcmUgdmFsdWVzIGZvciBleGlzdGluZyBwZW5kaW5nIHJlY29yZCAnICsgcGVuZGluZ1JlYy51aWQpO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdSZWMucHJlID0gbmV3UmVjLmRhdGE7XG4gICAgICAgICAgICAgICAgcGVuZGluZ1JlYy5wcmVIYXNoID0gbmV3UmVjLmhhc2g7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHVwZGF0ZS9kZWxldGUgbWF5IGJlIGZvciBhIG5ld2x5IGNyZWF0ZWQgcmVjb3JkIGluIHdoaWNoIGNhc2UgdGhlIHVpZCB3aWxsIGhhdmUgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNQZW5kaW5nVWlkID0gZGF0YXNldC5tZXRhW3BlbmRpbmdSZWMudWlkXS5wcmV2aW91c1BlbmRpbmdVaWQ7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzUGVuZGluZyA9IHBlbmRpbmdbcHJldmlvdXNQZW5kaW5nVWlkXTtcbiAgICAgICAgICAgICAgICBpZiggcHJldmlvdXNQZW5kaW5nICkge1xuICAgICAgICAgICAgICAgICAgaWYoIG5ld0RhdGEgJiYgbmV3RGF0YS51cGRhdGVzICYmICBuZXdEYXRhLnVwZGF0ZXMuYXBwbGllZCAmJiBuZXdEYXRhLnVwZGF0ZXMuYXBwbGllZFtwcmV2aW91c1BlbmRpbmcuaGFzaF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGFuIHVwZGF0ZSBpbiBmcm9tIGEgcHJldmlvdXMgcGVuZGluZyBhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1VpZCA9IG5ld0RhdGEudXBkYXRlcy5hcHBsaWVkW3ByZXZpb3VzUGVuZGluZy5oYXNoXS51aWQ7XG4gICAgICAgICAgICAgICAgICAgIG5ld1JlYyA9IG5ld0RhdGEucmVjb3Jkc1tuZXdVaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiggbmV3UmVjICkge1xuICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygndXBkYXRlUGVuZGluZ0Zyb21OZXdEYXRhIC0gVXBkYXRpbmcgcHJlIHZhbHVlcyBmb3IgZXhpc3RpbmcgcGVuZGluZyByZWNvcmQgd2hpY2ggd2FzIHByZXZpb3VzbHkgYSBjcmVhdGUgJyArIHBlbmRpbmdSZWMudWlkICsgJyA9PT4gJyArIG5ld1VpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1JlYy5wcmUgPSBuZXdSZWMuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLnByZUhhc2ggPSBuZXdSZWMuaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLnVpZCA9IG5ld1VpZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggcGVuZGluZ1JlYy5hY3Rpb24gPT09IFwiY3JlYXRlXCIgKSB7XG4gICAgICAgICAgICAgIGlmKCBuZXdEYXRhICYmIG5ld0RhdGEudXBkYXRlcyAmJiAgbmV3RGF0YS51cGRhdGVzLmFwcGxpZWQgJiYgbmV3RGF0YS51cGRhdGVzLmFwcGxpZWRbcGVuZGluZ0hhc2hdICkge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygndXBkYXRlUGVuZGluZ0Zyb21OZXdEYXRhIC0gRm91bmQgYW4gdXBkYXRlIGZvciBhIHBlbmRpbmcgY3JlYXRlICcgKyBKU09OLnN0cmluZ2lmeShuZXdEYXRhLnVwZGF0ZXMuYXBwbGllZFtwZW5kaW5nSGFzaF0pKTtcbiAgICAgICAgICAgICAgICBuZXdSZWMgPSBuZXdEYXRhLnJlY29yZHNbbmV3RGF0YS51cGRhdGVzLmFwcGxpZWRbcGVuZGluZ0hhc2hdLnVpZF07XG4gICAgICAgICAgICAgICAgaWYoIG5ld1JlYyApIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygndXBkYXRlUGVuZGluZ0Zyb21OZXdEYXRhIC0gQ2hhbmdpbmcgcGVuZGluZyBjcmVhdGUgdG8gYW4gdXBkYXRlIGJhc2VkIG9uIG5ldyByZWNvcmQgICcgKyBKU09OLnN0cmluZ2lmeShuZXdSZWMpKTtcblxuICAgICAgICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBwZW5kaW5nIGNyZWF0ZSBhcyBhbiB1cGRhdGVcbiAgICAgICAgICAgICAgICAgIHBlbmRpbmdSZWMuYWN0aW9uID0gXCJ1cGRhdGVcIjtcbiAgICAgICAgICAgICAgICAgIHBlbmRpbmdSZWMucHJlID0gbmV3UmVjLmRhdGE7XG4gICAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLnByZUhhc2ggPSBuZXdSZWMuaGFzaDtcbiAgICAgICAgICAgICAgICAgIHBlbmRpbmdSZWMudWlkID0gbmV3RGF0YS51cGRhdGVzLmFwcGxpZWRbcGVuZGluZ0hhc2hdLnVpZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlTmV3RGF0YUZyb21JbkZsaWdodDogZnVuY3Rpb24oZGF0YXNldF9pZCwgZGF0YXNldCwgbmV3RGF0YSkge1xuICAgIHZhciBwZW5kaW5nID0gZGF0YXNldC5wZW5kaW5nO1xuXG4gICAgaWYoIHBlbmRpbmcgJiYgbmV3RGF0YS5yZWNvcmRzKSB7XG4gICAgICBmb3IoIHZhciBwZW5kaW5nSGFzaCBpbiBwZW5kaW5nICkge1xuICAgICAgICBpZiggcGVuZGluZy5oYXNPd25Qcm9wZXJ0eShwZW5kaW5nSGFzaCkgKSB7XG4gICAgICAgICAgdmFyIHBlbmRpbmdSZWMgPSBwZW5kaW5nW3BlbmRpbmdIYXNoXTtcblxuICAgICAgICAgIGlmKCBwZW5kaW5nUmVjLmluRmxpZ2h0ICkge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVJlY2VpdmVkRm9yUGVuZGluZyA9IChuZXdEYXRhICYmIG5ld0RhdGEudXBkYXRlcyAmJiAgbmV3RGF0YS51cGRhdGVzLmhhc2hlcyAmJiBuZXdEYXRhLnVwZGF0ZXMuaGFzaGVzW3BlbmRpbmdIYXNoXSkgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygndXBkYXRlTmV3RGF0YUZyb21JbkZsaWdodCAtIEZvdW5kIGluZmxpZ2h0IHBlbmRpbmcgUmVjb3JkIC0gYWN0aW9uID0gJyArIHBlbmRpbmdSZWMuYWN0aW9uICsgJyA6OiBoYXNoID0gJyArIHBlbmRpbmdIYXNoICsgJyA6OiB1cGRhdGVSZWNlaXZlZEZvclBlbmRpbmc9JyArIHVwZGF0ZVJlY2VpdmVkRm9yUGVuZGluZyk7XG5cbiAgICAgICAgICAgIGlmKCAhIHVwZGF0ZVJlY2VpdmVkRm9yUGVuZGluZyApIHtcbiAgICAgICAgICAgICAgdmFyIG5ld1JlYyA9IG5ld0RhdGEucmVjb3Jkc1twZW5kaW5nUmVjLnVpZF07XG5cbiAgICAgICAgICAgICAgaWYoIHBlbmRpbmdSZWMuYWN0aW9uID09PSBcInVwZGF0ZVwiICYmIG5ld1JlYykge1xuICAgICAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgbmV3IFJlY29yZCB0byBoYXZlIHRoZSB1cGRhdGVzIGZyb20gdGhlIHBlbmRpbmcgcmVjb3JkIHNvIHRoZSBsb2NhbCBkYXRhc2V0IGlzIGNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICBuZXdSZWMuZGF0YSA9IHBlbmRpbmdSZWMucG9zdDtcbiAgICAgICAgICAgICAgICBuZXdSZWMuaGFzaCA9IHBlbmRpbmdSZWMucG9zdEhhc2g7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiggcGVuZGluZ1JlYy5hY3Rpb24gPT09IFwiZGVsZXRlXCIgJiYgbmV3UmVjKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSByZWNvcmQgZnJvbSB0aGUgbmV3IGRhdGFzZXQgc28gdGhlIGxvY2FsIGRhdGFzZXQgaXMgY29uc2lzdGVudFxuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdEYXRhLnJlY29yZHNbcGVuZGluZ1JlYy51aWRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYoIHBlbmRpbmdSZWMuYWN0aW9uID09PSBcImNyZWF0ZVwiICkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcGVuZGluZyBjcmVhdGUgaW50byB0aGUgbmV3IGRhdGFzZXQgc28gaXQgaXMgbm90IGxvc3QgZnJvbSB0aGUgVUlcbiAgICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0ZU5ld0RhdGFGcm9tSW5GbGlnaHQgLSByZSBhZGRpbmcgcGVuZGluZyBjcmVhdGUgdG8gaW5jb21taW5nIGRhdGFzZXQnKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UGVuZGluZ0NyZWF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHBlbmRpbmdSZWMucG9zdCxcbiAgICAgICAgICAgICAgICAgIGhhc2g6IHBlbmRpbmdSZWMucG9zdEhhc2hcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5ld0RhdGEucmVjb3Jkc1twZW5kaW5nUmVjLnVpZF0gPSBuZXdQZW5kaW5nQ3JlYXRlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZU5ld0RhdGFGcm9tUGVuZGluZzogZnVuY3Rpb24oZGF0YXNldF9pZCwgZGF0YXNldCwgbmV3RGF0YSkge1xuICAgIHZhciBwZW5kaW5nID0gZGF0YXNldC5wZW5kaW5nO1xuXG4gICAgaWYoIHBlbmRpbmcgJiYgbmV3RGF0YS5yZWNvcmRzKSB7XG4gICAgICBmb3IoIHZhciBwZW5kaW5nSGFzaCBpbiBwZW5kaW5nICkge1xuICAgICAgICBpZiggcGVuZGluZy5oYXNPd25Qcm9wZXJ0eShwZW5kaW5nSGFzaCkgKSB7XG4gICAgICAgICAgdmFyIHBlbmRpbmdSZWMgPSBwZW5kaW5nW3BlbmRpbmdIYXNoXTtcblxuICAgICAgICAgIGlmKCBwZW5kaW5nUmVjLmluRmxpZ2h0ID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygndXBkYXRlTmV3RGF0YUZyb21QZW5kaW5nIC0gRm91bmQgTm9uIGluRmxpZ2h0IHJlY29yZCAtPiBhY3Rpb249JyArIHBlbmRpbmdSZWMuYWN0aW9uICsnIDo6IHVpZD0nICsgcGVuZGluZ1JlYy51aWQgICsgJyA6OiBoYXNoPScgKyBwZW5kaW5nUmVjLmhhc2gpO1xuICAgICAgICAgICAgdmFyIG5ld1JlYyA9IG5ld0RhdGEucmVjb3Jkc1twZW5kaW5nUmVjLnVpZF07XG4gICAgICAgICAgICBpZiggcGVuZGluZ1JlYy5hY3Rpb24gPT09IFwidXBkYXRlXCIgJiYgbmV3UmVjKSB7XG4gICAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgbmV3IFJlY29yZCB0byBoYXZlIHRoZSB1cGRhdGVzIGZyb20gdGhlIHBlbmRpbmcgcmVjb3JkIHNvIHRoZSBsb2NhbCBkYXRhc2V0IGlzIGNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgbmV3UmVjLmRhdGEgPSBwZW5kaW5nUmVjLnBvc3Q7XG4gICAgICAgICAgICAgIG5ld1JlYy5oYXNoID0gcGVuZGluZ1JlYy5wb3N0SGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoIHBlbmRpbmdSZWMuYWN0aW9uID09PSBcImRlbGV0ZVwiICYmIG5ld1JlYykge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHJlY29yZCBmcm9tIHRoZSBuZXcgZGF0YXNldCBzbyB0aGUgbG9jYWwgZGF0YXNldCBpcyBjb25zaXN0ZW50XG4gICAgICAgICAgICAgIGRlbGV0ZSBuZXdEYXRhLnJlY29yZHNbcGVuZGluZ1JlYy51aWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiggcGVuZGluZ1JlYy5hY3Rpb24gPT09IFwiY3JlYXRlXCIgKSB7XG4gICAgICAgICAgICAgIC8vIEFkZCB0aGUgcGVuZGluZyBjcmVhdGUgaW50byB0aGUgbmV3IGRhdGFzZXQgc28gaXQgaXMgbm90IGxvc3QgZnJvbSB0aGUgVUlcbiAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCd1cGRhdGVOZXdEYXRhRnJvbVBlbmRpbmcgLSByZSBhZGRpbmcgcGVuZGluZyBjcmVhdGUgdG8gaW5jb21taW5nIGRhdGFzZXQnKTtcbiAgICAgICAgICAgICAgdmFyIG5ld1BlbmRpbmdDcmVhdGUgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogcGVuZGluZ1JlYy5wb3N0LFxuICAgICAgICAgICAgICAgIGhhc2g6IHBlbmRpbmdSZWMucG9zdEhhc2hcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbmV3RGF0YS5yZWNvcmRzW3BlbmRpbmdSZWMudWlkXSA9IG5ld1BlbmRpbmdDcmVhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZUNyYXNoZWRJbkZsaWdodEZyb21OZXdEYXRhOiBmdW5jdGlvbihkYXRhc2V0X2lkLCBkYXRhc2V0LCBuZXdEYXRhKSB7XG4gICAgdmFyIHVwZGF0ZU5vdGlmaWNhdGlvbnMgPSB7XG4gICAgICBhcHBsaWVkOiBzZWxmLm5vdGlmaWNhdGlvbnMuUkVNT1RFX1VQREFURV9BUFBMSUVELFxuICAgICAgZmFpbGVkOiBzZWxmLm5vdGlmaWNhdGlvbnMuUkVNT1RFX1VQREFURV9GQUlMRUQsXG4gICAgICBjb2xsaXNpb25zOiBzZWxmLm5vdGlmaWNhdGlvbnMuQ09MTElTSU9OX0RFVEVDVEVEXG4gICAgfTtcblxuICAgIHZhciBwZW5kaW5nID0gZGF0YXNldC5wZW5kaW5nO1xuICAgIHZhciByZXNvbHZlZENyYXNoZXMgPSB7fTtcbiAgICB2YXIgcGVuZGluZ0hhc2g7XG4gICAgdmFyIHBlbmRpbmdSZWM7XG5cblxuICAgIGlmKCBwZW5kaW5nICkge1xuICAgICAgZm9yKCBwZW5kaW5nSGFzaCBpbiBwZW5kaW5nICkge1xuICAgICAgICBpZiggcGVuZGluZy5oYXNPd25Qcm9wZXJ0eShwZW5kaW5nSGFzaCkgKSB7XG4gICAgICAgICAgcGVuZGluZ1JlYyA9IHBlbmRpbmdbcGVuZGluZ0hhc2hdO1xuXG4gICAgICAgICAgaWYoIHBlbmRpbmdSZWMuaW5GbGlnaHQgJiYgcGVuZGluZ1JlYy5jcmFzaGVkKSB7XG4gICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0ZUNyYXNoZWRJbkZsaWdodEZyb21OZXdEYXRhIC0gRm91bmQgY3Jhc2hlZCBpbkZsaWdodCBwZW5kaW5nIHJlY29yZCB1aWQ9JyArIHBlbmRpbmdSZWMudWlkICsgJyA6OiBoYXNoPScgKyBwZW5kaW5nUmVjLmhhc2ggKTtcbiAgICAgICAgICAgIGlmKCBuZXdEYXRhICYmIG5ld0RhdGEudXBkYXRlcyAmJiBuZXdEYXRhLnVwZGF0ZXMuaGFzaGVzKSB7XG5cbiAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHVwZGF0ZXMgcmVjZWl2ZWQgY29udGFpbiBhbnkgaW5mbyBhYm91dCB0aGUgY3Jhc2hlZCBpbiBmbGlnaHQgdXBkYXRlXG4gICAgICAgICAgICAgIHZhciBjcmFzaGVkVXBkYXRlID0gbmV3RGF0YS51cGRhdGVzLmhhc2hlc1twZW5kaW5nSGFzaF07XG4gICAgICAgICAgICAgIGlmKCBjcmFzaGVkVXBkYXRlICkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgZm91bmQgYW4gdXBkYXRlIG9uIG9uZSBvZiBvdXIgaW4gZmxpZ2h0IGNyYXNoZWQgcmVjb3Jkc1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRDcmFzaGVzW2NyYXNoZWRVcGRhdGUudWlkXSA9IGNyYXNoZWRVcGRhdGU7XG5cbiAgICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0ZUNyYXNoZWRJbkZsaWdodEZyb21OZXdEYXRhIC0gUmVzb2x2aW5nIHN0YXR1cyBmb3IgY3Jhc2hlZCBpbmZsaWdodCBwZW5kaW5nIHJlY29yZCAnICsgSlNPTi5zdHJpbmdpZnkoY3Jhc2hlZFVwZGF0ZSkpO1xuXG4gICAgICAgICAgICAgICAgaWYoIGNyYXNoZWRVcGRhdGUudHlwZSA9PT0gJ2ZhaWxlZCcgKSB7XG4gICAgICAgICAgICAgICAgICAvLyBDcmFzaGVkIHVwZGF0ZSBmYWlsZWQgLSByZXZlcnQgbG9jYWwgZGF0YXNldFxuICAgICAgICAgICAgICAgICAgaWYoIGNyYXNoZWRVcGRhdGUuYWN0aW9uID09PSAnY3JlYXRlJyApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCd1cGRhdGVDcmFzaGVkSW5GbGlnaHRGcm9tTmV3RGF0YSAtIERlbGV0aW5nIGZhaWxlZCBjcmVhdGUgZnJvbSBkYXRhc2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhc2V0LmRhdGFbY3Jhc2hlZFVwZGF0ZS51aWRdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIGNyYXNoZWRVcGRhdGUuYWN0aW9uID09PSAndXBkYXRlJyB8fCBjcmFzaGVkVXBkYXRlLmFjdGlvbiA9PT0gJ2RlbGV0ZScgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygndXBkYXRlQ3Jhc2hlZEluRmxpZ2h0RnJvbU5ld0RhdGEgLSBSZXZlcnRpbmcgZmFpbGVkICcgKyBjcmFzaGVkVXBkYXRlLmFjdGlvbiArICcgaW4gZGF0YXNldCcpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhc2V0LmRhdGFbY3Jhc2hlZFVwZGF0ZS51aWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGEgOiBwZW5kaW5nUmVjLnByZSxcbiAgICAgICAgICAgICAgICAgICAgICBoYXNoIDogcGVuZGluZ1JlYy5wcmVIYXNoXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHBlbmRpbmdbcGVuZGluZ0hhc2hdO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9Ob3RpZnkoZGF0YXNldF9pZCwgY3Jhc2hlZFVwZGF0ZS51aWQsIHVwZGF0ZU5vdGlmaWNhdGlvbnNbY3Jhc2hlZFVwZGF0ZS50eXBlXSwgY3Jhc2hlZFVwZGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gd29yZCBvbiBvdXIgY3Jhc2hlZCB1cGRhdGUgLSBpbmNyZW1lbnQgYSBjb3VudGVyIHRvIHJlZmxlY3QgYW5vdGhlciBzeW5jIHRoYXQgZGlkIG5vdCBnaXZlIHVzXG4gICAgICAgICAgICAgICAgLy8gYW55IHVwZGF0ZSBvbiBvdXIgY3Jhc2hlZCByZWNvcmQuXG4gICAgICAgICAgICAgICAgaWYoIHBlbmRpbmdSZWMuY3Jhc2hlZENvdW50ICkge1xuICAgICAgICAgICAgICAgICAgcGVuZGluZ1JlYy5jcmFzaGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLmNyYXNoZWRDb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTm8gd29yZCBvbiBvdXIgY3Jhc2hlZCB1cGRhdGUgLSBpbmNyZW1lbnQgYSBjb3VudGVyIHRvIHJlZmxlY3QgYW5vdGhlciBzeW5jIHRoYXQgZGlkIG5vdCBnaXZlIHVzXG4gICAgICAgICAgICAgIC8vIGFueSB1cGRhdGUgb24gb3VyIGNyYXNoZWQgcmVjb3JkLlxuICAgICAgICAgICAgICBpZiggcGVuZGluZ1JlYy5jcmFzaGVkQ291bnQgKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ1JlYy5jcmFzaGVkQ291bnQrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLmNyYXNoZWRDb3VudCA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yKCBwZW5kaW5nSGFzaCBpbiBwZW5kaW5nICkge1xuICAgICAgICBpZiggcGVuZGluZy5oYXNPd25Qcm9wZXJ0eShwZW5kaW5nSGFzaCkgKSB7XG4gICAgICAgICAgcGVuZGluZ1JlYyA9IHBlbmRpbmdbcGVuZGluZ0hhc2hdO1xuXG4gICAgICAgICAgaWYoIHBlbmRpbmdSZWMuaW5GbGlnaHQgJiYgcGVuZGluZ1JlYy5jcmFzaGVkKSB7XG4gICAgICAgICAgICBpZiggcGVuZGluZ1JlYy5jcmFzaGVkQ291bnQgPiBkYXRhc2V0LmNvbmZpZy5jcmFzaGVkX2NvdW50X3dhaXQgKSB7XG4gICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygndXBkYXRlQ3Jhc2hlZEluRmxpZ2h0RnJvbU5ld0RhdGEgLSBDcmFzaGVkIGluZmxpZ2h0IHBlbmRpbmcgcmVjb3JkIGhhcyByZWFjaGVkIGNyYXNoZWRfY291bnRfd2FpdCBsaW1pdCA6ICcgKyBKU09OLnN0cmluZ2lmeShwZW5kaW5nUmVjKSk7XG4gICAgICAgICAgICAgIGlmKCBkYXRhc2V0LmNvbmZpZy5yZXNlbmRfY3Jhc2hlZF91cGRhdGVzICkge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygndXBkYXRlQ3Jhc2hlZEluRmxpZ2h0RnJvbU5ld0RhdGEgLSBSZXRyeWlnIGNyYXNoZWQgaW5mbGlnaHQgcGVuZGluZyByZWNvcmQnKTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLmNyYXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLmluRmxpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCd1cGRhdGVDcmFzaGVkSW5GbGlnaHRGcm9tTmV3RGF0YSAtIERlbGV0aW5nIGNyYXNoZWQgaW5mbGlnaHQgcGVuZGluZyByZWNvcmQnKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGVuZGluZ1twZW5kaW5nSGFzaF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIXBlbmRpbmdSZWMuaW5GbGlnaHQgJiYgcGVuZGluZ1JlYy5jcmFzaGVkICkge1xuICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCd1cGRhdGVDcmFzaGVkSW5GbGlnaHRGcm9tTmV3RGF0YSAtIFRyeWluZyB0byByZXNvbHZlIGlzc3VlcyB3aXRoIGNyYXNoZWQgbm9uIGluIGZsaWdodCByZWNvcmQgLSB1aWQgPSAnICsgcGVuZGluZ1JlYy51aWQpO1xuICAgICAgICAgICAgLy8gU3RhbGxlZCBwZW5kaW5nIHJlY29yZCBiZWNhdXNlIGEgcHJldmlvdXMgcGVuZGluZyB1cGRhdGUgb24gdGhlIHNhbWUgcmVjb3JkIGNyYXNoZWRcbiAgICAgICAgICAgIHZhciBjcmFzaGVkUmVmID0gcmVzb2x2ZWRDcmFzaGVzW3BlbmRpbmdSZWMudWlkXTtcbiAgICAgICAgICAgIGlmKCBjcmFzaGVkUmVmICkge1xuICAgICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0ZUNyYXNoZWRJbkZsaWdodEZyb21OZXdEYXRhIC0gRm91bmQgYSBzdGFsbGVkIHBlbmRpbmcgcmVjb3JkIGJhY2tlZCB1cCBiZWhpbmQgYSByZXNvbHZlZCBjcmFzaCB1aWQ9JyArIHBlbmRpbmdSZWMudWlkICsgJyA6OiBoYXNoPScgKyBwZW5kaW5nUmVjLmhhc2gpO1xuICAgICAgICAgICAgICBwZW5kaW5nUmVjLmNyYXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlRGVsYXllZEZyb21OZXdEYXRhOiBmdW5jdGlvbihkYXRhc2V0X2lkLCBkYXRhc2V0LCBuZXdEYXRhKXtcbiAgICB2YXIgcGVuZGluZyA9IGRhdGFzZXQucGVuZGluZztcbiAgICB2YXIgcGVuZGluZ0hhc2g7XG4gICAgdmFyIHBlbmRpbmdSZWM7XG4gICAgaWYocGVuZGluZyl7XG4gICAgICBmb3IoIHBlbmRpbmdIYXNoIGluIHBlbmRpbmcgKXtcbiAgICAgICAgaWYoIHBlbmRpbmcuaGFzT3duUHJvcGVydHkocGVuZGluZ0hhc2gpICl7XG4gICAgICAgICAgcGVuZGluZ1JlYyA9IHBlbmRpbmdbcGVuZGluZ0hhc2hdO1xuICAgICAgICAgIGlmKCBwZW5kaW5nUmVjLmRlbGF5ZWQgJiYgcGVuZGluZ1JlYy53YWl0aW5nICl7XG4gICAgICAgICAgICBzZWxmLmNvbnNvbGVMb2coJ3VwZGF0ZURlbGF5ZWRGcm9tTmV3RGF0YSAtIEZvdW5kIGRlbGF5ZWQgcGVuZGluZyByZWNvcmQgdWlkPScgKyBwZW5kaW5nUmVjLnVpZCArICcgOjogaGFzaD0nICsgcGVuZGluZ1JlYy5oYXNoICsgJyA6OiB3YWl0aW5nPScgKyBwZW5kaW5nUmVjLndhaXRpbmcpO1xuICAgICAgICAgICAgaWYoIG5ld0RhdGEgJiYgbmV3RGF0YS51cGRhdGVzICYmIG5ld0RhdGEudXBkYXRlcy5oYXNoZXMgKXtcbiAgICAgICAgICAgICAgdmFyIHdhaXRpbmdSZWMgPSBuZXdEYXRhLnVwZGF0ZXMuaGFzaGVzW3BlbmRpbmdSZWMud2FpdGluZ107XG4gICAgICAgICAgICAgIGlmKHdhaXRpbmdSZWMpe1xuICAgICAgICAgICAgICAgIHNlbGYuY29uc29sZUxvZygndXBkYXRlRGVsYXllZEZyb21OZXdEYXRhIC0gV2FpdGluZyBwZW5kaW5nIHJlY29yZCBpcyByZXNvbHZlZCByZWM9JyArIEpTT04uc3RyaW5naWZ5KHdhaXRpbmdSZWMpKTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLmRlbGF5ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVjLndhaXRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cblxuICBtYXJrSW5GbGlnaHRBc0NyYXNoZWQgOiBmdW5jdGlvbihkYXRhc2V0KSB7XG4gICAgdmFyIHBlbmRpbmcgPSBkYXRhc2V0LnBlbmRpbmc7XG4gICAgdmFyIHBlbmRpbmdIYXNoO1xuICAgIHZhciBwZW5kaW5nUmVjO1xuXG4gICAgaWYoIHBlbmRpbmcgKSB7XG4gICAgICB2YXIgY3Jhc2hlZFJlY29yZHMgPSB7fTtcbiAgICAgIGZvciggcGVuZGluZ0hhc2ggaW4gcGVuZGluZyApIHtcbiAgICAgICAgaWYoIHBlbmRpbmcuaGFzT3duUHJvcGVydHkocGVuZGluZ0hhc2gpICkge1xuICAgICAgICAgIHBlbmRpbmdSZWMgPSBwZW5kaW5nW3BlbmRpbmdIYXNoXTtcblxuICAgICAgICAgIGlmKCBwZW5kaW5nUmVjLmluRmxpZ2h0ICkge1xuICAgICAgICAgICAgc2VsZi5jb25zb2xlTG9nKCdNYXJraW5nIGluIGZsaWdodCBwZW5kaW5nIHJlY29yZCBhcyBjcmFzaGVkIDogJyArIHBlbmRpbmdIYXNoKTtcbiAgICAgICAgICAgIHBlbmRpbmdSZWMuY3Jhc2hlZCA9IHRydWU7XG4gICAgICAgICAgICBjcmFzaGVkUmVjb3Jkc1twZW5kaW5nUmVjLnVpZF0gPSBwZW5kaW5nUmVjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgYW55IHBlbmRpbmcgdXBkYXRlcyB0aGF0IHdvdWxkIGJlIG1vZGlmeWluZyBhIGNyYXNoZWQgcmVjb3JkLiBUaGVzZSBjYW4gbm90IGdvIG91dCB1bnRpbCB0aGVcbiAgICAgIC8vIHN0YXR1cyBvZiB0aGUgY3Jhc2hlZCByZWNvcmQgaXMgZGV0ZXJtaW5lZFxuICAgICAgZm9yKCBwZW5kaW5nSGFzaCBpbiBwZW5kaW5nICkge1xuICAgICAgICBpZiggcGVuZGluZy5oYXNPd25Qcm9wZXJ0eShwZW5kaW5nSGFzaCkgKSB7XG4gICAgICAgICAgcGVuZGluZ1JlYyA9IHBlbmRpbmdbcGVuZGluZ0hhc2hdO1xuXG4gICAgICAgICAgaWYoICEgcGVuZGluZ1JlYy5pbkZsaWdodCAmJiAhIHBlbmRpbmdSZWMuZGVsYXllZCApIHtcbiAgICAgICAgICAgIHZhciBjcmFzaGVkUmVmID0gY3Jhc2hlZFJlY29yZHNbcGVuZGluZ1JlYy51aWRdO1xuICAgICAgICAgICAgaWYoIGNyYXNoZWRSZWYgKSB7XG4gICAgICAgICAgICAgIHBlbmRpbmdSZWMuY3Jhc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbnNvbGVMb2c6IGZ1bmN0aW9uKG1zZykge1xuICAgIGlmKCBzZWxmLmNvbmZpZy5kb19jb25zb2xlX2xvZyApIHtcbiAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgfVxuICB9XG59O1xuXG4oZnVuY3Rpb24oKSB7XG4gIHNlbGYuY29uZmlnID0gc2VsZi5kZWZhdWx0cztcbiAgLy9Jbml0aWFsc2UgdGhlIHN5bmMgc2VydmljZSB3aXRoIGRlZmF1bHQgY29uZmlnXG4gIC8vc2VsZi5pbml0KHt9KTtcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0OiBzZWxmLmluaXQsXG4gIG1hbmFnZTogc2VsZi5tYW5hZ2UsXG4gIG5vdGlmeTogc2VsZi5ub3RpZnksXG4gIGRvTGlzdDogc2VsZi5saXN0LFxuICBkb0NyZWF0ZTogc2VsZi5jcmVhdGUsXG4gIGRvUmVhZDogc2VsZi5yZWFkLFxuICBkb1VwZGF0ZTogc2VsZi51cGRhdGUsXG4gIGRvRGVsZXRlOiBzZWxmWydkZWxldGUnXSxcbiAgbGlzdENvbGxpc2lvbnM6IHNlbGYubGlzdENvbGxpc2lvbnMsXG4gIHJlbW92ZUNvbGxpc2lvbjogc2VsZi5yZW1vdmVDb2xsaXNpb24sXG4gIGdldFBlbmRpbmcgOiBzZWxmLmdldFBlbmRpbmcsXG4gIGNsZWFyUGVuZGluZyA6IHNlbGYuY2xlYXJQZW5kaW5nLFxuICBnZXREYXRhc2V0IDogc2VsZi5nZXREYXRhU2V0LFxuICBnZXRRdWVyeVBhcmFtczogc2VsZi5nZXRRdWVyeVBhcmFtcyxcbiAgc2V0UXVlcnlQYXJhbXM6IHNlbGYuc2V0UXVlcnlQYXJhbXMsXG4gIGdldE1ldGFEYXRhOiBzZWxmLmdldE1ldGFEYXRhLFxuICBzZXRNZXRhRGF0YTogc2VsZi5zZXRNZXRhRGF0YSxcbiAgZ2V0Q29uZmlnOiBzZWxmLmdldENvbmZpZyxcbiAgc2V0Q29uZmlnOiBzZWxmLnNldENvbmZpZyxcbiAgc3RhcnRTeW5jOiBzZWxmLnN0YXJ0U3luYyxcbiAgc3RvcFN5bmM6IHNlbGYuc3RvcFN5bmMsXG4gIGRvU3luYzogc2VsZi5kb1N5bmMsXG4gIGZvcmNlU3luYzogc2VsZi5mb3JjZVN5bmMsXG4gIGdlbmVyYXRlSGFzaDogc2VsZi5nZW5lcmF0ZUhhc2hcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZVVVSUQgOiBmdW5jdGlvbiAoKSB7XG4gICAgLy9mcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdFxuICAgIC8vYmFzZWQgb24gUkZDIDQxMjIsIHNlY3Rpb24gNC40IChBbGdvcml0aG1zIGZvciBjcmVhdGluZyBVVUlEIGZyb20gdHJ1ZWx5IHJhbmRvbSBwciBwc2V1ZG8tcmFuZG9tIG51bWJlcilcbiAgICB2YXIgcyA9IFtdO1xuICAgIHZhciBoZXhEaWdpdGFscyA9IFwiMDEyMzQ1Njc4OUFCQ0RFRlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgc1tpXSA9IGhleERpZ2l0YWxzLnN1YnN0cihNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDEwKSwgMSk7XG4gICAgfVxuICAgIHNbMTJdID0gXCI0XCI7XG4gICAgc1sxNl0gPSBoZXhEaWdpdGFscy5zdWJzdHIoKHNbMTZdICYgMHgzKSB8IDB4OCwgMSk7XG4gICAgdmFyIHV1aWQgPSBzLmpvaW4oXCJcIik7XG4gICAgcmV0dXJuIHV1aWQ7XG4gIH1cbn07XG4iLCJ2YXIgaW5pdGlhbGl6ZXIgPSByZXF1aXJlKFwiLi9pbml0aWFsaXplclwiKTtcbnZhciBldmVudHMgPSByZXF1aXJlKFwiLi9ldmVudHNcIik7XG52YXIgQ2xvdWRIb3N0ID0gcmVxdWlyZShcIi4vaG9zdHNcIik7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIGxvZ2dlciA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcblxuXG4vL3RoZSBjbG91ZCBjb25maWd1cmF0aW9uc1xudmFyIGNsb3VkX2hvc3Q7XG5cbnZhciBpc19pbml0aWFsaXNpbmcgPSBmYWxzZTtcbnZhciBpc19jbG91ZF9yZWFkeSA9IGZhbHNlO1xudmFyIGluaXRfZXJyb3IgPSBudWxsO1xuXG5cbnZhciByZWFkeSA9IGZ1bmN0aW9uKGNiKXtcbiAgaWYoaXNfY2xvdWRfcmVhZHkpe1xuICAgIHJldHVybiBjYihudWxsLCB7aG9zdDogZ2V0Q2xvdWRIb3N0VXJsKCl9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMub25jZShjb25zdGFudHMuSU5JVF9FVkVOVCwgZnVuY3Rpb24oZXJyLCBob3N0KXtcbiAgICAgIHJldHVybiBjYihlcnIsIGhvc3QpO1xuICAgIH0pO1xuICAgIGlmKCFpc19pbml0aWFsaXNpbmcpe1xuICAgICAgaXNfaW5pdGlhbGlzaW5nID0gdHJ1ZTtcbiAgICAgIGluaXRpYWxpemVyLmluaXQoZnVuY3Rpb24oZXJyLCBpbml0UmVzKXtcbiAgICAgICAgaXNfaW5pdGlhbGlzaW5nID0gZmFsc2U7XG4gICAgICAgIGlmKGVycil7XG4gICAgICAgICAgaW5pdF9lcnJvciA9IGVycjtcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmVtaXQoY29uc3RhbnRzLklOSVRfRVZFTlQsIGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5pdF9lcnJvciA9IG51bGw7XG4gICAgICAgICAgaXNfY2xvdWRfcmVhZHkgPSB0cnVlO1xuICAgICAgICAgIGNsb3VkX2hvc3QgPSBuZXcgQ2xvdWRIb3N0KGluaXRSZXMuY2xvdWQpO1xuICAgICAgICAgIHJldHVybiBldmVudHMuZW1pdChjb25zdGFudHMuSU5JVF9FVkVOVCwgbnVsbCwge2hvc3Q6IGdldENsb3VkSG9zdFVybCgpfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZ2V0Q2xvdWRIb3N0ID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGNsb3VkX2hvc3Q7XG59XG5cbnZhciBnZXRDbG91ZEhvc3RVcmwgPSBmdW5jdGlvbigpe1xuICBpZih0eXBlb2YgY2xvdWRfaG9zdCAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgdmFyIGFwcFByb3BzID0gcmVxdWlyZShcIi4vYXBwUHJvcHNcIikuZ2V0QXBwUHJvcHMoKTtcbiAgICByZXR1cm4gY2xvdWRfaG9zdC5nZXRIb3N0KGFwcFByb3BzLm1vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxudmFyIGlzUmVhZHkgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gaXNfY2xvdWRfcmVhZHk7XG59XG5cbnZhciBnZXRJbml0RXJyb3IgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gaW5pdF9lcnJvcjtcbn1cblxuLy9mb3IgdGVzdFxudmFyIHJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgaXNfY2xvdWRfcmVhZHkgPSBmYWxzZTtcbiAgaXNfaW5pdGlhbGlzaW5nID0gZmFsc2U7XG4gIGNsb3VkX2hvc3QgPSB1bmRlZmluZWQ7XG4gIGluaXRfZXJyb3IgPSB1bmRlZmluZWQ7XG4gIHJlYWR5KGZ1bmN0aW9uKCl7XG4gICAgXG4gIH0pO1xufVxuXG5yZWFkeShmdW5jdGlvbihlcnJvciwgaG9zdCl7XG4gIGlmKGVycm9yKXtcbiAgICBpZihlcnJvci5tZXNzYWdlICE9PSBcImFwcF9jb25maWdfbWlzc2luZ1wiKXtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBpbml0aWFsaXNlIGZoLlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmluZm8oXCJObyBmaCBjb25maWcgZmlsZVwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyLmluZm8oXCJmaCBjbG91ZCBpcyByZWFkeVwiKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZWFkeTogcmVhZHksXG4gIGlzUmVhZHk6IGlzUmVhZHksXG4gIGdldENsb3VkSG9zdDogZ2V0Q2xvdWRIb3N0LFxuICBnZXRDbG91ZEhvc3RVcmw6IGdldENsb3VkSG9zdFVybCxcbiAgZ2V0SW5pdEVycm9yOiBnZXRJbml0RXJyb3IsXG4gIHJlc2V0OiByZXNldFxufSIsInJlcXVpcmUoXCIuLi90ZXN0cy90ZXN0X2FqYXguanNcIik7XG5yZXF1aXJlKFwiLi4vdGVzdHMvdGVzdF9zZWMuanNcIik7XG5yZXF1aXJlKFwiLi4vdGVzdHMvdGVzdF9jbG91ZF9yZWxhdGVkLmpzXCIpO1xucmVxdWlyZShcIi4uL3Rlc3RzL3Rlc3RfbGVnYWN5X2FjdC5qc1wiKTtcbnJlcXVpcmUoXCIuLi90ZXN0cy90ZXN0X3N5bmNfb2ZmbGluZS5qc1wiKTtcbnJlcXVpcmUoXCIuLi90ZXN0cy90ZXN0X3N5bmNfb25saW5lLmpzXCIpO1xuXG4iLCJ2YXIgY2hhaSA9IHJlcXVpcmUoJ2NoYWknKTtcbnZhciBleHBlY3QgPSBjaGFpLmV4cGVjdDtcbnZhciBzaW5vbkNoYWkgPSByZXF1aXJlKCdzaW5vbi1jaGFpJyk7XG5jaGFpLnVzZShzaW5vbkNoYWkpO1xuXG52YXIgcHJvY2VzcyA9IHJlcXVpcmUoXCJwcm9jZXNzXCIpO1xuaWYoZG9jdW1lbnQgJiYgZG9jdW1lbnQubG9jYXRpb24pe1xuICBpZihkb2N1bWVudC5sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJjb3ZlcmFnZT0xXCIpID4gLTEpe1xuICAgIHByb2Nlc3MuZW52LkxJQl9DT1YgPSAxO1xuICB9XG59XG5cbnZhciBhamF4ID0gcHJvY2Vzcy5lbnYuTElCX0NPVj8gcmVxdWlyZShcIi4uLy4uL3NyYy1jb3YvbW9kdWxlcy9hamF4XCIpIDogcmVxdWlyZShcIi4uLy4uL3NyYy9tb2R1bGVzL2FqYXhcIik7XG52YXIgZXZlbnRzID0gcHJvY2Vzcy5lbnYuTElCX0NPVj8gcmVxdWlyZShcIi4uLy4uL3NyYy1jb3YvbW9kdWxlcy9ldmVudHNcIikgOiByZXF1aXJlKFwiLi4vLi4vc3JjL21vZHVsZXMvZXZlbnRzXCIpO1xuXG5cbmRlc2NyaWJlKFwidGVzdCBhamF4IG1vZHVsZVwiLCBmdW5jdGlvbigpe1xuXG4gICAgdmFyIHNlcnZlcjtcblxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkgeyBzZXJ2ZXIgPSBzaW5vbi5mYWtlU2VydmVyLmNyZWF0ZSgpOyB9KTtcbiAgICBhZnRlckVhY2goZnVuY3Rpb24gKCkgeyBzZXJ2ZXIucmVzdG9yZSgpOyB9KTtcblxuICAgIGl0KFwic2hvdWxkIGNhbGwgdGhlIHN1Y2Nlc3MgY2FsbGJhY2tcIiwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciBzdWNjZXNzID0gc2lub24uc3B5KCk7XG4gICAgICB2YXIgZmFpbCA9IHNpbm9uLnNweSgpO1xuXG4gICAgICBhamF4LmFjdGl2ZSA9IDA7XG5cbiAgICAgIHZhciBhamF4U3RhcnQgPSBzaW5vbi5zcHkoKTtcbiAgICAgIHZhciBhamF4U2VuZCA9IHNpbm9uLnNweSgpO1xuICAgICAgdmFyIGFqYXhTdWNjZXNzID0gc2lub24uc3B5KCk7XG4gICAgICB2YXIgYWpheENvbXBsZXRlID0gc2lub24uc3B5KCk7XG5cbiAgICAgIGV2ZW50cy5vbihcImFqYXhTdGFydFwiLCBhamF4U3RhcnQpO1xuICAgICAgZXZlbnRzLm9uKFwiYWpheFNlbmRcIiwgYWpheFNlbmQpO1xuICAgICAgZXZlbnRzLm9uKFwiYWpheFN1Y2Nlc3NcIiwgYWpheFN1Y2Nlc3MpO1xuICAgICAgZXZlbnRzLm9uKFwiYWpheENvbXBsZXRlXCIsIGFqYXhDb21wbGV0ZSk7XG5cbiAgICAgIHNlcnZlci5yZXNwb25kV2l0aCgnR0VUJywgL3Rlc3Rfb2svLCBbMjAwLCB7XCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJ9LCBKU09OLnN0cmluZ2lmeSh7XCJyZXN1bHRcIjogXCJva1wifSldKTtcbiAgICAgIFxuICAgICAgYWpheCh7XG4gICAgICAgIHVybDogXCJ0ZXN0X29rXCIsXG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuICAgICAgICBub2pzb25wOiB0cnVlLFxuICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICBlcnJvcjogZmFpbFxuICAgICAgfSk7XG5cbiAgICAgIHNlcnZlci5yZXNwb25kKCk7XG5cbiAgICAgIGV4cGVjdChzdWNjZXNzKS50by5oYXZlLmJlZW4uY2FsbGVkO1xuICAgICAgZXhwZWN0KHN1Y2Nlc3MpLnRvLmhhdmUuYmVlbi5jYWxsZWRPbmNlO1xuXG4gICAgICBleHBlY3QoYWpheFN0YXJ0KS50by5oYXZlLmJlZW4uY2FsbGVkT25jZTtcbiAgICAgIGV4cGVjdChhamF4U2VuZCkudG8uaGF2ZS5iZWVuLmNhbGxlZE9uY2U7XG4gICAgICBleHBlY3QoYWpheFN1Y2Nlc3MpLnRvLmhhdmUuYmVlbi5jYWxsZWRPbmNlO1xuICAgICAgZXhwZWN0KGFqYXhDb21wbGV0ZSkudG8uaGF2ZS5iZWVuLmNhbGxlZE9uY2U7XG4gICAgICBcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGNhbGwgdGhlIGVycm9yIGNhbGxiYWNrXCIsIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgc3VjY2VzcyA9IHNpbm9uLnNweSgpO1xuICAgICAgdmFyIGZhaWwgPSBzaW5vbi5zcHkoKTtcblxuICAgICAgYWpheC5hY3RpdmUgPSAwO1xuXG4gICAgICB2YXIgYWpheFN0YXJ0ID0gc2lub24uc3B5KCk7XG4gICAgICB2YXIgYWpheFNlbmQgPSBzaW5vbi5zcHkoKTtcbiAgICAgIHZhciBhamF4RXJyb3IgPSBzaW5vbi5zcHkoKTtcbiAgICAgIHZhciBhamF4Q29tcGxldGUgPSBzaW5vbi5zcHkoKTtcblxuICAgICAgZXZlbnRzLm9uKFwiYWpheFN0YXJ0XCIsIGFqYXhTdGFydCk7XG4gICAgICBldmVudHMub24oXCJhamF4U2VuZFwiLCBhamF4U2VuZCk7XG4gICAgICBldmVudHMub24oXCJhamF4RXJyb3JcIiwgYWpheEVycm9yKTtcbiAgICAgIGV2ZW50cy5vbihcImFqYXhDb21wbGV0ZVwiLCBhamF4Q29tcGxldGUpO1xuXG4gICAgICBzZXJ2ZXIucmVzcG9uZFdpdGgoJ0dFVCcsIC90ZXN0X2Vycm9yLywgWzQwNCwge1wiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwifSwgXCJOT1QgRk9VTkRcIl0pO1xuXG4gICAgICBhamF4KHtcbiAgICAgICAgdXJsOiBcInRlc3RfZXJyb3JcIixcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgIG5vanNvbnA6IHRydWUsXG4gICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgIGVycm9yOiBmYWlsXG4gICAgICB9KTtcblxuICAgICAgc2VydmVyLnJlc3BvbmQoKTtcblxuICAgICAgZXhwZWN0KGZhaWwpLnRvLmhhdmUuYmVlbi5jYWxsZWQ7XG4gICAgICBleHBlY3QoZmFpbCkudG8uaGF2ZS5iZWVuLmNhbGxlZE9uY2U7XG5cbiAgICAgIGV4cGVjdChhamF4U3RhcnQpLnRvLmhhdmUuYmVlbi5jYWxsZWRPbmNlO1xuICAgICAgZXhwZWN0KGFqYXhTZW5kKS50by5oYXZlLmJlZW4uY2FsbGVkT25jZTtcbiAgICAgIGV4cGVjdChhamF4RXJyb3IpLnRvLmhhdmUuYmVlbi5jYWxsZWRPbmNlO1xuICAgICAgZXhwZWN0KGFqYXhDb21wbGV0ZSkudG8uaGF2ZS5iZWVuLmNhbGxlZE9uY2U7XG5cbiAgICB9KTtcbiAgfSk7XG5cbiIsInZhciBjaGFpID0gcmVxdWlyZSgnY2hhaScpO1xudmFyIGV4cGVjdCA9IGNoYWkuZXhwZWN0O1xudmFyIHNpbm9uQ2hhaSA9IHJlcXVpcmUoJ3Npbm9uLWNoYWknKTtcblxudmFyIHByb2Nlc3MgPSByZXF1aXJlKFwicHJvY2Vzc1wiKTtcbmlmKGRvY3VtZW50ICYmIGRvY3VtZW50LmxvY2F0aW9uKXtcbiAgaWYoZG9jdW1lbnQubG9jYXRpb24uaHJlZi5pbmRleE9mKFwiY292ZXJhZ2U9MVwiKSA+IC0xKXtcbiAgICBwcm9jZXNzLmVudi5MSUJfQ09WID0gMTtcbiAgfVxufVxuXG52YXIgYWpheCA9IHByb2Nlc3MuZW52LkxJQl9DT1Y/IHJlcXVpcmUoXCIuLi8uLi9zcmMtY292L21vZHVsZXMvYWpheFwiKSA6IHJlcXVpcmUoXCIuLi8uLi9zcmMvbW9kdWxlcy9hamF4XCIpO1xudmFyIHFzID0gcHJvY2Vzcy5lbnYuTElCX0NPVj8gcmVxdWlyZShcIi4uLy4uL3NyYy1jb3YvbW9kdWxlcy9xdWVyeU1hcFwiKTogcmVxdWlyZShcIi4uLy4uL3NyYy9tb2R1bGVzL3F1ZXJ5TWFwXCIpO1xuXG5cbmNoYWkudXNlKHNpbm9uQ2hhaSk7XG5cbnZhciBmaGNvbmZpZyA9IHtcbiAgXCJob3N0XCI6IFwiaHR0cDovL2xvY2FsaG9zdDo4MTAwXCIsXG4gIFwiYXBwaWRcIiA6IFwidGVzdGFwcGlkXCIsXG4gIFwiYXBwa2V5XCIgOiBcInRlc3RhcHBrZXlcIixcbiAgXCJwcm9qZWN0aWRcIiA6IFwidGVzdHByb2plY3RpZFwiLFxuICBcImNvbm5lY3Rpb250YWdcIiA6IFwidGVzdGNvbm5lY3Rpb250YWdcIlxufVxuXG52YXIgYXBwaG9zdCA9IHtcbiAgZG9tYWluOiBcInRlc3RpbmdcIixcbiAgZmlyc3RUaW1lOiBmYWxzZSxcbiAgaG9zdHM6IHtcbiAgICBcInVybFwiOiBcImh0dHA6Ly9sb2NhbGhvc3Q6ODEwMVwiXG4gIH0sXG4gIGluaXQ6IHtcbiAgICBcInRyYWNrSWRcIjogXCJ0ZXN0dHJhY2tpZFwiXG4gIH1cbn1cblxudmFyIGV4cGVjdGVkVXJsID0gXCJodHRwOi8vbG9jYWxob3N0OjgxMDFcIjtcbmlmKGRvY3VtZW50ICYmIGRvY3VtZW50LmxvY2F0aW9uKXtcbiAgdmFyIGRvY191cmwgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuICB2YXIgdXJsX3BhcmFtcyA9IHFzKGRvY191cmwpO1xuICB2YXIgbG9jYWwgPSAodHlwZW9mIHVybF9wYXJhbXMudXJsICE9PSAndW5kZWZpbmVkJyk7XG4gIGlmKGxvY2FsKXtcbiAgICBleHBlY3RlZFVybCA9IHVybF9wYXJhbXMudXJsO1xuICB9XG59XG5cblxudmFyIGJ1aWxkRmFrZVJlcyA9IGZ1bmN0aW9uKGRhdGEpe1xuICByZXR1cm4gWzIwMCwge1wiQ29udGVudC1UeXBlXCI6IFwidGV4dC9zY3JpcHRcIn0sIEpTT04uc3RyaW5naWZ5KGRhdGEpXTsgLy93ZSBkZWxpYmVyYXRlbHkgc2V0IHRoZSB3cm9uZyBjb250ZW50IHR5cGUgaGVyZSB0byBtYWtlIHN1cmUgdGhlIHJlc3BvbnNlIGRvZXMgZ2V0IGNvbnZlcnRlZCB0byBKU09OXG59XG5cbnZhciBpbml0RmFrZVNlcnZlciA9IGZ1bmN0aW9uKHNlcnZlcil7XG4gICBzZXJ2ZXIucmVzcG9uZFdpdGgoJ0dFVCcsIC9maGNvbmZpZy5qc29uLywgYnVpbGRGYWtlUmVzKGZoY29uZmlnKSk7XG5cbiAgIHNlcnZlci5yZXNwb25kV2l0aCgnUE9TVCcsIC9pbml0LywgYnVpbGRGYWtlUmVzKGFwcGhvc3QpKTtcbn1cblxuZGVzY3JpYmUoXCJ0ZXN0IGFsbCBjbG91ZCByZWxhdGVkXCIsIGZ1bmN0aW9uKCl7XG5cbiAgdmFyIHNlcnZlcjtcblxuICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHsgc2VydmVyID0gc2lub24uZmFrZVNlcnZlci5jcmVhdGUoKTsgfSk7XG4gIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7IHNlcnZlci5yZXN0b3JlKCk7IH0pO1xuXG4gIGRlc2NyaWJlKFwidGVzdCBhdXRvIGluaXRpYWxpc2F0aW9uXCIsIGZ1bmN0aW9uKCl7XG4gICAgaXQoXCJzaG91bGQgZW1pdCBmaGluaXQgZXZlbnRzXCIsIGZ1bmN0aW9uKCl7XG5cbiAgICAgIHZhciBjYWxsYmFjayA9IHNpbm9uLnNweSgpO1xuICAgICAgdmFyIGNiMiA9IHNpbm9uLnNweSgpO1xuXG4gICAgICBpbml0RmFrZVNlcnZlcihzZXJ2ZXIpO1xuICAgICAgdmFyICRmaCA9IHByb2Nlc3MuZW52LkxJQl9DT1Y/IHJlcXVpcmUoXCIuLi8uLi9zcmMtY292L2ZlZWRoZW5yeVwiKSA6IHJlcXVpcmUoXCIuLi8uLi9zcmMvZmVlZGhlbnJ5XCIpO1xuICAgICAgLy9hdCB0aGlzIHBvaW50LCAkZmggaXMgYWxyZWFkeSBpbml0aWFsaXNlZCAoYW5kIGZhaWxlZCksIGl0IHdpbGwgbm90IGVtaXQgYW5vdGhlciBmaGluaXQgZXZlbnQgXG4gICAgICAvL3VudGlsIGFub3RoZXIgY2FsbCB0byBhbnkgJGZoIGNsb3VkIEFQSXMsIHNvIGZvciB0ZXN0aW5nLCBjYWxsIHJlc2V0IHdoaWNoIHdpbGwgZm9yY2UgaXQgdG8gcmUtaW50aWFsaXNlIGFnYWluLlxuICAgICAgJGZoLnJlc2V0KCk7XG5cbiAgICAgICRmaC5vbignZmhpbml0JywgY2FsbGJhY2spO1xuICAgICAgJGZoLm9uKCdmaGluaXQnLCBjYjIpO1xuXG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuICAgICAgc2VydmVyLnJlc3BvbmQoKTtcbiAgICAgIC8vaG9zdCB1cmwgaXMgb3ZlcnJpZGRlbiBieSB0aGUgdXJsIGluIHRoZSByZXF1ZXN0XG4gICAgICBleHBlY3QoY2FsbGJhY2spLnRvLmhhdmUuYmVlbi5jYWxsZWQ7XG4gICAgICBleHBlY3QoY2FsbGJhY2spLnRvLmhhdmUuYmVlbi5jYWxsZWRPbmNlO1xuICAgICAgZXhwZWN0KGNhbGxiYWNrKS50by5oYXZlLmJlZW4uY2FsbGVkV2l0aChudWxsLCB7aG9zdDogZXhwZWN0ZWRVcmx9KTtcblxuICAgICAgZXhwZWN0KGNiMikudG8uaGF2ZS5iZWVuLmNhbGxlZDtcbiAgICAgIGV4cGVjdChjYjIpLnRvLmhhdmUuYmVlbi5jYWxsZWRPbmNlO1xuXG4gICAgICB2YXIgaG9zdFVybCA9ICRmaC5nZXRDbG91ZFVSTCgpO1xuICAgICAgZXhwZWN0KGhvc3RVcmwpLnRvLmVxdWFsKGV4cGVjdGVkVXJsKTtcblxuICAgICAgXG4gICAgICBleHBlY3QoJGZoKS50by5oYXZlLnByb3BlcnR5KFwiY2xvdWRfcHJvcHNcIik7XG4gICAgICBleHBlY3QoJGZoLmNsb3VkX3Byb3BzKS50by5oYXZlLnByb3BlcnR5KFwiaG9zdHNcIik7XG4gICAgICBleHBlY3QoJGZoLmNsb3VkX3Byb3BzLmhvc3RzKS50by5oYXZlLnByb3BlcnR5KFwidXJsXCIpO1xuICAgICAgZXhwZWN0KCRmaC5jbG91ZF9wcm9wcy5ob3N0cy51cmwpLnRvLmVxdWFsKGV4cGVjdGVkVXJsKTtcblxuICAgICAgZXhwZWN0KCRmaCkudG8uaGF2ZS5wcm9wZXJ0eShcImFwcF9wcm9wc1wiKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJ0ZXN0IGFjdC9jbG91ZCBjYWxsXCIsIGZ1bmN0aW9uKCl7XG4gICAgaXQoXCJhY3QgY2FsbCBzaG91bGQgc3VjY2Vzc1wiLCBmdW5jdGlvbigpe1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBzaW5vbi5zcHkoKTtcbiAgICAgIHZhciBmYWlsID0gc2lub24uc3B5KCk7XG5cbiAgICAgIGluaXRGYWtlU2VydmVyKHNlcnZlcik7XG5cbiAgICAgIHZhciBkYXRhID0ge2VjaG86ICdoaSd9O1xuXG4gICAgICBzZXJ2ZXIucmVzcG9uZFdpdGgoJ1BPU1QnLCAvY2xvdWRcXC9lY2hvLywgYnVpbGRGYWtlUmVzKGRhdGEpKTtcblxuICAgICAgdmFyICRmaCA9IHByb2Nlc3MuZW52LkxJQl9DT1Y/IHJlcXVpcmUoXCIuLi8uLi9zcmMtY292L2ZlZWRoZW5yeVwiKSA6IHJlcXVpcmUoXCIuLi8uLi9zcmMvZmVlZGhlbnJ5XCIpO1xuICAgICAgJGZoLnJlc2V0KCk7XG5cbiAgICAgICRmaC5hY3Qoe30sIHN1Y2Nlc3MsIGZhaWwpO1xuXG4gICAgICBleHBlY3QoZmFpbCkudG8uaGF2ZS5iZWVuLmNhbGxlZE9uY2U7XG5cbiAgICAgIHZhciBmYWlsMiA9IHNpbm9uLnNweSgpO1xuXG4gICAgICAkZmguYWN0KHthY3Q6ICdlY2hvJywgcmVxOiB7fX0sIHN1Y2Nlc3MsIGZhaWwyKTtcblxuICAgICAgc2VydmVyLnJlc3BvbmQoKTtcbiAgICAgIHNlcnZlci5yZXNwb25kKCk7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICBleHBlY3Qoc3VjY2VzcykudG8uaGF2ZS5iZWVuLmNhbGxlZE9uY2U7XG4gICAgICBleHBlY3Qoc3VjY2VzcykudG8uaGF2ZS5iZWVuLmNhbGxlZFdpdGgoZGF0YSk7XG5cbiAgICAgIGV4cGVjdChmYWlsMikudG8uaGF2ZS5ub3QuYmVlbi5jYWxsZWQ7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCB3b3JrIHdpdGggY2xvdWQgY2FsbFwiLCBmdW5jdGlvbigpe1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBzaW5vbi5zcHkoKTtcbiAgICAgIHZhciBmYWlsID0gc2lub24uc3B5KCk7XG5cbiAgICAgIGluaXRGYWtlU2VydmVyKHNlcnZlcik7XG5cbiAgICAgIHZhciBkYXRhID0ge2VjaG86ICdoaSd9O1xuXG4gICAgICBzZXJ2ZXIucmVzcG9uZFdpdGgoJ1BPU1QnLCAvdGVzdFxcL2VjaG8vLCBidWlsZEZha2VSZXMoZGF0YSkpO1xuXG4gICAgICB2YXIgJGZoID0gcHJvY2Vzcy5lbnYuTElCX0NPVj8gcmVxdWlyZShcIi4uLy4uL3NyYy1jb3YvZmVlZGhlbnJ5XCIpIDogcmVxdWlyZShcIi4uLy4uL3NyYy9mZWVkaGVucnlcIik7XG4gICAgICAkZmgucmVzZXQoKTtcblxuICAgICAgJGZoLmNsb3VkKHtcbiAgICAgICAgcGF0aDogJ3Rlc3QvZWNobycsXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnXG4gICAgICB9LCBzdWNjZXNzLCBmYWlsKTtcblxuICAgICAgc2VydmVyLnJlc3BvbmQoKTtcbiAgICAgIHNlcnZlci5yZXNwb25kKCk7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICBleHBlY3Qoc3VjY2VzcykudG8uaGF2ZS5iZWVuLmNhbGxlZE9uY2U7XG4gICAgICBleHBlY3Qoc3VjY2VzcykudG8uaGF2ZS5iZWVuLmNhbGxlZFdpdGgoZGF0YSk7XG4gICAgICBleHBlY3QoZmFpbCkudG8uaGF2ZS5ub3QuYmVlbi5jYWxsZWQ7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwidGVzdCBhdXRoIGNhbGxcIiwgZnVuY3Rpb24oKXtcbiAgICBpdChcImF1dGggY2FsbCBzaG91bGQgd29ya1wiLCBmdW5jdGlvbigpe1xuICAgICAgaW5pdEZha2VTZXJ2ZXIoc2VydmVyKTtcbiAgICAgIHNlcnZlci5yZXNwb25kV2l0aCgnUE9TVCcsIC9hdXRocG9saWN5LywgYnVpbGRGYWtlUmVzKHtzdGF0dXM6IFwib2tcIn0pKTtcblxuICAgICAgdmFyICRmaCA9IHByb2Nlc3MuZW52LkxJQl9DT1Y/IHJlcXVpcmUoXCIuLi8uLi9zcmMtY292L2ZlZWRoZW5yeVwiKSA6IHJlcXVpcmUoXCIuLi8uLi9zcmMvZmVlZGhlbnJ5XCIpO1xuICAgICAgJGZoLnJlc2V0KCk7XG5cbiAgICAgIHZhciBzdWNjZXNzID0gc2lub24uc3B5KCk7XG4gICAgICB2YXIgZmFpbCA9IHNpbm9uLnNweSgpO1xuICAgICAgJGZoLmF1dGgoe30sIHN1Y2Nlc3MsIGZhaWwpO1xuICAgICAgZXhwZWN0KGZhaWwpLnRvLmhhdmUuYmVlbi5jYWxsZWRPbmNlO1xuXG4gICAgICBmYWlsID0gc2lub24uc3B5KCk7XG4gICAgICAkZmguYXV0aCh7cG9saWN5SWQ6ICd0ZXN0cG9saWN5JywgY2xpZW50VG9rZW46ICd0ZXN0dG9rZW4nLCB0cmFuc3BvcnQ6IGFqYXh9LCBzdWNjZXNzLCBmYWlsKTtcblxuICAgICAgc2VydmVyLnJlc3BvbmQoKTtcbiAgICAgIHNlcnZlci5yZXNwb25kKCk7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICBleHBlY3Qoc3VjY2VzcykudG8uaGF2ZS5iZWVuLmNhbGxlZE9uY2U7XG4gICAgICBleHBlY3QoZmFpbCkudG8uaGF2ZS5ub3QuYmVlbi5jYWxsZWQ7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwidGVzdCBtYmFhcyBjYWxsXCIsIGZ1bmN0aW9uKCl7XG4gICAgaXQoXCJtYmFhcyBjYWxsIHNob3VsZCBjYWxsXCIsIGZ1bmN0aW9uKCl7XG4gICAgICBpbml0RmFrZVNlcnZlcihzZXJ2ZXIpO1xuICAgICAgc2VydmVyLnJlc3BvbmRXaXRoKCdQT1NUJywgL21iYWFzXFwvZm9ybXMvLCBidWlsZEZha2VSZXMoe1wic3RhdHVzXCI6IFwib2tcIn0pKTtcblxuICAgICAgdmFyICRmaCA9IHByb2Nlc3MuZW52LkxJQl9DT1Y/IHJlcXVpcmUoXCIuLi8uLi9zcmMtY292L2ZlZWRoZW5yeVwiKSA6IHJlcXVpcmUoXCIuLi8uLi9zcmMvZmVlZGhlbnJ5XCIpO1xuICAgICAgJGZoLnJlc2V0KCk7XG5cbiAgICAgIHZhciBzdWNjZXNzID0gc2lub24uc3B5KCk7XG4gICAgICB2YXIgZmFpbCA9IHNpbm9uLnNweSgpO1xuXG4gICAgICAkZmgubWJhYXMoe3NlcnZpY2U6IFwiZm9ybXNcIn0sIHN1Y2Nlc3MsIGZhaWwpO1xuXG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuICAgICAgc2VydmVyLnJlc3BvbmQoKTtcbiAgICAgIHNlcnZlci5yZXNwb25kKCk7XG5cbiAgICAgIGV4cGVjdChzdWNjZXNzKS50by5oYXZlLmJlZW4uY2FsbGVkT25jZTtcbiAgICAgIGV4cGVjdChmYWlsKS50by5oYXZlLm5vdC5iZWVuLmNhbGxlZDtcbiAgICAgIGV4cGVjdChzdWNjZXNzKS50by5oYXZlLmJlZW4uY2FsbGVkV2l0aCh7XCJzdGF0dXNcIjogXCJva1wifSk7XG5cbiAgICB9KTtcbiAgfSk7XG59KTsiLCJ2YXIgY2hhaSA9IHJlcXVpcmUoJ2NoYWknKTtcbnZhciBleHBlY3QgPSBjaGFpLmV4cGVjdDtcbnZhciBzaW5vbkNoYWkgPSByZXF1aXJlKCdzaW5vbi1jaGFpJyk7XG5jaGFpLnVzZShzaW5vbkNoYWkpO1xuXG52YXIgcHJvY2VzcyA9IHJlcXVpcmUoXCJwcm9jZXNzXCIpO1xuaWYoZG9jdW1lbnQgJiYgZG9jdW1lbnQubG9jYXRpb24pe1xuICBpZihkb2N1bWVudC5sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJjb3ZlcmFnZT0xXCIpID4gLTEpe1xuICAgIHByb2Nlc3MuZW52LkxJQl9DT1YgPSAxO1xuICB9XG59XG5cbnZhciBxcyA9IHByb2Nlc3MuZW52LkxJQl9DT1Y/IHJlcXVpcmUoXCIuLi8uLi9zcmMtY292L21vZHVsZXMvcXVlcnlNYXBcIik6IHJlcXVpcmUoXCIuLi8uLi9zcmMvbW9kdWxlcy9xdWVyeU1hcFwiKTtcblxudmFyIGZoY29uZmlnID0ge1xuICBcImhvc3RcIjogXCJodHRwOi8vbG9jYWxob3N0OjgxMDBcIixcbiAgXCJhcHBpZFwiIDogXCJ0ZXN0YXBwaWRcIixcbiAgXCJhcHBrZXlcIiA6IFwidGVzdGFwcGtleVwiLFxuICBcIm1vZGVcIjogXCJkZXZcIlxufVxuXG52YXIgbGVnYWN5QXBwSG9zdCA9IHtcbiAgZG9tYWluOiBcInRlc3RpbmdcIixcbiAgZmlyc3RUaW1lOiBmYWxzZSxcbiAgaG9zdHM6IHtcbiAgICBcInJlbGVhc2VDbG91ZFVybFwiOiBcImh0dHA6Ly9sb2NhbGhvc3Q6ODEwMlwiLFxuICAgIFwicmVsZWFzZUNsb3VkVHlwZVwiOiBcImZoXCIsXG4gICAgXCJkZWJ1Z0Nsb3VkVXJsXCI6IFwiaHR0cDovL2xvY2FsaG9zdDo4MTAzXCIsXG4gICAgXCJkZWJ1Z0Nsb3VkVHlwZVwiOiBcImZoXCJcbiAgfSxcbiAgaW5pdDoge1xuICAgIFwidHJhY2tJZFwiOiBcInRlc3R0cmFja2lkXCJcbiAgfVxufVxuXG52YXIgZXhwZWN0ZWRVcmwgPSBcImh0dHA6Ly9sb2NhbGhvc3Q6ODEwM1wiO1xuaWYoZG9jdW1lbnQgJiYgZG9jdW1lbnQubG9jYXRpb24pe1xuICB2YXIgZG9jX3VybCA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG4gIHZhciB1cmxfcGFyYW1zID0gcXMoZG9jX3VybCk7XG4gIHZhciBsb2NhbCA9ICh0eXBlb2YgdXJsX3BhcmFtcy51cmwgIT09ICd1bmRlZmluZWQnKTtcbiAgaWYobG9jYWwpe1xuICAgIGV4cGVjdGVkVXJsID0gdXJsX3BhcmFtcy51cmw7XG4gIH1cbn1cblxudmFyIGJ1aWxkRmFrZVJlcyA9IGZ1bmN0aW9uKGRhdGEpe1xuICByZXR1cm4gWzIwMCwge1wiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwifSwgSlNPTi5zdHJpbmdpZnkoZGF0YSldO1xufVxuXG52YXIgaW5pdEZha2VTZXJ2ZXIgPSBmdW5jdGlvbihzZXJ2ZXIpe1xuICAgc2VydmVyLnJlc3BvbmRXaXRoKCdHRVQnLCAvZmhjb25maWcuanNvbi8sIGJ1aWxkRmFrZVJlcyhmaGNvbmZpZykpO1xuXG4gICBzZXJ2ZXIucmVzcG9uZFdpdGgoJ1BPU1QnLCAvaW5pdC8sIGJ1aWxkRmFrZVJlcyhsZWdhY3lBcHBIb3N0KSk7XG59XG5cbmRlc2NyaWJlKFwidGVzdCBsZWdhY3kgYXBwIHByb3BzL2FwcCBpbml0XCIsIGZ1bmN0aW9uKCl7XG4gIHZhciBzZXJ2ZXI7XG5cbiAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7IHNlcnZlciA9IHNpbm9uLmZha2VTZXJ2ZXIuY3JlYXRlKCk7IH0pO1xuICBhZnRlckVhY2goZnVuY3Rpb24gKCkgeyBzZXJ2ZXIucmVzdG9yZSgpOyB9KTtcblxuICBkZXNjcmliZShcInRlc3QgbGVnYWN5IGFwcCBpbml0XCIsIGZ1bmN0aW9uKCl7XG4gICAgaXQoXCIkZmguaW5pdCBzaG91bGQgaW5pdGlhbGlzZSB0aGUgYXBwXCIsIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBzaW5vbi5zcHkoKTtcblxuICAgICAgaW5pdEZha2VTZXJ2ZXIoc2VydmVyKTtcbiAgICAgIHZhciAkZmggPSBwcm9jZXNzLmVudi5MSUJfQ09WPyByZXF1aXJlKFwiLi4vLi4vc3JjLWNvdi9mZWVkaGVucnlcIikgOiByZXF1aXJlKFwiLi4vLi4vc3JjL2ZlZWRoZW5yeVwiKTtcblxuICAgICAgJGZoLnJlc2V0KCk7XG5cbiAgICAgICRmaC5pbml0KHt9LCBjYWxsYmFjayk7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuICAgICAgc2VydmVyLnJlc3BvbmQoKTtcblxuICAgICAgZXhwZWN0KGNhbGxiYWNrKS50by5oYXZlLmJlZW4uY2FsbGVkO1xuICAgICAgZXhwZWN0KGNhbGxiYWNrKS50by5oYXZlLmJlZW4uY2FsbGVkT25jZTtcbiAgICAgIGV4cGVjdChjYWxsYmFjaykudG8uaGF2ZS5iZWVuLmNhbGxlZFdpdGgoZXhwZWN0ZWRVcmwpO1xuXG4gICAgICB2YXIgaG9zdFVybCA9ICRmaC5nZXRDbG91ZFVSTCgpO1xuICAgICAgZXhwZWN0KGhvc3RVcmwpLnRvLmVxdWFsKGV4cGVjdGVkVXJsKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJ0ZXN0IGF1dG8gaW5pdGlhbGlzYXRpb25cIiwgZnVuY3Rpb24oKXtcbiAgICBpdChcInNob3VsZCBlbWl0IGZoaW5pdCBldmVudHNcIiwgZnVuY3Rpb24oKXtcblxuICAgICAgdmFyIGNhbGxiYWNrID0gc2lub24uc3B5KCk7XG5cbiAgICAgIGluaXRGYWtlU2VydmVyKHNlcnZlcik7XG4gICAgICB2YXIgJGZoID0gcHJvY2Vzcy5lbnYuTElCX0NPVj8gcmVxdWlyZShcIi4uLy4uL3NyYy1jb3YvZmVlZGhlbnJ5XCIpIDogcmVxdWlyZShcIi4uLy4uL3NyYy9mZWVkaGVucnlcIik7XG4gICAgICBcbiAgICAgICRmaC5yZXNldCgpO1xuXG4gICAgICAkZmgub24oJ2ZoaW5pdCcsIGNhbGxiYWNrKTtcblxuICAgICAgc2VydmVyLnJlc3BvbmQoKTtcbiAgICAgIHNlcnZlci5yZXNwb25kKCk7XG5cbiAgICAgIGV4cGVjdChjYWxsYmFjaykudG8uaGF2ZS5iZWVuLmNhbGxlZDtcbiAgICAgIGV4cGVjdChjYWxsYmFjaykudG8uaGF2ZS5iZWVuLmNhbGxlZE9uY2U7XG4gICAgICBleHBlY3QoY2FsbGJhY2spLnRvLmhhdmUuYmVlbi5jYWxsZWRXaXRoKG51bGwsIHtob3N0OiBleHBlY3RlZFVybH0pO1xuXG4gICAgICB2YXIgaG9zdFVybCA9ICRmaC5nZXRDbG91ZFVSTCgpO1xuICAgICAgZXhwZWN0KGhvc3RVcmwpLnRvLmVxdWFsKGV4cGVjdGVkVXJsKTtcblxuICAgIH0pO1xuICB9KTtcbn0pOyIsInZhciBjaGFpID0gcmVxdWlyZSgnY2hhaScpO1xudmFyIGV4cGVjdCA9IGNoYWkuZXhwZWN0O1xudmFyIHNpbm9uQ2hhaSA9IHJlcXVpcmUoJ3Npbm9uLWNoYWknKTtcbmNoYWkudXNlKHNpbm9uQ2hhaSk7XG5cbnZhciBwcm9jZXNzID0gcmVxdWlyZShcInByb2Nlc3NcIik7XG5pZihkb2N1bWVudCAmJiBkb2N1bWVudC5sb2NhdGlvbil7XG4gIGlmKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYuaW5kZXhPZihcImNvdmVyYWdlPTFcIikgPiAtMSl7XG4gICAgcHJvY2Vzcy5lbnYuTElCX0NPViA9IDE7XG4gIH1cbn1cblxudmFyICRmaCA9IHByb2Nlc3MuZW52LkxJQl9DT1Y/IHJlcXVpcmUoXCIuLi8uLi9zcmMtY292L2ZlZWRoZW5yeVwiKSA6IHJlcXVpcmUoXCIuLi8uLi9zcmMvZmVlZGhlbnJ5XCIpO1xuXG5kZXNjcmliZShcInRlc3Qgc2VjdXJpdHkgQVBJc1wiLCBmdW5jdGlvbigpe1xuICBpdChcIkFFUyBrZXlnZW5cIiwgZnVuY3Rpb24oKXtcbiAgICB2YXIgZmFpbCA9IHNpbm9uLnNweSgpO1xuXG4gICAgJGZoLnNlYyh7YWN0OidrZXlnZW4nLCBwYXJhbXM6e2FsZ29yaXRobTonQUVTJywga2V5c2l6ZTogMTI4fX0sIGZ1bmN0aW9uKGtleXMpe1xuICAgICAgZXhwZWN0KGtleXMpLnRvLmhhdmUucHJvcGVydHkoXCJzZWNyZXRrZXlcIik7XG4gICAgICBleHBlY3Qoa2V5cykudG8uaGF2ZS5wcm9wZXJ0eShcIml2XCIpO1xuICAgICAgZXhwZWN0KGtleXMuc2VjcmV0a2V5Lmxlbmd0aCkudG8uZXF1YWwoMTI4LzgqMik7XG4gICAgICBleHBlY3Qoa2V5cy5pdi5sZW5ndGgpLnRvLmVxdWFsKDEyOC84KjIpO1xuICAgIH0sIGZhaWwpO1xuXG4gICAgZXhwZWN0KGZhaWwpLnRvLmhhdmUubm90LmJlZW4uY2FsbGVkO1xuICB9KTtcblxuICBpdChcIkFFUyBlbmNyeXB0L2RlY3J5cHRcIiwgZnVuY3Rpb24oKXtcbiAgICB2YXIgc2sgPSAnNzUxNzRCN0NENzA5Qjg0RjM1MDUzQjE4NTUxMDdFQzYnO1xuICAgIHZhciBpdiA9ICc5MjU4N0YwRUY3QUVERTYxM0NEMjA3MjVCNTQ5OTY0OSc7XG4gICAgdmFyIHBsYWludGV4dCA9ICcyYmU0NjRmZTU0Y2NlZmEyYzliZGM3MjMxMjc1YTk5NSc7XG4gICAgdmFyIGNpcGhlcnRleHQgPSAnNGZiMmEzODhkYWJiNGYxMWU3MTcxMWM5Mjc5YzVjNDk2YWVkNGYxZDc1ZTQxMTUzMDBmYjMwZmYxOWVjMzIzZjk3NzBiZTE5NDU1MzIzNzdiYjk5ZDUwYmNlZTI5NjY3JztcblxuICAgICRmaC5zZWMoe2FjdDonZW5jcnlwdCcsIHBhcmFtczp7a2V5OiBzaywgaXY6IGl2LCBwbGFpbnRleHQ6cGxhaW50ZXh0LCBhbGdvcml0aG06J0FFUyd9fSwgZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgIGV4cGVjdChjaXBoZXJ0ZXh0KS50by5lcXVhbChyZXN1bHQuY2lwaGVydGV4dCk7XG4gICAgfSk7XG5cbiAgICAkZmguc2VjKHthY3Q6J2RlY3J5cHQnLCBwYXJhbXM6e2tleTogc2ssIGl2OiBpdiwgY2lwaGVydGV4dDpjaXBoZXJ0ZXh0LCBhbGdvcml0aG06J0FFUyd9fSwgZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgIGV4cGVjdChwbGFpbnRleHQpLnRvLmVxdWFsKHJlc3VsdC5wbGFpbnRleHQpO1xuICAgIH0pO1xuICB9KTtcblxuICBpdChcIlJTQSBlbmNyeXB0XCIsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIG1vZHVsdSA9IFwiYTUyNjE5Mzk5NzU5NDhiYjdhNThkZmZlNWZmNTRlNjVmMDQ5OGY5MTc1ZjVhMDkyODg4MTBiODk3NTg3MWU5OVxcbmFmM2I1ZGQ5NDA1N2IwZmMwNzUzNWY1Zjk3NDQ0NTA0ZmEzNTE2OWQ0NjFkMGQzMGNmMDE5MmUzMDc3MjdjMDZcXG41MTY4Yzc4ODc3MWM1NjFhOTQwMGZiNDkxNzVlOWU2YWE0ZTIzZmUxMWFmNjllOTQxMmRkMjNiMGNiNjY4NGM0XFxuYzI0MjliY2UxMzllODQ4YWIyNmQwODI5MDczMzUxZjRhY2QzNjA3NGVhZmQwMzZhNWViODMzNTlkMmE2OThkM1wiO1xuICAgIHZhciBwbGFpbnRleHQgPSBcIlRoaXMgaXMgdGVzdFwiO1xuICAgICRmaC5zZWMoe2FjdDonZW5jcnlwdCcsIHBhcmFtczp7YWxnb3JpdGhtOidSU0EnLCBtb2R1bHU6IG1vZHVsdSwgcGxhaW50ZXh0OnBsYWludGV4dH19LCBmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgdmFyIHByaSA9IFwiOGU5OTEyZjZkMzY0NTg5NGU4ZDM4Y2I1OGMwZGI4MWZmNTE2Y2Y0YzdlNWExNGM3ZjFlZGRiMTQ1OWQyY2RlZFxcbjRkOGQyOTNmYzk3YWVlNmFlZmI4NjE4NTljOGI2YTNkMWRmZTcxMDQ2M2UxZjlkZGM3MjA0OGMwOTc1MTk3MWNcXG40YTU4MGFhNTFlYjUyMzM1N2EzY2M0OGQzMWNmYWQxZDRhMTY1MDY2ZWQ5MmQ0NzQ4ZmI2NTcxMjExZGE1Y2IxXFxuNGJjMTFiNmUyZGY3YzFhNTU5ZTZkNWFjMWNkNWM5NDcwM2EyMjg5MTQ2NGZiYTIzZDBkOTY1MDg2Mjc3YTE2MVwiO1xuICAgICAgdmFyIHAgPSBcImQwOTBjZTU4YTkyYzc1MjMzYTY0ODZjYjBhOTIwOWJmMzU4M2I2NGY1NDBjNzZmNTI5NGJiOTdkMjg1ZWVkMzNcXG5hZWMyMjBiZGUxNGIyNDE3OTUxMTc4YWMxNTJjZWFiNmRhNzA5MDkwNWI0NzgxOTU0OThiMzUyMDQ4ZjE1ZTdkXCI7XG4gICAgICB2YXIgcSA9IFwiY2FiNTc1ZGM2NTJiYjY2ZGYxNWEwMzU5NjA5ZDUxZDFkYjE4NDc1MGMwMGM2Njk4YjkwZWYzNDY1Yzk5NjU1MVxcbjAzZWRiZjBkNTRjNTZhZWMwY2UzYzRkMjI1OTIzMzgwOTJhMTI2YTBjYzQ5ZjY1YTRhMzBkMjIyYjQxMWU1OGZcIjtcbiAgICAgIHZhciBkbXAxID0gXCIxYTI0YmNhOGUyNzNkZjJmMGU0N2MxOTliYmY2Nzg2MDRlN2RmNzIxNTQ4MGM3N2M4ZGIzOWY0OWIwMDBjZTJjXFxuZjc1MDAwMzhhY2ZmZjU0MzNiN2Q1ODJhMDFmMTgyNmU2ZjRkNDJlMWM1N2Y1ZTFmZWY3YjEyYWFiYzU5ZmQyNVwiO1xuICAgICAgdmFyIGRtcTEgPSBcIjNkMDY5ODJlZmJiZTQ3MzM5ZTFmNmQzNmIxMjE2YjhhNzQxZDQxMGIwYzY2MmY1NGY3MTE4YjI3YjlhNGVjOWRcXG45MTQzMzdlYjM5ODQxZDg2NjZmMzAzNDQwOGNmOTRmNWI2MmYxMWM0MDJmYzk5NGZlMTVhMDU0OTMxNTBkOWZkXCI7XG4gICAgICB2YXIgY29lZmYgPSBcIjNhM2U3MzFhY2Q4OTYwYjdmZjllYjgxYTdmZjkzYmQxY2ZhNzRjYmQ1Njk4N2RiNThiNDU5NGZiMDljMDkwODRcXG5kYjE3MzRjODE0M2Y5OGI2MDJiOTgxYWFhOTI0M2NhMjhkZWI2OWI1YjI4MGVlOGRjZWUwZmQyNjI1ZTUzMjUwXCI7XG4gICAgICBleHBlY3QocmVzdWx0KS50by5oYXZlLnByb3BlcnR5KFwiY2lwaGVydGV4dFwiKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgaXQoXCJoYXNoXCIsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhc2hfcGxhaW5fdGV4dCA9IFwiVGhpcyBpcyB0byB0ZXN0IGhhc2hcIjtcbiAgICB2YXIgZXhwZWN0ZWRfbWQ1X2hhc2ggPSBcImVlMWQzMDQyZGM0ZDZjYzk5OTU2NjViNjY3ZjFkNDViXCI7XG4gICAgdmFyIGV4cGVjdGVkX3NoYTFfaGFzaCA9IFwiMGY2NjcxYzkxYzY1OWUxNjI4MTViZWYwMDJiMzZhOTBiYTk2MTMwNlwiO1xuICAgIHZhciBleHBlY3RlZF9zaGEyNTZfaGFzaCA9IFwiNzc1OTNmMmZlNGRmNThkNmQxMWY5YjMxZGNjNmU3ZjU1ZWM2M2Q0MmFkODdlYTBkZjZhOTRiODFiOTMwNzk0MVwiO1xuICAgIHZhciBleHBlY3RlZF9zaGE1MTJfaGFzaCA9IFwiNzlkNTk4YTg3YWNhNDVlNTFiZDZjNjQ0OTc2YzIwZDZmN2JiMWNjMzJkNjM1YjM1MGIyNGIyY2QxNmEwMjVlNDFkMzBkZjJhODY5NjkxNmU4OTZjOWE5OGUyYjRiYzYyYzA1OTIyYzdlMzQwYzU3ZTE0ZTVkNjIzYWY3N2U1YjZcIjtcblxuICAgICRmaC5oYXNoKHthbGdvcml0aG06J21kNScsIHRleHQ6IGhhc2hfcGxhaW5fdGV4dH0sIGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICBleHBlY3QoZXhwZWN0ZWRfbWQ1X2hhc2gpLnRvLmVxdWFsKHJlc3VsdC5oYXNodmFsdWUpO1xuICAgIH0pO1xuXG4gICAgJGZoLmhhc2goe2FsZ29yaXRobTonc2hhMScsIHRleHQ6IGhhc2hfcGxhaW5fdGV4dH0sIGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICBleHBlY3QoZXhwZWN0ZWRfc2hhMV9oYXNoKS50by5lcXVhbChyZXN1bHQuaGFzaHZhbHVlKTtcbiAgICB9KTtcblxuICAgICRmaC5oYXNoKHthbGdvcml0aG06J3NoYTI1NicsIHRleHQ6IGhhc2hfcGxhaW5fdGV4dH0sIGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICBleHBlY3QoZXhwZWN0ZWRfc2hhMjU2X2hhc2gpLnRvLmVxdWFsKHJlc3VsdC5oYXNodmFsdWUpO1xuICAgIH0pO1xuXG4gICAgJGZoLmhhc2goe2FsZ29yaXRobTonc2hhNTEyJywgdGV4dDogaGFzaF9wbGFpbl90ZXh0fSwgZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgIGV4cGVjdChleHBlY3RlZF9zaGE1MTJfaGFzaCkudG8uZXF1YWwocmVzdWx0Lmhhc2h2YWx1ZSk7XG4gICAgfSk7XG4gIH0pO1xufSkiLCJ2YXIgcHJvY2VzcyA9IHJlcXVpcmUoXCJwcm9jZXNzXCIpO1xuaWYoZG9jdW1lbnQgJiYgZG9jdW1lbnQubG9jYXRpb24pe1xuICBpZihkb2N1bWVudC5sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJjb3ZlcmFnZT0xXCIpID4gLTEpe1xuICAgIHByb2Nlc3MuZW52LkxJQl9DT1YgPSAxO1xuICB9XG59XG52YXIgc3luY0NsaWVudCA9IHByb2Nlc3MuZW52LkxJQl9DT1Y/IHJlcXVpcmUoXCIuLi8uLi9zcmMtY292L21vZHVsZXMvc3luYy1jbGlcIikgOiByZXF1aXJlKFwiLi4vLi4vc3JjL21vZHVsZXMvc3luYy1jbGlcIik7XG52YXIgY2hhaSA9IHJlcXVpcmUoJ2NoYWknKTtcbnZhciBleHBlY3QgPSBjaGFpLmV4cGVjdDtcbnZhciBzaW5vbkNoYWkgPSByZXF1aXJlKCdzaW5vbi1jaGFpJyk7XG52YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXG5jaGFpLnVzZShzaW5vbkNoYWkpO1xuXG4vL3dvcmsgYXJvdW5kIHBoYW50b21qcydzIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMDY0N1xudmFyIGZha2VOYXZpZ2F0b3IgPSB7fTtcbmZvciAodmFyIGkgaW4gbmF2aWdhdG9yKSB7IFxuICAgIGZha2VOYXZpZ2F0b3JbaV0gPSBuYXZpZ2F0b3JbaV07XG59XG5mYWtlTmF2aWdhdG9yLm9uTGluZSA9IHRydWU7XG5uYXZpZ2F0b3IgPSBmYWtlTmF2aWdhdG9yO1xuXG5zeW5jQ2xpZW50LmluaXQoe1xuICBkb19jb25zb2xlX2xvZzogdHJ1ZSxcbiAgc3luY19mcmVxdWVuY3k6IDEsXG4gIHN5bmNfYWN0aXZlOiBmYWxzZSxcbiAgc3RvcmFnZV9zdHJhdGVneTogWydtZW1vcnknXSxcbiAgY3Jhc2hlZF9jb3VudF93YWl0OiAwXG59KTtcblxuZGVzY3JpYmUoXCJ0ZXN0IHN5bmMgZnJhbWV3b3JrIG9mZmxpbmVcIiwgZnVuY3Rpb24oKXtcbiAgdGhpcy50aW1lb3V0KDUwMDApO1xuICB2YXIgZGF0YVNldElkID0gXCJ0ZXN0RGF0YXNldFwiO1xuICBiZWZvcmUoZnVuY3Rpb24oZG9uZSl7XG4gICAgc3luY0NsaWVudC5tYW5hZ2UoZGF0YVNldElkLCBudWxsLCBudWxsLCBudWxsLCBkb25lKTtcbiAgfSk7XG5cbiAgYmVmb3JlRWFjaChmdW5jdGlvbigpe1xuXG4gIH0pO1xuXG4gIGFmdGVyRWFjaChmdW5jdGlvbihkb25lKXtcbiAgICBzeW5jQ2xpZW50Lm5vdGlmeSh1bmRlZmluZWQpO1xuICAgIHN5bmNDbGllbnQuc3RvcFN5bmMoZGF0YVNldElkLCBkb25lLCBkb25lKTtcbiAgfSk7XG5cbiAgaXQoXCJzeW5jLm1hbmFnZVwiLCBmdW5jdGlvbihkb25lKXtcbiAgICB2YXIgb3B0cyA9IHtcImZpbGVfc3lzdGVtX3F1b3RhXCI6IDEqMTAyNCoxMDI0LCBjcmFzaGVkX2NvdW50X3dhaXQ6IDV9O1xuICAgIHZhciBxcCA9IHtcInF1ZXJ5XCI6XCJ0ZXN0XCJ9O1xuICAgIHZhciBtZXRhX2RhdGEgPSB7XCJ1c2VyXCI6IFwidGVzdFwifTtcbiAgICBzeW5jQ2xpZW50Lm1hbmFnZShkYXRhU2V0SWQsIG9wdHMsIHFwLCBtZXRhX2RhdGEsIGZ1bmN0aW9uKCl7XG4gICAgICBzeW5jQ2xpZW50LmdldERhdGFzZXQoZGF0YVNldElkLCBmdW5jdGlvbihkYXRhc2V0KXtcbiAgICAgICAgZXhwZWN0KGRhdGFzZXQuY29uZmlnLmZpbGVfc3lzdGVtX3F1b3RhKS50by5lcXVhbCgxKjEwMjQqMTAyNCk7XG4gICAgICAgIGV4cGVjdChkYXRhc2V0LmNvbmZpZy5jcmFzaGVkX2NvdW50X3dhaXQpLnRvLmVxdWFsKDUpO1xuICAgICAgICBleHBlY3QoZGF0YXNldC5jb25maWcuZG9fY29uc29sZV9sb2cpLnRvLmVxdWFsKHRydWUpO1xuICAgICAgICBleHBlY3QoZGF0YXNldC5xdWVyeV9wYXJhbXMpLmVxdWFsKHFwKTtcbiAgICAgICAgZXhwZWN0KGRhdGFzZXQubWV0YV9kYXRhKS5lcXVhbChtZXRhX2RhdGEpO1xuXG4gICAgICAgIGV4cGVjdChkYXRhc2V0Lm1ldGEpLnRvLmJlLmVtcHR5O1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgaXQoXCJzeW5jLnNldENvbmZpZy9nZXRDb25maWdcIiwgZnVuY3Rpb24oZG9uZSl7XG4gICAgdmFyIG9wdHMgPSB7XCJmaWxlX3N5c3RlbV9xdW90YVwiOiAxMCoxMDI0KjEwMjQsIGNyYXNoZWRfY291bnRfd2FpdDogMTB9O1xuICAgIHZhciBmYWlsID0gc2lub24uc3B5KCk7XG4gICAgc3luY0NsaWVudC5zZXRDb25maWcoZGF0YVNldElkLCBvcHRzLCBmdW5jdGlvbihjb25mKXtcbiAgICAgIGV4cGVjdChmYWlsKS50by5oYXZlLm5vdC5iZWVuLmNhbGxlZDtcblxuICAgICAgc3luY0NsaWVudC5nZXRDb25maWcoZGF0YVNldElkLCBmdW5jdGlvbihjb25maWcpe1xuICAgICAgICBleHBlY3QoY29uZi5maWxlX3N5c3RlbV9xdW90YSkudG8uZXF1YWwoMTAqMTAyNCoxMDI0KTtcbiAgICAgICAgZXhwZWN0KGNvbmYuY3Jhc2hlZF9jb3VudF93YWl0KS50by5lcXVhbCgxMCk7XG5cbiAgICAgICAgZXhwZWN0KGNvbmYuZG9fY29uc29sZV9sb2cpLnRvLmVxdWFsKHRydWUpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9LCBmYWlsKTtcbiAgfSk7XG5cbiAgaXQoXCJzeW5jLmdldFF1ZXJ5UGFyYW1zL3NldFF1ZXJ5UGFyYW1zXCIsIGZ1bmN0aW9uKGRvbmUpe1xuICAgIHZhciBxcCA9IHtcInFcIjpcInRcIn07XG4gICAgdmFyIGZhaWwgPSBzaW5vbi5zcHkoKTtcblxuICAgIHN5bmNDbGllbnQuc2V0UXVlcnlQYXJhbXMoZGF0YVNldElkLCBxcCwgZnVuY3Rpb24oKXtcbiAgICAgIGV4cGVjdChmYWlsKS5oYXZlLm5vdC5iZWVuLmNhbGxlZDtcblxuICAgICAgc3luY0NsaWVudC5nZXRRdWVyeVBhcmFtcyhkYXRhU2V0SWQsIGZ1bmN0aW9uKHF1ZXJ5KXtcbiAgICAgICAgZXhwZWN0KHF1ZXJ5KS5lcXVhbChxcCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgfSwgZmFpbCk7XG4gIH0pO1xuXG4gIGl0KFwic3luYy5nZXRNZXRhRGF0YS9zZXRNZXRhRGF0YVwiLCBmdW5jdGlvbihkb25lKXtcbiAgICB2YXIgbWRhdGEgPSB7bWV0YTpcInRlc3RcIn07XG5cbiAgICB2YXIgZmFpbCA9IHNpbm9uLnNweSgpO1xuICAgIHN5bmNDbGllbnQuc2V0TWV0YURhdGEoZGF0YVNldElkLCBtZGF0YSwgZnVuY3Rpb24oKXtcbiAgICAgIGV4cGVjdChmYWlsKS5oYXZlLm5vdC5iZWVuLmNhbGxlZDtcbiAgICAgIHN5bmNDbGllbnQuZ2V0TWV0YURhdGEoZGF0YVNldElkLCBmdW5jdGlvbihtZXRhKXtcbiAgICAgICAgZXhwZWN0KG1ldGEpLmVxdWFsKG1kYXRhKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSwgZmFpbCk7XG4gIH0pO1xuXG5cblxuICBpdChcInN5bmMubm90aWZ5XCIsIGZ1bmN0aW9uKGRvbmUpe1xuICAgIHZhciBzdGFydENhbGxiYWNrID0gc2lub24uc3B5KCk7XG4gICAgdmFyIGZhaWxDYWxsYmFjayA9IHNpbm9uLnNweSgpO1xuICAgIHZhciBjb21wQ2FsbGJhY2sgPSBzaW5vbi5zcHkoKTtcblxuXG4gICAgc3luY0NsaWVudC5ub3RpZnkoZnVuY3Rpb24oZSl7XG4gICAgICBzd2l0Y2goZS5jb2RlKXtcbiAgICAgICAgY2FzZSBcInN5bmNfc3RhcnRlZFwiOlxuICAgICAgICAgIHN0YXJ0Q2FsbGJhY2soZS5jb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN5bmNfZmFpbGVkXCI6XG4gICAgICAgICAgZmFpbENhbGxiYWNrKGUuY29kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzeW5jX2NvbXBsZXRlXCI6XG4gICAgICAgICAgY29tcENhbGxiYWNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzeW5jQ2xpZW50LnN0YXJ0U3luYyhkYXRhU2V0SWQsIGZ1bmN0aW9uKCl7XG5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgZXhwZWN0KHN0YXJ0Q2FsbGJhY2spLnRvLmhhdmUuYmVlbi5jYWxsZWQ7XG4gICAgICAgIGV4cGVjdChmYWlsQ2FsbGJhY2spLnRvLmhhdmUuYmVlbi5jYWxsZWQ7XG4gICAgICAgIGV4cGVjdChmYWlsQ2FsbGJhY2spLnRvLmhhdmUuYmVlbi5jYWxsZWRXaXRoKCdzeW5jX2ZhaWxlZCcpO1xuXG4gICAgICAgIGV4cGVjdChjb21wQ2FsbGJhY2spLnRvLmhhdmUubm90LmJlZW4uY2FsbGVkO1xuXG4gICAgICAgIHN5bmNDbGllbnQuc3RvcFN5bmMoZGF0YVNldElkLCBmdW5jdGlvbigpe1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIH0sIDYwMCk7XG5cbiAgICB9KTtcbiAgfSk7XG5cbiAgdmFyIHVpZDtcblxuICBpdChcInN5bmMuZG9DcmVhdGVcIiwgZnVuY3Rpb24oZG9uZSl7XG4gICAgdmFyIHN1Y2Nlc3MgPSBzaW5vbi5zcHkoKTtcbiAgICB2YXIgZmFpbCA9IHNpbm9uLnNweSgpO1xuXG4gICAgdmFyIHVwZGF0ZUNCID0gc2lub24uc3B5KCk7XG5cbiAgICB2YXIgZGF0YSA9IHtcIm5hbWVcIjogXCJpdGVtMVwifTtcbiAgICB2YXIgaGFzaCA9IHN5bmNDbGllbnQuZ2VuZXJhdGVIYXNoKGRhdGEpO1xuICAgIHVpZCA9IGhhc2g7XG5cbiAgICBzeW5jQ2xpZW50Lm5vdGlmeShmdW5jdGlvbihlKXtcbiAgICAgIHN3aXRjaChlLmNvZGUpe1xuICAgICAgICBjYXNlICdsb2NhbF91cGRhdGVfYXBwbGllZCc6XG4gICAgICAgICAgdXBkYXRlQ0IoZS5kYXRhc2V0X2lkLCBlLnVpZCwgZS5jb2RlLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pXG5cbiAgICBzeW5jQ2xpZW50LmRvQ3JlYXRlKGRhdGFTZXRJZCwgZGF0YSwgZnVuY3Rpb24oKXtcblxuICAgICAgZXhwZWN0KGZhaWwpLnRvLmhhdmUubm90LmJlZW4uY2FsbGVkO1xuICAgICAgLy9ub3cgdGhlIG5ldyBkYXRhIHNob3VsZCBiZSBpbiB0aGUgZGF0YXNldCBhcyB3ZWxsIGFzIHRoZSBwZW5kaW5nIHNldFxuICAgICAgdmFyIGdldEZhaWwgPSBzaW5vbi5zcHkoKTtcbiAgICAgIHN5bmNDbGllbnQuZ2V0RGF0YXNldChkYXRhU2V0SWQsIGZ1bmN0aW9uKGRhdGFzZXQpe1xuICAgICAgICBleHBlY3QoZ2V0RmFpbCkudG8uaGF2ZS5ub3QuYmVlbi5jYWxsZWQ7XG5cbiAgICAgICAgLy90aGUgY3VycmVudCBkYXRhc2V0IHNob3VsZCBoYXZlIHRoZSBuZXcgZGF0YSBlbnRyeVxuICAgICAgICBleHBlY3QoZGF0YXNldC5kYXRhKS50by5oYXZlLmtleXMoaGFzaCk7XG4gICAgICAgIGV4cGVjdChKU09OLnN0cmluZ2lmeShkYXRhc2V0LmRhdGFbaGFzaF0uZGF0YSkpLnRvLmVxdWFsKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcblxuICAgICAgICAvL3RoZSBuZXcgZGF0YSBlbnRyeSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIHBlbmRpbmcgZGF0YVxuICAgICAgICBleHBlY3QoXy5zaXplKGRhdGFzZXQucGVuZGluZykpLnRvLmVxdWFsKDEpO1xuICAgICAgICB2YXIgcGVuZGluZ09iaiA9IF8udmFsdWVzKGRhdGFzZXQucGVuZGluZylbMF07XG4gICAgICAgIGNvbnNvbGUubG9nKHBlbmRpbmdPYmopO1xuICAgICAgICBleHBlY3QocGVuZGluZ09iai5hY3Rpb24pLnRvLmVxdWFsKFwiY3JlYXRlXCIpO1xuICAgICAgICBleHBlY3QocGVuZGluZ09iai5pbkZsaWdodCkudG8uYmUuZmFsc2U7XG4gICAgICAgIGV4cGVjdChwZW5kaW5nT2JqLnVpZCkudG8uZXF1YWwoaGFzaCk7XG4gICAgICAgIGV4cGVjdChKU09OLnN0cmluZ2lmeShwZW5kaW5nT2JqLnBvc3QpKS50by5lcXVhbChKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgIGV4cGVjdChwZW5kaW5nT2JqLnBvc3RIYXNoKS50by5lcXVhbChoYXNoKTtcbiAgICAgICAgZXhwZWN0KHBlbmRpbmdPYmoucHJlKS50by5iZS51bmRlZmluZWQ7XG5cbiAgICAgICAgdmFyIG1ldGEgPSBkYXRhc2V0Lm1ldGFbaGFzaF07XG4gICAgICAgIGV4cGVjdChtZXRhLmZyb21QZW5kaW5nKS50by5iZS50cnVlO1xuICAgICAgICBleHBlY3QobWV0YS5wZW5kaW5nVWlkKS50by5lcXVhbChwZW5kaW5nT2JqLmhhc2gpO1xuXG4gICAgICAgIC8vdGhlIG5vdGlmaWNhdGlvbiBmdW5jdGlvbiBpcyBjYWxsZWQgaW5zaWRlIGEgc2V0VGltZW91dCB3cmFwcGVyLCBzbyBuZWVkIHRvIHdhaXQgYW5vdGhlciAxbXMgdG8gbWFrZSBzdXJlXG4gICAgICAgIC8vdGhlIG5vdGlmaWNhdGlvbiBkb2VzIGdldCBpbnZva2VkLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZXhwZWN0KHVwZGF0ZUNCKS50by5oYXZlLmJlZW4uY2FsbGVkO1xuICAgICAgICAgIGV4cGVjdCh1cGRhdGVDQikudG8uaGF2ZS5iZWVuLmNhbGxlZFdpdGgoZGF0YVNldElkLCBudWxsLCBcImxvY2FsX3VwZGF0ZV9hcHBsaWVkXCIsIFwiY3JlYXRlXCIpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSwgMSk7XG4gICAgICAgIFxuICAgICAgfSwgZ2V0RmFpbCk7XG5cbiAgICB9LCBmYWlsKTtcblxuICB9KTtcblxuXG4gIGl0KFwic3luYy5kb1VwZGF0ZVwiLCBmdW5jdGlvbihkb25lKXtcbiAgICB2YXIgc3VjY2VzcyA9IHNpbm9uLnNweSgpO1xuICAgIHZhciBmYWlsID0gc2lub24uc3B5KCk7XG5cbiAgICB2YXIgdXBkYXRlQ0IgPSBzaW5vbi5zcHkoKTtcblxuICAgIHZhciBkYXRhID0ge1wibmFtZVwiOiBcIml0ZW0xX3VwZGF0ZWRcIn07XG4gICAgdmFyIGhhc2ggPSBzeW5jQ2xpZW50LmdlbmVyYXRlSGFzaChkYXRhKTtcblxuICAgIHN5bmNDbGllbnQubm90aWZ5KGZ1bmN0aW9uKGUpe1xuICAgICAgc3dpdGNoKGUuY29kZSl7XG4gICAgICAgIGNhc2UgJ2xvY2FsX3VwZGF0ZV9hcHBsaWVkJzpcbiAgICAgICAgICB1cGRhdGVDQihlLmRhdGFzZXRfaWQsIGUudWlkLCBlLmNvZGUsIGUubWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzeW5jQ2xpZW50LmRvVXBkYXRlKGRhdGFTZXRJZCwgdWlkLCBkYXRhLCBmdW5jdGlvbigpe1xuICAgICAgZXhwZWN0KGZhaWwpLnRvLmhhdmUubm90LmJlZW4uY2FsbGVkO1xuXG4gICAgICB2YXIgZ2V0RmFpbCA9IHNpbm9uLnNweSgpO1xuXG4gICAgICBzeW5jQ2xpZW50LmdldERhdGFzZXQoZGF0YVNldElkLCBmdW5jdGlvbihkYXRhc2V0KXtcbiAgICAgICAgZXhwZWN0KGdldEZhaWwpLnRvLmhhdmUubm90LmJlZW4uY2FsbGVkO1xuXG4gICAgICAgIC8vbm93IHRoZSBkYXRhc2V0IHNob3VsZCBoYXZlIHRoZSB1cGRhdGVkIGRhdGFcbiAgICAgICAgZXhwZWN0KEpTT04uc3RyaW5naWZ5KGRhdGFzZXQuZGF0YVt1aWRdLmRhdGEpKS50by5lcXVhbChKU09OLnN0cmluZ2lmeShkYXRhKSk7XG5cbiAgICAgICAgLy9jaGVjayBwZW5kaW5nIHJlY29yZHMsIHNpbmNlIHdlIGFyZSB1cGRhdGluZyBhIHBlbmRpbmcgZGF0YSByZWNvcmQsXG4gICAgICAgIC8vdGhlcmUgc2hvdWxkIHN0aWxsIG9ubHkgb25lIHBlbmRpbmcgZGF0YSBlbnRyeVxuICAgICAgICBleHBlY3QoXy5zaXplKGRhdGFzZXQucGVuZGluZykpLnRvLmVxdWFsKDEpO1xuICAgICAgICB2YXIgcGVuZGluZ09iaiA9IF8udmFsdWVzKGRhdGFzZXQucGVuZGluZylbMF07XG5cbiAgICAgICAgY29uc29sZS5sb2cocGVuZGluZ09iaik7XG4gICAgICAgIC8vaXQgc2hvdWxkIHN0aWxsIGJlIFwiY3JlYXRlXCIgYWN0aW9uXG4gICAgICAgIGV4cGVjdChwZW5kaW5nT2JqLmFjdGlvbikudG8uZXF1YWwoXCJjcmVhdGVcIik7XG4gICAgICAgIGV4cGVjdChwZW5kaW5nT2JqLmluRmxpZ2h0KS50by5iZS5mYWxzZTtcbiAgICAgICAgZXhwZWN0KHBlbmRpbmdPYmoudWlkKS50by5lcXVhbCh1aWQpO1xuICAgICAgICBleHBlY3QoSlNPTi5zdHJpbmdpZnkocGVuZGluZ09iai5wb3N0KSkudG8uZXF1YWwoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICBleHBlY3QocGVuZGluZ09iai5wb3N0SGFzaCkudG8uZXF1YWwoaGFzaCk7XG4gICAgICAgIGV4cGVjdChwZW5kaW5nT2JqLnByZSkudG8uYmUudW5kZWZpbmVkO1xuXG4gICAgICAgIC8vdGhlIG5vdGlmaWNhdGlvbiBmdW5jdGlvbiBpcyBjYWxsZWQgaW5zaWRlIGEgc2V0VGltZW91dCB3cmFwcGVyLCBzbyBuZWVkIHRvIHdhaXQgYW5vdGhlciAxbXMgdG8gbWFrZSBzdXJlXG4gICAgICAgIC8vdGhlIG5vdGlmaWNhdGlvbiBkb2VzIGdldCBpbnZva2VkLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZXhwZWN0KHVwZGF0ZUNCKS50by5oYXZlLmJlZW4uY2FsbGVkO1xuICAgICAgICAgIGV4cGVjdCh1cGRhdGVDQikudG8uaGF2ZS5iZWVuLmNhbGxlZFdpdGgoZGF0YVNldElkLCB1aWQsIFwibG9jYWxfdXBkYXRlX2FwcGxpZWRcIiwgXCJ1cGRhdGVcIik7XG4gICAgICAgICAgc3luY0NsaWVudC5ub3RpZnkodW5kZWZpbmVkKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0sIDEpO1xuXG4gICAgICB9LCBnZXRGYWlsKTtcblxuICAgIH0sIGZhaWwpO1xuICB9KTtcblxuICBpdChcInN5bmMuZG9MaXN0IHN1Y2Nlc3NcIiwgZnVuY3Rpb24oZG9uZSl7IFxuICAgIHZhciBmYWlsID0gc2lub24uc3B5KCk7XG5cbiAgICBzeW5jQ2xpZW50LmRvTGlzdChkYXRhU2V0SWQsIGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgZXhwZWN0KGZhaWwpLnRvLmhhdmUubm90LmJlZW4uY2FsbGVkO1xuXG4gICAgICBleHBlY3QoXy5zaXplKGRhdGEpKS50by5lcXVhbCgxKTtcbiAgICAgIGV4cGVjdChkYXRhW3VpZF0uZGF0YS5uYW1lKS50by5lcXVhbChcIml0ZW0xX3VwZGF0ZWRcIik7XG4gICAgICBkb25lKCk7XG4gICAgfSwgZmFpbCk7XG5cbiAgfSk7XG5cbiAgaXQoXCJzeW5jLmRvTGlzdCBmYWlsXCIsIGZ1bmN0aW9uKGRvbmUpe1xuICAgIHZhciBzdWNjZXNzID0gc2lub24uc3B5KCk7XG5cbiAgICBzeW5jQ2xpZW50LmRvTGlzdChcImludmFsaWREYXRhU2V0XCIsIHN1Y2Nlc3MsIGZ1bmN0aW9uKGVycil7XG4gICAgICBleHBlY3QoZXJyKS50by5lcXVhbChcInVua25vd25fZGF0YXNldCBpbnZhbGlkRGF0YVNldFwiKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgaXQoXCJzeW5jLmRvUmVhZCBzdWNjZXNzXCIsIGZ1bmN0aW9uKGRvbmUpe1xuICAgIHZhciBmYWlsID0gc2lub24uc3B5KCk7XG5cbiAgICBzeW5jQ2xpZW50LmRvUmVhZChkYXRhU2V0SWQsIHVpZCwgZnVuY3Rpb24oZGF0YSl7XG4gICAgICBleHBlY3QoZmFpbCkudG8uaGF2ZS5ub3QuYmVlbi5jYWxsZWQ7XG4gICAgICBleHBlY3QoZGF0YS5kYXRhLm5hbWUpLmVxdWFsKFwiaXRlbTFfdXBkYXRlZFwiKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9LCBmYWlsKTtcbiAgfSk7XG5cbiAgaXQoXCJzeW5jLmRvUmVhZCBmYWlsXCIsIGZ1bmN0aW9uKGRvbmUpe1xuICAgIHZhciBzdWNjZXNzID0gc2lub24uc3B5KCk7XG5cbiAgICBzeW5jQ2xpZW50LmRvUmVhZChkYXRhU2V0SWQsIFwiaW52YWxpZGlkXCIsIHN1Y2Nlc3MsIGZ1bmN0aW9uKGVycil7XG4gICAgICBleHBlY3Qoc3VjY2VzcykudG8uaGF2ZS5ub3QuYmVlbi5jYWxsZWQ7XG4gICAgICBleHBlY3QoZXJyKS50by5lcXVhbChcInVua25vd25fdWlkXCIpO1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9KTtcblxuICBpdChcInN5bmMuZ2V0UGVuZGluZ1wiLCBmdW5jdGlvbihkb25lKXtcbiAgICB2YXIgZmFpbCA9IHNpbm9uLnNweSgpO1xuXG4gICAgc3luY0NsaWVudC5nZXRQZW5kaW5nKGRhdGFTZXRJZCwgZnVuY3Rpb24ocGVuZGluZyl7XG4gICAgICBleHBlY3QoZmFpbCkuaGF2ZS5ub3QuYmVlbi5jYWxsZWQ7XG4gICAgICBleHBlY3QoXy5zaXplKHBlbmRpbmcpKS50by5lcXVhbCgxKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9LCBmYWlsKTtcbiAgfSk7XG5cbiAgaXQoXCJzeW5jLnN0b3BTeW5jL3N0YXJ0U3luY1wiLCBmdW5jdGlvbihkb25lKXtcblxuICAgIHZhciBjYjEgPSBzaW5vbi5zcHkoKTtcbiAgICB2YXIgY2IyID0gc2lub24uc3B5KCk7XG5cbiAgICBzeW5jQ2xpZW50LnN0b3BTeW5jKGRhdGFTZXRJZCk7XG5cbiAgICBzeW5jQ2xpZW50Lm5vdGlmeShmdW5jdGlvbihlKXtcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgc3dpdGNoKGUuY29kZSl7XG4gICAgICAgIGNhc2UgXCJzeW5jX3N0YXJ0ZWRcIjpcbiAgICAgICAgICBjYjEoZS5jb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN5bmNfZmFpbGVkXCI6XG4gICAgICAgICAgY2IyKGUuY29kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAvL2Egc3luY0xvb3Agc2hvdWxkIGFscmVhZHkgYmUgcnVuLCBidXQgc2luY2Ugd2Ugc3RvcHBlZCBzeW5jLFxuICAgICAgLy9ub25lIG9mIHRoZSBub3RpZmljYXRpb25zIHNob3VsZCBiZSBmaXJlZFxuICAgICAgZXhwZWN0KGNiMSkubm90LmhhdmUuYmVlbi5jYWxsZWQ7XG4gICAgICBleHBlY3QoY2IyKS5ub3QuaGF2ZS5iZWVuLmNhbGxlZDtcblxuICAgICAgLy9zdGFydCBzeW5jXG4gICAgICBzeW5jQ2xpZW50LnN0YXJ0U3luYyhkYXRhU2V0SWQsIGZ1bmN0aW9uKCl7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICBleHBlY3QoY2IxKS5oYXZlLmJlZW4uY2FsbGVkT25jZTtcbiAgICAgICAgICBleHBlY3QoY2IyKS5oYXZlLmJlZW4uY2FsbGVkT25jZTtcblxuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSwgMTAwMSk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgIH0sIDEwMDEpO1xuICB9KTtcblxuICBpdChcInN5bmMuZG9EZWxldGVcIiwgZnVuY3Rpb24oZG9uZSl7XG4gICAgdmFyIGZhaWwgPSBzaW5vbi5zcHkoKTtcblxuICAgIHN5bmNDbGllbnQuZG9EZWxldGUoZGF0YVNldElkLCB1aWQsIGZ1bmN0aW9uKGRhdGFzZXQpe1xuICAgICAgZXhwZWN0KGZhaWwpLnRvLmhhdmUubm90LmJlZW4uY2FsbGVkO1xuXG4gICAgICAvL3RoZSBkYXRhIHNob3VsZCBiZSBnb25lIG5vd1xuICAgICAgZXhwZWN0KF8uc2l6ZShkYXRhc2V0LmRhdGEpKS50by5lcXVhbCgwKTtcbiAgICAgIC8vdGhlIHBlbmRpbmcgZGF0YSBzaG91bGQgYmUgZ29uZSBhcyB3ZWxsXG4gICAgICBleHBlY3QoXy5zaXplKGRhdGFzZXQucGVuZGluZykpLnRvLmVxdWFsKDApO1xuICAgICAgZG9uZSgpO1xuICAgIH0sIGZhaWwpO1xuICB9KTtcblxuICBpdChcInN5bmMuZG9TeW5jXCIsIGZ1bmN0aW9uKGRvbmUpe1xuXG4gICAgdmFyIGNiMSA9IHNpbm9uLnNweSgpO1xuICAgIHZhciBjYjIgPSBzaW5vbi5zcHkoKTtcblxuXG4gICAgc3luY0NsaWVudC5ub3RpZnkoZnVuY3Rpb24oZSl7XG4gICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgIHN3aXRjaChlLmNvZGUpe1xuICAgICAgICBjYXNlIFwic3luY19zdGFydGVkXCI6XG4gICAgICAgICAgY2IxKGUuY29kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzeW5jX2ZhaWxlZFwiOlxuICAgICAgICAgIGNiMihlLmNvZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy9zdGFydCBzeW5jXG4gICAgc3luY0NsaWVudC5zdGFydFN5bmMoZGF0YVNldElkLCBmdW5jdGlvbigpe1xuICAgICAgc3luY0NsaWVudC5kb1N5bmMoZGF0YVNldElkLCBmdW5jdGlvbigpe1xuICAgICAgICAvL29uY2UgZG9TeW5jIGlzIGNhbGxlZCwgYSBzeW5jIGxvb3Agc2hvdWxkIGhhcHBlbiBpbiBuZXh0IDUwMG1zXG4gICAgICAgIC8vbm8gbWF0dGVyIHdoYXQgdGhlIHZhbHVlIG9mIHN5bmMgZnJlcWVuY3lcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIGV4cGVjdChjYjEpLmhhdmUuYmVlbi5jYWxsZWRPbmNlO1xuICAgICAgICAgIGV4cGVjdChjYjIpLmhhdmUuYmVlbi5jYWxsZWRPbmNlO1xuXG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9LCA1MDEpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGl0KFwic3luYy5mb3JjZVN5bmNcIiwgZnVuY3Rpb24oZG9uZSl7XG4gICAgdmFyIGNiMSA9IHNpbm9uLnNweSgpO1xuICAgIHZhciBjYjIgPSBzaW5vbi5zcHkoKTtcblxuXG4gICAgc3luY0NsaWVudC5ub3RpZnkoZnVuY3Rpb24oZSl7XG4gICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgIHN3aXRjaChlLmNvZGUpe1xuICAgICAgICBjYXNlIFwic3luY19zdGFydGVkXCI6XG4gICAgICAgICAgY2IxKGUuY29kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzeW5jX2ZhaWxlZFwiOlxuICAgICAgICAgIGNiMihlLmNvZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy9zeW5jIGlzIHN0b3BwZWQsIGJ1dCBpZiBmb3JjZVN5bmMgaXMgY2FsbGVkLCBhIHN5bmMgbG9vcCB3aWxsIHN0aWxsIGhhcHBlblxuICAgIHN5bmNDbGllbnQuZm9yY2VTeW5jKGRhdGFTZXRJZCwgZnVuY3Rpb24oKXtcbiAgICAgIC8vb25jZSBkb1N5bmMgaXMgY2FsbGVkLCBhIHN5bmMgbG9vcCBzaG91bGQgaGFwcGVuIGluIG5leHQgNTAwbXNcbiAgICAgIC8vbm8gbWF0dGVyIHdoYXQgdGhlIHZhbHVlIG9mIHN5bmMgZnJlcWVuY3lcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgZXhwZWN0KGNiMSkuaGF2ZS5iZWVuLmNhbGxlZE9uY2U7XG4gICAgICAgIGV4cGVjdChjYjIpLmhhdmUuYmVlbi5jYWxsZWRPbmNlO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIDUwMSk7XG4gICAgfSk7XG4gIH0pO1xufSk7IiwidmFyIHByb2Nlc3MgPSByZXF1aXJlKFwicHJvY2Vzc1wiKTtcbmlmKGRvY3VtZW50ICYmIGRvY3VtZW50LmxvY2F0aW9uKXtcbiAgaWYoZG9jdW1lbnQubG9jYXRpb24uaHJlZi5pbmRleE9mKFwiY292ZXJhZ2U9MVwiKSA+IC0xKXtcbiAgICBwcm9jZXNzLmVudi5MSUJfQ09WID0gMTtcbiAgfVxufVxuXG52YXIgc3luY0NsaWVudCA9IHByb2Nlc3MuZW52LkxJQl9DT1Y/IHJlcXVpcmUoXCIuLi8uLi9zcmMtY292L21vZHVsZXMvc3luYy1jbGlcIikgOiByZXF1aXJlKFwiLi4vLi4vc3JjL21vZHVsZXMvc3luYy1jbGlcIik7XG52YXIgY2hhaSA9IHJlcXVpcmUoJ2NoYWknKTtcbnZhciBleHBlY3QgPSBjaGFpLmV4cGVjdDtcbnZhciBzaW5vbkNoYWkgPSByZXF1aXJlKCdzaW5vbi1jaGFpJyk7XG52YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXG5jaGFpLnVzZShzaW5vbkNoYWkpO1xuXG4vL3dvcmsgYXJvdW5kIHBoYW50b21qcydzIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMDY0N1xudmFyIGZha2VOYXZpZ2F0b3IgPSB7fTtcbmZvciAodmFyIGkgaW4gbmF2aWdhdG9yKSB7IFxuICAgIGZha2VOYXZpZ2F0b3JbaV0gPSBuYXZpZ2F0b3JbaV07XG59XG5mYWtlTmF2aWdhdG9yLm9uTGluZSA9IHRydWU7XG5uYXZpZ2F0b3IgPSBmYWtlTmF2aWdhdG9yO1xuXG52YXIgZGF0YVNldElkID0gXCJteVNob3BwaW5nTGlzdFwiO1xudmFyIG9uU3luYyA9IGZ1bmN0aW9uKGNiKXtcbiAgc3luY0NsaWVudC5mb3JjZVN5bmMoZGF0YVNldElkLCBmdW5jdGlvbigpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGNiKCk7XG4gICAgfSwgNTAxKTtcbiAgfSk7XG59XG5cbnN5bmNDbGllbnQuaW5pdCh7XG4gIGRvX2NvbnNvbGVfbG9nOiB0cnVlLFxuICBzeW5jX2ZyZXF1ZW5jeTogMSxcbiAgc3luY19hY3RpdmU6IGZhbHNlLFxuICBzdG9yYWdlX3N0cmF0ZWd5OiBbJ21lbW9yeSddLFxuICBjcmFzaGVkX2NvdW50X3dhaXQ6IDBcbn0pO1xuXG5kZXNjcmliZShcInRlc3Qgc3luYyBmcmFtZXdvcmsgb25saW5lIHdpdGggZmFrZSBYTUxIdHRwUmVxdWVzdFwiLCBmdW5jdGlvbigpe1xuICB0aGlzLnRpbWVvdXQoMTAwMDApO1xuICB2YXIgaGVhZGVyID0geyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9O1xuICB2YXIgeGhyLCByZXF1ZXN0cztcbiAgYmVmb3JlKGZ1bmN0aW9uKGRvbmUpe1xuICAgIHN5bmNDbGllbnQubWFuYWdlKGRhdGFTZXRJZCwge1wic3luY19hY3RpdmVcIjogZmFsc2V9LCB7fSwge30sIGRvbmUpO1xuICB9KTtcblxuICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpe1xuICAgIHhociA9IHNpbm9uLnVzZUZha2VYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3RzID0gW107XG5cbiAgICB4aHIub25DcmVhdGUgPSBmdW5jdGlvbihyZXEpe1xuICAgICAgY29uc29sZS5sb2coXCJHb3Qgc3luYyByZXF1ZXN0XCIsIHJlcSk7XG4gICAgICByZXF1ZXN0cy5wdXNoKHJlcSk7XG4gICAgfVxuXG4gICAgc3luY0NsaWVudC5jbGVhclBlbmRpbmcoZGF0YVNldElkLCBmdW5jdGlvbigpe1xuICAgICAgZG9uZSgpOyBcbiAgICB9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKGZ1bmN0aW9uKGRvbmUpe1xuICAgIHhoci5yZXN0b3JlKCk7XG4gICAgc3luY0NsaWVudC5ub3RpZnkodW5kZWZpbmVkKTtcbiAgICBzeW5jQ2xpZW50LnN0b3BTeW5jKGRhdGFTZXRJZCwgZG9uZSwgZG9uZSk7XG4gIH0pO1xuXG4gIGl0KFwibG9hZCBpbml0aWFsIGRhdGFzZXQgZnJvbSByZW1vdGVcIiwgZnVuY3Rpb24oZG9uZSl7XG4gICAgLy9zaW5jZSB3ZSB3YW50IHRvIGNoZWNrIHdoYXQgcmVxdWVzdHMgaGF2ZSBiZWVuIHNlbnQgYW5kIHRoZWlyIGRhdGEsXG4gICAgLy93ZSB0dXJuIG9mZiBzeW5jIGFuZCB1c2UgZm9yY2VTeW5jIHRvIGNvbnRyb2wgc3luYyBsb29wXG4gICAgb25TeW5jKGZ1bmN0aW9uKCl7XG4gICAgICAvL3ZlcmlmeSB0aGVyZSBpcyBvbmUgcmVxdWVzdCBpcyBpbiB0aGUgcXVldWVcbiAgICAgIGV4cGVjdChyZXF1ZXN0cy5sZW5ndGgpLnRvLmVxdWFsKDEpO1xuXG4gICAgICB2YXIgcmVxT2JqID0gcmVxdWVzdHNbMF07XG4gICAgICBleHBlY3QocmVxT2JqLnVybCkudG8uaGF2ZS5zdHJpbmcoXCIvbWJhYXMvc3luYy9cIiArIGRhdGFTZXRJZCk7XG4gICAgICBleHBlY3QocmVxT2JqLm1ldGhvZC50b0xvd2VyQ2FzZSgpKS50by5lcXVhbChcInBvc3RcIik7XG4gICAgICB2YXIgcmVxQm9keSA9IEpTT04ucGFyc2UocmVxT2JqLnJlcXVlc3RCb2R5KTtcbiAgICAgIGV4cGVjdChyZXFCb2R5LmZuKS50by5lcXVhbChcInN5bmNcIik7XG4gICAgICBleHBlY3QocmVxQm9keS5wZW5kaW5nKS5pcy5lbXB0eTtcblxuICAgICAgLy9yZXR1cm4gaGFzaFxuICAgICAgdmFyIG1vY2tIYXNoID0gXCI5N2QxNzBlMTU1MGVlZTRhZmMwYWYwNjViNzhjZGEzMDJhOTc2NzRjXCI7XG4gICAgICByZXFPYmoucmVzcG9uZCgyMDAsIGhlYWRlciwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBcImhhc2hcIjogbW9ja0hhc2gsXG4gICAgICAgIFwicmVjb3Jkc1wiOiB7fSxcbiAgICAgICAgXCJ1cGRhdGVzXCI6IHt9XG4gICAgICB9KSk7XG5cbiAgICAgIC8vc2VydmVyIHR1cm5lZCBlbXB0eSBkYXRhc2V0LCB0aGVuIHRoZSBjbGllbnQgZGF0YXNldCBzaG91bGQgYmUgZW1wdHkgYXMgd2VsbFxuICAgICAgc3luY0NsaWVudC5nZXREYXRhc2V0KGRhdGFTZXRJZCwgZnVuY3Rpb24oZGF0YXNldCl7XG4gICAgICAgIGV4cGVjdChkYXRhc2V0LmRhdGEpLmlzLmVtcHR5O1xuICAgICAgICBleHBlY3QoZGF0YXNldC5oYXNoKS50by5lcXVhbChtb2NrSGFzaCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBpdChcInRyeSBjcmVhdGUgYSBuZXcgcmVjb3JkXCIsIGZ1bmN0aW9uKGRvbmUpe1xuXG4gICAgdmFyIHJlY29yZCA9IHtcIm5hbWVcIjpcIml0ZW0xXCIsIFwiY3JlYXRlZFwiOiAxMzk2NTM3MTc4ODE3fTtcblxuICAgIG9uU3luYyhmdW5jdGlvbigpe1xuICAgICAgZXhwZWN0KHJlcXVlc3RzLmxlbmd0aCkudG8uZXF1YWwoMSk7XG4gICAgICB2YXIgcmVxT2JqID0gcmVxdWVzdHNbMF07XG4gICAgICB2YXIgcmVxQm9keSA9IEpTT04ucGFyc2UocmVxT2JqLnJlcXVlc3RCb2R5KTtcbiAgICAgIHZhciBtb2NrSGFzaCA9IFwiOTdkMTcwZTE1NTBlZWU0YWZjMGFmMDY1Yjc4Y2RhMzAyYTk3Njc0Y1wiO1xuICAgICAgZXhwZWN0KHJlcUJvZHkuZGF0YXNldF9oYXNoKS50by5lcXVhbChtb2NrSGFzaCk7XG5cbiAgICAgIHJlcU9iai5yZXNwb25kKDIwMCwgaGVhZGVyLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIFwidXBkYXRlc1wiOiB7fVxuICAgICAgfSkpO1xuXG4gICAgICAvL3NlcnZlciB0dXJuZWQgZW1wdHkgZGF0YXNldCwgdGhlbiB0aGUgY2xpZW50IGRhdGFzZXQgc2hvdWxkIGJlIGVtcHR5IGFzIHdlbGxcbiAgICAgIHN5bmNDbGllbnQuZ2V0RGF0YXNldChkYXRhU2V0SWQsIGZ1bmN0aW9uKGRhdGFzZXQpe1xuICAgICAgICBleHBlY3QoZGF0YXNldC5kYXRhKS5pcy5lbXB0eTtcbiAgICAgICAgZXhwZWN0KGRhdGFzZXQuaGFzaCkudG8uZXF1YWwobW9ja0hhc2gpO1xuXG4gICAgICAgIC8vbm93IGFkZCBhIG5ldyByZWNvcmRcbiAgICAgICAgXG4gICAgICAgIHZhciBmYWlsID0gc2lub24uc3B5KCk7XG4gICAgICAgIHN5bmNDbGllbnQuZG9DcmVhdGUoZGF0YVNldElkLCByZWNvcmQsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgLy90cnkgdG8gY3JlYXRlIHRoZSBzYW1lIHJlY29yZCBtdWx0aXBsZSB0aW1lcyB3aWxsIGdlbmVyYXRlIHRoZSBzYW1lIGhhc2gsIFxuICAgICAgICAgIC8vd2hpY2ggd2lsbCBvbmx5IGNyZWF0ZSBvbmUgcGVuZGluZyByZXF1ZXN0XG4gICAgICAgICAgc3luY0NsaWVudC5kb0NyZWF0ZShkYXRhU2V0SWQsIHJlY29yZCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGV4cGVjdChmYWlsKS50by5oYXZlLm5vdC5iZWVuLmNhbGxlZDtcbiAgICAgICAgICAgIC8vZm9yY2Ugc3luYyBhbmQgY2hlY2sgdGhlIHJlcXVlc3QgcGFyYW1zXG4gICAgICAgICAgICBvblN5bmMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgY2hlY2tVcGRhdGVSZXF1ZXN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICB9LCBmYWlsKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGNoZWNrVXBkYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKCl7XG4gICAgICBleHBlY3QocmVxdWVzdHMubGVuZ3RoKS50by5lcXVhbCgyKTtcbiAgICAgIHZhciByZXFPYmogPSByZXF1ZXN0c1sxXTtcbiAgICAgIHZhciByZXFCb2R5ID0gSlNPTi5wYXJzZShyZXFPYmoucmVxdWVzdEJvZHkpO1xuICAgICAgZXhwZWN0KHJlcUJvZHkucGVuZGluZy5sZW5ndGgpLnRvLmVxdWFsKDEpO1xuXG4gICAgICB2YXIgcGVuZGluZ09iaiA9IHJlcUJvZHkucGVuZGluZ1swXTtcbiAgICAgIGV4cGVjdChwZW5kaW5nT2JqLmluRmxpZ2h0KS50by5iZS50cnVlO1xuICAgICAgZXhwZWN0KHBlbmRpbmdPYmouYWN0aW9uKS50by5lcXVhbChcImNyZWF0ZVwiKTtcbiAgICAgIGV4cGVjdChKU09OLnN0cmluZ2lmeShwZW5kaW5nT2JqLnBvc3QpKS50by5lcXVhbChKU09OLnN0cmluZ2lmeShyZWNvcmQpKTtcblxuICAgICAgdmFyIHBlbmRpbmdIYXNoID0gcGVuZGluZ09iai5oYXNoO1xuXG4gICAgICB2YXIgbW9ja1JlcyA9IHtcbiAgICAgICAgXCJoYXNoXCI6IFwiNDI0ZTRkZmY1YWEyN2MyZmI3YmYwZmM3NGQzOWI5NGRhZTQ1NzJlYlwiLFxuICAgICAgICBcInVwZGF0ZXNcIjoge1xuICAgICAgICAgICAgXCJoYXNoZXNcIjoge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYXBwbGllZFwiOiB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbW9ja1Jlcy51cGRhdGVzLmhhc2hlc1twZW5kaW5nSGFzaF0gPSB7XG4gICAgICAgIFwiY3VpZFwiOiBcIjlGMzkzMEZFMkE0MzRFMEJBMEFENkY1QTQwQzc3Q0Q3XCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFwcGxpZWRcIixcbiAgICAgICAgXCJhY3Rpb25cIjogXCJjcmVhdGVcIixcbiAgICAgICAgXCJoYXNoXCI6IFwiMjI4NzBkZDQwYjE3NTI5MmIzZTYwZDYzMjQwZDU3YjRiOGI1YTYyM1wiLFxuICAgICAgICBcInVpZFwiOiBcIjUzM2Q3NzVhOGU4MTU5ZDljNjAwMDAwMVwiLFxuICAgICAgICBcIm1zZ1wiOiBcIicnXCJcbiAgICAgIH1cblxuICAgICAgbW9ja1Jlcy51cGRhdGVzLmFwcGxpZWRbcGVuZGluZ0hhc2hdID0ge1xuICAgICAgICBcImN1aWRcIjogXCI5RjM5MzBGRTJBNDM0RTBCQTBBRDZGNUE0MEM3N0NEN1wiLFxuICAgICAgICBcInR5cGVcIjogXCJhcHBsaWVkXCIsXG4gICAgICAgIFwiYWN0aW9uXCI6IFwiY3JlYXRlXCIsXG4gICAgICAgIFwiaGFzaFwiOiBcIjIyODcwZGQ0MGIxNzUyOTJiM2U2MGQ2MzI0MGQ1N2I0YjhiNWE2MjNcIixcbiAgICAgICAgXCJ1aWRcIjogXCI1MzNkNzc1YThlODE1OWQ5YzYwMDAwMDFcIixcbiAgICAgICAgXCJtc2dcIjogXCInJ1wiXG4gICAgICB9XG5cbiAgICAgIHJlcU9iai5yZXNwb25kKDIwMCwgaGVhZGVyLCBKU09OLnN0cmluZ2lmeShtb2NrUmVzKSk7XG4gICAgICAvL3RoZSBzeW5jIGNsaWVudCBzaG91bGQgdHJ5IHRvIHN5bmNSZWNvcmRzIGltbWVkaWF0ZWx5XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXF1ZXN0cy5sZW5ndGgpLnRvLmVxdWFsKDMpO1xuICAgICAgdmFyIHJlcU9iajEgPSByZXF1ZXN0c1syXTtcbiAgICAgIHZhciByZXFCb2R5MSA9IEpTT04ucGFyc2UocmVxT2JqMS5yZXF1ZXN0Qm9keSk7XG5cbiAgICAgIGV4cGVjdChyZXFPYmoxLnVybCkudG8uaGF2ZS5zdHJpbmcoXCIvbWJhYXMvc3luYy9cIiArIGRhdGFTZXRJZCk7XG4gICAgICBleHBlY3QocmVxQm9keTEuZm4pLnRvLmVxdWFsKFwic3luY1JlY29yZHNcIik7XG4gICAgICBleHBlY3QoXy5zaXplKHJlcUJvZHkxLmNsaWVudFJlY3MpKS50by5lcXVhbCgxKTsgLy90aGVyZSBpcyBvbmUgcmVjb3JkIGluIHRoZSBjbGllbnRcblxuICAgICAgdmFyIG1vY2tSZXMxID0ge1xuICAgICAgICBcImNyZWF0ZVwiOiB7XG4gICAgICAgICAgICBcIjUzM2Q3NzVhOGU4MTU5ZDljNjAwMDAwMVwiOiB7XG4gICAgICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaXRlbTFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjcmVhdGVkXCI6IDEzOTY1MzcxNzg4MTdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiaGFzaFwiOiBcIjljZDMwMWQ2ZDUxZDAzODI0OWRkN2NmYWYzYWM4OGU0Zjc2ZGZlYjJcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInVwZGF0ZVwiOiB7fSxcbiAgICAgICAgXCJkZWxldGVcIjoge1xuICAgICAgICAgICAgXCI5Y2QzMDFkNmQ1MWQwMzgyNDlkZDdjZmFmM2FjODhlNGY3NmRmZWIyXCI6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIFwiaGFzaFwiOiBcIjQyNGU0ZGZmNWFhMjdjMmZiN2JmMGZjNzRkMzliOTRkYWU0NTcyZWJcIlxuICAgICAgfVxuXG4gICAgICByZXFPYmoxLnJlc3BvbmQoMjAwLCBoZWFkZXIsIEpTT04uc3RyaW5naWZ5KG1vY2tSZXMxKSk7XG4gICAgICAvL3ZlcmlmeSBsb2NhbCBkYXRhc2V0IGNvbnRhaW5zIHRoZSBzYW1lIGRhdGEgYXMgc2VydmVyXG4gICAgICBzeW5jQ2xpZW50LmdldERhdGFzZXQoZGF0YVNldElkLCBmdW5jdGlvbihkYXRhc2V0KXtcbiAgICAgICAgZXhwZWN0KF8uc2l6ZShkYXRhc2V0LmRhdGEpKS50by5lcXVhbCgxKTtcbiAgICAgICAgY29uc29sZS5sb2coZGF0YXNldCk7XG4gICAgICAgIGV4cGVjdChfLmtleXMoZGF0YXNldC5kYXRhKVswXSkudG8uZXF1YWwoXCI1MzNkNzc1YThlODE1OWQ5YzYwMDAwMDFcIik7XG4gICAgICAgIGV4cGVjdChfLnZhbHVlcyhkYXRhc2V0LmRhdGEpWzBdLmhhc2gpLnRvLmVxdWFsKFwiOWNkMzAxZDZkNTFkMDM4MjQ5ZGQ3Y2ZhZjNhYzg4ZTRmNzZkZmViMlwiKTtcbiAgICAgICAgZXhwZWN0KEpTT04uc3RyaW5naWZ5KF8udmFsdWVzKGRhdGFzZXQuZGF0YSlbMF0uZGF0YSkpLnRvLmVxdWFsKEpTT04uc3RyaW5naWZ5KHJlY29yZCkpO1xuICAgICAgICBleHBlY3QoZGF0YXNldC5oYXNoKS50by5lcXVhbChcIjQyNGU0ZGZmNWFhMjdjMmZiN2JmMGZjNzRkMzliOTRkYWU0NTcyZWJcIik7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgfVxuICB9KTtcblxuICBpdChcInRyeSB0byB1cGRhdGUgYW4gZXhpc3RpbmcgcmVjb3JkIFwiLCBmdW5jdGlvbihkb25lKXtcbiAgICB2YXIgcHJlID0ge1wibmFtZVwiOlwiaXRlbTFcIiwgXCJjcmVhdGVkXCI6IDEzOTY1MzcxNzg4MTd9O1xuICAgIHZhciByZWNvcmQgPSB7IFwibmFtZVwiOiBcIml0ZW0xX3VwZGF0X2ZhaWxlZFwiLCBcImNyZWF0ZWRcIjogMTM5NjUzNzE3ODgxN307XG4gICAgdmFyIHVwZGF0ZSA9IHsgXCJuYW1lXCI6IFwiaXRlbTFfdXBkYXRlZFwiLCBcImNyZWF0ZWRcIjogMTM5NjUzNzE3ODgxN307XG4gICAgdmFyIHVpZCA9IFwiNTMzZDc3NWE4ZTgxNTlkOWM2MDAwMDAxXCI7XG4gICAgc3luY0NsaWVudC5kb1VwZGF0ZShkYXRhU2V0SWQsIHVpZCwgcmVjb3JkLCBmdW5jdGlvbigpe1xuXG4gICAgICBvblN5bmMoZnVuY3Rpb24oKXtcbiAgICAgICAgZXhwZWN0KHJlcXVlc3RzLmxlbmd0aCkudG8uZXF1YWwoMSk7XG4gICAgICAgIHZhciByZXFPYmogPSByZXF1ZXN0c1swXTtcbiAgICAgICAgdmFyIHJlcUJvZHkgPSBKU09OLnBhcnNlKHJlcU9iai5yZXF1ZXN0Qm9keSk7XG4gICAgICAgIGV4cGVjdChyZXFCb2R5LnBlbmRpbmcubGVuZ3RoKS50by5lcXVhbCgxKTtcblxuICAgICAgICB2YXIgcGVuZGluZ09iaiA9IHJlcUJvZHkucGVuZGluZ1swXTtcbiAgICAgICAgZXhwZWN0KHBlbmRpbmdPYmouaW5GbGlnaHQpLnRvLmJlLnRydWU7XG4gICAgICAgIGV4cGVjdChwZW5kaW5nT2JqLmFjdGlvbikudG8uZXF1YWwoXCJ1cGRhdGVcIik7XG4gICAgICAgIGV4cGVjdChKU09OLnN0cmluZ2lmeSgocGVuZGluZ09iai5wcmUpKSkudG8uZXF1YWwoSlNPTi5zdHJpbmdpZnkoKHByZSkpKTtcbiAgICAgICAgZXhwZWN0KEpTT04uc3RyaW5naWZ5KHBlbmRpbmdPYmoucG9zdCkpLnRvLmVxdWFsKEpTT04uc3RyaW5naWZ5KHJlY29yZCkpO1xuXG4gICAgICAgIC8vcHJldGVuZCB0byBiZSBvZmZsaW5lIG9yIGJhZCBuZXR3b3JrXG4gICAgICAgIHJlcU9iai5yZXNwb25kKDAsIG51bGwsIG51bGwpO1xuICAgICAgICAvL3ZlcmlmeSB0aGUgZGF0YSBpcyBtYXJrZWQgd2l0aCBjcmFzaGVkXG4gICAgICAgIHN5bmNDbGllbnQuZ2V0RGF0YXNldChkYXRhU2V0SWQsIGZ1bmN0aW9uKGRhdGFzZXQpe1xuICAgICAgICAgIGV4cGVjdChkYXRhc2V0LmRhdGFbdWlkXS5kYXRhLm5hbWUpLnRvLmVxdWFsKFwiaXRlbTFfdXBkYXRfZmFpbGVkXCIpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGFzZXQucGVuZGluZyk7XG4gICAgICAgICAgZXhwZWN0KF8uc2l6ZShkYXRhc2V0LnBlbmRpbmcpKS50by5lcXVhbCgxKTtcbiAgICAgICAgICBleHBlY3QoXy52YWx1ZXMoZGF0YXNldC5wZW5kaW5nKVswXS5jcmFzaGVkKS50by5iZS50cnVlO1xuXG4gICAgICAgICAgLy9ub3cgdXBkYXRlIGFuIGFscmVhZHkgY3Jhc2hlZCByZWNvcmQ6XG4gICAgICAgICAgc3luY0NsaWVudC5kb1VwZGF0ZShkYXRhU2V0SWQsIHVpZCwgdXBkYXRlLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgc3luY0NsaWVudC5nZXREYXRhc2V0KGRhdGFTZXRJZCwgZnVuY3Rpb24oZGF0YXNldCl7XG4gICAgICAgICAgICAgIC8vYXQgdGhpcyBwb2ludCwgdGhlcmUgc2hvdWxkIGJlIDIgcGVuZGluZyBvYmplY3RzXG4gICAgICAgICAgICAgIGV4cGVjdChfLnNpemUoZGF0YXNldC5wZW5kaW5nKSkudG8uZXF1YWwoMik7XG5cbiAgICAgICAgICAgICAgdmFyIGRlbGF5ZWQgPSBfLmZpbmRXaGVyZShkYXRhc2V0LnBlbmRpbmcsIHtkZWxheWVkOiB0cnVlfSk7XG4gICAgICAgICAgICAgIHZhciBjcmFzaGVkID0gXy5maW5kV2hlcmUoZGF0YXNldC5wZW5kaW5nLCB7Y3Jhc2hlZDogdHJ1ZX0pO1xuICAgICAgICAgICAgICBleHBlY3QoZGVsYXllZCkubm90Lm51bGw7XG5cbiAgICAgICAgICAgICAgb25TeW5jKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHJlcXVlc3RzLmxlbmd0aCkudG8uZXF1YWwoMik7XG4gICAgICAgICAgICAgICAgdmFyIHJlcU9iajEgPSByZXF1ZXN0c1sxXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVxQm9keTEgPSBKU09OLnBhcnNlKHJlcU9iajEucmVxdWVzdEJvZHkpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChyZXFCb2R5MS5wZW5kaW5nLmxlbmd0aCkudG8uZXF1YWwoMCk7IC8vb25lIGlzIGNyYXNoZWQgYW5kIHRoZSBvdGhlciBpcyBkZWxheWVkXG5cbiAgICAgICAgICAgICAgICByZXFPYmoxLnJlc3BvbmQoMjAwLCBoZWFkZXIsIEpTT04uc3RyaW5naWZ5KHtoYXNoOiBkYXRhc2V0Lmhhc2h9KSk7IC8vaW5jcmVhc2UgdGhlIGNyYXNoIGNvdW50XG5cbiAgICAgICAgICAgICAgICBleHBlY3QoY3Jhc2hlZC5jcmFzaGVkQ291bnQpLnRvLmVxdWFsKDEpO1xuXG4gICAgICAgICAgICAgICAgb25TeW5jKGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICAgIC8vZG8gYW5vdGhlciBzeW5jLCB0aGlzIHRpbWUgdGhlIGNyYXNoIGRhdGEgc2hvdWxkIGJlIHNlbnQgYWdhaW5cbiAgICAgICAgICAgICAgICAgIC8vYXMgdGhlIGNyYXNoQ291bnQgaXMgZ3JlYXRlciB0aGFuIHRoZSB0aHJlc2hvbGRcbiAgICAgICAgICAgICAgICAgIGV4cGVjdChyZXF1ZXN0cy5sZW5ndGgpLnRvLmVxdWFsKDMpO1xuICAgICAgICAgICAgICAgICAgdmFyIHJlcU9iajIgPSByZXF1ZXN0c1syXTtcbiAgICAgICAgICAgICAgICAgIHZhciByZXFCb2R5MiA9IEpTT04ucGFyc2UocmVxT2JqMi5yZXF1ZXN0Qm9keSk7XG4gICAgICAgICAgICAgICAgICBleHBlY3QocmVxQm9keTIucGVuZGluZy5sZW5ndGgpLnRvLmVxdWFsKDEpO1xuICAgICAgICAgICAgICAgICAgdmFyIHBlbmRpbmdIYXNoID0gcmVxQm9keTIucGVuZGluZ1swXS5oYXNoO1xuICAgICAgICAgICAgICAgICAgdmFyIHByZWRhdGEgPSByZXFCb2R5Mi5wZW5kaW5nWzBdLnByZTtcbiAgICAgICAgICAgICAgICAgIHZhciBwcmVoYXNoID0gcmVxQm9keTIucGVuZGluZ1swXS5wcmVIYXNoO1xuXG5cbiAgICAgICAgICAgICAgICAgIHZhciBtb2NrUmVzID0ge1xuICAgICAgICAgICAgICAgICAgICBcImhhc2hcIjogXCI0MjRlNGRmZjVhYTI3YzJmYjdiZjBmYzc0ZDM5Yjk0ZGFlNDU3MmViXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXBkYXRlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJoYXNoZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJjb2xsaXNpb25zXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgICAgICBcInJlY29yZHNcIjoge1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgIG1vY2tSZXMudXBkYXRlcy5oYXNoZXNbcGVuZGluZ0hhc2hdID0gbW9ja1Jlcy51cGRhdGVzLmNvbGxpc2lvbnNbcGVuZGluZ0hhc2hdID0ge1xuICAgICAgICAgICAgICAgICAgICBcImN1aWRcIjogXCI5RjM5MzBGRTJBNDM0RTBCQTBBRDZGNUE0MEM3N0NEN1wiLFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJjb2xsaXNpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJhY3Rpb25cIjogXCJ1cGRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJoYXNoXCI6IHBlbmRpbmdIYXNoLFxuICAgICAgICAgICAgICAgICAgICBcInVpZFwiOiBcIjUzM2Q3NzVhOGU4MTU5ZDljNjAwMDAwMVwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1zZ1wiOiBcIicnXCJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgbW9ja1Jlcy5yZWNvcmRzW3VpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHByZWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGhhc2g6IHByZWhhc2hcbiAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICByZXFPYmoyLnJlc3BvbmQoMjAwLCBoZWFkZXIsIEpTT04uc3RyaW5naWZ5KG1vY2tSZXMpKTtcblxuICAgICAgICAgICAgICAgICAgZXhwZWN0KF8uc2l6ZShkYXRhc2V0LnBlbmRpbmcpKS50by5lcXVhbCgxKTtcblxuICAgICAgICAgICAgICAgICAgZXhwZWN0KF8udmFsdWVzKGRhdGFzZXQucGVuZGluZylbMF0ucHJlLm5hbWUpLnRvLmVxdWFsKFwiaXRlbTFcIik7XG5cbiAgICAgICAgICAgICAgICAgIG9uU3luYyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QocmVxdWVzdHMubGVuZ3RoKS50by5lcXVhbCg0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcU9iajMgPSByZXF1ZXN0c1szXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcUJvZHkzID0gSlNPTi5wYXJzZShyZXFPYmozLnJlcXVlc3RCb2R5KTtcblxuICAgICAgICAgICAgICAgICAgICBleHBlY3QocmVxQm9keTMucGVuZGluZy5sZW5ndGgpLnRvLmVxdWFsKDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVuZGluZ0hhc2ggPSByZXFCb2R5My5wZW5kaW5nWzBdLmhhc2g7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVkYXRhID0gcmVxQm9keTMucGVuZGluZ1swXS5wcmU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVoYXNoID0gcmVxQm9keTMucGVuZGluZ1swXS5wcmVIYXNoO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2NrUmVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgIFwiaGFzaFwiOiBcIjkzMmIwYjdlNjg2MmQ0NjM0ZGM2ZjQxOGRhNzE3Yzc4YzFhMWQ3NDJcIixcbiAgICAgICAgICAgICAgICAgICAgICBcInVwZGF0ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJoYXNoZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXBwbGllZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgIG1vY2tSZXMudXBkYXRlcy5oYXNoZXNbcGVuZGluZ0hhc2hdID0gbW9ja1Jlcy51cGRhdGVzLmFwcGxpZWRbcGVuZGluZ0hhc2hdID0ge1xuICAgICAgICAgICAgICAgICAgICAgIFwiY3VpZFwiOiBcIjlGMzkzMEZFMkE0MzRFMEJBMEFENkY1QTQwQzc3Q0Q3XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXBwbGllZFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWN0aW9uXCI6IFwidXBkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJoYXNoXCI6IHBlbmRpbmdIYXNoLFxuICAgICAgICAgICAgICAgICAgICAgIFwidWlkXCI6IFwiNTMzZDc3NWE4ZTgxNTlkOWM2MDAwMDAxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJtc2dcIjogXCInJ1wiXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXFPYmozLnJlc3BvbmQoMjAwLCBoZWFkZXIsIEpTT04uc3RyaW5naWZ5KG1vY2tSZXMpKTtcblxuICAgICAgICAgICAgICAgICAgICAvL3Nob3VsZCBzdGFydCBzeW5jUmVjb3Jkc1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QocmVxdWVzdHMubGVuZ3RoKS50by5lcXVhbCg1KTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxT2JqNCA9IHJlcXVlc3RzWzRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9ja1JlczEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImNyZWF0ZVwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidXBkYXRlXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkZWxldGVcIjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImhhc2hcIjogXCI5MzJiMGI3ZTY4NjJkNDYzNGRjNmY0MThkYTcxN2M3OGMxYTFkNzQyXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXFPYmo0LnJlc3BvbmQoMjAwLCBoZWFkZXIsIEpTT04uc3RyaW5naWZ5KG1vY2tSZXMxKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGRhdGFzZXQuaGFzaCkudG8uZXF1YWwoXCI5MzJiMGI3ZTY4NjJkNDYzNGRjNmY0MThkYTcxN2M3OGMxYTFkNzQyXCIpO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoXy5zaXplKGRhdGFzZXQucGVuZGluZykpLnRvLmVxdWFsKDApO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoZGF0YXNldC5kYXRhW3VpZF0uZGF0YS5uYW1lKS50by5lcXVhbChcIml0ZW0xX3VwZGF0ZWRcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGl0KFwidGVzdCBjcmVhdGUgJiBkZWxldGVcIiwgZnVuY3Rpb24oZG9uZSl7XG4gICAgdmFyIHJlY29yZCA9IHtuYW1lOlwiaXRlbTNcIn07XG4gICAgc3luY0NsaWVudC5kb0NyZWF0ZShkYXRhU2V0SWQsIHJlY29yZCwgZnVuY3Rpb24ocmVzKXtcbiAgICAgIHN5bmNDbGllbnQuZ2V0RGF0YXNldChkYXRhU2V0SWQsIGZ1bmN0aW9uKGRhdGFzZXQpe1xuICAgICAgICBleHBlY3QoXy5zaXplKGRhdGFzZXQucGVuZGluZykpLnRvLmVxdWFsKDEpO1xuICAgICAgICB2YXIgdWlkID0gcmVzLnVpZDtcbiAgICAgICAgc3luY0NsaWVudC5kb0RlbGV0ZShkYXRhU2V0SWQsIHVpZCwgZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICBleHBlY3QoXy5zaXplKGRhdGFzZXQucGVuZGluZykpLnRvLmVxdWFsKDApO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgaXQoXCJ0ZXN0IHJlbW90ZSBkYXRhIGNoYW5nZVwiLCBmdW5jdGlvbihkb25lKXtcbiAgICBvblN5bmMoZnVuY3Rpb24oKXtcbiAgICAgIGV4cGVjdChyZXF1ZXN0cy5sZW5ndGgpLnRvLmVxdWFsKDEpO1xuXG4gICAgICB2YXIgcmVxT2JqID0gcmVxdWVzdHNbMF07XG4gICAgICB2YXIgcmVxQm9keSA9IEpTT04ucGFyc2UocmVxT2JqLnJlcXVlc3RCb2R5KTtcblxuICAgICAgZXhwZWN0KHJlcUJvZHkucGVuZGluZy5sZW5ndGgpLnRvLmVxdWFsKDApO1xuXG4gICAgICB2YXIgbW9ja1JlcyA9IHtcbiAgICAgICAgaGFzaCA6IFwiMjFkYWVjMzAzYzdkOTNiN2Q4MDY4MjNlYWFhYWI2YjgyZjAzNjA5N1wiXG4gICAgICB9XG5cbiAgICAgIHJlcU9iai5yZXNwb25kKDIwMCwgaGVhZGVyLCBKU09OLnN0cmluZ2lmeShtb2NrUmVzKSk7XG5cbiAgICAgIGV4cGVjdChyZXF1ZXN0cy5sZW5ndGgpLnRvLmVxdWFsKDIpO1xuXG4gICAgICB2YXIgcmVxT2JqMSA9IHJlcXVlc3RzWzFdO1xuICAgICAgdmFyIHJlcUJvZHkxID0gSlNPTi5wYXJzZShyZXFPYmoxLnJlcXVlc3RCb2R5KTtcbiAgICAgIGV4cGVjdChfLnNpemUocmVxQm9keTEuY2xpZW50UmVjcykpLnRvLmVxdWFsKDEpO1xuXG4gICAgICB2YXIgbW9ja1JlczEgPSB7XG4gICAgICAgIGhhc2ggOiBcIjIxZGFlYzMwM2M3ZDkzYjdkODA2ODIzZWFhYWFiNmI4MmYwMzYwOTdcIixcbiAgICAgICAgY3JlYXRlOiB7XG4gICAgICAgICAgXCI1MzNkNzdhMzhlODE1OWQ5YzYwMDAwMDNcIjoge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpdGVtMlwiLFxuICAgICAgICAgICAgICAgIFwiY3JlYXRlZFwiOiAxMzk2NTM3MjUwNjkyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJoYXNoXCI6IFwiOWYzN2Y0NjEyNmExYzE4ZmYzYjEzZGUwNmQ4ZmM2YThmNGZkMTE2N1wiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlcU9iajEucmVzcG9uZCgyMDAsIGhlYWRlciwgSlNPTi5zdHJpbmdpZnkobW9ja1JlczEpKTtcblxuICAgICAgc3luY0NsaWVudC5nZXREYXRhc2V0KGRhdGFTZXRJZCwgZnVuY3Rpb24oZGF0YXNldCl7XG4gICAgICAgIGV4cGVjdChfLnNpemUoZGF0YXNldC5kYXRhKSkudG8uZXF1YWwoMik7XG4gICAgICAgIGV4cGVjdChkYXRhc2V0LmRhdGFbJzUzM2Q3N2EzOGU4MTU5ZDljNjAwMDAwMyddLmRhdGEubmFtZSkudG8uZXF1YWwoXCJpdGVtMlwiKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGl0KFwidGVzdCBkZWxldGUgZXhpc3RpbmcgZGF0YVwiLCBmdW5jdGlvbihkb25lKXtcbiAgICB2YXIgdWlkID0gXCI1MzNkNzdhMzhlODE1OWQ5YzYwMDAwMDNcIjtcbiAgICB2YXIgcmVjb3JkID0ge25hbWU6XCJpdGVtX3VwZGF0ZWRfYWdhaW5cIn07XG4gICAgc3luY0NsaWVudC5kb1VwZGF0ZShkYXRhU2V0SWQsIHVpZCwgcmVjb3JkLCBmdW5jdGlvbigpe1xuICAgICAgc3luY0NsaWVudC5nZXREYXRhc2V0KGRhdGFTZXRJZCwgZnVuY3Rpb24oZGF0YXNldCl7XG4gICAgICAgIGV4cGVjdChfLnNpemUoZGF0YXNldC5wZW5kaW5nKSkudG8uZXF1YWwoMSk7XG5cbiAgICAgICAgc3luY0NsaWVudC5kb0RlbGV0ZShkYXRhU2V0SWQsIHVpZCwgZnVuY3Rpb24oKXtcblxuICAgICAgICAgIGV4cGVjdChfLnNpemUoZGF0YXNldC5wZW5kaW5nKSkudG8uZXF1YWwoMSk7XG4gICAgICAgICAgZXhwZWN0KF8udmFsdWVzKGRhdGFzZXQucGVuZGluZylbMF0ucHJlLm5hbWUpLnRvLmVxdWFsKFwiaXRlbTJcIik7XG5cbiAgICAgICAgICBvblN5bmMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGV4cGVjdChyZXF1ZXN0cy5sZW5ndGgpLnRvLmVxdWFsKDEpO1xuXG4gICAgICAgICAgICB2YXIgcmVxT2JqID0gcmVxdWVzdHNbMF07XG4gICAgICAgICAgICB2YXIgcmVxQm9keSA9IEpTT04ucGFyc2UocmVxT2JqLnJlcXVlc3RCb2R5KTtcblxuICAgICAgICAgICAgZXhwZWN0KHJlcUJvZHkucGVuZGluZy5sZW5ndGgpLnRvLmVxdWFsKDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcUJvZHkucGVuZGluZ1swXS51aWQpLnRvLmVxdWFsKHVpZCk7XG5cbiAgICAgICAgICAgIHZhciBwZW5kaW5nSGFzaCA9IHJlcUJvZHkucGVuZGluZ1swXS5oYXNoO1xuXG4gICAgICAgICAgICB2YXIgbW9ja1JlcyA9IHtcbiAgICAgICAgICAgICAgICBcImhhc2hcIjogXCJmOWYxN2RlZmNjZjIyZDliZjFkMGZiNzNlMWY2YWY2YjY3YzI2NmU4XCIsXG4gICAgICAgICAgICAgICAgXCJ1cGRhdGVzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiaGFzaGVzXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgXCJhcHBsaWVkXCI6IHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb2NrUmVzLnVwZGF0ZXMuaGFzaGVzW3BlbmRpbmdIYXNoXSA9IG1vY2tSZXMudXBkYXRlcy5hcHBsaWVkW3BlbmRpbmdIYXNoXSA9IHtcbiAgICAgICAgICAgICAgXCJjdWlkXCI6IFwiOUYzOTMwRkUyQTQzNEUwQkEwQUQ2RjVBNDBDNzdDRDdcIixcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXBwbGllZFwiLFxuICAgICAgICAgICAgICBcImFjdGlvblwiOiBcImRlbGV0ZVwiLFxuICAgICAgICAgICAgICBcImhhc2hcIjogcGVuZGluZ0hhc2gsXG4gICAgICAgICAgICAgIFwidWlkXCI6IFwiNTMzZDc3YTM4ZTgxNTlkOWM2MDAwMDAzXCIsXG4gICAgICAgICAgICAgIFwibXNnXCI6IFwiJydcIlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXFPYmoucmVzcG9uZCgyMDAsIGhlYWRlciwgSlNPTi5zdHJpbmdpZnkobW9ja1JlcykpO1xuXG4gICAgICAgICAgICBleHBlY3QocmVxdWVzdHMubGVuZ3RoKS50by5lcXVhbCgyKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHJlcU9iajEgPSByZXF1ZXN0c1sxXTtcbiAgICAgICAgICAgIHZhciByZXFCb2R5MSA9IEpTT04ucGFyc2UocmVxT2JqMS5yZXF1ZXN0Qm9keSk7XG4gICAgICAgICAgICBleHBlY3QocmVxQm9keTEuZm4pLnRvLmVxdWFsKFwic3luY1JlY29yZHNcIik7XG5cbiAgICAgICAgICAgIGV4cGVjdChfLnNpemUocmVxQm9keTEuY2xpZW50UmVjcykpLnRvLmVxdWFsKDEpO1xuXG4gICAgICAgICAgICB2YXIgbW9ja1JlczEgPSB7XG4gICAgICAgICAgICAgIFwiY3JlYXRlXCI6IHt9LFxuICAgICAgICAgICAgICBcInVwZGF0ZVwiOiB7fSxcbiAgICAgICAgICAgICAgXCJkZWxldGVcIjoge30sXG4gICAgICAgICAgICAgIFwiaGFzaFwiOiBcImY5ZjE3ZGVmY2NmMjJkOWJmMWQwZmI3M2UxZjZhZjZiNjdjMjY2ZThcIlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXFPYmoxLnJlc3BvbmQoMjAwLCBoZWFkZXIsIEpTT04uc3RyaW5naWZ5KG1vY2tSZXMxKSk7XG5cbiAgICAgICAgICAgIHN5bmNDbGllbnQuZ2V0RGF0YXNldChkYXRhU2V0SWQsIGZ1bmN0aW9uKGRhdGFzZXQpe1xuICAgICAgICAgICAgICBleHBlY3QoZGF0YXNldC5oYXNoKS50by5lcXVhbChcImY5ZjE3ZGVmY2NmMjJkOWJmMWQwZmI3M2UxZjZhZjZiNjdjMjY2ZThcIik7XG4gICAgICAgICAgICAgIGV4cGVjdChfLnNpemUoZGF0YXNldC5kYXRhKSkudG8uZXF1YWwoMSk7XG4gICAgICAgICAgICAgIGV4cGVjdChfLnNpemUoZGF0YXNldC5wZW5kaW5nKSkudG8uZXF1YWwoMCk7XG4gICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBpdChcInRlc3QgdXBkYXRlIHBlbmRpbmcgZGF0YVwiLCBmdW5jdGlvbihkb25lKXtcbiAgICB2YXIgcmVjb3JkID0ge25hbWU6XCJpdGVtNFwifTtcbiAgICB2YXIgdXBkYXRlZCA9IHtuYW1lOlwiaXRlbTRfdXBkYXRlZFwifTtcbiAgICBzeW5jQ2xpZW50LmRvQ3JlYXRlKGRhdGFTZXRJZCwgcmVjb3JkLCBmdW5jdGlvbihyZXMpe1xuICAgICAgb25TeW5jKGZ1bmN0aW9uKCl7XG4gICAgICAgIGV4cGVjdChyZXF1ZXN0cy5sZW5ndGgpLnRvLmVxdWFsKDEpO1xuICAgICAgICB2YXIgcmVxT2JqID0gcmVxdWVzdHNbMF07XG4gICAgICAgIHZhciByZXFCb2R5ID0gSlNPTi5wYXJzZShyZXFPYmoucmVxdWVzdEJvZHkpO1xuXG4gICAgICAgIHZhciBwZW5kaW5nT2JqID0gcmVxQm9keS5wZW5kaW5nWzBdO1xuICAgICAgICB2YXIgcGVuZGluZ0hhc2ggPSBwZW5kaW5nT2JqLmhhc2g7XG5cbiAgICAgICAgLy9hdCB0aGlzIHBvaW50LCB0aGUgbmV3IHJlY29yZCBzaG91bGQgYmUgaW5mbGlnaHQsIHRyeSB0byB1cGRhdGUgaXRcbiAgICAgICAgc3luY0NsaWVudC5kb1VwZGF0ZShkYXRhU2V0SWQsIHJlcy51aWQsIHVwZGF0ZWQsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgLy90aGVuIGdvdCByZXNwb25zZSBmb3IgdGhlIHVwZGF0ZVxuICAgICAgICAgIHZhciBtb2NrUmVzID0ge1xuICAgICAgICAgICAgXCJoYXNoXCI6IFwiNDI0ZTRkZmY1YWEyN2MyZmI3YmYwZmM3NGQzOWI5NDQ4MjMyMzQ4MzJcIixcbiAgICAgICAgICAgIFwidXBkYXRlc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJoYXNoZXNcIjoge1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhcHBsaWVkXCI6IHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjb3Jkczoge1xuICAgICAgICAgICAgICBcIjUzM2Q3NzVhOGU4MTU5ZDljNjAwMDAwNVwiOiB7XG4gICAgICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiY3VpZFwiOiBcIjlGMzkzMEZFMkE0MzRFMEJBMEFENkY1QTQwQzc3Q0Q3XCIsXG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhcHBsaWVkXCIsXG4gICAgICAgICAgICAgICAgICBcImFjdGlvblwiOiBcImNyZWF0ZVwiLFxuICAgICAgICAgICAgICAgICAgXCJoYXNoXCI6IHBlbmRpbmdIYXNoLFxuICAgICAgICAgICAgICAgICAgXCJ1aWRcIjogXCI1MzNkNzc1YThlODE1OWQ5YzYwMDAwMDVcIixcbiAgICAgICAgICAgICAgICAgIFwibXNnXCI6IFwiJydcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJoYXNoXCI6IHBlbmRpbmdIYXNoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2NrUmVzLnVwZGF0ZXMuaGFzaGVzW3BlbmRpbmdIYXNoXSA9IHtcbiAgICAgICAgICAgIFwiY3VpZFwiOiBcIjlGMzkzMEZFMkE0MzRFMEJBMEFENkY1QTQwQzc3Q0Q3XCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcHBsaWVkXCIsXG4gICAgICAgICAgICBcImFjdGlvblwiOiBcImNyZWF0ZVwiLFxuICAgICAgICAgICAgXCJoYXNoXCI6IHBlbmRpbmdIYXNoLFxuICAgICAgICAgICAgXCJ1aWRcIjogXCI1MzNkNzc1YThlODE1OWQ5YzYwMDAwMDVcIixcbiAgICAgICAgICAgIFwibXNnXCI6IFwiJydcIlxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vY2tSZXMudXBkYXRlcy5hcHBsaWVkW3BlbmRpbmdIYXNoXSA9IHtcbiAgICAgICAgICAgIFwiY3VpZFwiOiBcIjlGMzkzMEZFMkE0MzRFMEJBMEFENkY1QTQwQzc3Q0Q3XCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcHBsaWVkXCIsXG4gICAgICAgICAgICBcImFjdGlvblwiOiBcImNyZWF0ZVwiLFxuICAgICAgICAgICAgXCJoYXNoXCI6IHBlbmRpbmdIYXNoLFxuICAgICAgICAgICAgXCJ1aWRcIjogXCI1MzNkNzc1YThlODE1OWQ5YzYwMDAwMDVcIixcbiAgICAgICAgICAgIFwibXNnXCI6IFwiJydcIlxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcU9iai5yZXNwb25kKDIwMCwgaGVhZGVyLCBKU09OLnN0cmluZ2lmeShtb2NrUmVzKSk7XG5cbiAgICAgICAgICBzeW5jQ2xpZW50LmdldERhdGFzZXQoZGF0YVNldElkLCBmdW5jdGlvbihkYXRhc2V0KXtcbiAgICAgICAgICAgIHZhciBwZW5kaW5nID0gZGF0YXNldC5wZW5kaW5nO1xuICAgICAgICAgICAgZXhwZWN0KF8uc2l6ZShwZW5kaW5nKSkudG8uZXF1YWwoMSk7XG4gICAgICAgICAgICB2YXIgcGVuZGluZ09iaiA9IF8udmFsdWVzKHBlbmRpbmcpWzBdO1xuICAgICAgICAgICAgZXhwZWN0KHBlbmRpbmdPYmoucHJlSGFzaCkudG8uZXF1YWwocGVuZGluZ0hhc2gpO1xuICAgICAgICAgICAgZXhwZWN0KHBlbmRpbmdPYmoudWlkKS50by5lcXVhbChcIjUzM2Q3NzVhOGU4MTU5ZDljNjAwMDAwNVwiKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgaXQoXCJ0ZXN0IGNyZWF0ZSBwZW5kaW5nIGRhdGFcIiwgZnVuY3Rpb24oZG9uZSl7XG4gICAgdmFyIHJlY29yZCA9IHtuYW1lOlwiaXRlbTVcIn07XG4gICAgb25TeW5jKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcmVxT2JqID0gcmVxdWVzdHNbMF07XG4gICAgICB2YXIgcmVxQm9keSA9IEpTT04ucGFyc2UocmVxT2JqLnJlcXVlc3RCb2R5KTtcblxuICAgICAgc3luY0NsaWVudC5kb0NyZWF0ZShkYXRhU2V0SWQsIHJlY29yZCwgZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgLy9hdCB0aGlzIHBvaW50LCB0aGVyZSBpcyBvbmUgcGVuZGluZyBjcmVhdGUsIFxuICAgICAgICBzeW5jQ2xpZW50LmdldERhdGFzZXQoZGF0YVNldElkLCBmdW5jdGlvbihkYXRhc2V0KXtcbiAgICAgICAgICB2YXIgcGVuZGluZ3MgPSBkYXRhc2V0LnBlbmRpbmc7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJwZW5kaW5nXCIsIHBlbmRpbmdzKTtcbiAgICAgICAgICB2YXIgcGVuZGluZ09iaiA9IF8udmFsdWVzKHBlbmRpbmdzKVswXTtcbiAgICAgICAgICBleHBlY3QocGVuZGluZ09iai5hY3Rpb24pLnRvLmVxdWFsKFwiY3JlYXRlXCIpO1xuICAgICAgICAgIHZhciBwZW5kaW5nSGFzaCA9IHBlbmRpbmdPYmouaGFzaDtcbiAgICAgICAgICB2YXIgbW9ja1JlcyA9IHtcbiAgICAgICAgICAgIFwidXBkYXRlc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJoYXNoZXNcIjoge1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhcHBsaWVkXCI6IHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjb3Jkczoge1xuICAgICAgICAgICAgICBcIjUzM2Q3NzVhOGU4MTU5ZDljNjAwMDAwNlwiOiB7XG4gICAgICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiY3VpZFwiOiBcIjlGMzkzMEZFMkE0MzRFMEJBMEFENkY1QTQwQzc3Q0Q3XCIsXG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhcHBsaWVkXCIsXG4gICAgICAgICAgICAgICAgICBcImFjdGlvblwiOiBcImNyZWF0ZVwiLFxuICAgICAgICAgICAgICAgICAgXCJoYXNoXCI6IHBlbmRpbmdIYXNoLFxuICAgICAgICAgICAgICAgICAgXCJ1aWRcIjogXCI1MzNkNzc1YThlODE1OWQ5YzYwMDAwMDZcIixcbiAgICAgICAgICAgICAgICAgIFwibXNnXCI6IFwiJydcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJoYXNoXCI6IHBlbmRpbmdIYXNoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2NrUmVzLnVwZGF0ZXMuaGFzaGVzW3BlbmRpbmdIYXNoXSA9IHtcbiAgICAgICAgICAgIFwiY3VpZFwiOiBcIjlGMzkzMEZFMkE0MzRFMEJBMEFENkY1QTQwQzc3Q0Q3XCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcHBsaWVkXCIsXG4gICAgICAgICAgICBcImFjdGlvblwiOiBcImNyZWF0ZVwiLFxuICAgICAgICAgICAgXCJoYXNoXCI6IHBlbmRpbmdIYXNoLFxuICAgICAgICAgICAgXCJ1aWRcIjogXCI1MzNkNzc1YThlODE1OWQ5YzYwMDAwMDZcIixcbiAgICAgICAgICAgIFwibXNnXCI6IFwiJydcIlxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vY2tSZXMudXBkYXRlcy5hcHBsaWVkW3BlbmRpbmdIYXNoXSA9IHtcbiAgICAgICAgICAgIFwiY3VpZFwiOiBcIjlGMzkzMEZFMkE0MzRFMEJBMEFENkY1QTQwQzc3Q0Q3XCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcHBsaWVkXCIsXG4gICAgICAgICAgICBcImFjdGlvblwiOiBcImNyZWF0ZVwiLFxuICAgICAgICAgICAgXCJoYXNoXCI6IHBlbmRpbmdIYXNoLFxuICAgICAgICAgICAgXCJ1aWRcIjogXCI1MzNkNzc1YThlODE1OWQ5YzYwMDAwMDZcIixcbiAgICAgICAgICAgIFwibXNnXCI6IFwiJydcIlxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcU9iai5yZXNwb25kKDIwMCwgaGVhZGVyLCBKU09OLnN0cmluZ2lmeShtb2NrUmVzKSk7XG5cbiAgICAgICAgICBleHBlY3QocGVuZGluZ09iai5hY3Rpb24pLnRvLmVxdWFsKFwidXBkYXRlXCIpO1xuXG4gICAgICAgICAgZG9uZSgpO1xuXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGl0KFwidGVzdCB1cGRhdGVOZXdEYXRhRnJvbUluRmxpZ2h0XCIsIGZ1bmN0aW9uKGRvbmUpe1xuICAvLyAgIHZhciByZWNvcmQgPSB7bmFtZTpcIml0ZW02XCJ9O1xuICAvLyAgIHN5bmNDbGllbnQuZG9DcmVhdGUoZGF0YVNldElkLCByZWNvcmQsIGZ1bmN0aW9uKHJlcyl7XG4gIC8vICAgICBvblN5bmMoZnVuY3Rpb24oKXtcbiAgLy8gICAgICAgdmFyIHJlcU9iaiA9IHJlcXVlc3RzWzBdO1xuICAvLyAgICAgICB2YXIgcmVxQm9keSA9IEpTT04ucGFyc2UocmVxT2JqLnJlcXVlc3RCb2R5KTtcbiAgLy8gICAgICAgdmFyIHBlbmRpbmdPYmogPSByZXFCb2R5LnBlbmRpbmdbMF07XG4gIC8vICAgICAgIHZhciBtb2NrUmVzID0ge1xuICAvLyAgICAgICAgIHJlY29yZHMgOiB7XG5cbiAgLy8gICAgICAgICB9XG4gIC8vICAgICAgIH1cblxuICAvLyAgICAgICByZXFPYmoucmVzcG9uZCgyMDAsIGhlYWRlciwgSlNPTi5zdHJpbmdpZnkobW9ja1JlcykpO1xuXG4gIC8vICAgICAgIHN5bmNDbGllbnQuZ2V0RGF0YXNldChkYXRhU2V0SWQsIGZ1bmN0aW9uKGRhdGFzZXQpe1xuICAvLyAgICAgICAgIGV4cGVjdChkYXRhc2V0LmRhdGFbcGVuZGluZ09iai51aWRdLmRhdGEubmFtZSkudG8uZXF1YWwoXCJpdGVtNlwiKTtcbiAgLy8gICAgICAgICBkb25lKCk7XG4gIC8vICAgICAgIH0pO1xuICAvLyAgICAgfSk7XG4gIC8vICAgfSk7XG4gIC8vIH0pO1xuXG4gIGl0KFwidGVzdCB1cGRhdGVOZXdEYXRhRnJvbUluRmxpZ2h0IGNyZWF0ZS91cGRhdGVcIiwgZnVuY3Rpb24oZG9uZSl7XG4gICAgdmFyIHJlY29yZCA9IHtuYW1lOlwiaXRlbTdcIn07XG4gICAgc3luY0NsaWVudC5kb0NyZWF0ZShkYXRhU2V0SWQsIHJlY29yZCwgZnVuY3Rpb24ocmVzKXtcbiAgICAgIG9uU3luYyhmdW5jdGlvbigpe1xuICAgICAgICB2YXIgcmVxT2JqID0gcmVxdWVzdHNbMF07XG4gICAgICAgIHZhciByZXFCb2R5ID0gSlNPTi5wYXJzZShyZXFPYmoucmVxdWVzdEJvZHkpO1xuICAgICAgICB2YXIgcGVuZGluZ09iaiA9IHJlcUJvZHkucGVuZGluZ1swXTtcbiAgICAgICAgdmFyIG1vY2tSZXMgPSB7XG4gICAgICAgICAgcmVjb3JkcyA6IHtcblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlcU9iai5yZXNwb25kKDIwMCwgaGVhZGVyLCBKU09OLnN0cmluZ2lmeShtb2NrUmVzKSk7XG4gICAgICAgIFxuICAgICAgICBzeW5jQ2xpZW50LmdldERhdGFzZXQoZGF0YVNldElkLCBmdW5jdGlvbihkYXRhc2V0KXtcbiAgICAgICAgICBleHBlY3QoZGF0YXNldC5kYXRhW3BlbmRpbmdPYmoudWlkXS5kYXRhLm5hbWUpLnRvLmVxdWFsKFwiaXRlbTdcIik7XG4gICAgICAgICAgXG4gICAgICAgICAgc3luY0NsaWVudC5jbGVhclBlbmRpbmcoZGF0YVNldElkLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgc3luY0NsaWVudC5kb1VwZGF0ZShkYXRhU2V0SWQsIHJlcy51aWQsIHtuYW1lOlwiaXRlbThcIn0sIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIG9uU3luYyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHZhciByZXFPYmoxID0gcmVxdWVzdHNbMV07XG4gICAgICAgICAgICAgICAgdmFyIHJlcUJvZHkxID0gSlNPTi5wYXJzZShyZXFPYmoxLnJlcXVlc3RCb2R5KTtcbiAgICAgICAgICAgICAgICB2YXIgcGVuZGluZ09iajEgPSByZXFCb2R5MS5wZW5kaW5nWzBdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBtb2NrUmVzMSA9IHtcbiAgICAgICAgICAgICAgICAgIHJlY29yZHMgOiB7XG5cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9ja1JlczEucmVjb3Jkc1twZW5kaW5nT2JqMS51aWRdID0ge1xuICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaXRlbTlcIlxuICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgaGFzaDogXCI0MjRlNGRmZjVhYTI3YzJmYjdiZjBmYzc0ZDM5Yjk0NDgyM2FzZGZoZmpcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXFPYmoxLnJlc3BvbmQoMjAwLCBoZWFkZXIsIEpTT04uc3RyaW5naWZ5KG1vY2tSZXMxKSk7XG5cbiAgICAgICAgICAgICAgICBleHBlY3QoZGF0YXNldC5kYXRhW3BlbmRpbmdPYmoxLnVpZF0uZGF0YS5uYW1lKS50by5lcXVhbChcIml0ZW04XCIpO1xuXG4gICAgICAgICAgICAgICAgc3luY0NsaWVudC5jbGVhclBlbmRpbmcoZGF0YVNldElkLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgc3luY0NsaWVudC5kb0RlbGV0ZShkYXRhU2V0SWQsIHJlcy51aWQsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIG9uU3luYyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByZXFPYmoyID0gcmVxdWVzdHNbMl07XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcUJvZHkyID0gSlNPTi5wYXJzZShyZXFPYmoyLnJlcXVlc3RCb2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVuZGluZ09iajIgPSByZXFCb2R5Mi5wZW5kaW5nWzBdO1xuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2NrUmVzMiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZHMgOiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgbW9ja1JlczIucmVjb3Jkc1twZW5kaW5nT2JqMi51aWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaXRlbTEwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IFwiNDI0ZTRkZmY1YWEyN2MyZmI3YmYwZmM3NGQzOWI5NDQ4MmFkZmVzZmVmXCJcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmVxT2JqMi5yZXNwb25kKDIwMCwgaGVhZGVyLCBKU09OLnN0cmluZ2lmeShtb2NrUmVzMSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG59KTsiXX0=
